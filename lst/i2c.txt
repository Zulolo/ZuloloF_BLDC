; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\i2c.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\i2c.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\Mini51Series\Include -I..\..\..\Library\StdDriver\inc -I.\StdDriver\inc -I.\CMSIS -I.\RTE\Device\Mini54ZDE -I.\RTE\_BLDC_driver -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.0\CMSIS\Include -ID:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.1.0\Device\Mini51\Driver -ID:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.1.0\Device\Mini51\Include -D__MICROLIB -D__UVISION_VERSION=524 -D_RTE_ -DCLK_APBCLK_ACMP_EN_Pos=CLK_APBCLK_CMP_EN_Pos -DFOR_CAR --omf_browse=.\obj\i2c.crf D:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.1.0\Device\Mini51\Driver\i2c.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  I2C_Open PROC
;;;31       */
;;;32     uint32_t I2C_Open(I2C_T *i2c, uint32_t u32BusClock)
000000  b570              PUSH     {r4-r6,lr}
;;;33     {
;;;34         uint32_t u32Div;
;;;35     
;;;36         u32Div = (uint32_t) (((SystemCoreClock * 10)/(u32BusClock * 4) + 5) / 10 - 1); /* Compute proper divider for I2C clock */
000002  4d5b              LDR      r5,|L1.368|
000004  4604              MOV      r4,r0                 ;33
000006  6828              LDR      r0,[r5,#0]  ; SystemCoreClock
000008  220a              MOVS     r2,#0xa
00000a  0089              LSLS     r1,r1,#2
00000c  4350              MULS     r0,r2,r0
00000e  f7fffffe          BL       __aeabi_uidivmod
000012  210a              MOVS     r1,#0xa
000014  1d40              ADDS     r0,r0,#5
000016  f7fffffe          BL       __aeabi_uidivmod
00001a  1e40              SUBS     r0,r0,#1
;;;37         i2c->I2CLK = u32Div;
00001c  6120              STR      r0,[r4,#0x10]
;;;38     
;;;39         /* Enable I2C */
;;;40         i2c->I2CON |= I2C_I2CON_ENSI_Msk;
00001e  6821              LDR      r1,[r4,#0]
000020  2240              MOVS     r2,#0x40
000022  4311              ORRS     r1,r1,r2
000024  6021              STR      r1,[r4,#0]
;;;41     
;;;42         return ( SystemCoreClock / ((u32Div+1)<<2) );
000026  0081              LSLS     r1,r0,#2
000028  1d09              ADDS     r1,r1,#4
00002a  6828              LDR      r0,[r5,#0]  ; SystemCoreClock
00002c  f7fffffe          BL       __aeabi_uidivmod
;;;43     }
000030  bd70              POP      {r4-r6,pc}
;;;44     
                          ENDP

                  I2C_Close PROC
;;;49       */
;;;50     void I2C_Close(I2C_T *i2c)
000032  2105              MOVS     r1,#5
;;;51     {
;;;52         /* Reset SPI */
;;;53         SYS->IPRSTC2 |= SYS_IPRSTC2_I2C_RST_Msk;
000034  0709              LSLS     r1,r1,#28
000036  68cb              LDR      r3,[r1,#0xc]
000038  22ff              MOVS     r2,#0xff
00003a  3201              ADDS     r2,#1
00003c  4313              ORRS     r3,r3,r2
00003e  60cb              STR      r3,[r1,#0xc]
;;;54         SYS->IPRSTC2 &= ~SYS_IPRSTC2_I2C_RST_Msk;
000040  68cb              LDR      r3,[r1,#0xc]
000042  4393              BICS     r3,r3,r2
000044  60cb              STR      r3,[r1,#0xc]
;;;55     
;;;56         /* Disable I2C */
;;;57         i2c->I2CON &= ~I2C_I2CON_ENSI_Msk;
000046  6801              LDR      r1,[r0,#0]
000048  2240              MOVS     r2,#0x40
00004a  4391              BICS     r1,r1,r2
00004c  6001              STR      r1,[r0,#0]
;;;58     }
00004e  4770              BX       lr
;;;59     
                          ENDP

                  I2C_ClearTimeoutFlag PROC
;;;64       */
;;;65     void I2C_ClearTimeoutFlag(I2C_T *i2c)
000050  6941              LDR      r1,[r0,#0x14]
;;;66     {
;;;67         i2c->I2CTOC |= I2C_I2CTOC_TIF_Msk;
000052  2201              MOVS     r2,#1
000054  4311              ORRS     r1,r1,r2
000056  6141              STR      r1,[r0,#0x14]
;;;68     }
000058  4770              BX       lr
;;;69     
                          ENDP

                  I2C_Trigger PROC
;;;78       */
;;;79     void I2C_Trigger(I2C_T *i2c, uint8_t u8Start, uint8_t u8Stop, uint8_t u8Si, uint8_t u8Ack)
00005a  b530              PUSH     {r4,r5,lr}
;;;80     {
;;;81         uint32_t u32Reg = 0;
00005c  2400              MOVS     r4,#0
;;;82     
;;;83         if (u8Start)
00005e  9d03              LDR      r5,[sp,#0xc]
000060  2900              CMP      r1,#0
000062  d000              BEQ      |L1.102|
;;;84             u32Reg |= I2C_STA;
000064  2420              MOVS     r4,#0x20
                  |L1.102|
;;;85         if (u8Stop)
000066  2a00              CMP      r2,#0
000068  d001              BEQ      |L1.110|
;;;86             u32Reg |= I2C_STO;
00006a  2110              MOVS     r1,#0x10
00006c  430c              ORRS     r4,r4,r1
                  |L1.110|
;;;87         if (u8Si)
00006e  2b00              CMP      r3,#0
000070  d001              BEQ      |L1.118|
;;;88             u32Reg |= I2C_SI;
000072  2108              MOVS     r1,#8
000074  430c              ORRS     r4,r4,r1
                  |L1.118|
;;;89         if (u8Ack)
000076  2d00              CMP      r5,#0
000078  d001              BEQ      |L1.126|
;;;90             u32Reg |= I2C_AA;
00007a  2104              MOVS     r1,#4
00007c  430c              ORRS     r4,r4,r1
                  |L1.126|
;;;91     
;;;92         i2c->I2CON = (i2c->I2CON & ~0x3C) | u32Reg;
00007e  6801              LDR      r1,[r0,#0]
000080  223c              MOVS     r2,#0x3c
000082  4391              BICS     r1,r1,r2
000084  4321              ORRS     r1,r1,r4
000086  6001              STR      r1,[r0,#0]
;;;93     }
000088  bd30              POP      {r4,r5,pc}
;;;94     
                          ENDP

                  I2C_DisableInt PROC
;;;99       */
;;;100    void I2C_DisableInt(I2C_T *i2c)
00008a  6801              LDR      r1,[r0,#0]
;;;101    {
;;;102        i2c->I2CON &= ~I2C_I2CON_EI_Msk;
00008c  2280              MOVS     r2,#0x80
00008e  4391              BICS     r1,r1,r2
000090  6001              STR      r1,[r0,#0]
;;;103    }
000092  4770              BX       lr
;;;104    
                          ENDP

                  I2C_EnableInt PROC
;;;109      */
;;;110    void I2C_EnableInt(I2C_T *i2c)
000094  6801              LDR      r1,[r0,#0]
;;;111    {
;;;112        i2c->I2CON |= I2C_I2CON_EI_Msk;
000096  2280              MOVS     r2,#0x80
000098  4311              ORRS     r1,r1,r2
00009a  6001              STR      r1,[r0,#0]
;;;113    }
00009c  4770              BX       lr
;;;114    
                          ENDP

                  I2C_GetBusClockFreq PROC
;;;119      */
;;;120    uint32_t I2C_GetBusClockFreq(I2C_T *i2c)
00009e  b510              PUSH     {r4,lr}
;;;121    {
;;;122        uint32_t u32Divider = i2c->I2CLK;
0000a0  6900              LDR      r0,[r0,#0x10]
;;;123    
;;;124        return ( SystemCoreClock / ((u32Divider+1)<<2) );
0000a2  0081              LSLS     r1,r0,#2
0000a4  4832              LDR      r0,|L1.368|
0000a6  1d09              ADDS     r1,r1,#4
0000a8  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
0000aa  f7fffffe          BL       __aeabi_uidivmod
;;;125    }
0000ae  bd10              POP      {r4,pc}
;;;126    
                          ENDP

                  I2C_SetBusClockFreq PROC
;;;132      */
;;;133    uint32_t I2C_SetBusClockFreq(I2C_T *i2c, uint32_t u32BusClock)
0000b0  b570              PUSH     {r4-r6,lr}
;;;134    {
0000b2  4604              MOV      r4,r0
;;;135        uint32_t u32Div;
;;;136    
;;;137        u32Div = (uint32_t) (((SystemCoreClock * 10)/(u32BusClock * 4) + 5) / 10 - 1); /* Compute proper divider for I2C clock */
0000b4  482e              LDR      r0,|L1.368|
0000b6  220a              MOVS     r2,#0xa
0000b8  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
0000ba  0089              LSLS     r1,r1,#2
0000bc  4605              MOV      r5,r0
0000be  4350              MULS     r0,r2,r0
0000c0  f7fffffe          BL       __aeabi_uidivmod
0000c4  210a              MOVS     r1,#0xa
0000c6  1d40              ADDS     r0,r0,#5
0000c8  f7fffffe          BL       __aeabi_uidivmod
0000cc  1e40              SUBS     r0,r0,#1
;;;138        i2c->I2CLK = u32Div;
0000ce  6120              STR      r0,[r4,#0x10]
;;;139    
;;;140        return ( SystemCoreClock / ((u32Div+1)<<2) );
0000d0  0081              LSLS     r1,r0,#2
0000d2  4628              MOV      r0,r5
0000d4  1d09              ADDS     r1,r1,#4
0000d6  f7fffffe          BL       __aeabi_uidivmod
;;;141    }
0000da  bd70              POP      {r4-r6,pc}
;;;142    
                          ENDP

                  I2C_GetIntFlag PROC
;;;149      */
;;;150    uint32_t I2C_GetIntFlag(I2C_T *i2c)
0000dc  6800              LDR      r0,[r0,#0]
;;;151    {
;;;152        return ( (i2c->I2CON & I2C_I2CON_SI_Msk) == I2C_I2CON_SI_Msk ? 1:0 );
0000de  0700              LSLS     r0,r0,#28
0000e0  0fc0              LSRS     r0,r0,#31
;;;153    }
0000e2  4770              BX       lr
;;;154    
                          ENDP

                  I2C_GetStatus PROC
;;;159      */
;;;160    uint32_t I2C_GetStatus(I2C_T *i2c)
0000e4  68c0              LDR      r0,[r0,#0xc]
;;;161    {
;;;162        return ( i2c->I2CSTATUS );
;;;163    }
0000e6  4770              BX       lr
;;;164    
                          ENDP

                  I2C_GetData PROC
;;;169      */
;;;170    uint32_t I2C_GetData(I2C_T *i2c)
0000e8  6880              LDR      r0,[r0,#8]
;;;171    {
;;;172        return ( i2c->I2CDAT );
;;;173    }
0000ea  4770              BX       lr
;;;174    
                          ENDP

                  I2C_SetData PROC
;;;180      */
;;;181    void I2C_SetData(I2C_T *i2c, uint8_t u8Data)
0000ec  6081              STR      r1,[r0,#8]
;;;182    {
;;;183        i2c->I2CDAT = u8Data;
;;;184    }
0000ee  4770              BX       lr
;;;185    
                          ENDP

                  I2C_SetSlaveAddr PROC
;;;193      */
;;;194    void I2C_SetSlaveAddr(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddr, uint8_t u8GCMode)
0000f0  0052              LSLS     r2,r2,#1
;;;195    {
;;;196        switch (u8SlaveNo) {
;;;197        case 0:
;;;198            i2c->I2CADDR0  = (u8SlaveAddr << 1) | u8GCMode;
0000f2  431a              ORRS     r2,r2,r3
0000f4  2900              CMP      r1,#0                 ;196
0000f6  d005              BEQ      |L1.260|
0000f8  2901              CMP      r1,#1                 ;196
0000fa  d005              BEQ      |L1.264|
0000fc  2902              CMP      r1,#2                 ;196
0000fe  d005              BEQ      |L1.268|
000100  2903              CMP      r1,#3                 ;196
000102  d005              BEQ      |L1.272|
                  |L1.260|
;;;199            break;
;;;200        case 1:
;;;201            i2c->I2CADDR1  = (u8SlaveAddr << 1) | u8GCMode;
;;;202            break;
;;;203        case 2:
;;;204            i2c->I2CADDR2  = (u8SlaveAddr << 1) | u8GCMode;
;;;205            break;
;;;206        case 3:
;;;207            i2c->I2CADDR3  = (u8SlaveAddr << 1) | u8GCMode;
;;;208            break;
;;;209        default:
;;;210            i2c->I2CADDR0  = (u8SlaveAddr << 1) | u8GCMode;
000104  6042              STR      r2,[r0,#4]
;;;211        }
;;;212    }
000106  4770              BX       lr
                  |L1.264|
000108  6182              STR      r2,[r0,#0x18]         ;201
00010a  4770              BX       lr
                  |L1.268|
00010c  61c2              STR      r2,[r0,#0x1c]         ;204
00010e  4770              BX       lr
                  |L1.272|
000110  6202              STR      r2,[r0,#0x20]         ;207
000112  4770              BX       lr
;;;213    
                          ENDP

                  I2C_SetSlaveAddrMask PROC
;;;220      */
;;;221    void I2C_SetSlaveAddrMask(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddrMask)
000114  0052              LSLS     r2,r2,#1
;;;222    {
;;;223        switch (u8SlaveNo) {
000116  2900              CMP      r1,#0
000118  d005              BEQ      |L1.294|
00011a  2901              CMP      r1,#1
00011c  d005              BEQ      |L1.298|
00011e  2902              CMP      r1,#2
000120  d005              BEQ      |L1.302|
000122  2903              CMP      r1,#3
000124  d005              BEQ      |L1.306|
                  |L1.294|
;;;224        case 0:
;;;225            i2c->I2CADM0  = u8SlaveAddrMask << 1;
;;;226            break;
;;;227        case 1:
;;;228            i2c->I2CADM1  = u8SlaveAddrMask << 1;
;;;229            break;
;;;230        case 2:
;;;231            i2c->I2CADM2  = u8SlaveAddrMask << 1;
;;;232            break;
;;;233        case 3:
;;;234            i2c->I2CADM3  = u8SlaveAddrMask << 1;
;;;235            break;
;;;236        default:
;;;237            i2c->I2CADM0  = u8SlaveAddrMask << 1;
000126  6242              STR      r2,[r0,#0x24]
;;;238        }
;;;239    }
000128  4770              BX       lr
                  |L1.298|
00012a  6282              STR      r2,[r0,#0x28]         ;228
00012c  4770              BX       lr
                  |L1.302|
00012e  62c2              STR      r2,[r0,#0x2c]         ;231
000130  4770              BX       lr
                  |L1.306|
000132  6302              STR      r2,[r0,#0x30]         ;234
000134  4770              BX       lr
;;;240    
                          ENDP

                  I2C_EnableTimeout PROC
;;;246      */
;;;247    void I2C_EnableTimeout(I2C_T *i2c, uint8_t u8LongTimeout)
000136  2202              MOVS     r2,#2
;;;248    {
;;;249        if(u8LongTimeout)
000138  2900              CMP      r1,#0
;;;250            i2c->I2CTOC |= I2C_I2CTOC_DIV4_Msk;
;;;251        else
;;;252            i2c->I2CTOC &= ~I2C_I2CTOC_DIV4_Msk;
00013a  6941              LDR      r1,[r0,#0x14]
00013c  d001              BEQ      |L1.322|
00013e  4311              ORRS     r1,r1,r2              ;250
000140  e000              B        |L1.324|
                  |L1.322|
000142  4391              BICS     r1,r1,r2
                  |L1.324|
000144  6141              STR      r1,[r0,#0x14]
;;;253    
;;;254        i2c->I2CTOC |= I2C_I2CTOC_ENTI_Msk;
000146  6941              LDR      r1,[r0,#0x14]
000148  2204              MOVS     r2,#4
00014a  4311              ORRS     r1,r1,r2
00014c  6141              STR      r1,[r0,#0x14]
;;;255    }
00014e  4770              BX       lr
;;;256    
                          ENDP

                  I2C_DisableTimeout PROC
;;;261      */
;;;262    void I2C_DisableTimeout(I2C_T *i2c)
000150  6941              LDR      r1,[r0,#0x14]
;;;263    {
;;;264        i2c->I2CTOC &= ~I2C_I2CTOC_ENTI_Msk;
000152  2204              MOVS     r2,#4
000154  4391              BICS     r1,r1,r2
000156  6141              STR      r1,[r0,#0x14]
;;;265    }
000158  4770              BX       lr
;;;266    
                          ENDP

                  I2C_EnableWakeup PROC
;;;271      */
;;;272    void I2C_EnableWakeup(I2C_T *i2c)
00015a  6bc1              LDR      r1,[r0,#0x3c]
;;;273    {
;;;274        i2c->I2CON2 |= I2C_I2CON2_WKUPEN_Msk;
00015c  2201              MOVS     r2,#1
00015e  4311              ORRS     r1,r1,r2
000160  63c1              STR      r1,[r0,#0x3c]
;;;275    }
000162  4770              BX       lr
;;;276    
                          ENDP

                  I2C_DisableWakeup PROC
;;;281      */
;;;282    void I2C_DisableWakeup(I2C_T *i2c)
000164  6bc1              LDR      r1,[r0,#0x3c]
;;;283    {
;;;284        i2c->I2CON2 &= ~I2C_I2CON2_WKUPEN_Msk;
000166  0849              LSRS     r1,r1,#1
000168  0049              LSLS     r1,r1,#1
00016a  63c1              STR      r1,[r0,#0x3c]
;;;285    }
00016c  4770              BX       lr
;;;286    
                          ENDP

00016e  0000              DCW      0x0000
                  |L1.368|
                          DCD      SystemCoreClock

;*** Start embedded assembler ***

#line 1 "D:\\Keil_v5\\ARM\\PACK\\Nuvoton\\NuMicro_DFP\\1.1.0\\Device\\Mini51\\Driver\\i2c.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_i2c_c_I2C_Open____REV16|
#line 464 "D:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.1.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_i2c_c_I2C_Open____REV16| PROC
#line 465

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_i2c_c_I2C_Open____REVSH|
#line 479
|__asm___5_i2c_c_I2C_Open____REVSH| PROC
#line 480

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
