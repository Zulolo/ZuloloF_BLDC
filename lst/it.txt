; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\it.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\it.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\Mini51Series\Include -I..\..\..\Library\StdDriver\inc -I.\StdDriver\inc -I.\CMSIS -IG:\Geek\Projects\Zulolo_F\Force\Code\Zulolo_F_Force\RTE -ID:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.0.2\Device\Mini51\Include -ID:\Keil_v5\ARM\CMSIS\Include -I\ -D__MICROLIB -D__UVISION_VERSION=518 --omf_browse=.\obj\it.crf User\it.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  TMR0_IRQHandler PROC
;;;14     // Used to change phase
;;;15     void TMR0_IRQHandler(void)                                   
000000  b530              PUSH     {r4,r5,lr}
;;;16     {
;;;17     	TIMER0->TISR  = TIMER0->TISR;	//~0;    // Clear interrupt flag
000002  49ac              LDR      r1,|L1.692|
000004  6888              LDR      r0,[r1,#8]
000006  6088              STR      r0,[r1,#8]
;;;18     
;;;19     	//iPhaseChangeCNT4Period++;
;;;20     	FLAG_PHASE_CHANGED = SET;
000008  4aab              LDR      r2,|L1.696|
00000a  2001              MOVS     r0,#1
00000c  7010              STRB     r0,[r2,#0]
;;;21     //	iTestACMPIntEachPhaseCNT = 0;
;;;22     
;;;23     	// Disable comparator's interrupt in case after change phase it triggers
;;;24     	//ACMP0_INT_DISABLE; 
;;;25     
;;;26     	// Disable PWM's interrupt in case after change phase it triggers
;;;27     	PWM_INT_DISABLE;
00000e  48ab              LDR      r0,|L1.700|
000010  2400              MOVS     r4,#0
000012  6144              STR      r4,[r0,#0x14]
;;;28     
;;;29     
;;;30     	if (TRUE == mMotor.structMotor.MSR.ZeroCrossDetecting)
000014  48aa              LDR      r0,|L1.704|
000016  8840              LDRH     r0,[r0,#2]  ; mMotor
000018  0780              LSLS     r0,r0,#30
00001a  d517              BPL      |L1.76|
00001c  4aa5              LDR      r2,|L1.692|
00001e  3220              ADDS     r2,r2,#0x20           ;16
000020  6810              LDR      r0,[r2,#0]            ;16
000022  034b              LSLS     r3,r1,#13             ;16
000024  4398              BICS     r0,r0,r3              ;16
000026  6010              STR      r0,[r2,#0]            ;16
;;;31     	{
;;;32     		// In case TIM1 interrupt happened but preeempted by TIM0
;;;33     		TIMER_DisableInt(TIMER1);
;;;34     		TIMER1->TISR  = ~0;    // Clear interrupt flag
000028  1e60              SUBS     r0,r4,#1
00002a  6288              STR      r0,[r1,#0x28]
;;;35     		TIMER_SET_CMP_VALUE(TIMER1, GET_TIM1_CMP_VALUE(TIMER1->TDR + AVOID_ZXD_AFTER_PHCHG));	
00002c  6ac8              LDR      r0,[r1,#0x2c]
00002e  4da5              LDR      r5,|L1.708|
000030  30a0              ADDS     r0,r0,#0xa0
000032  42a8              CMP      r0,r5
000034  6ac8              LDR      r0,[r1,#0x2c]
000036  d302              BCC      |L1.62|
000038  4da3              LDR      r5,|L1.712|
00003a  1940              ADDS     r0,r0,r5
00003c  e000              B        |L1.64|
                  |L1.62|
00003e  30a0              ADDS     r0,r0,#0xa0
                  |L1.64|
000040  6248              STR      r0,[r1,#0x24]
;;;36     		//GET_TIMER_DIFF(PWM_ZX_FILTER_TIME, GET_TIM1_CMP_VALUE(TIMER1->TDR + (mMotor.structMotor.ACT_PERIOD >> 1))));	
;;;37     		//(mMotor.structMotor.ACT_PERIOD >> 2)));
;;;38     		FLAG_TIM1_USEAGE = ENUM_TIM1_AVOID_ZXD;
000042  48a2              LDR      r0,|L1.716|
000044  7004              STRB     r4,[r0,#0]
000046  6810              LDR      r0,[r2,#0]
000048  4318              ORRS     r0,r0,r3
00004a  6010              STR      r0,[r2,#0]
                  |L1.76|
;;;39     		TIMER_EnableInt(TIMER1);
;;;40     	}
;;;41     }
00004c  bd30              POP      {r4,r5,pc}
;;;42     
                          ENDP

                  DetectdTimeWhenPWMHigh PROC
;;;58     //		    ZX found
;;;59     uint32_t DetectdTimeWhenPWMHigh(void)
00004e  b530              PUSH     {r4,r5,lr}
;;;60     {
;;;61     	
;;;62     
;;;63     //	uint32_t iMaxTIM0atThisPWMHigh;
;;;64     //	iMaxTIM0atThisPWMHigh = getTIM0atThisPWMHigh(mMotor.structMotor.ACT_DUTY);
;;;65     
;;;66     	// ALready done when enter PWM interrupt
;;;67     	//PWM->PIIR |= PWM_PIIR_PWMPIF1_Msk;
;;;68     
;;;69     	while ((PWM->PIIR & PWM_PIIR_PWMPIF1_Msk) == 0)
;;;70     	{
;;;71     //		BRG_DISABLE;
;;;72     //		stopMotor();
;;;73     		if (iZXMatchCNT > MAX_ZX_MATCH_IN_PWM)
000050  489f              LDR      r0,|L1.720|
;;;74     		{
;;;75     			return TIMER_GetCounter(TIMER1);	//GET_TIMER_DIFF(PWM_ZX_FILTER_TIME, TIMER_GetCounter(TIMER1));
;;;76     		}
;;;77     
;;;78     		if (ACMP0_EDGE_MATCH)
000052  499a              LDR      r1,|L1.700|
000054  4b9f              LDR      r3,|L1.724|
000056  2400              MOVS     r4,#0
;;;79     		{
;;;80     			iZXMatchCNT++; 
;;;81     		}
;;;82     		else
;;;83     		{
;;;84     			iZXMatchCNT = 0;
000058  e013              B        |L1.130|
                  |L1.90|
00005a  6842              LDR      r2,[r0,#4]            ;73  ; iZXMatchCNT
00005c  2a24              CMP      r2,#0x24              ;73
00005e  d903              BLS      |L1.104|
000060  4894              LDR      r0,|L1.692|
000062  3020              ADDS     r0,r0,#0x20           ;73
000064  68c0              LDR      r0,[r0,#0xc]          ;73
;;;85     		}
;;;86     		
;;;87     	}
;;;88     	return TIMER_INVALID_CNT;
;;;89     }
000066  bd30              POP      {r4,r5,pc}
                  |L1.104|
000068  6b8a              LDR      r2,[r1,#0x38]         ;78
00006a  689d              LDR      r5,[r3,#8]            ;78
00006c  0612              LSLS     r2,r2,#24             ;78
00006e  0fd2              LSRS     r2,r2,#31             ;78
000070  076d              LSLS     r5,r5,#29             ;78
000072  0fed              LSRS     r5,r5,#31             ;78
000074  42aa              CMP      r2,r5                 ;78
000076  d103              BNE      |L1.128|
000078  6842              LDR      r2,[r0,#4]            ;80  ; iZXMatchCNT
00007a  1c52              ADDS     r2,r2,#1              ;80
00007c  6042              STR      r2,[r0,#4]            ;80  ; iZXMatchCNT
00007e  e000              B        |L1.130|
                  |L1.128|
000080  6044              STR      r4,[r0,#4]            ;84  ; iZXMatchCNT
                  |L1.130|
000082  698a              LDR      r2,[r1,#0x18]         ;69
000084  0792              LSLS     r2,r2,#30             ;69
000086  d5e8              BPL      |L1.90|
000088  2000              MOVS     r0,#0                 ;88
00008a  43c0              MVNS     r0,r0                 ;88
00008c  bd30              POP      {r4,r5,pc}
;;;90     
                          ENDP

                  PhaseZXDedHandler PROC
;;;120    
;;;121    uint8_t PhaseZXDedHandler(uint32_t iThisZXDetectedTime)
00008e  b530              PUSH     {r4,r5,lr}
;;;122    {
;;;123    	static uint32_t iTempDeltaZXD = 0;
;;;124    	static uint32_t iHalfPeriod = 0;
;;;125    //	static uint32_t iThisZXDetectedTime = 0;
;;;126    
;;;127    	//iThisZXDetectedTime = TIMER_GetCounter(TIMER1);
;;;128    
;;;129    	iTempDeltaZXD = GET_TIMER_DIFF(iLastZXDetectedTime, iThisZXDetectedTime);
000090  4b91              LDR      r3,|L1.728|
000092  6819              LDR      r1,[r3,#0]  ; iLastZXDetectedTime
000094  4288              CMP      r0,r1
000096  d901              BLS      |L1.156|
000098  1a41              SUBS     r1,r0,r1
00009a  e002              B        |L1.162|
                  |L1.156|
00009c  4a89              LDR      r2,|L1.708|
00009e  1a51              SUBS     r1,r2,r1
0000a0  1809              ADDS     r1,r1,r0
                  |L1.162|
;;;130    
;;;131    	if ((iTempDeltaZXD > MIN_PHASE_TIME) && (iTempDeltaZXD < MAX_PHASE_TIME))
0000a2  460c              MOV      r4,r1
0000a4  4a8a              LDR      r2,|L1.720|
0000a6  3cff              SUBS     r4,r4,#0xff
0000a8  4d8c              LDR      r5,|L1.732|
0000aa  3cf6              SUBS     r4,r4,#0xf6
0000ac  6091              STR      r1,[r2,#8]  ; iTempDeltaZXD
0000ae  42ac              CMP      r4,r5
0000b0  d221              BCS      |L1.246|
;;;132    	{
;;;133    		iLastZXDetectedTime = iThisZXDetectedTime;
;;;134    		mMotor.structMotor.MSR.ThisPhaseDetectedZX = TRUE;
0000b2  6018              STR      r0,[r3,#0]  ; iLastZXDetectedTime
0000b4  4882              LDR      r0,|L1.704|
0000b6  8843              LDRH     r3,[r0,#2]  ; mMotor
0000b8  2408              MOVS     r4,#8
0000ba  4323              ORRS     r3,r3,r4
0000bc  8043              STRH     r3,[r0,#2]
;;;135    //		iTestDetectedZX++;
;;;136    		if (TRUE == mMotor.structMotor.MSR.Locked)
0000be  8843              LDRH     r3,[r0,#2]  ; mMotor
0000c0  075b              LSLS     r3,r3,#29
0000c2  d516              BPL      |L1.242|
;;;137    		{
;;;138    			mMotor.structMotor.ACT_PERIOD = (iTempDeltaZXD + mMotor.structMotor.ACT_PERIOD) >> 1;
0000c4  6943              LDR      r3,[r0,#0x14]  ; mMotor
0000c6  1859              ADDS     r1,r3,r1
0000c8  0849              LSRS     r1,r1,#1
0000ca  6141              STR      r1,[r0,#0x14]  ; mMotor
;;;139    			iHalfPeriod = mMotor.structMotor.ACT_PERIOD >> 1;
0000cc  6940              LDR      r0,[r0,#0x14]  ; mMotor
0000ce  0840              LSRS     r0,r0,#1
;;;140    			TIMER_SET_CMP_VALUE(TIMER0, TIMER0->TDR + (iHalfPeriod > TIME_DEBT) ? (iHalfPeriod - TIME_DEBT) : ZXD_BEFORE_PHCHG);
0000d0  60d0              STR      r0,[r2,#0xc]  ; iHalfPeriod
0000d2  4a78              LDR      r2,|L1.692|
0000d4  68d3              LDR      r3,[r2,#0xc]
0000d6  21ff              MOVS     r1,#0xff
0000d8  3105              ADDS     r1,#5
0000da  4288              CMP      r0,r1
0000dc  d901              BLS      |L1.226|
0000de  2101              MOVS     r1,#1
0000e0  e000              B        |L1.228|
                  |L1.226|
0000e2  2100              MOVS     r1,#0
                  |L1.228|
0000e4  42cb              CMN      r3,r1
0000e6  d002              BEQ      |L1.238|
0000e8  38ff              SUBS     r0,r0,#0xff
0000ea  3805              SUBS     r0,#5
0000ec  e000              B        |L1.240|
                  |L1.238|
0000ee  2032              MOVS     r0,#0x32
                  |L1.240|
0000f0  6050              STR      r0,[r2,#4]
                  |L1.242|
;;;141    		}
;;;142    		return TRUE;
0000f2  2001              MOVS     r0,#1
;;;143    	}
;;;144    	else
;;;145    	{
;;;146    		return FALSE;
;;;147    	}
;;;148    }
0000f4  bd30              POP      {r4,r5,pc}
                  |L1.246|
0000f6  2000              MOVS     r0,#0                 ;146
0000f8  bd30              POP      {r4,r5,pc}
;;;149    
                          ENDP

                  TMR1_IRQHandler PROC
;;;150    // Used to set time reference and filter ZXD
;;;151    void TMR1_IRQHandler(void)                                   
0000fa  b5f0              PUSH     {r4-r7,lr}
;;;152    {
;;;153    //	static uint32_t iZXTimeDuringPWMHigh;
;;;154    //	static uint32_t iTempDeltaZXD = 0;
;;;155    //	static uint32_t iTempPhaseChange2ZX = 0;
;;;156    //	static uint32_t iThisZXDetectedTime = 0;
;;;157    //	static uint32_t iTargetNewPeriod = 0;
;;;158    
;;;159    //	TIMER_DisableInt(TIMER1);
;;;160    	TIMER1->TISR = ~0;    // Clear interrupt flag
0000fc  2000              MOVS     r0,#0
0000fe  496d              LDR      r1,|L1.692|
000100  43c0              MVNS     r0,r0
000102  6288              STR      r0,[r1,#0x28]
;;;161    //	iZXMatchCNT = 0;
;;;162    
;;;163    /*		iZXTimeDuringPWMHigh = DetectdTimeWhenPWMHigh();
;;;164    		if (iZXTimeDuringPWMHigh == TIMER_INVALID_CNT)
;;;165    		{
;;;166    			// Start PWM duty interrupt, during each PWM high, check is there is ZX
;;;167    			PWM->PIIR = ~0;
;;;168    			PWM_INT_ENABLE;
;;;169    		}
;;;170    		else
;;;171    		{
;;;172    			if (PhaseZXDedHandler(iZXTimeDuringPWMHigh) == FALSE)
;;;173    			{	// The value has some problem, still open interrupt of PWM to detect ZX when PWM high
;;;174    				PWM->PIIR = ~0;
;;;175    				PWM_INT_ENABLE;
;;;176    			}
;;;177    		}
;;;178    
;;;179    
;;;180    	if (ENUM_TIM1_START_ZXD == FLAG_TIM1_USEAGE)
;;;181    	{
;;;182    		// First check if ACMP already match
;;;183    		if (ACMP0_EDGE_MATCH)
;;;184    		{
;;;185    			iTestEnter_TMR1_MATCH++;
;;;186    			PhaseZXDedHandler();
;;;187    		}
;;;188    		else
;;;189    		{
;;;190    			// ACMPF0 may already be set
;;;191    			if (ACMP->CMPSR & ACMP_CMPSR_ACMPF0_Msk)
;;;192    			{
;;;193    				ACMP->CMPSR |= ACMP_CMPSR_ACMPF0_Msk;
;;;194    			}
;;;195    			// If not match, open ACMP interrupt to monitor ZX
;;;196    			ACMP0_INT_ENABLE;
;;;197    		}
;;;198    	}
;;;199    */
;;;200    
;;;201    	if (ENUM_TIM1_AVOID_ZXD == FLAG_TIM1_USEAGE)
000104  4871              LDR      r0,|L1.716|
000106  4d6b              LDR      r5,|L1.692|
000108  7801              LDRB     r1,[r0,#0]  ; FLAG_TIM1_USEAGE
00010a  2701              MOVS     r7,#1
00010c  077f              LSLS     r7,r7,#29
;;;202    	{
;;;203    		TIMER_DisableInt(TIMER1);	// ACMP interrupt will re-open TIM1's interrupt
;;;204    		FLAG_TIM1_USEAGE = ENUM_TIM1_ZXD_FILTER;
;;;205    		// Clear all ACMP changed flag happened before
;;;206    		ACMP->CMPSR |= ACMP_CMPSR_ACMPF0_Msk;
;;;207    		ACMP0_INT_ENABLE;
00010e  2602              MOVS     r6,#2
000110  4c70              LDR      r4,|L1.724|
000112  3520              ADDS     r5,r5,#0x20           ;206
000114  2900              CMP      r1,#0                 ;201
000116  d014              BEQ      |L1.322|
;;;208    	}
;;;209    	else
;;;210    	{	// for now can only be ENUM_TIM1_ZXD_FILTER
;;;211    		if (ACMP0_EDGE_MATCH)
000118  4868              LDR      r0,|L1.700|
00011a  6b80              LDR      r0,[r0,#0x38]
00011c  68a1              LDR      r1,[r4,#8]
00011e  0600              LSLS     r0,r0,#24
000120  0fc0              LSRS     r0,r0,#31
000122  0749              LSLS     r1,r1,#29
000124  0fc9              LSRS     r1,r1,#31
000126  4288              CMP      r0,r1
000128  d10a              BNE      |L1.320|
00012a  68e8              LDR      r0,[r5,#0xc]
;;;212    		{	
;;;213    			// No need to find the real ZXD time, we only care the delta 
;;;214    			if (TRUE == PhaseZXDedHandler(TIMER_GetCounter(TIMER1)))	//GET_TIMER_DIFF(ZXD_FILTER_TIME, TIMER_GetCounter(TIMER1))))
00012c  f7fffffe          BL       PhaseZXDedHandler
000130  2801              CMP      r0,#1
000132  d105              BNE      |L1.320|
;;;215    			{
;;;216    				ACMP0_INT_DISABLE;  // This phase ACMP job done
000134  6820              LDR      r0,[r4,#0]
000136  43b0              BICS     r0,r0,r6
000138  6020              STR      r0,[r4,#0]
00013a  6828              LDR      r0,[r5,#0]
00013c  43b8              BICS     r0,r0,r7
00013e  6028              STR      r0,[r5,#0]
                  |L1.320|
;;;217    				TIMER_DisableInt(TIMER1);
;;;218    			}
;;;219    
;;;220    //			iThisZXDetectedTime = TIMER_GetCounter(TIMER1) - ZXD_FILTER_TIME;
;;;221    //			//iTempDeltaZXD = GET_TIMER_DIFF(iLastZXDetectedTime, iThisZXDetectedTime) - ZXD_FILTER_TIME - ACMP_HYS_AVG_TIME;
;;;222    //			iTempDeltaZXD = GET_TIMER_DIFF(iLastZXDetectedTime, iThisZXDetectedTime);
;;;223    ////			iTempPhaseChange2ZX = GET_TIMER_DIFF(iPhaseChangeTime, iThisZXDetectedTime) - ZXD_FILTER_TIME;
;;;224    //			//iTargetNewPeriod = (iTempDeltaZXD >> 1) + iTempPhaseChange2ZX;
;;;225    //			iTargetNewPeriod = iTempDeltaZXD;	// >> 1 + iTempPhaseChange2ZX;	//(iTempDeltaZXD + mMotor.structMotor.ACT_PERIOD) >> 1;
;;;226    ////			iTargetNewPeriod = (iTargetNewPeriod + mMotor.structMotor.ACT_PERIOD) >> 1;
;;;227    //			iTestEnter_TMR1_MATCH++;
;;;228    ////			RECORD_TEST_VALUE(iTestNewPeriodIndex, iTestZXDPeriodArray, iTargetNewPeriod);
;;;229    ////			RECORD_TEST_VALUE(iTestTIM0CNTIndex, iTestTIM0CNTArray, TIMER0->TCMPR);
;;;230    ////			if ((iTestNewPeriodIndex == 0) && (iTestZXDPeriodArray[0] != 0))
;;;231    ////			{
;;;232    ////				BRG_DISABLE;
;;;233    ////				stopMotor();
;;;234    ////				iTestZXDPeriodMax = getMax(iTestZXDPeriodArray, TEST_ARRAY_LEN);
;;;235    ////				iTestZXDPeriodMin = getMin(iTestZXDPeriodArray, TEST_ARRAY_LEN);
;;;236    ////				iTestTIM0CNTMax = getMax(iTestTIM0CNTArray, TEST_ARRAY_LEN);
;;;237    ////				iTestTIM0CNTMin = getMin(iTestTIM0CNTArray, TEST_ARRAY_LEN);
;;;238    ////			}
;;;239    ////			RECORD_TEST_DELTA_ZXD(iTestNewPeriodIndex, iThisZXDetectedTime);
;;;240    //			// Only when iTempDeltaZXD larger than minimum phase time and
;;;241    //			// smaller then max phase time we consider it is valid
;;;242    //			if ((iTargetNewPeriod > MIN_PHASE_TIME) && (iTargetNewPeriod < MAX_PHASE_TIME))
;;;243    //			{
;;;244    ////				ACMP0_INT_DISABLE;	// This phase job done
;;;245    //				TIMER_DisableInt(TIMER1);	// TIM1 interrupt will be re-open in TIM0 interrupt (phase change) to implement AVOID_ZXD_AFTER_PHCHG
;;;246    //				iTestEnter_ACMP_MATCH++;
;;;247    //				// We can consider ZX detected, and USE IT!!!!
;;;248    //				// To get stable and solide ZXD, more filter will be added in the TIM0 (phase change) interrupt
;;;249    //				// Only after continuously some number of ThisPhaseDetectedZX or miss ThisPhaseDetectedZX, it will enter or loss lock
;;;250    //				mMotor.structMotor.MSR.ThisPhaseDetectedZX = TRUE;
;;;251    //				iLastZXDetectedTime = iThisZXDetectedTime;
;;;252    //
;;;253    //				// Incase the counter of TIM0 is already in front of iTempDeltaZXD
;;;254    //				if ((TRUE == mMotor.structMotor.MSR.Locked))	// && (iTargetNewPeriod > (TIMER_GetCounter(TIMER0) + ZXD_BEFORE_PHCHG)))
;;;255    //				{	// Still have time to change CMP in TIM0
;;;256    //					// You can have a rest, now the only thing left is T0 trigger phase change
;;;257    //
;;;258    ////					BRG_DISABLE;
;;;259    //					iTestDetectedZX++;
;;;260    //					//iTempDeltaZXD = (mMotor.structMotor.ACT_PERIOD * 3 + iTempDeltaZXD) >> 2;
;;;261    //					if (iTargetNewPeriod > (TIMER_GetCounter(TIMER0) + ZXD_BEFORE_PHCHG))
;;;262    //					{
;;;263    //						mMotor.structMotor.ACT_PERIOD = iTargetNewPeriod;   //GET_TIMER_DIFF(iLastZXDetectedTime, TIMER_GetCounter(TIMER1));
;;;264    //					}
;;;265    //					else
;;;266    //					{
;;;267    //						mMotor.structMotor.ACT_PERIOD = TIMER_GetCounter(TIMER0) + (ZXD_BEFORE_PHCHG << 1);
;;;268    //					}
;;;269    //					TIMER_SET_CMP_VALUE(TIMER0, mMotor.structMotor.ACT_PERIOD);	//TIMER0->TDR + (iTargetNewPeriod >> 2));	//(iTempPhaseChange2ZX >> 1));
;;;270    ////					if (TIMER0->TISR & 0x01)
;;;271    ////					{	// If TIM0 interrupt was already triggered
;;;272    ////						// Clear interrupt flag
;;;273    ////						TIMER0->TISR |= 0x01;
;;;274    ////					}
;;;275    //					//TIMER_SET_CMP_VALUE(TIMER0, mMotor.structMotor.ACT_PERIOD);
;;;276    //				}
;;;277    //			}
;;;278    		}
;;;279    	}
;;;280    }
000140  bdf0              POP      {r4-r7,pc}
                  |L1.322|
000142  6829              LDR      r1,[r5,#0]
000144  43b9              BICS     r1,r1,r7
000146  6029              STR      r1,[r5,#0]
000148  2101              MOVS     r1,#1                 ;204
00014a  7001              STRB     r1,[r0,#0]            ;204
00014c  68a0              LDR      r0,[r4,#8]            ;206
00014e  4308              ORRS     r0,r0,r1              ;206
000150  60a0              STR      r0,[r4,#8]            ;206
000152  6820              LDR      r0,[r4,#0]            ;207
000154  4330              ORRS     r0,r0,r6              ;207
000156  6020              STR      r0,[r4,#0]            ;207
000158  bdf0              POP      {r4-r7,pc}
;;;281    
                          ENDP

                  ACMP_IRQHandler PROC
;;;301    
;;;302    void ACMP_IRQHandler(void)
00015a  485e              LDR      r0,|L1.724|
;;;303    {
;;;304    	ACMP->CMPSR |= ACMP_CMPSR_ACMPF0_Msk;
00015c  6881              LDR      r1,[r0,#8]
00015e  2201              MOVS     r2,#1
000160  4311              ORRS     r1,r1,r2
000162  6081              STR      r1,[r0,#8]
;;;305    //	iTestACMPIntEachPhaseCNT++;
;;;306    //	// maybe before enter TIM0 interrupt this ACMP int was triggered
;;;307    //	if (ACMP->CMPCR[0] & ACMP_CMPCR_ACMPIE_Msk)
;;;308    //	{
;;;309    //		if (ACMP0_EDGE_MATCH)
;;;310    //		{
;;;311    ////			RECORD_TEST_VALUE(iTestNewPeriodIndex, iTestZXDPeriodArray, TIMER_GetCounter(TIMER1) - TIMER1->TCMPR);
;;;312    ////			if (TIMER_GetCounter(TIMER1) < TIMER1->TCMPR)//((iTestNewPeriodIndex == 0) && (iTestZXDPeriodArray[0] != 0))
;;;313    ////			{
;;;314    ////				BRG_DISABLE;
;;;315    ////				stopMotor();
;;;316    ////				iTestZXDPeriodMax = getMax(iTestZXDPeriodArray, TEST_ARRAY_LEN);
;;;317    ////				iTestZXDPeriodMin = getMin(iTestZXDPeriodArray, TEST_ARRAY_LEN);
;;;318    ////			}
;;;319    ////			iTestEnter_ACMP_MATCH++;
;;;320    //			ACMP0_INT_DISABLE;
;;;321    //			PhaseZXDedHandler(TIMER_GetCounter(TIMER1));
;;;322    //		}
;;;323    //	}
;;;324    //}
;;;325    
;;;326    	// In case this was triggered by last phase
;;;327    	// and in TIM0 interrupt didin't successfully disabled this interrupt
;;;328    	if (ENUM_TIM1_ZXD_FILTER == FLAG_TIM1_USEAGE)
000164  4859              LDR      r0,|L1.716|
000166  7800              LDRB     r0,[r0,#0]  ; FLAG_TIM1_USEAGE
000168  2801              CMP      r0,#1
00016a  d112              BNE      |L1.402|
;;;329    	{	 	
;;;330    		// Rising or falling edge will be put into TIM1 Interrupt handler because the following situdation will have problem:
;;;331    		// First a matched edge happened, then an un-matched edge happened
;;;332    		// So NOT check ACMP0_EDGE_MATCH here
;;;333    		//	if (ACMP0_EDGE_MATCH)
;;;334    		//	{
;;;335    		// Start count, if ACMP level can be stable for ZXD_FILTER_TIME
;;;336    		// we can consider real ZX
;;;337    		// If ACMP_IRQHandler was re-entered before ZXD_FILTER_TIME, postpond 
;;;338    		TIMER_SET_CMP_VALUE(TIMER1, GET_TIM1_CMP_VALUE(TIMER1->TDR + ZXD_FILTER_TIME));
00016c  4951              LDR      r1,|L1.692|
00016e  6ac8              LDR      r0,[r1,#0x2c]
000170  4a54              LDR      r2,|L1.708|
000172  30c8              ADDS     r0,r0,#0xc8
000174  4290              CMP      r0,r2
000176  6ac8              LDR      r0,[r1,#0x2c]
000178  d303              BCC      |L1.386|
00017a  4a53              LDR      r2,|L1.712|
00017c  3228              ADDS     r2,r2,#0x28
00017e  1880              ADDS     r0,r0,r2
000180  e000              B        |L1.388|
                  |L1.386|
000182  30c8              ADDS     r0,r0,#0xc8
                  |L1.388|
000184  6248              STR      r0,[r1,#0x24]
000186  484b              LDR      r0,|L1.692|
000188  3020              ADDS     r0,r0,#0x20
00018a  6801              LDR      r1,[r0,#0]
00018c  0602              LSLS     r2,r0,#24
00018e  4311              ORRS     r1,r1,r2
000190  6001              STR      r1,[r0,#0]
                  |L1.402|
;;;339    		TIMER_EnableInt(TIMER1);
;;;340    //		if (ACMP0_EDGE_MATCH)
;;;341    //		{
;;;342    //			ACMP0_INT_DISABLE;	// This phase job done
;;;343    //			iThisZXDetectedTime = TIMER_GetCounter(TIMER1);	// - ZXD_FILTER_TIME;
;;;344    //			//iTempDeltaZXD = GET_TIMER_DIFF(iLastZXDetectedTime, iThisZXDetectedTime) - ZXD_FILTER_TIME - ACMP_HYS_AVG_TIME;
;;;345    //			iTempDeltaZXD = GET_TIMER_DIFF(iLastZXDetectedTime, iThisZXDetectedTime);
;;;346    ////			iTempPhaseChange2ZX = GET_TIMER_DIFF(iPhaseChangeTime, iThisZXDetectedTime) - ZXD_FILTER_TIME;
;;;347    //			//iTargetNewPeriod = (iTempDeltaZXD >> 1) + iTempPhaseChange2ZX;
;;;348    //			iTargetNewPeriod = (iTempDeltaZXD + mMotor.structMotor.ACT_PERIOD) >> 1;
;;;349    ////			iTargetNewPeriod = (iTargetNewPeriod + mMotor.structMotor.ACT_PERIOD) >> 1;
;;;350    //			iTestEnter_TMR1_MATCH++;
;;;351    ////			RECORD_TEST_VALUE(iTestNewPeriodIndex, iTestZXDPeriodArray, iTargetNewPeriod);
;;;352    ////			RECORD_TEST_VALUE(iTestTIM0CNTIndex, iTestTIM0CNTArray, TIMER0->TCMPR);
;;;353    ////			if ((iTestNewPeriodIndex == 0) && (iTestZXDPeriodArray[0] != 0))
;;;354    ////			{
;;;355    ////				BRG_DISABLE;
;;;356    ////				stopMotor();
;;;357    ////				iTestZXDPeriodMax = getMax(iTestZXDPeriodArray, TEST_ARRAY_LEN);
;;;358    ////				iTestZXDPeriodMin = getMin(iTestZXDPeriodArray, TEST_ARRAY_LEN);
;;;359    ////				iTestTIM0CNTMax = getMax(iTestTIM0CNTArray, TEST_ARRAY_LEN);
;;;360    ////				iTestTIM0CNTMin = getMin(iTestTIM0CNTArray, TEST_ARRAY_LEN);
;;;361    ////			}
;;;362    ////			RECORD_TEST_DELTA_ZXD(iTestNewPeriodIndex, iThisZXDetectedTime);
;;;363    //			// Only when iTempDeltaZXD larger than minimum phase time and
;;;364    //			// smaller then max phase time we consider it is valid
;;;365    //			if ((iTargetNewPeriod > MIN_PHASE_TIME) && (iTargetNewPeriod < MAX_PHASE_TIME))
;;;366    //			{
;;;367    ////				ACMP0_INT_DISABLE;	// This phase job done
;;;368    //				TIMER_DisableInt(TIMER1);	// TIM1 interrupt will be re-open in TIM0 interrupt (phase change) to implement AVOID_ZXD_AFTER_PHCHG
;;;369    //				iTestEnter_ACMP_MATCH++;
;;;370    //				// We can consider ZX detected, and USE IT!!!!
;;;371    //				// To get stable and solide ZXD, more filter will be added in the TIM0 (phase change) interrupt
;;;372    //				// Only after continuously some number of ThisPhaseDetectedZX or miss ThisPhaseDetectedZX, it will enter or loss lock
;;;373    //				mMotor.structMotor.MSR.ThisPhaseDetectedZX = TRUE;
;;;374    //				iLastZXDetectedTime = iThisZXDetectedTime;
;;;375    //
;;;376    //				// Incase the counter of TIM0 is already in front of iTempDeltaZXD
;;;377    //				if ((TRUE == mMotor.structMotor.MSR.Locked))	// && (iTargetNewPeriod > (TIMER_GetCounter(TIMER0) + ZXD_BEFORE_PHCHG)))
;;;378    //				{	// Still have time to change CMP in TIM0
;;;379    //					// You can have a rest, now the only thing left is T0 trigger phase change
;;;380    //
;;;381    ////					BRG_DISABLE;
;;;382    //					iTestDetectedZX++;
;;;383    //					//iTempDeltaZXD = (mMotor.structMotor.ACT_PERIOD * 3 + iTempDeltaZXD) >> 2;
;;;384    //
;;;385    //					mMotor.structMotor.ACT_PERIOD = iTargetNewPeriod;   //GET_TIMER_DIFF(iLastZXDetectedTime, TIMER_GetCounter(TIMER1));
;;;386    //					TIMER_SET_CMP_VALUE(TIMER0, TIMER0->TDR + (iTargetNewPeriod >> 2));	//(iTempPhaseChange2ZX >> 1));
;;;387    ////					if (TIMER0->TISR & 0x01)
;;;388    ////					{	// If TIM0 interrupt was already triggered
;;;389    ////						// Clear interrupt flag
;;;390    ////						TIMER0->TISR |= 0x01;
;;;391    ////					}
;;;392    //					//TIMER_SET_CMP_VALUE(TIMER0, mMotor.structMotor.ACT_PERIOD);
;;;393    //				}
;;;394    //			}
;;;395    //		}
;;;396    //	}
;;;397    	}
;;;398    }
000192  4770              BX       lr
;;;399    
                          ENDP

                  ADC_IRQHandler PROC
;;;400    void ADC_IRQHandler(void)
000194  b5f8              PUSH     {r3-r7,lr}
;;;401    {
;;;402        static uint32_t iADC_ComparatorFlag;
;;;403    	static uint32_t iSystemTickTemp;
;;;404    	static uint16_t iBatteryLowCNT = 0;
;;;405        static uint32_t iBatteryLowLastTimeRCD = 0;
;;;406    
;;;407        // Get ADC comparator interrupt flag
;;;408        iADC_ComparatorFlag = ADC_GET_INT_FLAG(ADC, ADC_CURRENT_CMP_MSK | ADC_BATTERY_CMP_MSK | ADC_ADF_MSK);
000196  4e52              LDR      r6,|L1.736|
000198  6b30              LDR      r0,[r6,#0x30]
00019a  4c4d              LDR      r4,|L1.720|
00019c  0740              LSLS     r0,r0,#29
00019e  0f40              LSRS     r0,r0,#29
;;;409        if(iADC_ComparatorFlag & ADC_ADF_MSK)
0001a0  6120              STR      r0,[r4,#0x10]  ; iADC_ComparatorFlag
0001a2  07c1              LSLS     r1,r0,#31
0001a4  d01d              BEQ      |L1.482|
;;;410    	{
;;;411    		// Change ADC channel
;;;412    		if (ADC->ADCHER & ADC_CURRENT_CHN_MSK)
0001a6  6a71              LDR      r1,[r6,#0x24]
0001a8  07ca              LSLS     r2,r1,#31
;;;413    		{
;;;414    			mMotor.structMotor.CURRENT = (uint16_t)(ADC_GET_CONVERSION_DATA(ADC, WHAT_EVER_DO_NOT_CARE));
0001aa  4945              LDR      r1,|L1.704|
0001ac  d008              BEQ      |L1.448|
0001ae  6832              LDR      r2,[r6,#0]
0001b0  0592              LSLS     r2,r2,#22
0001b2  0d92              LSRS     r2,r2,#22
0001b4  844a              STRH     r2,[r1,#0x22]
;;;415    			ADC_SET_INPUT_CHANNEL(ADC, ADC_BATTERY_CHN_MSK);		
0001b6  6a71              LDR      r1,[r6,#0x24]
0001b8  0a09              LSRS     r1,r1,#8
0001ba  0209              LSLS     r1,r1,#8
0001bc  3180              ADDS     r1,r1,#0x80
0001be  e00a              B        |L1.470|
                  |L1.448|
;;;416    		}
;;;417    		else if (ADC->ADCHER & ADC_BATTERY_CHN_MSK)
0001c0  6a72              LDR      r2,[r6,#0x24]
0001c2  0612              LSLS     r2,r2,#24
0001c4  d508              BPL      |L1.472|
;;;418    		{
;;;419    			mMotor.structMotor.BATTERY = (uint16_t)(ADC_GET_CONVERSION_DATA(ADC, WHAT_EVER_DO_NOT_CARE));
0001c6  6832              LDR      r2,[r6,#0]
0001c8  0592              LSLS     r2,r2,#22
0001ca  0d92              LSRS     r2,r2,#22
0001cc  840a              STRH     r2,[r1,#0x20]
;;;420    			ADC_SET_INPUT_CHANNEL(ADC, ADC_CURRENT_CHN_MSK);
0001ce  6a71              LDR      r1,[r6,#0x24]
0001d0  0a09              LSRS     r1,r1,#8
0001d2  0209              LSLS     r1,r1,#8
0001d4  1c49              ADDS     r1,r1,#1
                  |L1.470|
0001d6  6271              STR      r1,[r6,#0x24]
                  |L1.472|
;;;421    		}
;;;422    		ADC_START_CONV(ADC);
0001d8  6a31              LDR      r1,[r6,#0x20]
0001da  2201              MOVS     r2,#1
0001dc  02d2              LSLS     r2,r2,#11
0001de  4311              ORRS     r1,r1,r2
0001e0  6231              STR      r1,[r6,#0x20]
                  |L1.482|
0001e2  4d34              LDR      r5,|L1.692|
;;;423    	}    
;;;424        if(iADC_ComparatorFlag & ADC_CURRENT_CMP_MSK)
0001e4  0780              LSLS     r0,r0,#30
0001e6  2700              MOVS     r7,#0
0001e8  3520              ADDS     r5,r5,#0x20
0001ea  2800              CMP      r0,#0
0001ec  da18              BGE      |L1.544|
;;;425    	{
;;;426    		// current too big
;;;427    		MOTOR_SHUT_DOWN;
0001ee  483d              LDR      r0,|L1.740|
0001f0  6207              STR      r7,[r0,#0x20]
0001f2  4932              LDR      r1,|L1.700|
0001f4  614f              STR      r7,[r1,#0x14]
0001f6  482f              LDR      r0,|L1.692|
0001f8  6803              LDR      r3,[r0,#0]
0001fa  0382              LSLS     r2,r0,#14
0001fc  4393              BICS     r3,r3,r2
0001fe  6003              STR      r3,[r0,#0]
000200  682b              LDR      r3,[r5,#0]
000202  4393              BICS     r3,r3,r2
000204  602b              STR      r3,[r5,#0]
000206  6803              LDR      r3,[r0,#0]
000208  0342              LSLS     r2,r0,#13
00020a  4393              BICS     r3,r3,r2
00020c  6003              STR      r3,[r0,#0]
00020e  6828              LDR      r0,[r5,#0]
000210  4390              BICS     r0,r0,r2
000212  6028              STR      r0,[r5,#0]
000214  20ff              MOVS     r0,#0xff
000216  63c8              STR      r0,[r1,#0x3c]
000218  6388              STR      r0,[r1,#0x38]
;;;428    		setError(ERR_CURRENT_BURNING);
00021a  2006              MOVS     r0,#6
00021c  f7fffffe          BL       setError
                  |L1.544|
;;;429    	}
;;;430        if(iADC_ComparatorFlag & ADC_BATTERY_CMP_MSK)
000220  7c20              LDRB     r0,[r4,#0x10]  ; iADC_ComparatorFlag
000222  0740              LSLS     r0,r0,#29
000224  d529              BPL      |L1.634|
;;;431    	{
;;;432    		// if this time's battery low is near to the last one
;;;433    		// 0.64ms interval of each measurement
;;;434    		iSystemTickTemp = iSystemTick;
000226  4830              LDR      r0,|L1.744|
000228  6800              LDR      r0,[r0,#0]  ; iSystemTick
;;;435    		if ((uint32_t)(iSystemTickTemp - iBatteryLowLastTimeRCD) < BATTERY_LOW_MIN_INTERVAL)
00022a  6160              STR      r0,[r4,#0x14]  ; iSystemTickTemp
00022c  69a1              LDR      r1,[r4,#0x18]  ; iBatteryLowLastTimeRCD
00022e  1a40              SUBS     r0,r0,r1
000230  280a              CMP      r0,#0xa
000232  d21f              BCS      |L1.628|
;;;436    		{
;;;437    			if (iBatteryLowCNT < MAX_BATT_LOW_CNT)
000234  8820              LDRH     r0,[r4,#0]  ; iBatteryLowCNT
000236  2832              CMP      r0,#0x32
000238  d202              BCS      |L1.576|
00023a  1c40              ADDS     r0,r0,#1
;;;438    			{
;;;439    				iBatteryLowCNT++;
00023c  8020              STRH     r0,[r4,#0]
00023e  e01a              B        |L1.630|
                  |L1.576|
;;;440    			}
;;;441    			else
;;;442    			{
;;;443    				// battery really too low
;;;444    				MOTOR_SHUT_DOWN;
000240  4828              LDR      r0,|L1.740|
000242  6207              STR      r7,[r0,#0x20]
000244  491d              LDR      r1,|L1.700|
000246  614f              STR      r7,[r1,#0x14]
000248  481a              LDR      r0,|L1.692|
00024a  6802              LDR      r2,[r0,#0]
00024c  0383              LSLS     r3,r0,#14
00024e  439a              BICS     r2,r2,r3
000250  6002              STR      r2,[r0,#0]
000252  682a              LDR      r2,[r5,#0]
000254  439a              BICS     r2,r2,r3
000256  602a              STR      r2,[r5,#0]
000258  6803              LDR      r3,[r0,#0]
00025a  0342              LSLS     r2,r0,#13
00025c  4393              BICS     r3,r3,r2
00025e  6003              STR      r3,[r0,#0]
000260  6828              LDR      r0,[r5,#0]
000262  4390              BICS     r0,r0,r2
000264  6028              STR      r0,[r5,#0]
000266  20ff              MOVS     r0,#0xff
000268  63c8              STR      r0,[r1,#0x3c]
00026a  6388              STR      r0,[r1,#0x38]
;;;445    				setError(ERR_BATTERY_LOW);
00026c  2004              MOVS     r0,#4
00026e  f7fffffe          BL       setError
000272  e000              B        |L1.630|
                  |L1.628|
;;;446    			}
;;;447    		}
;;;448    		else
;;;449    		{
;;;450    			iBatteryLowCNT = 0;
000274  8027              STRH     r7,[r4,#0]
                  |L1.630|
;;;451    		}
;;;452    		iBatteryLowLastTimeRCD = iSystemTickTemp; 
000276  6960              LDR      r0,[r4,#0x14]  ; iSystemTickTemp
000278  61a0              STR      r0,[r4,#0x18]  ; iBatteryLowLastTimeRCD
                  |L1.634|
;;;453    	}
;;;454        
;;;455        ADC_CLR_INT_FLAG(ADC, iADC_ComparatorFlag);
00027a  6b30              LDR      r0,[r6,#0x30]
00027c  6921              LDR      r1,[r4,#0x10]  ; iADC_ComparatorFlag
00027e  08c0              LSRS     r0,r0,#3
000280  00c0              LSLS     r0,r0,#3
000282  4308              ORRS     r0,r0,r1
000284  6330              STR      r0,[r6,#0x30]
;;;456    }
000286  bdf8              POP      {r3-r7,pc}
;;;457    
                          ENDP

                  SPI_IRQHandler PROC
;;;468    
;;;469    void SPI_IRQHandler(void)
000288  4918              LDR      r1,|L1.748|
;;;470    {
;;;471    	iSPI_ReadData = SPI->RX;
00028a  6908              LDR      r0,[r1,#0x10]
00028c  4a18              LDR      r2,|L1.752|
;;;472    	if(IS_COMM_CMD(iSPI_ReadData))
;;;473    	{
;;;474    		if(IS_COMM_CMD_WR(iSPI_ReadData))
;;;475    		{
;;;476    			// Write register command
;;;477    			enumRegister = (ENUM_COMM_REG)(COMM_VALUE_MASK & iSPI_ReadData);
;;;478    		}
;;;479    		else
;;;480    		{
;;;481    			// Read register command
;;;482    			SPI_WRITE_TX(SPI, mMotor.iValue[enumRegister]);
;;;483    			SPI_TRIGGER(SPI);
;;;484    		}
;;;485    	}
;;;486    	else
;;;487    	{
;;;488    		// write register value, which register was pointed in CMD (last transmision)
;;;489    		mMotor.iValue[enumRegister] = COMM_VALUE_MASK & iSPI_ReadData;
00028e  4b0c              LDR      r3,|L1.704|
000290  8010              STRH     r0,[r2,#0]            ;471
000292  4a18              LDR      r2,|L1.756|
000294  0440              LSLS     r0,r0,#17
000296  7812              LDRB     r2,[r2,#0]  ; enumRegister
000298  0c40              LSRS     r0,r0,#17
00029a  0052              LSLS     r2,r2,#1
00029c  5298              STRH     r0,[r3,r2]
;;;490    	}
;;;491    	// Clear unit transfer interrupt flag IF (SPI_CNTRL[16])
;;;492    	SPI->CNTRL |= SPI_CNTRL_IF_Msk;
00029e  6808              LDR      r0,[r1,#0]
0002a0  2201              MOVS     r2,#1
0002a2  0412              LSLS     r2,r2,#16
0002a4  4310              ORRS     r0,r0,r2
0002a6  6008              STR      r0,[r1,#0]
;;;493    }
0002a8  4770              BX       lr
;;;494    
                          ENDP

                  SysTick_Handler PROC
;;;495    void SysTick_Handler(void)
0002aa  480f              LDR      r0,|L1.744|
;;;496    {
;;;497    	iSystemTick += 5;
0002ac  6801              LDR      r1,[r0,#0]  ; iSystemTick
0002ae  1d49              ADDS     r1,r1,#5
0002b0  6001              STR      r1,[r0,#0]  ; iSystemTick
;;;498    }
0002b2  4770              BX       lr
                          ENDP

                  |L1.692|
                          DCD      0x40010000
                  |L1.696|
                          DCD      FLAG_PHASE_CHANGED
                  |L1.700|
                          DCD      0x40040040
                  |L1.704|
                          DCD      mMotor
                  |L1.708|
                          DCD      0x00ffffff
                  |L1.712|
                          DCD      0xff0000a1
                  |L1.716|
                          DCD      FLAG_TIM1_USEAGE
                  |L1.720|
                          DCD      ||.data||
                  |L1.724|
                          DCD      0x400d0000
                  |L1.728|
                          DCD      iLastZXDetectedTime
                  |L1.732|
                          DCD      0x0000251b
                  |L1.736|
                          DCD      0x400e0000
                  |L1.740|
                          DCD      0x50004240
                  |L1.744|
                          DCD      iSystemTick
                  |L1.748|
                          DCD      0x40030000
                  |L1.752|
                          DCD      iSPI_ReadData
                  |L1.756|
                          DCD      enumRegister

                          AREA ||.data||, DATA, ALIGN=2

                  iBatteryLowCNT
000000  0000              DCW      0x0000
000002  0000              DCB      0x00,0x00
                  iZXMatchCNT
                          DCD      0x00000000
                  iTempDeltaZXD
                          DCD      0x00000000
                  iHalfPeriod
                          DCD      0x00000000
                  iADC_ComparatorFlag
                          DCD      0x00000000
                  iSystemTickTemp
                          DCD      0x00000000
                  iBatteryLowLastTimeRCD
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "User\\it.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___4_it_c_7868258a____REV16|
#line 118 ".\\CMSIS\\core_cmInstr.h"
|__asm___4_it_c_7868258a____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___4_it_c_7868258a____REVSH|
#line 132
|__asm___4_it_c_7868258a____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
