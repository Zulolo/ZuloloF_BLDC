; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\it.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\it.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\Mini51Series\Include -I..\..\..\Library\StdDriver\inc -I.\StdDriver\inc -I.\CMSIS -I.\RTE\_Template -IC:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.1.0\Device\Mini51\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=524 --omf_browse=.\obj\it.crf User\it.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  TMR0_IRQHandler PROC
;;;14     // Timer 0 is used to change phase
;;;15     void TMR0_IRQHandler(void)                                   
000000  b510              PUSH     {r4,lr}
;;;16     {
;;;17     	TIMER0->TISR  = TIMER0->TISR;	//~0;    // Write 1 to clear interrupt flag
000002  499e              LDR      r1,|L1.636|
000004  6888              LDR      r0,[r1,#8]
000006  6088              STR      r0,[r1,#8]
;;;18     
;;;19     	FLAG_PHASE_CHANGED = SET;
000008  4a9d              LDR      r2,|L1.640|
00000a  2001              MOVS     r0,#1
00000c  7010              STRB     r0,[r2,#0]
;;;20     
;;;21     	if (TRUE == tMotor.structMotor.MSR.bZeroCrossDetecting)
00000e  489d              LDR      r0,|L1.644|
000010  8880              LDRH     r0,[r0,#4]  ; tMotor
000012  0780              LSLS     r0,r0,#30
000014  d519              BPL      |L1.74|
000016  4a99              LDR      r2,|L1.636|
000018  3220              ADDS     r2,r2,#0x20           ;16
00001a  6810              LDR      r0,[r2,#0]            ;16
00001c  034b              LSLS     r3,r1,#13             ;16
00001e  4398              BICS     r0,r0,r3              ;16
000020  6010              STR      r0,[r2,#0]            ;16
;;;22     	{
;;;23     		// In case TIM1 interrupt was triggered but before TIM0 interrupt (phase change)
;;;24     		TIMER_DisableInt(TIMER1);
;;;25     		TIMER1->TISR  = ~0;    // Clear interrupt flag
000022  2000              MOVS     r0,#0
000024  43c0              MVNS     r0,r0
000026  6288              STR      r0,[r1,#0x28]
;;;26     		TIMER_SET_CMP_VALUE(TIMER1, GET_TIM1_CMP_VALUE(TIMER1->TDR + AVOID_ZXD_AFTER_PHCHG));	
000028  6ac8              LDR      r0,[r1,#0x2c]
00002a  4c97              LDR      r4,|L1.648|
00002c  30a0              ADDS     r0,r0,#0xa0
00002e  42a0              CMP      r0,r4
000030  6ac8              LDR      r0,[r1,#0x2c]
000032  d302              BCC      |L1.58|
000034  4c95              LDR      r4,|L1.652|
000036  1900              ADDS     r0,r0,r4
000038  e000              B        |L1.60|
                  |L1.58|
00003a  30a0              ADDS     r0,r0,#0xa0
                  |L1.60|
00003c  6248              STR      r0,[r1,#0x24]
;;;27     		// ****!! In future AVOID_ZXD_AFTER_PHCHG can be made to dynamic !!****
;;;28     		// ****!! which means at lower RPM, the AVOID_ZXD_AFTER_PHCHG will be longer than at higher RPM !!****
;;;29     		//GET_TIMER_DIFF(PWM_ZX_FILTER_TIME, GET_TIM1_CMP_VALUE(TIMER1->TDR + (tMotor.structMotor.ACT_PERIOD >> 1))));	
;;;30     		//(tMotor.structMotor.ACT_PERIOD >> 2)));
;;;31     		FLAG_TIM1_USEAGE = ENUM_TIM1_AVOID_ZXD;
00003e  4994              LDR      r1,|L1.656|
000040  2000              MOVS     r0,#0
000042  7008              STRB     r0,[r1,#0]
000044  6810              LDR      r0,[r2,#0]
000046  4318              ORRS     r0,r0,r3
000048  6010              STR      r0,[r2,#0]
                  |L1.74|
;;;32     		TIMER_EnableInt(TIMER1);
;;;33     	}
;;;34     }
00004a  bd10              POP      {r4,pc}
;;;35     
                          ENDP

                  PhaseZXDedHandler PROC
;;;36     int32_t PhaseZXDedHandler(uint32_t iThisZXDetectedTime)
00004c  b530              PUSH     {r4,r5,lr}
;;;37     {
;;;38     	static uint32_t iTempDeltaZXD = 0;
;;;39     	static uint32_t iHalfPeriod = 0;
;;;40     //	static uint32_t iThisZXDetectedTime = 0;
;;;41     
;;;42     	//iThisZXDetectedTime = TIMER_GetCounter(TIMER1);
;;;43     
;;;44     	iTempDeltaZXD = GET_TIMER_DIFF(unLastZXDetectedTime, iThisZXDetectedTime);
00004e  4a91              LDR      r2,|L1.660|
000050  6811              LDR      r1,[r2,#0]  ; unLastZXDetectedTime
000052  4288              CMP      r0,r1
000054  d902              BLS      |L1.92|
000056  6811              LDR      r1,[r2,#0]  ; unLastZXDetectedTime
000058  1a41              SUBS     r1,r0,r1
00005a  e003              B        |L1.100|
                  |L1.92|
00005c  6813              LDR      r3,[r2,#0]  ; unLastZXDetectedTime
00005e  498a              LDR      r1,|L1.648|
000060  1ac9              SUBS     r1,r1,r3
000062  1809              ADDS     r1,r1,r0
                  |L1.100|
;;;45     
;;;46     	if ((iTempDeltaZXD > MIN_PHASE_TIME) && (iTempDeltaZXD < MAX_PHASE_TIME))
000064  460c              MOV      r4,r1
000066  4b8c              LDR      r3,|L1.664|
000068  3cff              SUBS     r4,r4,#0xff
00006a  4d8c              LDR      r5,|L1.668|
00006c  3cf6              SUBS     r4,r4,#0xf6
00006e  6059              STR      r1,[r3,#4]  ; iTempDeltaZXD
000070  42ac              CMP      r4,r5
000072  d221              BCS      |L1.184|
;;;47     	{
;;;48     		unLastZXDetectedTime = iThisZXDetectedTime;
000074  6010              STR      r0,[r2,#0]  ; unLastZXDetectedTime
;;;49     		tMotor.structMotor.MSR.bThisPhaseDetectedZX = TRUE;
000076  4883              LDR      r0,|L1.644|
000078  8882              LDRH     r2,[r0,#4]  ; tMotor
00007a  2408              MOVS     r4,#8
00007c  4322              ORRS     r2,r2,r4
00007e  8082              STRH     r2,[r0,#4]
;;;50     //		iTestDetectedZX++;
;;;51     		if (TRUE == tMotor.structMotor.MSR.bLocked)
000080  8882              LDRH     r2,[r0,#4]  ; tMotor
000082  0752              LSLS     r2,r2,#29
000084  d516              BPL      |L1.180|
;;;52     		{
;;;53     			tMotor.structMotor.unActualPeriod = (iTempDeltaZXD + tMotor.structMotor.unActualPeriod) >> 1;
000086  69c2              LDR      r2,[r0,#0x1c]  ; tMotor
000088  1851              ADDS     r1,r2,r1
00008a  0849              LSRS     r1,r1,#1
00008c  61c1              STR      r1,[r0,#0x1c]  ; tMotor
;;;54     			iHalfPeriod = tMotor.structMotor.unActualPeriod >> 1;
00008e  69c0              LDR      r0,[r0,#0x1c]  ; tMotor
;;;55     			TIMER_SET_CMP_VALUE(TIMER0, TIMER0->TDR + (iHalfPeriod > TIME_DEBT) ? (iHalfPeriod - TIME_DEBT) : ZXD_BEFORE_PHCHG);
000090  4a7a              LDR      r2,|L1.636|
000092  0840              LSRS     r0,r0,#1              ;54
000094  6098              STR      r0,[r3,#8]  ; iHalfPeriod
000096  68d3              LDR      r3,[r2,#0xc]
000098  21ff              MOVS     r1,#0xff
00009a  3105              ADDS     r1,#5
00009c  4288              CMP      r0,r1
00009e  d901              BLS      |L1.164|
0000a0  2101              MOVS     r1,#1
0000a2  e000              B        |L1.166|
                  |L1.164|
0000a4  2100              MOVS     r1,#0
                  |L1.166|
0000a6  42cb              CMN      r3,r1
0000a8  d002              BEQ      |L1.176|
0000aa  38ff              SUBS     r0,r0,#0xff
0000ac  3805              SUBS     r0,#5
0000ae  e000              B        |L1.178|
                  |L1.176|
0000b0  2032              MOVS     r0,#0x32
                  |L1.178|
0000b2  6050              STR      r0,[r2,#4]
                  |L1.180|
;;;56     		}
;;;57     		return TRUE;
0000b4  2001              MOVS     r0,#1
;;;58     	}
;;;59     	else
;;;60     	{
;;;61     		return FALSE;
;;;62     	}
;;;63     }
0000b6  bd30              POP      {r4,r5,pc}
                  |L1.184|
0000b8  2000              MOVS     r0,#0                 ;61
0000ba  bd30              POP      {r4,r5,pc}
;;;64     
                          ENDP

                  TMR1_IRQHandler PROC
;;;65     // Used to set time reference and filter ZXD
;;;66     void TMR1_IRQHandler(void)                                   
0000bc  b5f0              PUSH     {r4-r7,lr}
;;;67     {
;;;68     //	TIMER_DisableInt(TIMER1);
;;;69     	TIMER1->TISR = ~0;    // Clear interrupt flag
0000be  2000              MOVS     r0,#0
0000c0  496e              LDR      r1,|L1.636|
0000c2  43c0              MVNS     r0,r0
0000c4  6288              STR      r0,[r1,#0x28]
;;;70     
;;;71     	if (ENUM_TIM1_AVOID_ZXD == FLAG_TIM1_USEAGE)
0000c6  4872              LDR      r0,|L1.656|
0000c8  7801              LDRB     r1,[r0,#0]  ; FLAG_TIM1_USEAGE
0000ca  4d6c              LDR      r5,|L1.636|
0000cc  2701              MOVS     r7,#1
0000ce  077f              LSLS     r7,r7,#29
;;;72     	{
;;;73     		TIMER_DisableInt(TIMER1);	// ACMP interrupt will re-open TIM1's interrupt
;;;74     		FLAG_TIM1_USEAGE = ENUM_TIM1_ZXD_FILTER;
;;;75     		// Clear all ACMP changed flag happened before
;;;76     		ACMP->CMPSR |= ACMP_CMPSR_ACMPF0_Msk;
;;;77     		ACMP0_INT_ENABLE;
0000d0  2602              MOVS     r6,#2
0000d2  4c73              LDR      r4,|L1.672|
0000d4  3520              ADDS     r5,r5,#0x20           ;76
0000d6  2900              CMP      r1,#0                 ;71
0000d8  d014              BEQ      |L1.260|
;;;78     	}
;;;79     	else
;;;80     	{	// for now can only be ENUM_TIM1_ZXD_FILTER
;;;81     		if (ACMP0_EDGE_MATCH)
0000da  4872              LDR      r0,|L1.676|
0000dc  6b80              LDR      r0,[r0,#0x38]
0000de  68a1              LDR      r1,[r4,#8]
0000e0  0600              LSLS     r0,r0,#24
0000e2  0fc0              LSRS     r0,r0,#31
0000e4  0749              LSLS     r1,r1,#29
0000e6  0fc9              LSRS     r1,r1,#31
0000e8  4288              CMP      r0,r1
0000ea  d10a              BNE      |L1.258|
0000ec  68e8              LDR      r0,[r5,#0xc]
;;;82     		{	
;;;83     			// No need to find the real ZXD time, we only care the delta 
;;;84     			if (TRUE == PhaseZXDedHandler(TIMER_GetCounter(TIMER1)))	//GET_TIMER_DIFF(ZXD_FILTER_TIME, TIMER_GetCounter(TIMER1))))
0000ee  f7fffffe          BL       PhaseZXDedHandler
0000f2  2801              CMP      r0,#1
0000f4  d105              BNE      |L1.258|
;;;85     			{
;;;86     				ACMP0_INT_DISABLE;  // This phase ACMP job done
0000f6  6820              LDR      r0,[r4,#0]
0000f8  43b0              BICS     r0,r0,r6
0000fa  6020              STR      r0,[r4,#0]
0000fc  6828              LDR      r0,[r5,#0]
0000fe  43b8              BICS     r0,r0,r7
000100  6028              STR      r0,[r5,#0]
                  |L1.258|
;;;87     				TIMER_DisableInt(TIMER1);
;;;88     			}
;;;89     		}
;;;90     	}
;;;91     }
000102  bdf0              POP      {r4-r7,pc}
                  |L1.260|
000104  6829              LDR      r1,[r5,#0]
000106  43b9              BICS     r1,r1,r7
000108  6029              STR      r1,[r5,#0]
00010a  2101              MOVS     r1,#1                 ;74
00010c  7001              STRB     r1,[r0,#0]            ;74
00010e  68a0              LDR      r0,[r4,#8]            ;76
000110  4308              ORRS     r0,r0,r1              ;76
000112  60a0              STR      r0,[r4,#8]            ;76
000114  6820              LDR      r0,[r4,#0]            ;77
000116  4330              ORRS     r0,r0,r6              ;77
000118  6020              STR      r0,[r4,#0]            ;77
00011a  bdf0              POP      {r4-r7,pc}
;;;92     
                          ENDP

                  ACMP_IRQHandler PROC
;;;93     void ACMP_IRQHandler(void)
00011c  4860              LDR      r0,|L1.672|
;;;94     {
;;;95     	ACMP->CMPSR |= ACMP_CMPSR_ACMPF0_Msk;
00011e  6881              LDR      r1,[r0,#8]
000120  2201              MOVS     r2,#1
000122  4311              ORRS     r1,r1,r2
000124  6081              STR      r1,[r0,#8]
;;;96     
;;;97     	// In case this was triggered by last phase
;;;98     	// and in TIM0 interrupt didin't successfully disabled this interrupt
;;;99     	if (ENUM_TIM1_ZXD_FILTER == FLAG_TIM1_USEAGE)
000126  485a              LDR      r0,|L1.656|
000128  7800              LDRB     r0,[r0,#0]  ; FLAG_TIM1_USEAGE
00012a  2801              CMP      r0,#1
00012c  d112              BNE      |L1.340|
;;;100    	{	 	
;;;101    		// Rising or falling edge will be put into TIM1 Interrupt handler because the following situation will have problem:
;;;102    		// First a matched edge happened, then an un-matched edge happened
;;;103    		// So do NOT check ACMP0_EDGE_MATCH here.
;;;104    
;;;105    		// Start count, if ACMP level can be stable for ZXD_FILTER_TIME
;;;106    		// we can consider real ZX happened
;;;107    		// If ACMP_IRQHandler was re-entered before ZXD_FILTER_TIME, TIM1's interrupt will be postponed
;;;108    		TIMER_SET_CMP_VALUE(TIMER1, GET_TIM1_CMP_VALUE(TIMER1->TDR + ZXD_FILTER_TIME));
00012e  4953              LDR      r1,|L1.636|
000130  6ac8              LDR      r0,[r1,#0x2c]
000132  4a55              LDR      r2,|L1.648|
000134  30c8              ADDS     r0,r0,#0xc8
000136  4290              CMP      r0,r2
000138  6ac8              LDR      r0,[r1,#0x2c]
00013a  d303              BCC      |L1.324|
00013c  4a53              LDR      r2,|L1.652|
00013e  3228              ADDS     r2,r2,#0x28
000140  1880              ADDS     r0,r0,r2
000142  e000              B        |L1.326|
                  |L1.324|
000144  30c8              ADDS     r0,r0,#0xc8
                  |L1.326|
000146  6248              STR      r0,[r1,#0x24]
000148  484c              LDR      r0,|L1.636|
00014a  3020              ADDS     r0,r0,#0x20
00014c  6801              LDR      r1,[r0,#0]
00014e  0602              LSLS     r2,r0,#24
000150  4311              ORRS     r1,r1,r2
000152  6001              STR      r1,[r0,#0]
                  |L1.340|
;;;109    		TIMER_EnableInt(TIMER1);
;;;110    	}
;;;111    }
000154  4770              BX       lr
;;;112    
                          ENDP

                  ADC_IRQHandler PROC
;;;113    void ADC_IRQHandler(void)
000156  b5f8              PUSH     {r3-r7,lr}
;;;114    {
;;;115      static uint32_t iADC_ComparatorFlag;
;;;116    	static uint32_t iSystemTickTemp;
;;;117    	static uint16_t iBatteryLowCNT = 0;
;;;118      static uint32_t iBatteryLowLastTimeRCD = 0;
;;;119    
;;;120        // Get ADC comparator interrupt flag
;;;121      iADC_ComparatorFlag = ADC_GET_INT_FLAG(ADC, ADC_CURRENT_CMP_MSK | ADC_BATTERY_CMP_MSK | ADC_ADF_MSK);
000158  4e53              LDR      r6,|L1.680|
00015a  6b30              LDR      r0,[r6,#0x30]
00015c  4c4e              LDR      r4,|L1.664|
00015e  0740              LSLS     r0,r0,#29
000160  0f40              LSRS     r0,r0,#29
;;;122      if(iADC_ComparatorFlag & ADC_ADF_MSK)
000162  60e0              STR      r0,[r4,#0xc]  ; iADC_ComparatorFlag
000164  07c1              LSLS     r1,r0,#31
000166  d01d              BEQ      |L1.420|
;;;123    	{
;;;124    		// Change ADC channel
;;;125    		if (ADC->ADCHER & ADC_CURRENT_CHN_MSK)
000168  6a71              LDR      r1,[r6,#0x24]
00016a  07ca              LSLS     r2,r1,#31
;;;126    		{
;;;127    			tMotor.structMotor.unCurrent = (uint16_t)(ADC_GET_CONVERSION_DATA(ADC, WHAT_EVER_DO_NOT_CARE));
00016c  4945              LDR      r1,|L1.644|
00016e  d008              BEQ      |L1.386|
000170  6832              LDR      r2,[r6,#0]
000172  0592              LSLS     r2,r2,#22
000174  0d92              LSRS     r2,r2,#22
000176  850a              STRH     r2,[r1,#0x28]
;;;128    			ADC_SET_INPUT_CHANNEL(ADC, ADC_BATTERY_CHN_MSK);		
000178  6a71              LDR      r1,[r6,#0x24]
00017a  0a09              LSRS     r1,r1,#8
00017c  0209              LSLS     r1,r1,#8
00017e  3180              ADDS     r1,r1,#0x80
000180  e00a              B        |L1.408|
                  |L1.386|
;;;129    		}
;;;130    		else if (ADC->ADCHER & ADC_BATTERY_CHN_MSK)
000182  6a72              LDR      r2,[r6,#0x24]
000184  0612              LSLS     r2,r2,#24
000186  d508              BPL      |L1.410|
;;;131    		{
;;;132    			tMotor.structMotor.unBattery = (uint16_t)(ADC_GET_CONVERSION_DATA(ADC, WHAT_EVER_DO_NOT_CARE));
000188  6832              LDR      r2,[r6,#0]
00018a  0592              LSLS     r2,r2,#22
00018c  0d92              LSRS     r2,r2,#22
00018e  84ca              STRH     r2,[r1,#0x26]
;;;133    			ADC_SET_INPUT_CHANNEL(ADC, ADC_CURRENT_CHN_MSK);
000190  6a71              LDR      r1,[r6,#0x24]
000192  0a09              LSRS     r1,r1,#8
000194  0209              LSLS     r1,r1,#8
000196  1c49              ADDS     r1,r1,#1
                  |L1.408|
000198  6271              STR      r1,[r6,#0x24]
                  |L1.410|
;;;134    		}
;;;135    		ADC_START_CONV(ADC);
00019a  6a31              LDR      r1,[r6,#0x20]
00019c  2201              MOVS     r2,#1
00019e  02d2              LSLS     r2,r2,#11
0001a0  4311              ORRS     r1,r1,r2
0001a2  6231              STR      r1,[r6,#0x20]
                  |L1.420|
0001a4  4d35              LDR      r5,|L1.636|
;;;136    	}    
;;;137        if(iADC_ComparatorFlag & ADC_CURRENT_CMP_MSK)
0001a6  0780              LSLS     r0,r0,#30
0001a8  2700              MOVS     r7,#0
0001aa  3520              ADDS     r5,r5,#0x20
0001ac  2800              CMP      r0,#0
0001ae  da18              BGE      |L1.482|
;;;138    	{
;;;139    		// current too big
;;;140    		MOTOR_SHUT_DOWN;
0001b0  483e              LDR      r0,|L1.684|
0001b2  6207              STR      r7,[r0,#0x20]
0001b4  493b              LDR      r1,|L1.676|
0001b6  614f              STR      r7,[r1,#0x14]
0001b8  4830              LDR      r0,|L1.636|
0001ba  6803              LDR      r3,[r0,#0]
0001bc  0382              LSLS     r2,r0,#14
0001be  4393              BICS     r3,r3,r2
0001c0  6003              STR      r3,[r0,#0]
0001c2  682b              LDR      r3,[r5,#0]
0001c4  4393              BICS     r3,r3,r2
0001c6  602b              STR      r3,[r5,#0]
0001c8  6803              LDR      r3,[r0,#0]
0001ca  0342              LSLS     r2,r0,#13
0001cc  4393              BICS     r3,r3,r2
0001ce  6003              STR      r3,[r0,#0]
0001d0  6828              LDR      r0,[r5,#0]
0001d2  4390              BICS     r0,r0,r2
0001d4  6028              STR      r0,[r5,#0]
0001d6  20ff              MOVS     r0,#0xff
0001d8  63c8              STR      r0,[r1,#0x3c]
0001da  6388              STR      r0,[r1,#0x38]
;;;141    		setError(ERR_CURRENT_BURNING);
0001dc  2007              MOVS     r0,#7
0001de  f7fffffe          BL       setError
                  |L1.482|
;;;142    	}
;;;143        if(iADC_ComparatorFlag & ADC_BATTERY_CMP_MSK)
0001e2  7b20              LDRB     r0,[r4,#0xc]  ; iADC_ComparatorFlag
0001e4  0740              LSLS     r0,r0,#29
0001e6  d529              BPL      |L1.572|
;;;144    	{
;;;145        	// Longer filter for battery voltage
;;;146    		// if this time's battery low is near to the last one
;;;147    		// 0.64ms interval of each measurement
;;;148    		iSystemTickTemp = unSystemTick;
0001e8  4831              LDR      r0,|L1.688|
0001ea  6800              LDR      r0,[r0,#0]  ; unSystemTick
;;;149    		if ((uint32_t)(iSystemTickTemp - iBatteryLowLastTimeRCD) < BATTERY_LOW_MIN_INTERVAL)
0001ec  6120              STR      r0,[r4,#0x10]  ; iSystemTickTemp
0001ee  6961              LDR      r1,[r4,#0x14]  ; iBatteryLowLastTimeRCD
0001f0  1a40              SUBS     r0,r0,r1
0001f2  280a              CMP      r0,#0xa
0001f4  d21f              BCS      |L1.566|
;;;150    		{
;;;151    			if (iBatteryLowCNT < MAX_BATT_LOW_CNT)
0001f6  8820              LDRH     r0,[r4,#0]  ; iBatteryLowCNT
0001f8  2832              CMP      r0,#0x32
0001fa  d202              BCS      |L1.514|
0001fc  1c40              ADDS     r0,r0,#1
;;;152    			{
;;;153    				iBatteryLowCNT++;
0001fe  8020              STRH     r0,[r4,#0]
000200  e01a              B        |L1.568|
                  |L1.514|
;;;154    			}
;;;155    			else
;;;156    			{
;;;157    				// battery really too low
;;;158    				MOTOR_SHUT_DOWN;
000202  482a              LDR      r0,|L1.684|
000204  6207              STR      r7,[r0,#0x20]
000206  4927              LDR      r1,|L1.676|
000208  614f              STR      r7,[r1,#0x14]
00020a  481c              LDR      r0,|L1.636|
00020c  6802              LDR      r2,[r0,#0]
00020e  0383              LSLS     r3,r0,#14
000210  439a              BICS     r2,r2,r3
000212  6002              STR      r2,[r0,#0]
000214  682a              LDR      r2,[r5,#0]
000216  439a              BICS     r2,r2,r3
000218  602a              STR      r2,[r5,#0]
00021a  6803              LDR      r3,[r0,#0]
00021c  0342              LSLS     r2,r0,#13
00021e  4393              BICS     r3,r3,r2
000220  6003              STR      r3,[r0,#0]
000222  6828              LDR      r0,[r5,#0]
000224  4390              BICS     r0,r0,r2
000226  6028              STR      r0,[r5,#0]
000228  20ff              MOVS     r0,#0xff
00022a  63c8              STR      r0,[r1,#0x3c]
00022c  6388              STR      r0,[r1,#0x38]
;;;159    				setError(ERR_BATTERY_LOW);
00022e  2005              MOVS     r0,#5
000230  f7fffffe          BL       setError
000234  e000              B        |L1.568|
                  |L1.566|
;;;160    			}
;;;161    		}
;;;162    		else
;;;163    		{
;;;164    			iBatteryLowCNT = 0;
000236  8027              STRH     r7,[r4,#0]
                  |L1.568|
;;;165    		}
;;;166    		iBatteryLowLastTimeRCD = iSystemTickTemp; 
000238  6920              LDR      r0,[r4,#0x10]  ; iSystemTickTemp
00023a  6160              STR      r0,[r4,#0x14]  ; iBatteryLowLastTimeRCD
                  |L1.572|
;;;167    	}
;;;168        
;;;169        ADC_CLR_INT_FLAG(ADC, iADC_ComparatorFlag);
00023c  6b30              LDR      r0,[r6,#0x30]
00023e  68e1              LDR      r1,[r4,#0xc]  ; iADC_ComparatorFlag
000240  08c0              LSRS     r0,r0,#3
000242  00c0              LSLS     r0,r0,#3
000244  4308              ORRS     r0,r0,r1
000246  6330              STR      r0,[r6,#0x30]
;;;170    }
000248  bdf8              POP      {r3-r7,pc}
;;;171    	
                          ENDP

                  SPI_IRQHandler PROC
;;;172    void SPI_IRQHandler(void)
00024a  481a              LDR      r0,|L1.692|
00024c  6c41              LDR      r1,[r0,#0x44]
00024e  2201              MOVS     r2,#1
000250  0412              LSLS     r2,r2,#16
000252  4311              ORRS     r1,r1,r2
000254  6441              STR      r1,[r0,#0x44]
;;;173    {
;;;174    
;;;175    //	static uint8_t unSelectedReg = 0;
;;;176    	
;;;177    	// Check if it is really finished one unit transfer
;;;178    	SPI_CLR_UNIT_TRANS_INT_FLAG(SPI);
;;;179    	if ((SPI->SSR & SPI_SSR_LTRIG_FLAG_Msk) == SPI_SSR_LTRIG_FLAG_Msk)
000256  6881              LDR      r1,[r0,#8]
000258  0689              LSLS     r1,r1,#26
00025a  d505              BPL      |L1.616|
;;;180    	{
;;;181    		tMotor.structMotor.MSR.bNewComFrameReceived = TRUE;	
00025c  4809              LDR      r0,|L1.644|
00025e  8881              LDRH     r1,[r0,#4]  ; tMotor
000260  2210              MOVS     r2,#0x10
000262  4311              ORRS     r1,r1,r2
000264  8081              STRH     r1,[r0,#4]
;;;182    	}
;;;183    	else
;;;184    	{
;;;185    		SPI_TRIGGER(SPI);
;;;186    	}
;;;187    
;;;188    }
000266  4770              BX       lr
                  |L1.616|
000268  6801              LDR      r1,[r0,#0]
00026a  2201              MOVS     r2,#1
00026c  4311              ORRS     r1,r1,r2
00026e  6001              STR      r1,[r0,#0]
000270  4770              BX       lr
;;;189    
                          ENDP

                  SysTick_Handler PROC
;;;190    void SysTick_Handler(void)
000272  480f              LDR      r0,|L1.688|
;;;191    {
;;;192    	unSystemTick += 5;
000274  6801              LDR      r1,[r0,#0]  ; unSystemTick
000276  1d49              ADDS     r1,r1,#5
000278  6001              STR      r1,[r0,#0]  ; unSystemTick
;;;193    }
00027a  4770              BX       lr
                          ENDP

                  |L1.636|
                          DCD      0x40010000
                  |L1.640|
                          DCD      FLAG_PHASE_CHANGED
                  |L1.644|
                          DCD      tMotor
                  |L1.648|
                          DCD      0x00ffffff
                  |L1.652|
                          DCD      0xff0000a1
                  |L1.656|
                          DCD      FLAG_TIM1_USEAGE
                  |L1.660|
                          DCD      unLastZXDetectedTime
                  |L1.664|
                          DCD      ||.data||
                  |L1.668|
                          DCD      0x0000251b
                  |L1.672|
                          DCD      0x400d0000
                  |L1.676|
                          DCD      0x40040040
                  |L1.680|
                          DCD      0x400e0000
                  |L1.684|
                          DCD      0x50004240
                  |L1.688|
                          DCD      unSystemTick
                  |L1.692|
                          DCD      0x40030000

                          AREA ||.data||, DATA, ALIGN=2

                  iBatteryLowCNT
000000  0000              DCW      0x0000
000002  0000              DCB      0x00,0x00
                  iTempDeltaZXD
                          DCD      0x00000000
                  iHalfPeriod
                          DCD      0x00000000
                  iADC_ComparatorFlag
                          DCD      0x00000000
                  iSystemTickTemp
                          DCD      0x00000000
                  iBatteryLowLastTimeRCD
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "User\\it.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___4_it_c_d50ddd2d____REV16|
#line 118 ".\\CMSIS\\core_cmInstr.h"
|__asm___4_it_c_d50ddd2d____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___4_it_c_d50ddd2d____REVSH|
#line 132
|__asm___4_it_c_d50ddd2d____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
