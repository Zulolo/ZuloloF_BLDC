; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\it.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\it.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\Mini51Series\Include -I..\..\..\Library\StdDriver\inc -I.\StdDriver\inc -I.\CMSIS -IG:\Geek\Projects\Zulolo_F\Force\Code\Zulolo_F_Force\RTE -ID:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.0.7\Device\Mini51\Include -ID:\Keil_v5\ARM\CMSIS\Include -I\ -D__MICROLIB -D__UVISION_VERSION=518 --omf_browse=.\obj\it.crf User\it.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  TMR0_IRQHandler PROC
;;;14     // Timer 0 is used to change phase
;;;15     void TMR0_IRQHandler(void)                                   
000000  b510              PUSH     {r4,lr}
;;;16     {
;;;17     	TIMER0->TISR  = TIMER0->TISR;	//~0;    // Write 1 to clear interrupt flag
000002  49c0              LDR      r1,|L1.772|
000004  6888              LDR      r0,[r1,#8]
000006  6088              STR      r0,[r1,#8]
;;;18     
;;;19     	FLAG_PHASE_CHANGED = SET;
000008  4abf              LDR      r2,|L1.776|
00000a  2001              MOVS     r0,#1
00000c  7010              STRB     r0,[r2,#0]
;;;20     
;;;21     	if (TRUE == tMotor.structMotor.MSR.bZeroCrossDetecting)
00000e  48bf              LDR      r0,|L1.780|
000010  8840              LDRH     r0,[r0,#2]  ; tMotor
000012  0780              LSLS     r0,r0,#30
000014  d519              BPL      |L1.74|
000016  4abb              LDR      r2,|L1.772|
000018  3220              ADDS     r2,r2,#0x20           ;16
00001a  6810              LDR      r0,[r2,#0]            ;16
00001c  034b              LSLS     r3,r1,#13             ;16
00001e  4398              BICS     r0,r0,r3              ;16
000020  6010              STR      r0,[r2,#0]            ;16
;;;22     	{
;;;23     		// In case TIM1 interrupt was triggered but before TIM0 interrupt (phase change)
;;;24     		TIMER_DisableInt(TIMER1);
;;;25     		TIMER1->TISR  = ~0;    // Clear interrupt flag
000022  2000              MOVS     r0,#0
000024  43c0              MVNS     r0,r0
000026  6288              STR      r0,[r1,#0x28]
;;;26     		TIMER_SET_CMP_VALUE(TIMER1, GET_TIM1_CMP_VALUE(TIMER1->TDR + AVOID_ZXD_AFTER_PHCHG));	
000028  6ac8              LDR      r0,[r1,#0x2c]
00002a  4cb9              LDR      r4,|L1.784|
00002c  30a0              ADDS     r0,r0,#0xa0
00002e  42a0              CMP      r0,r4
000030  6ac8              LDR      r0,[r1,#0x2c]
000032  d302              BCC      |L1.58|
000034  4cb7              LDR      r4,|L1.788|
000036  1900              ADDS     r0,r0,r4
000038  e000              B        |L1.60|
                  |L1.58|
00003a  30a0              ADDS     r0,r0,#0xa0
                  |L1.60|
00003c  6248              STR      r0,[r1,#0x24]
;;;27     		// ****!! In future AVOID_ZXD_AFTER_PHCHG can be made to dynamic !!****
;;;28     		// ****!! which means at lower RPM, the AVOID_ZXD_AFTER_PHCHG will be longer than at higher RPM !!****
;;;29     		//GET_TIMER_DIFF(PWM_ZX_FILTER_TIME, GET_TIM1_CMP_VALUE(TIMER1->TDR + (tMotor.structMotor.ACT_PERIOD >> 1))));	
;;;30     		//(tMotor.structMotor.ACT_PERIOD >> 2)));
;;;31     		FLAG_TIM1_USEAGE = ENUM_TIM1_AVOID_ZXD;
00003e  49b6              LDR      r1,|L1.792|
000040  2000              MOVS     r0,#0
000042  7008              STRB     r0,[r1,#0]
000044  6810              LDR      r0,[r2,#0]
000046  4318              ORRS     r0,r0,r3
000048  6010              STR      r0,[r2,#0]
                  |L1.74|
;;;32     		TIMER_EnableInt(TIMER1);
;;;33     	}
;;;34     }
00004a  bd10              POP      {r4,pc}
;;;35     
                          ENDP

                  PhaseZXDedHandler PROC
;;;36     int32_t PhaseZXDedHandler(uint32_t iThisZXDetectedTime)
00004c  b530              PUSH     {r4,r5,lr}
;;;37     {
;;;38     	static uint32_t iTempDeltaZXD = 0;
;;;39     	static uint32_t iHalfPeriod = 0;
;;;40     //	static uint32_t iThisZXDetectedTime = 0;
;;;41     
;;;42     	//iThisZXDetectedTime = TIMER_GetCounter(TIMER1);
;;;43     
;;;44     	iTempDeltaZXD = GET_TIMER_DIFF(unLastZXDetectedTime, iThisZXDetectedTime);
00004e  4ab3              LDR      r2,|L1.796|
000050  6811              LDR      r1,[r2,#0]  ; unLastZXDetectedTime
000052  4288              CMP      r0,r1
000054  d902              BLS      |L1.92|
000056  6811              LDR      r1,[r2,#0]  ; unLastZXDetectedTime
000058  1a41              SUBS     r1,r0,r1
00005a  e003              B        |L1.100|
                  |L1.92|
00005c  6813              LDR      r3,[r2,#0]  ; unLastZXDetectedTime
00005e  49ac              LDR      r1,|L1.784|
000060  1ac9              SUBS     r1,r1,r3
000062  1809              ADDS     r1,r1,r0
                  |L1.100|
;;;45     
;;;46     	if ((iTempDeltaZXD > MIN_PHASE_TIME) && (iTempDeltaZXD < MAX_PHASE_TIME))
000064  460c              MOV      r4,r1
000066  4bae              LDR      r3,|L1.800|
000068  3cff              SUBS     r4,r4,#0xff
00006a  4dae              LDR      r5,|L1.804|
00006c  3cf6              SUBS     r4,r4,#0xf6
00006e  6059              STR      r1,[r3,#4]  ; iTempDeltaZXD
000070  42ac              CMP      r4,r5
000072  d221              BCS      |L1.184|
;;;47     	{
;;;48     		unLastZXDetectedTime = iThisZXDetectedTime;
000074  6010              STR      r0,[r2,#0]  ; unLastZXDetectedTime
;;;49     		tMotor.structMotor.MSR.bThisPhaseDetectedZX = TRUE;
000076  48a5              LDR      r0,|L1.780|
000078  8842              LDRH     r2,[r0,#2]  ; tMotor
00007a  2408              MOVS     r4,#8
00007c  4322              ORRS     r2,r2,r4
00007e  8042              STRH     r2,[r0,#2]
;;;50     //		iTestDetectedZX++;
;;;51     		if (TRUE == tMotor.structMotor.MSR.bLocked)
000080  8842              LDRH     r2,[r0,#2]  ; tMotor
000082  0752              LSLS     r2,r2,#29
000084  d516              BPL      |L1.180|
;;;52     		{
;;;53     			tMotor.structMotor.unActualPeriod = (iTempDeltaZXD + tMotor.structMotor.unActualPeriod) >> 1;
000086  6982              LDR      r2,[r0,#0x18]  ; tMotor
000088  1851              ADDS     r1,r2,r1
00008a  0849              LSRS     r1,r1,#1
00008c  6181              STR      r1,[r0,#0x18]  ; tMotor
;;;54     			iHalfPeriod = tMotor.structMotor.unActualPeriod >> 1;
00008e  6980              LDR      r0,[r0,#0x18]  ; tMotor
;;;55     			TIMER_SET_CMP_VALUE(TIMER0, TIMER0->TDR + (iHalfPeriod > TIME_DEBT) ? (iHalfPeriod - TIME_DEBT) : ZXD_BEFORE_PHCHG);
000090  4a9c              LDR      r2,|L1.772|
000092  0840              LSRS     r0,r0,#1              ;54
000094  6098              STR      r0,[r3,#8]  ; iHalfPeriod
000096  68d3              LDR      r3,[r2,#0xc]
000098  21ff              MOVS     r1,#0xff
00009a  3105              ADDS     r1,#5
00009c  4288              CMP      r0,r1
00009e  d901              BLS      |L1.164|
0000a0  2101              MOVS     r1,#1
0000a2  e000              B        |L1.166|
                  |L1.164|
0000a4  2100              MOVS     r1,#0
                  |L1.166|
0000a6  42cb              CMN      r3,r1
0000a8  d002              BEQ      |L1.176|
0000aa  38ff              SUBS     r0,r0,#0xff
0000ac  3805              SUBS     r0,#5
0000ae  e000              B        |L1.178|
                  |L1.176|
0000b0  2032              MOVS     r0,#0x32
                  |L1.178|
0000b2  6050              STR      r0,[r2,#4]
                  |L1.180|
;;;56     		}
;;;57     		return TRUE;
0000b4  2001              MOVS     r0,#1
;;;58     	}
;;;59     	else
;;;60     	{
;;;61     		return FALSE;
;;;62     	}
;;;63     }
0000b6  bd30              POP      {r4,r5,pc}
                  |L1.184|
0000b8  2000              MOVS     r0,#0                 ;61
0000ba  bd30              POP      {r4,r5,pc}
;;;64     
                          ENDP

                  TMR1_IRQHandler PROC
;;;65     // Used to set time reference and filter ZXD
;;;66     void TMR1_IRQHandler(void)                                   
0000bc  b5f0              PUSH     {r4-r7,lr}
;;;67     {
;;;68     //	TIMER_DisableInt(TIMER1);
;;;69     	TIMER1->TISR = ~0;    // Clear interrupt flag
0000be  2000              MOVS     r0,#0
0000c0  4990              LDR      r1,|L1.772|
0000c2  43c0              MVNS     r0,r0
0000c4  6288              STR      r0,[r1,#0x28]
;;;70     
;;;71     	if (ENUM_TIM1_AVOID_ZXD == FLAG_TIM1_USEAGE)
0000c6  4894              LDR      r0,|L1.792|
0000c8  7801              LDRB     r1,[r0,#0]  ; FLAG_TIM1_USEAGE
0000ca  4d8e              LDR      r5,|L1.772|
0000cc  2701              MOVS     r7,#1
0000ce  077f              LSLS     r7,r7,#29
;;;72     	{
;;;73     		TIMER_DisableInt(TIMER1);	// ACMP interrupt will re-open TIM1's interrupt
;;;74     		FLAG_TIM1_USEAGE = ENUM_TIM1_ZXD_FILTER;
;;;75     		// Clear all ACMP changed flag happened before
;;;76     		ACMP->CMPSR |= ACMP_CMPSR_ACMPF0_Msk;
;;;77     		ACMP0_INT_ENABLE;
0000d0  2602              MOVS     r6,#2
0000d2  4c95              LDR      r4,|L1.808|
0000d4  3520              ADDS     r5,r5,#0x20           ;76
0000d6  2900              CMP      r1,#0                 ;71
0000d8  d014              BEQ      |L1.260|
;;;78     	}
;;;79     	else
;;;80     	{	// for now can only be ENUM_TIM1_ZXD_FILTER
;;;81     		if (ACMP0_EDGE_MATCH)
0000da  4894              LDR      r0,|L1.812|
0000dc  6b80              LDR      r0,[r0,#0x38]
0000de  68a1              LDR      r1,[r4,#8]
0000e0  0600              LSLS     r0,r0,#24
0000e2  0fc0              LSRS     r0,r0,#31
0000e4  0749              LSLS     r1,r1,#29
0000e6  0fc9              LSRS     r1,r1,#31
0000e8  4288              CMP      r0,r1
0000ea  d10a              BNE      |L1.258|
0000ec  68e8              LDR      r0,[r5,#0xc]
;;;82     		{	
;;;83     			// No need to find the real ZXD time, we only care the delta 
;;;84     			if (TRUE == PhaseZXDedHandler(TIMER_GetCounter(TIMER1)))	//GET_TIMER_DIFF(ZXD_FILTER_TIME, TIMER_GetCounter(TIMER1))))
0000ee  f7fffffe          BL       PhaseZXDedHandler
0000f2  2801              CMP      r0,#1
0000f4  d105              BNE      |L1.258|
;;;85     			{
;;;86     				ACMP0_INT_DISABLE;  // This phase ACMP job done
0000f6  6820              LDR      r0,[r4,#0]
0000f8  43b0              BICS     r0,r0,r6
0000fa  6020              STR      r0,[r4,#0]
0000fc  6828              LDR      r0,[r5,#0]
0000fe  43b8              BICS     r0,r0,r7
000100  6028              STR      r0,[r5,#0]
                  |L1.258|
;;;87     				TIMER_DisableInt(TIMER1);
;;;88     			}
;;;89     		}
;;;90     	}
;;;91     }
000102  bdf0              POP      {r4-r7,pc}
                  |L1.260|
000104  6829              LDR      r1,[r5,#0]
000106  43b9              BICS     r1,r1,r7
000108  6029              STR      r1,[r5,#0]
00010a  2101              MOVS     r1,#1                 ;74
00010c  7001              STRB     r1,[r0,#0]            ;74
00010e  68a0              LDR      r0,[r4,#8]            ;76
000110  4308              ORRS     r0,r0,r1              ;76
000112  60a0              STR      r0,[r4,#8]            ;76
000114  6820              LDR      r0,[r4,#0]            ;77
000116  4330              ORRS     r0,r0,r6              ;77
000118  6020              STR      r0,[r4,#0]            ;77
00011a  bdf0              POP      {r4-r7,pc}
;;;92     
                          ENDP

                  ACMP_IRQHandler PROC
;;;93     void ACMP_IRQHandler(void)
00011c  4882              LDR      r0,|L1.808|
;;;94     {
;;;95     	ACMP->CMPSR |= ACMP_CMPSR_ACMPF0_Msk;
00011e  6881              LDR      r1,[r0,#8]
000120  2201              MOVS     r2,#1
000122  4311              ORRS     r1,r1,r2
000124  6081              STR      r1,[r0,#8]
;;;96     
;;;97     	// In case this was triggered by last phase
;;;98     	// and in TIM0 interrupt didin't successfully disabled this interrupt
;;;99     	if (ENUM_TIM1_ZXD_FILTER == FLAG_TIM1_USEAGE)
000126  487c              LDR      r0,|L1.792|
000128  7800              LDRB     r0,[r0,#0]  ; FLAG_TIM1_USEAGE
00012a  2801              CMP      r0,#1
00012c  d112              BNE      |L1.340|
;;;100    	{	 	
;;;101    		// Rising or falling edge will be put into TIM1 Interrupt handler because the following situation will have problem:
;;;102    		// First a matched edge happened, then an un-matched edge happened
;;;103    		// So do NOT check ACMP0_EDGE_MATCH here.
;;;104    
;;;105    		// Start count, if ACMP level can be stable for ZXD_FILTER_TIME
;;;106    		// we can consider real ZX happened
;;;107    		// If ACMP_IRQHandler was re-entered before ZXD_FILTER_TIME, TIM1's interrupt will be postponed
;;;108    		TIMER_SET_CMP_VALUE(TIMER1, GET_TIM1_CMP_VALUE(TIMER1->TDR + ZXD_FILTER_TIME));
00012e  4975              LDR      r1,|L1.772|
000130  6ac8              LDR      r0,[r1,#0x2c]
000132  4a77              LDR      r2,|L1.784|
000134  30c8              ADDS     r0,r0,#0xc8
000136  4290              CMP      r0,r2
000138  6ac8              LDR      r0,[r1,#0x2c]
00013a  d303              BCC      |L1.324|
00013c  4a75              LDR      r2,|L1.788|
00013e  3228              ADDS     r2,r2,#0x28
000140  1880              ADDS     r0,r0,r2
000142  e000              B        |L1.326|
                  |L1.324|
000144  30c8              ADDS     r0,r0,#0xc8
                  |L1.326|
000146  6248              STR      r0,[r1,#0x24]
000148  486e              LDR      r0,|L1.772|
00014a  3020              ADDS     r0,r0,#0x20
00014c  6801              LDR      r1,[r0,#0]
00014e  0602              LSLS     r2,r0,#24
000150  4311              ORRS     r1,r1,r2
000152  6001              STR      r1,[r0,#0]
                  |L1.340|
;;;109    		TIMER_EnableInt(TIMER1);
;;;110    	}
;;;111    }
000154  4770              BX       lr
;;;112    
                          ENDP

                  ADC_IRQHandler PROC
;;;113    void ADC_IRQHandler(void)
000156  b5f8              PUSH     {r3-r7,lr}
;;;114    {
;;;115      static uint32_t iADC_ComparatorFlag;
;;;116    	static uint32_t iSystemTickTemp;
;;;117    	static uint16_t iBatteryLowCNT = 0;
;;;118      static uint32_t iBatteryLowLastTimeRCD = 0;
;;;119    
;;;120        // Get ADC comparator interrupt flag
;;;121      iADC_ComparatorFlag = ADC_GET_INT_FLAG(ADC, ADC_CURRENT_CMP_MSK | ADC_BATTERY_CMP_MSK | ADC_ADF_MSK);
000158  4e75              LDR      r6,|L1.816|
00015a  6b30              LDR      r0,[r6,#0x30]
00015c  4c70              LDR      r4,|L1.800|
00015e  0740              LSLS     r0,r0,#29
000160  0f40              LSRS     r0,r0,#29
;;;122      if(iADC_ComparatorFlag & ADC_ADF_MSK)
000162  60e0              STR      r0,[r4,#0xc]  ; iADC_ComparatorFlag
000164  07c1              LSLS     r1,r0,#31
000166  d01d              BEQ      |L1.420|
;;;123    	{
;;;124    		// Change ADC channel
;;;125    		if (ADC->ADCHER & ADC_CURRENT_CHN_MSK)
000168  6a71              LDR      r1,[r6,#0x24]
00016a  07ca              LSLS     r2,r1,#31
;;;126    		{
;;;127    			tMotor.structMotor.unCurrent = (uint16_t)(ADC_GET_CONVERSION_DATA(ADC, WHAT_EVER_DO_NOT_CARE));
00016c  4967              LDR      r1,|L1.780|
00016e  d008              BEQ      |L1.386|
000170  6832              LDR      r2,[r6,#0]
000172  0592              LSLS     r2,r2,#22
000174  0d92              LSRS     r2,r2,#22
000176  848a              STRH     r2,[r1,#0x24]
;;;128    			ADC_SET_INPUT_CHANNEL(ADC, ADC_BATTERY_CHN_MSK);		
000178  6a71              LDR      r1,[r6,#0x24]
00017a  0a09              LSRS     r1,r1,#8
00017c  0209              LSLS     r1,r1,#8
00017e  3180              ADDS     r1,r1,#0x80
000180  e00a              B        |L1.408|
                  |L1.386|
;;;129    		}
;;;130    		else if (ADC->ADCHER & ADC_BATTERY_CHN_MSK)
000182  6a72              LDR      r2,[r6,#0x24]
000184  0612              LSLS     r2,r2,#24
000186  d508              BPL      |L1.410|
;;;131    		{
;;;132    			tMotor.structMotor.unBattery = (uint16_t)(ADC_GET_CONVERSION_DATA(ADC, WHAT_EVER_DO_NOT_CARE));
000188  6832              LDR      r2,[r6,#0]
00018a  0592              LSLS     r2,r2,#22
00018c  0d92              LSRS     r2,r2,#22
00018e  844a              STRH     r2,[r1,#0x22]
;;;133    			ADC_SET_INPUT_CHANNEL(ADC, ADC_CURRENT_CHN_MSK);
000190  6a71              LDR      r1,[r6,#0x24]
000192  0a09              LSRS     r1,r1,#8
000194  0209              LSLS     r1,r1,#8
000196  1c49              ADDS     r1,r1,#1
                  |L1.408|
000198  6271              STR      r1,[r6,#0x24]
                  |L1.410|
;;;134    		}
;;;135    		ADC_START_CONV(ADC);
00019a  6a31              LDR      r1,[r6,#0x20]
00019c  2201              MOVS     r2,#1
00019e  02d2              LSLS     r2,r2,#11
0001a0  4311              ORRS     r1,r1,r2
0001a2  6231              STR      r1,[r6,#0x20]
                  |L1.420|
0001a4  4d57              LDR      r5,|L1.772|
;;;136    	}    
;;;137        if(iADC_ComparatorFlag & ADC_CURRENT_CMP_MSK)
0001a6  0780              LSLS     r0,r0,#30
0001a8  2700              MOVS     r7,#0
0001aa  3520              ADDS     r5,r5,#0x20
0001ac  2800              CMP      r0,#0
0001ae  da18              BGE      |L1.482|
;;;138    	{
;;;139    		// current too big
;;;140    		MOTOR_SHUT_DOWN;
0001b0  4860              LDR      r0,|L1.820|
0001b2  6207              STR      r7,[r0,#0x20]
0001b4  495d              LDR      r1,|L1.812|
0001b6  614f              STR      r7,[r1,#0x14]
0001b8  4852              LDR      r0,|L1.772|
0001ba  6803              LDR      r3,[r0,#0]
0001bc  0382              LSLS     r2,r0,#14
0001be  4393              BICS     r3,r3,r2
0001c0  6003              STR      r3,[r0,#0]
0001c2  682b              LDR      r3,[r5,#0]
0001c4  4393              BICS     r3,r3,r2
0001c6  602b              STR      r3,[r5,#0]
0001c8  6803              LDR      r3,[r0,#0]
0001ca  0342              LSLS     r2,r0,#13
0001cc  4393              BICS     r3,r3,r2
0001ce  6003              STR      r3,[r0,#0]
0001d0  6828              LDR      r0,[r5,#0]
0001d2  4390              BICS     r0,r0,r2
0001d4  6028              STR      r0,[r5,#0]
0001d6  20ff              MOVS     r0,#0xff
0001d8  63c8              STR      r0,[r1,#0x3c]
0001da  6388              STR      r0,[r1,#0x38]
;;;141    		setError(ERR_CURRENT_BURNING);
0001dc  2007              MOVS     r0,#7
0001de  f7fffffe          BL       setError
                  |L1.482|
;;;142    	}
;;;143        if(iADC_ComparatorFlag & ADC_BATTERY_CMP_MSK)
0001e2  7b20              LDRB     r0,[r4,#0xc]  ; iADC_ComparatorFlag
0001e4  0740              LSLS     r0,r0,#29
0001e6  d529              BPL      |L1.572|
;;;144    	{
;;;145        	// Longer filter for battery voltage
;;;146    		// if this time's battery low is near to the last one
;;;147    		// 0.64ms interval of each measurement
;;;148    		iSystemTickTemp = unSystemTick;
0001e8  4853              LDR      r0,|L1.824|
0001ea  6800              LDR      r0,[r0,#0]  ; unSystemTick
;;;149    		if ((uint32_t)(iSystemTickTemp - iBatteryLowLastTimeRCD) < BATTERY_LOW_MIN_INTERVAL)
0001ec  6120              STR      r0,[r4,#0x10]  ; iSystemTickTemp
0001ee  6961              LDR      r1,[r4,#0x14]  ; iBatteryLowLastTimeRCD
0001f0  1a40              SUBS     r0,r0,r1
0001f2  280a              CMP      r0,#0xa
0001f4  d21f              BCS      |L1.566|
;;;150    		{
;;;151    			if (iBatteryLowCNT < MAX_BATT_LOW_CNT)
0001f6  8860              LDRH     r0,[r4,#2]  ; iBatteryLowCNT
0001f8  2832              CMP      r0,#0x32
0001fa  d202              BCS      |L1.514|
0001fc  1c40              ADDS     r0,r0,#1
;;;152    			{
;;;153    				iBatteryLowCNT++;
0001fe  8060              STRH     r0,[r4,#2]
000200  e01a              B        |L1.568|
                  |L1.514|
;;;154    			}
;;;155    			else
;;;156    			{
;;;157    				// battery really too low
;;;158    				MOTOR_SHUT_DOWN;
000202  484c              LDR      r0,|L1.820|
000204  6207              STR      r7,[r0,#0x20]
000206  4949              LDR      r1,|L1.812|
000208  614f              STR      r7,[r1,#0x14]
00020a  483e              LDR      r0,|L1.772|
00020c  6802              LDR      r2,[r0,#0]
00020e  0383              LSLS     r3,r0,#14
000210  439a              BICS     r2,r2,r3
000212  6002              STR      r2,[r0,#0]
000214  682a              LDR      r2,[r5,#0]
000216  439a              BICS     r2,r2,r3
000218  602a              STR      r2,[r5,#0]
00021a  6803              LDR      r3,[r0,#0]
00021c  0342              LSLS     r2,r0,#13
00021e  4393              BICS     r3,r3,r2
000220  6003              STR      r3,[r0,#0]
000222  6828              LDR      r0,[r5,#0]
000224  4390              BICS     r0,r0,r2
000226  6028              STR      r0,[r5,#0]
000228  20ff              MOVS     r0,#0xff
00022a  63c8              STR      r0,[r1,#0x3c]
00022c  6388              STR      r0,[r1,#0x38]
;;;159    				setError(ERR_BATTERY_LOW);
00022e  2005              MOVS     r0,#5
000230  f7fffffe          BL       setError
000234  e000              B        |L1.568|
                  |L1.566|
;;;160    			}
;;;161    		}
;;;162    		else
;;;163    		{
;;;164    			iBatteryLowCNT = 0;
000236  8067              STRH     r7,[r4,#2]
                  |L1.568|
;;;165    		}
;;;166    		iBatteryLowLastTimeRCD = iSystemTickTemp; 
000238  6920              LDR      r0,[r4,#0x10]  ; iSystemTickTemp
00023a  6160              STR      r0,[r4,#0x14]  ; iBatteryLowLastTimeRCD
                  |L1.572|
;;;167    	}
;;;168        
;;;169        ADC_CLR_INT_FLAG(ADC, iADC_ComparatorFlag);
00023c  6b30              LDR      r0,[r6,#0x30]
00023e  68e1              LDR      r1,[r4,#0xc]  ; iADC_ComparatorFlag
000240  08c0              LSRS     r0,r0,#3
000242  00c0              LSLS     r0,r0,#3
000244  4308              ORRS     r0,r0,r1
000246  6330              STR      r0,[r6,#0x30]
;;;170    }
000248  bdf8              POP      {r3-r7,pc}
;;;171    	uint8_t unFIFO_RX_CNT;
                          ENDP

                  SPI_IRQHandler PROC
;;;172    void SPI_IRQHandler(void)
00024a  b5f0              PUSH     {r4-r7,lr}
;;;173    {
;;;174    	static ENUM_SPI_RECEIVE_STATE tSPI_LastState = SPI_RCV_IDLE;
;;;175    	static uint32_t unSPI_RX_Value;
;;;176    	
;;;177    	if ((SPI->CNTRL & SPI_STATUS_IF_Msk) == SPI_STATUS_IF_Msk)
00024c  4c3b              LDR      r4,|L1.828|
00024e  6820              LDR      r0,[r4,#0]
;;;178    	{
;;;179    		// Check if it is really finished one unit transfer
;;;180    		if ((SPI->SSR & SPI_SSR_LTRIG_FLAG_Msk) == SPI_SSR_LTRIG_FLAG_Msk)
;;;181    		{
;;;182    			unSPI_RX_Value = SPI_READ_RX(SPI);
;;;183    			if (tMotor.structMotor.MSR.bNewComFrameReceived == FALSE)
;;;184    			{
;;;185    				switch(tSPI_LastState)
;;;186    				{
;;;187    				case SPI_RCV_IDLE:
;;;188    				case SPI_RCV_RD_CMD:
;;;189    				case SPI_RCV_WR_DATA:
;;;190    					unCOM_SPI_ReadData[0] = (uint16_t)(unSPI_RX_Value >> 16);
;;;191    					unCOM_SPI_ReadData[1] = (uint16_t)unSPI_RX_Value;
;;;192    					if (MTR_INVALID_MOTOR_CMD == unCOM_SPI_ReadData[0] )
;;;193    					{
;;;194    						// If it is dummy command, means to clear communication.
;;;195    						// What need to be read is already done in last transaction during receiving this dummy command
;;;196    						// SO next time no matter read or write command is transmitting, a fresh new frame with 0 data and 0 CRC is responsing
;;;197    						SPI_WRITE_TX(SPI, 0);
;;;198    						SPI_TRIGGER(SPI);
;;;199    						tSPI_LastState = SPI_RCV_IDLE;
;;;200    					}
;;;201    					else
;;;202    					{
;;;203    						if (IS_COMM_RD_CMD(unCOM_SPI_ReadData[0]))
;;;204    						{
;;;205    							tSPI_LastState = SPI_RCV_RD_CMD;
;;;206    							// Read command received, go to main procedure to handle
;;;207    							tMotor.structMotor.MSR.bNewComFrameReceived = TRUE;
;;;208    						}
;;;209    						else
;;;210    						{
;;;211    							SPI_WRITE_TX(SPI, 0);
;;;212    							SPI_TRIGGER(SPI);
;;;213    							tSPI_LastState = SPI_RCV_WR_CMD;
;;;214    						}
;;;215    					}
;;;216    					break;
;;;217    
;;;218    				case SPI_RCV_WR_CMD:
;;;219    					unCOM_SPI_ReadData[2] = (uint16_t)(unSPI_RX_Value >> 16);
;;;220    					unCOM_SPI_ReadData[3] = (uint16_t)unSPI_RX_Value;
;;;221    					// Write command and data received, go to main procedure to handle
;;;222    					tMotor.structMotor.MSR.bNewComFrameReceived = TRUE;
;;;223    					tSPI_LastState = SPI_RCV_WR_DATA;
;;;224    					break;
;;;225    
;;;226    				default:
;;;227    					SPI_WRITE_TX(SPI, 0);
;;;228    					SPI_TRIGGER(SPI);
;;;229    					unCOM_SPI_TransErrCNT++;
000250  4d3b              LDR      r5,|L1.832|
000252  03c0              LSLS     r0,r0,#15             ;177
000254  6829              LDR      r1,[r5,#0]
000256  2301              MOVS     r3,#1                 ;185
000258  1c49              ADDS     r1,r1,#1
00025a  2800              CMP      r0,#0                 ;177
00025c  da46              BGE      |L1.748|
00025e  68a0              LDR      r0,[r4,#8]            ;180
000260  0680              LSLS     r0,r0,#26             ;180
000262  d50f              BPL      |L1.644|
000264  6920              LDR      r0,[r4,#0x10]         ;180
000266  4e2e              LDR      r6,|L1.800|
000268  4f28              LDR      r7,|L1.780|
00026a  61b0              STR      r0,[r6,#0x18]         ;183  ; unSPI_RX_Value
00026c  887a              LDRH     r2,[r7,#2]            ;183  ; tMotor
00026e  06d2              LSLS     r2,r2,#27             ;183
000270  d408              BMI      |L1.644|
000272  7832              LDRB     r2,[r6,#0]            ;185  ; tSPI_LastState
000274  2a00              CMP      r2,#0                 ;185
000276  d011              BEQ      |L1.668|
000278  2a01              CMP      r2,#1                 ;185
00027a  d00f              BEQ      |L1.668|
00027c  2a02              CMP      r2,#2                 ;185
00027e  d02b              BEQ      |L1.728|
000280  2a03              CMP      r2,#3                 ;185
000282  d00b              BEQ      |L1.668|
                  |L1.644|
;;;230    					break;
;;;231    				}
;;;232    			}
;;;233    			else
;;;234    			{
;;;235    				SPI_WRITE_TX(SPI, 0);
000284  2000              MOVS     r0,#0
000286  6220              STR      r0,[r4,#0x20]
000288  6820              LDR      r0,[r4,#0]
00028a  4318              ORRS     r0,r0,r3
00028c  6020              STR      r0,[r4,#0]
;;;236    				SPI_TRIGGER(SPI);
;;;237    				unCOM_SPI_TransErrCNT++;
00028e  6029              STR      r1,[r5,#0]  ; unCOM_SPI_TransErrCNT
                  |L1.656|
000290  6c60              LDR      r0,[r4,#0x44]
000292  2101              MOVS     r1,#1
000294  0409              LSLS     r1,r1,#16
000296  4308              ORRS     r0,r0,r1
000298  6460              STR      r0,[r4,#0x44]
;;;238    			}
;;;239    		}
;;;240    		else
;;;241    		{
;;;242    			SPI_WRITE_TX(SPI, 0);
;;;243    			SPI_TRIGGER(SPI);
;;;244    			unCOM_SPI_TransErrCNT++;
;;;245    		}
;;;246    //			unFIFO_RX_CNT = SPI_GET_RX_FIFO_COUNT(SPI);
;;;247    //			if (unFIFO_RX_CNT == COMM_RD_CMD_CNT_IN_32BIT)
;;;248    //			{
;;;249    //				// Received 2 uint16, copy to RAM buffer and infor communication manager
;;;250    //				unSPI_RX_Value = SPI_READ_RX(SPI);
;;;251    //				unCOM_SPI_ReadData[0] = (uint16_t)(unSPI_RX_Value >> 16);
;;;252    //				unCOM_SPI_ReadData[1] = (uint16_t)unSPI_RX_Value;
;;;253    
;;;254    //				if (unCOM_SPI_ReadData[0] != MTR_INVALID_MOTOR_CMD)
;;;255    //				{
;;;256    //					// If it is dummy command, master just want to retrieve last time read's data.
;;;257    //					// For slave, do nothing
;;;258    //					if (IS_COMM_RD_CMD(unCOM_SPI_ReadData[0]))
;;;259    //					{
;;;260    //						tMotor.structMotor.MSR.bNewComFrameReceived = TRUE;
;;;261    //					}
;;;262    //					else
;;;263    //					{
;;;264    //						unCOM_SPI_TransErrCNT++;
;;;265    //					}
;;;266    //				}
;;;267    //			}
;;;268    //			else if (unFIFO_RX_CNT == COMM_WR_CMD_CNT_IN_32BIT)
;;;269    //			{
;;;270    //				// Received 4 uint16, copy to RAM buffer and infor communication manager
;;;271    //				unSPI_RX_Value = SPI_READ_RX(SPI);
;;;272    //				unCOM_SPI_ReadData[0] = (uint16_t)(unSPI_RX_Value >> 16);
;;;273    //				unCOM_SPI_ReadData[1] = (uint16_t)unSPI_RX_Value;
;;;274    //				unSPI_RX_Value = SPI_READ_RX(SPI);
;;;275    //				unCOM_SPI_ReadData[2] = (uint16_t)(unSPI_RX_Value >> 16);
;;;276    //				unCOM_SPI_ReadData[3] = (uint16_t)unSPI_RX_Value;
;;;277    //				if (IS_COMM_WR_CMD(unCOM_SPI_ReadData[0]))
;;;278    //				{
;;;279    //					tMotor.structMotor.MSR.bNewComFrameReceived = TRUE;
;;;280    //				}
;;;281    //				else
;;;282    //				{
;;;283    //					unCOM_SPI_TransErrCNT++;
;;;284    //				}
;;;285    //			}
;;;286    //			else
;;;287    //			{
;;;288    //				unCOM_SPI_TransErrCNT++;
;;;289    //			}
;;;290    //		}
;;;291    //		else
;;;292    //		{
;;;293    //			unCOM_SPI_TransErrCNT++;
;;;294    //		}
;;;295    			// Clear Receive FIFO interrupt
;;;296    			// I don't know how to clear. Maybe just after I read out the data in FIFO and it is below threshold it will be OK
;;;297    //		else
;;;298    //		{	// Receive FIFO interrupt should be the only interrupt enabled for SPI
;;;299    //			// So something strange happened
;;;300    //			unCOM_SPI_TransErrCNT++;
;;;301    //			SPI_WRITE_TX(SPI, 0);
;;;302    //			SPI_WRITE_TX(SPI, 0);
;;;303    //			SPI_TRIGGER(SPI);
;;;304    //		}		
;;;305    //		SPI_ClearRxFIFO(SPI);
;;;306    //		SPI_ClearTxFIFO(SPI);
;;;307    		SPI_CLR_UNIT_TRANS_INT_FLAG(SPI);
;;;308    
;;;309    	}
;;;310    	else
;;;311    	{
;;;312    		SPI_WRITE_TX(SPI, 0);
;;;313    		SPI_TRIGGER(SPI);
;;;314    		unCOM_SPI_TransErrCNT++;
;;;315    	}
;;;316    	
;;;317    }
00029a  bdf0              POP      {r4-r7,pc}
                  |L1.668|
00029c  4a29              LDR      r2,|L1.836|
00029e  0c01              LSRS     r1,r0,#16             ;190
0002a0  8011              STRH     r1,[r2,#0]            ;190
0002a2  8050              STRH     r0,[r2,#2]            ;191
0002a4  4828              LDR      r0,|L1.840|
0002a6  4281              CMP      r1,r0                 ;192
0002a8  d106              BNE      |L1.696|
0002aa  2000              MOVS     r0,#0                 ;197
0002ac  6220              STR      r0,[r4,#0x20]         ;197
0002ae  6820              LDR      r0,[r4,#0]            ;197
0002b0  4318              ORRS     r0,r0,r3              ;197
0002b2  6020              STR      r0,[r4,#0]            ;197
0002b4  2000              MOVS     r0,#0                 ;199
0002b6  e00d              B        |L1.724|
                  |L1.696|
0002b8  0bc8              LSRS     r0,r1,#15             ;203
0002ba  d005              BEQ      |L1.712|
0002bc  7033              STRB     r3,[r6,#0]            ;205
0002be  8879              LDRH     r1,[r7,#2]            ;207  ; tMotor
0002c0  2010              MOVS     r0,#0x10              ;207
0002c2  4301              ORRS     r1,r1,r0              ;207
0002c4  8079              STRH     r1,[r7,#2]            ;207
0002c6  e7e3              B        |L1.656|
                  |L1.712|
0002c8  2000              MOVS     r0,#0                 ;211
0002ca  6220              STR      r0,[r4,#0x20]         ;211
0002cc  6820              LDR      r0,[r4,#0]            ;211
0002ce  4318              ORRS     r0,r0,r3              ;211
0002d0  6020              STR      r0,[r4,#0]            ;211
0002d2  2002              MOVS     r0,#2                 ;213
                  |L1.724|
0002d4  7030              STRB     r0,[r6,#0]            ;213
0002d6  e7db              B        |L1.656|
                  |L1.728|
0002d8  491a              LDR      r1,|L1.836|
0002da  0c02              LSRS     r2,r0,#16             ;219
0002dc  808a              STRH     r2,[r1,#4]            ;219
0002de  80c8              STRH     r0,[r1,#6]            ;220
0002e0  8878              LDRH     r0,[r7,#2]            ;222  ; tMotor
0002e2  2110              MOVS     r1,#0x10              ;222
0002e4  4308              ORRS     r0,r0,r1              ;222
0002e6  8078              STRH     r0,[r7,#2]            ;222
0002e8  2003              MOVS     r0,#3                 ;223
0002ea  e7f3              B        |L1.724|
                  |L1.748|
0002ec  2000              MOVS     r0,#0                 ;312
0002ee  6220              STR      r0,[r4,#0x20]         ;312
0002f0  6820              LDR      r0,[r4,#0]            ;312
0002f2  4318              ORRS     r0,r0,r3              ;312
0002f4  6020              STR      r0,[r4,#0]            ;312
0002f6  6029              STR      r1,[r5,#0]            ;314  ; unCOM_SPI_TransErrCNT
0002f8  bdf0              POP      {r4-r7,pc}
;;;318    
                          ENDP

                  SysTick_Handler PROC
;;;319    void SysTick_Handler(void)
0002fa  480f              LDR      r0,|L1.824|
;;;320    {
;;;321    	unSystemTick += 5;
0002fc  6801              LDR      r1,[r0,#0]  ; unSystemTick
0002fe  1d49              ADDS     r1,r1,#5
000300  6001              STR      r1,[r0,#0]  ; unSystemTick
;;;322    }
000302  4770              BX       lr
                          ENDP

                  |L1.772|
                          DCD      0x40010000
                  |L1.776|
                          DCD      FLAG_PHASE_CHANGED
                  |L1.780|
                          DCD      tMotor
                  |L1.784|
                          DCD      0x00ffffff
                  |L1.788|
                          DCD      0xff0000a1
                  |L1.792|
                          DCD      FLAG_TIM1_USEAGE
                  |L1.796|
                          DCD      unLastZXDetectedTime
                  |L1.800|
                          DCD      ||.data||
                  |L1.804|
                          DCD      0x0000251b
                  |L1.808|
                          DCD      0x400d0000
                  |L1.812|
                          DCD      0x40040040
                  |L1.816|
                          DCD      0x400e0000
                  |L1.820|
                          DCD      0x50004240
                  |L1.824|
                          DCD      unSystemTick
                  |L1.828|
                          DCD      0x40030000
                  |L1.832|
                          DCD      unCOM_SPI_TransErrCNT
                  |L1.836|
                          DCD      unCOM_SPI_ReadData
                  |L1.840|
                          DCD      0x0000ffff

                          AREA ||.data||, DATA, ALIGN=2

                  tSPI_LastState
000000  0000              DCB      0x00,0x00
                  iBatteryLowCNT
000002  0000              DCW      0x0000
                  iTempDeltaZXD
                          DCD      0x00000000
                  iHalfPeriod
                          DCD      0x00000000
                  iADC_ComparatorFlag
                          DCD      0x00000000
                  iSystemTickTemp
                          DCD      0x00000000
                  iBatteryLowLastTimeRCD
                          DCD      0x00000000
                  unSPI_RX_Value
                          DCD      0x00000000

                          AREA ||area_number.5||, DATA, ALIGN=0

                          EXPORTAS ||area_number.5||, ||.data||
                  unFIFO_RX_CNT
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "User\\it.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___4_it_c_d50ddd2d____REV16|
#line 118 ".\\CMSIS\\core_cmInstr.h"
|__asm___4_it_c_d50ddd2d____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___4_it_c_d50ddd2d____REVSH|
#line 132
|__asm___4_it_c_d50ddd2d____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
