; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\it.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\it.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\Mini51Series\Include -I..\..\..\Library\StdDriver\inc -I.\StdDriver\inc -I.\CMSIS -IG:\Geek\Projects\Zulolo_F\Force\Code\Zulolo_F_Force\RTE -ID:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.0.2\Device\Mini51\Include -ID:\Keil_v5\ARM\CMSIS\Include -I\ -D__MICROLIB -D__UVISION_VERSION=518 --omf_browse=.\obj\it.crf User\it.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  TMR0_IRQHandler PROC
;;;14     // Used to change phase
;;;15     void TMR0_IRQHandler(void)                                   
000000  b530              PUSH     {r4,r5,lr}
;;;16     {
;;;17     	TIMER0->TISR  = TIMER0->TISR;	//~0;    // Clear interrupt flag
000002  49bb              LDR      r1,|L1.752|
000004  6888              LDR      r0,[r1,#8]
000006  6088              STR      r0,[r1,#8]
;;;18     
;;;19     	//iPhaseChangeCNT4Period++;
;;;20     	FLAG_PHASE_CHANGED = SET;
000008  4aba              LDR      r2,|L1.756|
00000a  2001              MOVS     r0,#1
00000c  7010              STRB     r0,[r2,#0]
;;;21     //	iTestACMPIntEachPhaseCNT = 0;
;;;22     
;;;23     	// Disable comparator's interrupt in case after change phase it triggers
;;;24     	//ACMP0_INT_DISABLE; 
;;;25     
;;;26     	// Disable PWM's interrupt in case after change phase it triggers
;;;27     	PWM_INT_DISABLE;
00000e  48ba              LDR      r0,|L1.760|
000010  2400              MOVS     r4,#0
000012  6144              STR      r4,[r0,#0x14]
;;;28     
;;;29     
;;;30     	if (TRUE == tMotor.structMotor.MSR.bZeroCrossDetecting)
000014  48b9              LDR      r0,|L1.764|
000016  8840              LDRH     r0,[r0,#2]  ; tMotor
000018  0780              LSLS     r0,r0,#30
00001a  d517              BPL      |L1.76|
00001c  4ab4              LDR      r2,|L1.752|
00001e  3220              ADDS     r2,r2,#0x20           ;16
000020  6810              LDR      r0,[r2,#0]            ;16
000022  034b              LSLS     r3,r1,#13             ;16
000024  4398              BICS     r0,r0,r3              ;16
000026  6010              STR      r0,[r2,#0]            ;16
;;;31     	{
;;;32     		// In case TIM1 interrupt happened but preeempted by TIM0
;;;33     		TIMER_DisableInt(TIMER1);
;;;34     		TIMER1->TISR  = ~0;    // Clear interrupt flag
000028  1e60              SUBS     r0,r4,#1
00002a  6288              STR      r0,[r1,#0x28]
;;;35     		TIMER_SET_CMP_VALUE(TIMER1, GET_TIM1_CMP_VALUE(TIMER1->TDR + AVOID_ZXD_AFTER_PHCHG));	
00002c  6ac8              LDR      r0,[r1,#0x2c]
00002e  4db4              LDR      r5,|L1.768|
000030  30a0              ADDS     r0,r0,#0xa0
000032  42a8              CMP      r0,r5
000034  6ac8              LDR      r0,[r1,#0x2c]
000036  d302              BCC      |L1.62|
000038  4db2              LDR      r5,|L1.772|
00003a  1940              ADDS     r0,r0,r5
00003c  e000              B        |L1.64|
                  |L1.62|
00003e  30a0              ADDS     r0,r0,#0xa0
                  |L1.64|
000040  6248              STR      r0,[r1,#0x24]
;;;36     		//GET_TIMER_DIFF(PWM_ZX_FILTER_TIME, GET_TIM1_CMP_VALUE(TIMER1->TDR + (tMotor.structMotor.ACT_PERIOD >> 1))));	
;;;37     		//(tMotor.structMotor.ACT_PERIOD >> 2)));
;;;38     		FLAG_TIM1_USEAGE = ENUM_TIM1_AVOID_ZXD;
000042  48b1              LDR      r0,|L1.776|
000044  7004              STRB     r4,[r0,#0]
000046  6810              LDR      r0,[r2,#0]
000048  4318              ORRS     r0,r0,r3
00004a  6010              STR      r0,[r2,#0]
                  |L1.76|
;;;39     		TIMER_EnableInt(TIMER1);
;;;40     	}
;;;41     }
00004c  bd30              POP      {r4,r5,pc}
;;;42     
                          ENDP

                  DetectdTimeWhenPWMHigh PROC
;;;58     //		    ZX found
;;;59     uint32_t DetectdTimeWhenPWMHigh(void)
00004e  b530              PUSH     {r4,r5,lr}
;;;60     {
;;;61     	
;;;62     
;;;63     //	uint32_t iMaxTIM0atThisPWMHigh;
;;;64     //	iMaxTIM0atThisPWMHigh = getTIM0atThisPWMHigh(tMotor.structMotor.ACT_DUTY);
;;;65     
;;;66     	// ALready done when enter PWM interrupt
;;;67     	//PWM->PIIR |= PWM_PIIR_PWMPIF1_Msk;
;;;68     
;;;69     	while ((PWM->PIIR & PWM_PIIR_PWMPIF1_Msk) == 0)
;;;70     	{
;;;71     //		BRG_DISABLE;
;;;72     //		BLDC_stopMotor();
;;;73     		if (unZXMatchCNT > MAX_ZX_MATCH_IN_PWM)
000050  48ae              LDR      r0,|L1.780|
;;;74     		{
;;;75     			return TIMER_GetCounter(TIMER1);	//GET_TIMER_DIFF(PWM_ZX_FILTER_TIME, TIMER_GetCounter(TIMER1));
;;;76     		}
;;;77     
;;;78     		if (ACMP0_EDGE_MATCH)
000052  49a9              LDR      r1,|L1.760|
000054  4bae              LDR      r3,|L1.784|
000056  2400              MOVS     r4,#0
;;;79     		{
;;;80     			unZXMatchCNT++; 
;;;81     		}
;;;82     		else
;;;83     		{
;;;84     			unZXMatchCNT = 0;
000058  e013              B        |L1.130|
                  |L1.90|
00005a  6802              LDR      r2,[r0,#0]            ;73  ; unZXMatchCNT
00005c  2a24              CMP      r2,#0x24              ;73
00005e  d903              BLS      |L1.104|
000060  48a3              LDR      r0,|L1.752|
000062  3020              ADDS     r0,r0,#0x20           ;73
000064  68c0              LDR      r0,[r0,#0xc]          ;73
;;;85     		}
;;;86     		
;;;87     	}
;;;88     	return TIMER_INVALID_CNT;
;;;89     }
000066  bd30              POP      {r4,r5,pc}
                  |L1.104|
000068  6b8a              LDR      r2,[r1,#0x38]         ;78
00006a  689d              LDR      r5,[r3,#8]            ;78
00006c  0612              LSLS     r2,r2,#24             ;78
00006e  0fd2              LSRS     r2,r2,#31             ;78
000070  076d              LSLS     r5,r5,#29             ;78
000072  0fed              LSRS     r5,r5,#31             ;78
000074  42aa              CMP      r2,r5                 ;78
000076  d103              BNE      |L1.128|
000078  6802              LDR      r2,[r0,#0]            ;80  ; unZXMatchCNT
00007a  1c52              ADDS     r2,r2,#1              ;80
00007c  6002              STR      r2,[r0,#0]            ;80  ; unZXMatchCNT
00007e  e000              B        |L1.130|
                  |L1.128|
000080  6004              STR      r4,[r0,#0]            ;84  ; unZXMatchCNT
                  |L1.130|
000082  698a              LDR      r2,[r1,#0x18]         ;69
000084  0792              LSLS     r2,r2,#30             ;69
000086  d5e8              BPL      |L1.90|
000088  2000              MOVS     r0,#0                 ;88
00008a  43c0              MVNS     r0,r0                 ;88
00008c  bd30              POP      {r4,r5,pc}
;;;90     
                          ENDP

                  PhaseZXDedHandler PROC
;;;120    
;;;121    int32_t PhaseZXDedHandler(uint32_t iThisZXDetectedTime)
00008e  b530              PUSH     {r4,r5,lr}
;;;122    {
;;;123    	static uint32_t iTempDeltaZXD = 0;
;;;124    	static uint32_t iHalfPeriod = 0;
;;;125    //	static uint32_t iThisZXDetectedTime = 0;
;;;126    
;;;127    	//iThisZXDetectedTime = TIMER_GetCounter(TIMER1);
;;;128    
;;;129    	iTempDeltaZXD = GET_TIMER_DIFF(unLastZXDetectedTime, iThisZXDetectedTime);
000090  4aa0              LDR      r2,|L1.788|
000092  6811              LDR      r1,[r2,#0]  ; unLastZXDetectedTime
000094  4288              CMP      r0,r1
000096  d902              BLS      |L1.158|
000098  6811              LDR      r1,[r2,#0]  ; unLastZXDetectedTime
00009a  1a41              SUBS     r1,r0,r1
00009c  e003              B        |L1.166|
                  |L1.158|
00009e  6813              LDR      r3,[r2,#0]  ; unLastZXDetectedTime
0000a0  4997              LDR      r1,|L1.768|
0000a2  1ac9              SUBS     r1,r1,r3
0000a4  1809              ADDS     r1,r1,r0
                  |L1.166|
;;;130    
;;;131    	if ((iTempDeltaZXD > MIN_PHASE_TIME) && (iTempDeltaZXD < MAX_PHASE_TIME))
0000a6  460c              MOV      r4,r1
0000a8  4b9b              LDR      r3,|L1.792|
0000aa  3cff              SUBS     r4,r4,#0xff
0000ac  4d9b              LDR      r5,|L1.796|
0000ae  3cf6              SUBS     r4,r4,#0xf6
0000b0  6059              STR      r1,[r3,#4]  ; iTempDeltaZXD
0000b2  42ac              CMP      r4,r5
0000b4  d221              BCS      |L1.250|
;;;132    	{
;;;133    		unLastZXDetectedTime = iThisZXDetectedTime;
0000b6  6010              STR      r0,[r2,#0]  ; unLastZXDetectedTime
;;;134    		tMotor.structMotor.MSR.bThisPhaseDetectedZX = TRUE;
0000b8  4890              LDR      r0,|L1.764|
0000ba  8842              LDRH     r2,[r0,#2]  ; tMotor
0000bc  2408              MOVS     r4,#8
0000be  4322              ORRS     r2,r2,r4
0000c0  8042              STRH     r2,[r0,#2]
;;;135    //		iTestDetectedZX++;
;;;136    		if (TRUE == tMotor.structMotor.MSR.bLocked)
0000c2  8842              LDRH     r2,[r0,#2]  ; tMotor
0000c4  0752              LSLS     r2,r2,#29
0000c6  d516              BPL      |L1.246|
;;;137    		{
;;;138    			tMotor.structMotor.unACT_PERIOD = (iTempDeltaZXD + tMotor.structMotor.unACT_PERIOD) >> 1;
0000c8  6942              LDR      r2,[r0,#0x14]  ; tMotor
0000ca  1851              ADDS     r1,r2,r1
0000cc  0849              LSRS     r1,r1,#1
0000ce  6141              STR      r1,[r0,#0x14]  ; tMotor
;;;139    			iHalfPeriod = tMotor.structMotor.unACT_PERIOD >> 1;
0000d0  6940              LDR      r0,[r0,#0x14]  ; tMotor
;;;140    			TIMER_SET_CMP_VALUE(TIMER0, TIMER0->TDR + (iHalfPeriod > TIME_DEBT) ? (iHalfPeriod - TIME_DEBT) : ZXD_BEFORE_PHCHG);
0000d2  4a87              LDR      r2,|L1.752|
0000d4  0840              LSRS     r0,r0,#1              ;139
0000d6  6098              STR      r0,[r3,#8]  ; iHalfPeriod
0000d8  68d3              LDR      r3,[r2,#0xc]
0000da  21ff              MOVS     r1,#0xff
0000dc  3105              ADDS     r1,#5
0000de  4288              CMP      r0,r1
0000e0  d901              BLS      |L1.230|
0000e2  2101              MOVS     r1,#1
0000e4  e000              B        |L1.232|
                  |L1.230|
0000e6  2100              MOVS     r1,#0
                  |L1.232|
0000e8  42cb              CMN      r3,r1
0000ea  d002              BEQ      |L1.242|
0000ec  38ff              SUBS     r0,r0,#0xff
0000ee  3805              SUBS     r0,#5
0000f0  e000              B        |L1.244|
                  |L1.242|
0000f2  2032              MOVS     r0,#0x32
                  |L1.244|
0000f4  6050              STR      r0,[r2,#4]
                  |L1.246|
;;;141    		}
;;;142    		return TRUE;
0000f6  2001              MOVS     r0,#1
;;;143    	}
;;;144    	else
;;;145    	{
;;;146    		return FALSE;
;;;147    	}
;;;148    }
0000f8  bd30              POP      {r4,r5,pc}
                  |L1.250|
0000fa  2000              MOVS     r0,#0                 ;146
0000fc  bd30              POP      {r4,r5,pc}
;;;149    
                          ENDP

                  TMR1_IRQHandler PROC
;;;150    // Used to set time reference and filter ZXD
;;;151    void TMR1_IRQHandler(void)                                   
0000fe  b5f0              PUSH     {r4-r7,lr}
;;;152    {
;;;153    //	static uint32_t iZXTimeDuringPWMHigh;
;;;154    //	static uint32_t iTempDeltaZXD = 0;
;;;155    //	static uint32_t iTempPhaseChange2ZX = 0;
;;;156    //	static uint32_t iThisZXDetectedTime = 0;
;;;157    //	static uint32_t iTargetNewPeriod = 0;
;;;158    
;;;159    //	TIMER_DisableInt(TIMER1);
;;;160    	TIMER1->TISR = ~0;    // Clear interrupt flag
000100  2000              MOVS     r0,#0
000102  497b              LDR      r1,|L1.752|
000104  43c0              MVNS     r0,r0
000106  6288              STR      r0,[r1,#0x28]
;;;161    //	unZXMatchCNT = 0;
;;;162    
;;;163    /*		iZXTimeDuringPWMHigh = DetectdTimeWhenPWMHigh();
;;;164    		if (iZXTimeDuringPWMHigh == TIMER_INVALID_CNT)
;;;165    		{
;;;166    			// Start PWM duty interrupt, during each PWM high, check is there is ZX
;;;167    			PWM->PIIR = ~0;
;;;168    			PWM_INT_ENABLE;
;;;169    		}
;;;170    		else
;;;171    		{
;;;172    			if (PhaseZXDedHandler(iZXTimeDuringPWMHigh) == FALSE)
;;;173    			{	// The value has some problem, still open interrupt of PWM to detect ZX when PWM high
;;;174    				PWM->PIIR = ~0;
;;;175    				PWM_INT_ENABLE;
;;;176    			}
;;;177    		}
;;;178    
;;;179    
;;;180    	if (ENUM_TIM1_START_ZXD == FLAG_TIM1_USEAGE)
;;;181    	{
;;;182    		// First check if ACMP already match
;;;183    		if (ACMP0_EDGE_MATCH)
;;;184    		{
;;;185    			iTestEnter_TMR1_MATCH++;
;;;186    			PhaseZXDedHandler();
;;;187    		}
;;;188    		else
;;;189    		{
;;;190    			// ACMPF0 may already be set
;;;191    			if (ACMP->CMPSR & ACMP_CMPSR_ACMPF0_Msk)
;;;192    			{
;;;193    				ACMP->CMPSR |= ACMP_CMPSR_ACMPF0_Msk;
;;;194    			}
;;;195    			// If not match, open ACMP interrupt to monitor ZX
;;;196    			ACMP0_INT_ENABLE;
;;;197    		}
;;;198    	}
;;;199    */
;;;200    
;;;201    	if (ENUM_TIM1_AVOID_ZXD == FLAG_TIM1_USEAGE)
000108  487f              LDR      r0,|L1.776|
00010a  7801              LDRB     r1,[r0,#0]  ; FLAG_TIM1_USEAGE
00010c  4d78              LDR      r5,|L1.752|
00010e  2701              MOVS     r7,#1
000110  077f              LSLS     r7,r7,#29
;;;202    	{
;;;203    		TIMER_DisableInt(TIMER1);	// ACMP interrupt will re-open TIM1's interrupt
;;;204    		FLAG_TIM1_USEAGE = ENUM_TIM1_ZXD_FILTER;
;;;205    		// Clear all ACMP changed flag happened before
;;;206    		ACMP->CMPSR |= ACMP_CMPSR_ACMPF0_Msk;
;;;207    		ACMP0_INT_ENABLE;
000112  2602              MOVS     r6,#2
000114  4c7e              LDR      r4,|L1.784|
000116  3520              ADDS     r5,r5,#0x20           ;206
000118  2900              CMP      r1,#0                 ;201
00011a  d014              BEQ      |L1.326|
;;;208    	}
;;;209    	else
;;;210    	{	// for now can only be ENUM_TIM1_ZXD_FILTER
;;;211    		if (ACMP0_EDGE_MATCH)
00011c  4876              LDR      r0,|L1.760|
00011e  6b80              LDR      r0,[r0,#0x38]
000120  68a1              LDR      r1,[r4,#8]
000122  0600              LSLS     r0,r0,#24
000124  0fc0              LSRS     r0,r0,#31
000126  0749              LSLS     r1,r1,#29
000128  0fc9              LSRS     r1,r1,#31
00012a  4288              CMP      r0,r1
00012c  d10a              BNE      |L1.324|
00012e  68e8              LDR      r0,[r5,#0xc]
;;;212    		{	
;;;213    			// No need to find the real ZXD time, we only care the delta 
;;;214    			if (TRUE == PhaseZXDedHandler(TIMER_GetCounter(TIMER1)))	//GET_TIMER_DIFF(ZXD_FILTER_TIME, TIMER_GetCounter(TIMER1))))
000130  f7fffffe          BL       PhaseZXDedHandler
000134  2801              CMP      r0,#1
000136  d105              BNE      |L1.324|
;;;215    			{
;;;216    				ACMP0_INT_DISABLE;  // This phase ACMP job done
000138  6820              LDR      r0,[r4,#0]
00013a  43b0              BICS     r0,r0,r6
00013c  6020              STR      r0,[r4,#0]
00013e  6828              LDR      r0,[r5,#0]
000140  43b8              BICS     r0,r0,r7
000142  6028              STR      r0,[r5,#0]
                  |L1.324|
;;;217    				TIMER_DisableInt(TIMER1);
;;;218    			}
;;;219    
;;;220    //			iThisZXDetectedTime = TIMER_GetCounter(TIMER1) - ZXD_FILTER_TIME;
;;;221    //			//iTempDeltaZXD = GET_TIMER_DIFF(unLastZXDetectedTime, iThisZXDetectedTime) - ZXD_FILTER_TIME - ACMP_HYS_AVG_TIME;
;;;222    //			iTempDeltaZXD = GET_TIMER_DIFF(unLastZXDetectedTime, iThisZXDetectedTime);
;;;223    ////			iTempPhaseChange2ZX = GET_TIMER_DIFF(iPhaseChangeTime, iThisZXDetectedTime) - ZXD_FILTER_TIME;
;;;224    //			//iTargetNewPeriod = (iTempDeltaZXD >> 1) + iTempPhaseChange2ZX;
;;;225    //			iTargetNewPeriod = iTempDeltaZXD;	// >> 1 + iTempPhaseChange2ZX;	//(iTempDeltaZXD + tMotor.structMotor.ACT_PERIOD) >> 1;
;;;226    ////			iTargetNewPeriod = (iTargetNewPeriod + tMotor.structMotor.ACT_PERIOD) >> 1;
;;;227    //			iTestEnter_TMR1_MATCH++;
;;;228    ////			RECORD_TEST_VALUE(iTestNewPeriodIndex, iTestZXDPeriodArray, iTargetNewPeriod);
;;;229    ////			RECORD_TEST_VALUE(iTestTIM0CNTIndex, iTestTIM0CNTArray, TIMER0->TCMPR);
;;;230    ////			if ((iTestNewPeriodIndex == 0) && (iTestZXDPeriodArray[0] != 0))
;;;231    ////			{
;;;232    ////				BRG_DISABLE;
;;;233    ////				BLDC_stopMotor();
;;;234    ////				iTestZXDPeriodMax = getMax(iTestZXDPeriodArray, TEST_ARRAY_LEN);
;;;235    ////				iTestZXDPeriodMin = getMin(iTestZXDPeriodArray, TEST_ARRAY_LEN);
;;;236    ////				iTestTIM0CNTMax = getMax(iTestTIM0CNTArray, TEST_ARRAY_LEN);
;;;237    ////				iTestTIM0CNTMin = getMin(iTestTIM0CNTArray, TEST_ARRAY_LEN);
;;;238    ////			}
;;;239    ////			RECORD_TEST_DELTA_ZXD(iTestNewPeriodIndex, iThisZXDetectedTime);
;;;240    //			// Only when iTempDeltaZXD larger than minimum phase time and
;;;241    //			// smaller then max phase time we consider it is valid
;;;242    //			if ((iTargetNewPeriod > MIN_PHASE_TIME) && (iTargetNewPeriod < MAX_PHASE_TIME))
;;;243    //			{
;;;244    ////				ACMP0_INT_DISABLE;	// This phase job done
;;;245    //				TIMER_DisableInt(TIMER1);	// TIM1 interrupt will be re-open in TIM0 interrupt (phase change) to implement AVOID_ZXD_AFTER_PHCHG
;;;246    //				iTestEnter_ACMP_MATCH++;
;;;247    //				// We can consider ZX detected, and USE IT!!!!
;;;248    //				// To get stable and solide ZXD, more filter will be added in the TIM0 (phase change) interrupt
;;;249    //				// Only after continuously some number of ThisPhaseDetectedZX or miss ThisPhaseDetectedZX, it will enter or loss lock
;;;250    //				tMotor.structMotor.MSR.ThisPhaseDetectedZX = TRUE;
;;;251    //				unLastZXDetectedTime = iThisZXDetectedTime;
;;;252    //
;;;253    //				// Incase the counter of TIM0 is already in front of iTempDeltaZXD
;;;254    //				if ((TRUE == tMotor.structMotor.MSR.Locked))	// && (iTargetNewPeriod > (TIMER_GetCounter(TIMER0) + ZXD_BEFORE_PHCHG)))
;;;255    //				{	// Still have time to change CMP in TIM0
;;;256    //					// You can have a rest, now the only thing left is T0 trigger phase change
;;;257    //
;;;258    ////					BRG_DISABLE;
;;;259    //					iTestDetectedZX++;
;;;260    //					//iTempDeltaZXD = (tMotor.structMotor.ACT_PERIOD * 3 + iTempDeltaZXD) >> 2;
;;;261    //					if (iTargetNewPeriod > (TIMER_GetCounter(TIMER0) + ZXD_BEFORE_PHCHG))
;;;262    //					{
;;;263    //						tMotor.structMotor.ACT_PERIOD = iTargetNewPeriod;   //GET_TIMER_DIFF(unLastZXDetectedTime, TIMER_GetCounter(TIMER1));
;;;264    //					}
;;;265    //					else
;;;266    //					{
;;;267    //						tMotor.structMotor.ACT_PERIOD = TIMER_GetCounter(TIMER0) + (ZXD_BEFORE_PHCHG << 1);
;;;268    //					}
;;;269    //					TIMER_SET_CMP_VALUE(TIMER0, tMotor.structMotor.ACT_PERIOD);	//TIMER0->TDR + (iTargetNewPeriod >> 2));	//(iTempPhaseChange2ZX >> 1));
;;;270    ////					if (TIMER0->TISR & 0x01)
;;;271    ////					{	// If TIM0 interrupt was already triggered
;;;272    ////						// Clear interrupt flag
;;;273    ////						TIMER0->TISR |= 0x01;
;;;274    ////					}
;;;275    //					//TIMER_SET_CMP_VALUE(TIMER0, tMotor.structMotor.ACT_PERIOD);
;;;276    //				}
;;;277    //			}
;;;278    		}
;;;279    	}
;;;280    }
000144  bdf0              POP      {r4-r7,pc}
                  |L1.326|
000146  6829              LDR      r1,[r5,#0]
000148  43b9              BICS     r1,r1,r7
00014a  6029              STR      r1,[r5,#0]
00014c  2101              MOVS     r1,#1                 ;204
00014e  7001              STRB     r1,[r0,#0]            ;204
000150  68a0              LDR      r0,[r4,#8]            ;206
000152  4308              ORRS     r0,r0,r1              ;206
000154  60a0              STR      r0,[r4,#8]            ;206
000156  6820              LDR      r0,[r4,#0]            ;207
000158  4330              ORRS     r0,r0,r6              ;207
00015a  6020              STR      r0,[r4,#0]            ;207
00015c  bdf0              POP      {r4-r7,pc}
;;;281    
                          ENDP

                  ACMP_IRQHandler PROC
;;;301    
;;;302    void ACMP_IRQHandler(void)
00015e  486c              LDR      r0,|L1.784|
;;;303    {
;;;304    	ACMP->CMPSR |= ACMP_CMPSR_ACMPF0_Msk;
000160  6881              LDR      r1,[r0,#8]
000162  2201              MOVS     r2,#1
000164  4311              ORRS     r1,r1,r2
000166  6081              STR      r1,[r0,#8]
;;;305    //	iTestACMPIntEachPhaseCNT++;
;;;306    //	// maybe before enter TIM0 interrupt this ACMP int was triggered
;;;307    //	if (ACMP->CMPCR[0] & ACMP_CMPCR_ACMPIE_Msk)
;;;308    //	{
;;;309    //		if (ACMP0_EDGE_MATCH)
;;;310    //		{
;;;311    ////			RECORD_TEST_VALUE(iTestNewPeriodIndex, iTestZXDPeriodArray, TIMER_GetCounter(TIMER1) - TIMER1->TCMPR);
;;;312    ////			if (TIMER_GetCounter(TIMER1) < TIMER1->TCMPR)//((iTestNewPeriodIndex == 0) && (iTestZXDPeriodArray[0] != 0))
;;;313    ////			{
;;;314    ////				BRG_DISABLE;
;;;315    ////				BLDC_stopMotor();
;;;316    ////				iTestZXDPeriodMax = getMax(iTestZXDPeriodArray, TEST_ARRAY_LEN);
;;;317    ////				iTestZXDPeriodMin = getMin(iTestZXDPeriodArray, TEST_ARRAY_LEN);
;;;318    ////			}
;;;319    ////			iTestEnter_ACMP_MATCH++;
;;;320    //			ACMP0_INT_DISABLE;
;;;321    //			PhaseZXDedHandler(TIMER_GetCounter(TIMER1));
;;;322    //		}
;;;323    //	}
;;;324    //}
;;;325    
;;;326    	// In case this was triggered by last phase
;;;327    	// and in TIM0 interrupt didin't successfully disabled this interrupt
;;;328    	if (ENUM_TIM1_ZXD_FILTER == FLAG_TIM1_USEAGE)
000168  4867              LDR      r0,|L1.776|
00016a  7800              LDRB     r0,[r0,#0]  ; FLAG_TIM1_USEAGE
00016c  2801              CMP      r0,#1
00016e  d112              BNE      |L1.406|
;;;329    	{	 	
;;;330    		// Rising or falling edge will be put into TIM1 Interrupt handler because the following situdation will have problem:
;;;331    		// First a matched edge happened, then an un-matched edge happened
;;;332    		// So NOT check ACMP0_EDGE_MATCH here
;;;333    		//	if (ACMP0_EDGE_MATCH)
;;;334    		//	{
;;;335    		// Start count, if ACMP level can be stable for ZXD_FILTER_TIME
;;;336    		// we can consider real ZX
;;;337    		// If ACMP_IRQHandler was re-entered before ZXD_FILTER_TIME, postpond 
;;;338    		TIMER_SET_CMP_VALUE(TIMER1, GET_TIM1_CMP_VALUE(TIMER1->TDR + ZXD_FILTER_TIME));
000170  495f              LDR      r1,|L1.752|
000172  6ac8              LDR      r0,[r1,#0x2c]
000174  4a62              LDR      r2,|L1.768|
000176  30c8              ADDS     r0,r0,#0xc8
000178  4290              CMP      r0,r2
00017a  6ac8              LDR      r0,[r1,#0x2c]
00017c  d303              BCC      |L1.390|
00017e  4a61              LDR      r2,|L1.772|
000180  3228              ADDS     r2,r2,#0x28
000182  1880              ADDS     r0,r0,r2
000184  e000              B        |L1.392|
                  |L1.390|
000186  30c8              ADDS     r0,r0,#0xc8
                  |L1.392|
000188  6248              STR      r0,[r1,#0x24]
00018a  4859              LDR      r0,|L1.752|
00018c  3020              ADDS     r0,r0,#0x20
00018e  6801              LDR      r1,[r0,#0]
000190  0602              LSLS     r2,r0,#24
000192  4311              ORRS     r1,r1,r2
000194  6001              STR      r1,[r0,#0]
                  |L1.406|
;;;339    		TIMER_EnableInt(TIMER1);
;;;340    //		if (ACMP0_EDGE_MATCH)
;;;341    //		{
;;;342    //			ACMP0_INT_DISABLE;	// This phase job done
;;;343    //			iThisZXDetectedTime = TIMER_GetCounter(TIMER1);	// - ZXD_FILTER_TIME;
;;;344    //			//iTempDeltaZXD = GET_TIMER_DIFF(unLastZXDetectedTime, iThisZXDetectedTime) - ZXD_FILTER_TIME - ACMP_HYS_AVG_TIME;
;;;345    //			iTempDeltaZXD = GET_TIMER_DIFF(unLastZXDetectedTime, iThisZXDetectedTime);
;;;346    ////			iTempPhaseChange2ZX = GET_TIMER_DIFF(iPhaseChangeTime, iThisZXDetectedTime) - ZXD_FILTER_TIME;
;;;347    //			//iTargetNewPeriod = (iTempDeltaZXD >> 1) + iTempPhaseChange2ZX;
;;;348    //			iTargetNewPeriod = (iTempDeltaZXD + tMotor.structMotor.ACT_PERIOD) >> 1;
;;;349    ////			iTargetNewPeriod = (iTargetNewPeriod + tMotor.structMotor.ACT_PERIOD) >> 1;
;;;350    //			iTestEnter_TMR1_MATCH++;
;;;351    ////			RECORD_TEST_VALUE(iTestNewPeriodIndex, iTestZXDPeriodArray, iTargetNewPeriod);
;;;352    ////			RECORD_TEST_VALUE(iTestTIM0CNTIndex, iTestTIM0CNTArray, TIMER0->TCMPR);
;;;353    ////			if ((iTestNewPeriodIndex == 0) && (iTestZXDPeriodArray[0] != 0))
;;;354    ////			{
;;;355    ////				BRG_DISABLE;
;;;356    ////				BLDC_stopMotor();
;;;357    ////				iTestZXDPeriodMax = getMax(iTestZXDPeriodArray, TEST_ARRAY_LEN);
;;;358    ////				iTestZXDPeriodMin = getMin(iTestZXDPeriodArray, TEST_ARRAY_LEN);
;;;359    ////				iTestTIM0CNTMax = getMax(iTestTIM0CNTArray, TEST_ARRAY_LEN);
;;;360    ////				iTestTIM0CNTMin = getMin(iTestTIM0CNTArray, TEST_ARRAY_LEN);
;;;361    ////			}
;;;362    ////			RECORD_TEST_DELTA_ZXD(iTestNewPeriodIndex, iThisZXDetectedTime);
;;;363    //			// Only when iTempDeltaZXD larger than minimum phase time and
;;;364    //			// smaller then max phase time we consider it is valid
;;;365    //			if ((iTargetNewPeriod > MIN_PHASE_TIME) && (iTargetNewPeriod < MAX_PHASE_TIME))
;;;366    //			{
;;;367    ////				ACMP0_INT_DISABLE;	// This phase job done
;;;368    //				TIMER_DisableInt(TIMER1);	// TIM1 interrupt will be re-open in TIM0 interrupt (phase change) to implement AVOID_ZXD_AFTER_PHCHG
;;;369    //				iTestEnter_ACMP_MATCH++;
;;;370    //				// We can consider ZX detected, and USE IT!!!!
;;;371    //				// To get stable and solide ZXD, more filter will be added in the TIM0 (phase change) interrupt
;;;372    //				// Only after continuously some number of ThisPhaseDetectedZX or miss ThisPhaseDetectedZX, it will enter or loss lock
;;;373    //				tMotor.structMotor.MSR.ThisPhaseDetectedZX = TRUE;
;;;374    //				unLastZXDetectedTime = iThisZXDetectedTime;
;;;375    //
;;;376    //				// Incase the counter of TIM0 is already in front of iTempDeltaZXD
;;;377    //				if ((TRUE == tMotor.structMotor.MSR.Locked))	// && (iTargetNewPeriod > (TIMER_GetCounter(TIMER0) + ZXD_BEFORE_PHCHG)))
;;;378    //				{	// Still have time to change CMP in TIM0
;;;379    //					// You can have a rest, now the only thing left is T0 trigger phase change
;;;380    //
;;;381    ////					BRG_DISABLE;
;;;382    //					iTestDetectedZX++;
;;;383    //					//iTempDeltaZXD = (tMotor.structMotor.ACT_PERIOD * 3 + iTempDeltaZXD) >> 2;
;;;384    //
;;;385    //					tMotor.structMotor.ACT_PERIOD = iTargetNewPeriod;   //GET_TIMER_DIFF(unLastZXDetectedTime, TIMER_GetCounter(TIMER1));
;;;386    //					TIMER_SET_CMP_VALUE(TIMER0, TIMER0->TDR + (iTargetNewPeriod >> 2));	//(iTempPhaseChange2ZX >> 1));
;;;387    ////					if (TIMER0->TISR & 0x01)
;;;388    ////					{	// If TIM0 interrupt was already triggered
;;;389    ////						// Clear interrupt flag
;;;390    ////						TIMER0->TISR |= 0x01;
;;;391    ////					}
;;;392    //					//TIMER_SET_CMP_VALUE(TIMER0, tMotor.structMotor.ACT_PERIOD);
;;;393    //				}
;;;394    //			}
;;;395    //		}
;;;396    //	}
;;;397    	}
;;;398    }
000196  4770              BX       lr
;;;399    
                          ENDP

                  ADC_IRQHandler PROC
;;;400    void ADC_IRQHandler(void)
000198  b5f8              PUSH     {r3-r7,lr}
;;;401    {
;;;402        static uint32_t iADC_ComparatorFlag;
;;;403    	static uint32_t iSystemTickTemp;
;;;404    	static uint16_t iBatteryLowCNT = 0;
;;;405        static uint32_t iBatteryLowLastTimeRCD = 0;
;;;406    
;;;407        // Get ADC comparator interrupt flag
;;;408        iADC_ComparatorFlag = ADC_GET_INT_FLAG(ADC, ADC_CURRENT_CMP_MSK | ADC_BATTERY_CMP_MSK | ADC_ADF_MSK);
00019a  4e61              LDR      r6,|L1.800|
00019c  6b30              LDR      r0,[r6,#0x30]
00019e  4c5e              LDR      r4,|L1.792|
0001a0  0740              LSLS     r0,r0,#29
0001a2  0f40              LSRS     r0,r0,#29
;;;409        if(iADC_ComparatorFlag & ADC_ADF_MSK)
0001a4  60e0              STR      r0,[r4,#0xc]  ; iADC_ComparatorFlag
0001a6  07c1              LSLS     r1,r0,#31
0001a8  d01d              BEQ      |L1.486|
;;;410    	{
;;;411    		// Change ADC channel
;;;412    		if (ADC->ADCHER & ADC_CURRENT_CHN_MSK)
0001aa  6a71              LDR      r1,[r6,#0x24]
0001ac  07ca              LSLS     r2,r1,#31
;;;413    		{
;;;414    			tMotor.structMotor.unCURRENT = (uint16_t)(ADC_GET_CONVERSION_DATA(ADC, WHAT_EVER_DO_NOT_CARE));
0001ae  4953              LDR      r1,|L1.764|
0001b0  d008              BEQ      |L1.452|
0001b2  6832              LDR      r2,[r6,#0]
0001b4  0592              LSLS     r2,r2,#22
0001b6  0d92              LSRS     r2,r2,#22
0001b8  844a              STRH     r2,[r1,#0x22]
;;;415    			ADC_SET_INPUT_CHANNEL(ADC, ADC_BATTERY_CHN_MSK);		
0001ba  6a71              LDR      r1,[r6,#0x24]
0001bc  0a09              LSRS     r1,r1,#8
0001be  0209              LSLS     r1,r1,#8
0001c0  3180              ADDS     r1,r1,#0x80
0001c2  e00a              B        |L1.474|
                  |L1.452|
;;;416    		}
;;;417    		else if (ADC->ADCHER & ADC_BATTERY_CHN_MSK)
0001c4  6a72              LDR      r2,[r6,#0x24]
0001c6  0612              LSLS     r2,r2,#24
0001c8  d508              BPL      |L1.476|
;;;418    		{
;;;419    			tMotor.structMotor.unBATTERY = (uint16_t)(ADC_GET_CONVERSION_DATA(ADC, WHAT_EVER_DO_NOT_CARE));
0001ca  6832              LDR      r2,[r6,#0]
0001cc  0592              LSLS     r2,r2,#22
0001ce  0d92              LSRS     r2,r2,#22
0001d0  840a              STRH     r2,[r1,#0x20]
;;;420    			ADC_SET_INPUT_CHANNEL(ADC, ADC_CURRENT_CHN_MSK);
0001d2  6a71              LDR      r1,[r6,#0x24]
0001d4  0a09              LSRS     r1,r1,#8
0001d6  0209              LSLS     r1,r1,#8
0001d8  1c49              ADDS     r1,r1,#1
                  |L1.474|
0001da  6271              STR      r1,[r6,#0x24]
                  |L1.476|
;;;421    		}
;;;422    		ADC_START_CONV(ADC);
0001dc  6a31              LDR      r1,[r6,#0x20]
0001de  2201              MOVS     r2,#1
0001e0  02d2              LSLS     r2,r2,#11
0001e2  4311              ORRS     r1,r1,r2
0001e4  6231              STR      r1,[r6,#0x20]
                  |L1.486|
0001e6  4d42              LDR      r5,|L1.752|
;;;423    	}    
;;;424        if(iADC_ComparatorFlag & ADC_CURRENT_CMP_MSK)
0001e8  0780              LSLS     r0,r0,#30
0001ea  2700              MOVS     r7,#0
0001ec  3520              ADDS     r5,r5,#0x20
0001ee  2800              CMP      r0,#0
0001f0  da18              BGE      |L1.548|
;;;425    	{
;;;426    		// current too big
;;;427    		MOTOR_SHUT_DOWN;
0001f2  484c              LDR      r0,|L1.804|
0001f4  6207              STR      r7,[r0,#0x20]
0001f6  4940              LDR      r1,|L1.760|
0001f8  614f              STR      r7,[r1,#0x14]
0001fa  483d              LDR      r0,|L1.752|
0001fc  6803              LDR      r3,[r0,#0]
0001fe  0382              LSLS     r2,r0,#14
000200  4393              BICS     r3,r3,r2
000202  6003              STR      r3,[r0,#0]
000204  682b              LDR      r3,[r5,#0]
000206  4393              BICS     r3,r3,r2
000208  602b              STR      r3,[r5,#0]
00020a  6803              LDR      r3,[r0,#0]
00020c  0342              LSLS     r2,r0,#13
00020e  4393              BICS     r3,r3,r2
000210  6003              STR      r3,[r0,#0]
000212  6828              LDR      r0,[r5,#0]
000214  4390              BICS     r0,r0,r2
000216  6028              STR      r0,[r5,#0]
000218  20ff              MOVS     r0,#0xff
00021a  63c8              STR      r0,[r1,#0x3c]
00021c  6388              STR      r0,[r1,#0x38]
;;;428    		setError(ERR_CURRENT_BURNING);
00021e  2007              MOVS     r0,#7
000220  f7fffffe          BL       setError
                  |L1.548|
;;;429    	}
;;;430        if(iADC_ComparatorFlag & ADC_BATTERY_CMP_MSK)
000224  7b20              LDRB     r0,[r4,#0xc]  ; iADC_ComparatorFlag
000226  0740              LSLS     r0,r0,#29
000228  d529              BPL      |L1.638|
;;;431    	{
;;;432        	// Longer filter for battery voltage
;;;433    		// if this time's battery low is near to the last one
;;;434    		// 0.64ms interval of each measurement
;;;435    		iSystemTickTemp = unSystemTick;
00022a  483f              LDR      r0,|L1.808|
00022c  6800              LDR      r0,[r0,#0]  ; unSystemTick
;;;436    		if ((uint32_t)(iSystemTickTemp - iBatteryLowLastTimeRCD) < BATTERY_LOW_MIN_INTERVAL)
00022e  6120              STR      r0,[r4,#0x10]  ; iSystemTickTemp
000230  6961              LDR      r1,[r4,#0x14]  ; iBatteryLowLastTimeRCD
000232  1a40              SUBS     r0,r0,r1
000234  280a              CMP      r0,#0xa
000236  d21f              BCS      |L1.632|
;;;437    		{
;;;438    			if (iBatteryLowCNT < MAX_BATT_LOW_CNT)
000238  8860              LDRH     r0,[r4,#2]  ; iBatteryLowCNT
00023a  2832              CMP      r0,#0x32
00023c  d202              BCS      |L1.580|
00023e  1c40              ADDS     r0,r0,#1
;;;439    			{
;;;440    				iBatteryLowCNT++;
000240  8060              STRH     r0,[r4,#2]
000242  e01a              B        |L1.634|
                  |L1.580|
;;;441    			}
;;;442    			else
;;;443    			{
;;;444    				// battery really too low
;;;445    				MOTOR_SHUT_DOWN;
000244  4837              LDR      r0,|L1.804|
000246  6207              STR      r7,[r0,#0x20]
000248  492b              LDR      r1,|L1.760|
00024a  614f              STR      r7,[r1,#0x14]
00024c  4828              LDR      r0,|L1.752|
00024e  6802              LDR      r2,[r0,#0]
000250  0383              LSLS     r3,r0,#14
000252  439a              BICS     r2,r2,r3
000254  6002              STR      r2,[r0,#0]
000256  682a              LDR      r2,[r5,#0]
000258  439a              BICS     r2,r2,r3
00025a  602a              STR      r2,[r5,#0]
00025c  6803              LDR      r3,[r0,#0]
00025e  0342              LSLS     r2,r0,#13
000260  4393              BICS     r3,r3,r2
000262  6003              STR      r3,[r0,#0]
000264  6828              LDR      r0,[r5,#0]
000266  4390              BICS     r0,r0,r2
000268  6028              STR      r0,[r5,#0]
00026a  20ff              MOVS     r0,#0xff
00026c  63c8              STR      r0,[r1,#0x3c]
00026e  6388              STR      r0,[r1,#0x38]
;;;446    				setError(ERR_BATTERY_LOW);
000270  2005              MOVS     r0,#5
000272  f7fffffe          BL       setError
000276  e000              B        |L1.634|
                  |L1.632|
;;;447    			}
;;;448    		}
;;;449    		else
;;;450    		{
;;;451    			iBatteryLowCNT = 0;
000278  8067              STRH     r7,[r4,#2]
                  |L1.634|
;;;452    		}
;;;453    		iBatteryLowLastTimeRCD = iSystemTickTemp; 
00027a  6920              LDR      r0,[r4,#0x10]  ; iSystemTickTemp
00027c  6160              STR      r0,[r4,#0x14]  ; iBatteryLowLastTimeRCD
                  |L1.638|
;;;454    	}
;;;455        
;;;456        ADC_CLR_INT_FLAG(ADC, iADC_ComparatorFlag);
00027e  6b30              LDR      r0,[r6,#0x30]
000280  68e1              LDR      r1,[r4,#0xc]  ; iADC_ComparatorFlag
000282  08c0              LSRS     r0,r0,#3
000284  00c0              LSLS     r0,r0,#3
000286  4308              ORRS     r0,r0,r1
000288  6330              STR      r0,[r6,#0x30]
;;;457    }
00028a  bdf8              POP      {r3-r7,pc}
;;;458    
                          ENDP

                  SPI_IRQHandler PROC
;;;469    
;;;470    void SPI_IRQHandler(void)
00028c  b570              PUSH     {r4-r6,lr}
;;;471    {
;;;472    	static uint8_t unValueIndex;
;;;473    	if ((SPI->STATUS & SPI_STATUS_RX_INTSTS_Msk) != 0)
00028e  4827              LDR      r0,|L1.812|
000290  6840              LDR      r0,[r0,#4]
;;;474    	{
;;;475    		if (SPI_GET_RX_FIFO_COUNT(SPI) != COMM_LENGTH)
;;;476    		{
;;;477    			unCOM_SPI_TransErrCNT++;
000292  4927              LDR      r1,|L1.816|
000294  07c2              LSLS     r2,r0,#31             ;473
000296  6808              LDR      r0,[r1,#0]
000298  1c40              ADDS     r0,r0,#1
00029a  2a00              CMP      r2,#0                 ;473
00029c  d021              BEQ      |L1.738|
00029e  4c23              LDR      r4,|L1.812|
0002a0  3c40              SUBS     r4,r4,#0x40           ;471
0002a2  6c62              LDR      r2,[r4,#0x44]         ;471
0002a4  0412              LSLS     r2,r2,#16             ;471
0002a6  0f12              LSRS     r2,r2,#28             ;471
0002a8  2a04              CMP      r2,#4                 ;475
0002aa  d001              BEQ      |L1.688|
0002ac  6008              STR      r0,[r1,#0]  ; unCOM_SPI_TransErrCNT
0002ae  e011              B        |L1.724|
                  |L1.688|
;;;478    		}
;;;479    		else
;;;480    		{
;;;481    			// Received 4 uint16, copy to RAM buffer and infor communication manager
;;;482    			for (unValueIndex = 0; unValueIndex < COMM_LENGTH; unValueIndex++)
0002b0  4819              LDR      r0,|L1.792|
0002b2  2100              MOVS     r1,#0
;;;483    			{
;;;484    				unCOM_SPI_ReadData[unValueIndex] = SPI_READ_RX(SPI);
0002b4  4a1f              LDR      r2,|L1.820|
0002b6  7001              STRB     r1,[r0,#0]            ;482
                  |L1.696|
0002b8  6923              LDR      r3,[r4,#0x10]         ;482
0002ba  b2c9              UXTB     r1,r1
0002bc  004d              LSLS     r5,r1,#1
0002be  1c49              ADDS     r1,r1,#1
0002c0  b2c9              UXTB     r1,r1                 ;482
0002c2  5353              STRH     r3,[r2,r5]
0002c4  7001              STRB     r1,[r0,#0]            ;482
0002c6  2904              CMP      r1,#4                 ;482
0002c8  d3f6              BCC      |L1.696|
;;;485    			}
;;;486    			tMotor.structMotor.MSR.bNewComFrameReceived = TRUE;
0002ca  490c              LDR      r1,|L1.764|
0002cc  8848              LDRH     r0,[r1,#2]  ; tMotor
0002ce  2210              MOVS     r2,#0x10
0002d0  4310              ORRS     r0,r0,r2
0002d2  8048              STRH     r0,[r1,#2]
                  |L1.724|
;;;487    		}
;;;488    
;;;489    		// Clear Receive FIFO interrupt
;;;490    		// I don't know how to clear. Maybe just after I read out the data in FIFO and it is below threshold it will be OK
;;;491    		SPI_ClearRxFIFO(SPI);
0002d4  4620              MOV      r0,r4
0002d6  f7fffffe          BL       SPI_ClearRxFIFO
;;;492    		SPI_ClearTxFIFO(SPI);
0002da  4620              MOV      r0,r4
0002dc  f7fffffe          BL       SPI_ClearTxFIFO
;;;493    	}
;;;494    	else
;;;495    	{	// Receive FIFO interrupt should be the only interrupt enabled for SPI
;;;496    		// So something strange happened
;;;497    		unCOM_SPI_TransErrCNT++;
;;;498    	}
;;;499    }
0002e0  bd70              POP      {r4-r6,pc}
                  |L1.738|
0002e2  6008              STR      r0,[r1,#0]            ;497  ; unCOM_SPI_TransErrCNT
0002e4  bd70              POP      {r4-r6,pc}
;;;500    
                          ENDP

                  SysTick_Handler PROC
;;;501    void SysTick_Handler(void)
0002e6  4810              LDR      r0,|L1.808|
;;;502    {
;;;503    	unSystemTick += 5;
0002e8  6801              LDR      r1,[r0,#0]  ; unSystemTick
0002ea  1d49              ADDS     r1,r1,#5
0002ec  6001              STR      r1,[r0,#0]  ; unSystemTick
;;;504    }
0002ee  4770              BX       lr
                          ENDP

                  |L1.752|
                          DCD      0x40010000
                  |L1.756|
                          DCD      FLAG_PHASE_CHANGED
                  |L1.760|
                          DCD      0x40040040
                  |L1.764|
                          DCD      tMotor
                  |L1.768|
                          DCD      0x00ffffff
                  |L1.772|
                          DCD      0xff0000a1
                  |L1.776|
                          DCD      FLAG_TIM1_USEAGE
                  |L1.780|
                          DCD      unZXMatchCNT
                  |L1.784|
                          DCD      0x400d0000
                  |L1.788|
                          DCD      unLastZXDetectedTime
                  |L1.792|
                          DCD      ||.data||
                  |L1.796|
                          DCD      0x0000251b
                  |L1.800|
                          DCD      0x400e0000
                  |L1.804|
                          DCD      0x50004240
                  |L1.808|
                          DCD      unSystemTick
                  |L1.812|
                          DCD      0x40030040
                  |L1.816|
                          DCD      unCOM_SPI_TransErrCNT
                  |L1.820|
                          DCD      unCOM_SPI_ReadData

                          AREA ||.data||, DATA, ALIGN=2

                  unValueIndex
000000  0000              DCB      0x00,0x00
                  iBatteryLowCNT
000002  0000              DCW      0x0000
                  iTempDeltaZXD
                          DCD      0x00000000
                  iHalfPeriod
                          DCD      0x00000000
                  iADC_ComparatorFlag
                          DCD      0x00000000
                  iSystemTickTemp
                          DCD      0x00000000
                  iBatteryLowLastTimeRCD
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "User\\it.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___4_it_c_d50ddd2d____REV16|
#line 118 ".\\CMSIS\\core_cmInstr.h"
|__asm___4_it_c_d50ddd2d____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___4_it_c_d50ddd2d____REVSH|
#line 132
|__asm___4_it_c_d50ddd2d____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
