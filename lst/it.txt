; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\it.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\it.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\Mini51Series\Include -I..\..\..\Library\StdDriver\inc -I.\StdDriver\inc -I.\CMSIS -IG:\Geek\Projects\Zulolo_F\Force\Code\Zulolo_F_Force\RTE -ID:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.0.7\Device\Mini51\Include -ID:\Keil_v5\ARM\CMSIS\Include -I\ -D__MICROLIB -D__UVISION_VERSION=518 --omf_browse=.\obj\it.crf User\it.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  TMR0_IRQHandler PROC
;;;14     // Timer 0 is used to change phase
;;;15     void TMR0_IRQHandler(void)                                   
000000  b510              PUSH     {r4,lr}
;;;16     {
;;;17     	TIMER0->TISR  = TIMER0->TISR;	//~0;    // Write 1 to clear interrupt flag
000002  49b9              LDR      r1,|L1.744|
000004  6888              LDR      r0,[r1,#8]
000006  6088              STR      r0,[r1,#8]
;;;18     
;;;19     	FLAG_PHASE_CHANGED = SET;
000008  4ab8              LDR      r2,|L1.748|
00000a  2001              MOVS     r0,#1
00000c  7010              STRB     r0,[r2,#0]
;;;20     
;;;21     	if (TRUE == tMotor.structMotor.MSR.bZeroCrossDetecting)
00000e  48b8              LDR      r0,|L1.752|
000010  8840              LDRH     r0,[r0,#2]  ; tMotor
000012  0780              LSLS     r0,r0,#30
000014  d519              BPL      |L1.74|
000016  4ab4              LDR      r2,|L1.744|
000018  3220              ADDS     r2,r2,#0x20           ;16
00001a  6810              LDR      r0,[r2,#0]            ;16
00001c  034b              LSLS     r3,r1,#13             ;16
00001e  4398              BICS     r0,r0,r3              ;16
000020  6010              STR      r0,[r2,#0]            ;16
;;;22     	{
;;;23     		// In case TIM1 interrupt was triggered but before TIM0 interrupt (phase change)
;;;24     		TIMER_DisableInt(TIMER1);
;;;25     		TIMER1->TISR  = ~0;    // Clear interrupt flag
000022  2000              MOVS     r0,#0
000024  43c0              MVNS     r0,r0
000026  6288              STR      r0,[r1,#0x28]
;;;26     		TIMER_SET_CMP_VALUE(TIMER1, GET_TIM1_CMP_VALUE(TIMER1->TDR + AVOID_ZXD_AFTER_PHCHG));	
000028  6ac8              LDR      r0,[r1,#0x2c]
00002a  4cb2              LDR      r4,|L1.756|
00002c  30a0              ADDS     r0,r0,#0xa0
00002e  42a0              CMP      r0,r4
000030  6ac8              LDR      r0,[r1,#0x2c]
000032  d302              BCC      |L1.58|
000034  4cb0              LDR      r4,|L1.760|
000036  1900              ADDS     r0,r0,r4
000038  e000              B        |L1.60|
                  |L1.58|
00003a  30a0              ADDS     r0,r0,#0xa0
                  |L1.60|
00003c  6248              STR      r0,[r1,#0x24]
;;;27     		// ****!! In future AVOID_ZXD_AFTER_PHCHG can be made to dynamic !!****
;;;28     		// ****!! which means at lower RPM, the AVOID_ZXD_AFTER_PHCHG will be longer than at higher RPM !!****
;;;29     		//GET_TIMER_DIFF(PWM_ZX_FILTER_TIME, GET_TIM1_CMP_VALUE(TIMER1->TDR + (tMotor.structMotor.ACT_PERIOD >> 1))));	
;;;30     		//(tMotor.structMotor.ACT_PERIOD >> 2)));
;;;31     		FLAG_TIM1_USEAGE = ENUM_TIM1_AVOID_ZXD;
00003e  49af              LDR      r1,|L1.764|
000040  2000              MOVS     r0,#0
000042  7008              STRB     r0,[r1,#0]
000044  6810              LDR      r0,[r2,#0]
000046  4318              ORRS     r0,r0,r3
000048  6010              STR      r0,[r2,#0]
                  |L1.74|
;;;32     		TIMER_EnableInt(TIMER1);
;;;33     	}
;;;34     }
00004a  bd10              POP      {r4,pc}
;;;35     
                          ENDP

                  PhaseZXDedHandler PROC
;;;36     int32_t PhaseZXDedHandler(uint32_t iThisZXDetectedTime)
00004c  b530              PUSH     {r4,r5,lr}
;;;37     {
;;;38     	static uint32_t iTempDeltaZXD = 0;
;;;39     	static uint32_t iHalfPeriod = 0;
;;;40     //	static uint32_t iThisZXDetectedTime = 0;
;;;41     
;;;42     	//iThisZXDetectedTime = TIMER_GetCounter(TIMER1);
;;;43     
;;;44     	iTempDeltaZXD = GET_TIMER_DIFF(unLastZXDetectedTime, iThisZXDetectedTime);
00004e  4aac              LDR      r2,|L1.768|
000050  6811              LDR      r1,[r2,#0]  ; unLastZXDetectedTime
000052  4288              CMP      r0,r1
000054  d902              BLS      |L1.92|
000056  6811              LDR      r1,[r2,#0]  ; unLastZXDetectedTime
000058  1a41              SUBS     r1,r0,r1
00005a  e003              B        |L1.100|
                  |L1.92|
00005c  6813              LDR      r3,[r2,#0]  ; unLastZXDetectedTime
00005e  49a5              LDR      r1,|L1.756|
000060  1ac9              SUBS     r1,r1,r3
000062  1809              ADDS     r1,r1,r0
                  |L1.100|
;;;45     
;;;46     	if ((iTempDeltaZXD > MIN_PHASE_TIME) && (iTempDeltaZXD < MAX_PHASE_TIME))
000064  460c              MOV      r4,r1
000066  4ba7              LDR      r3,|L1.772|
000068  3cff              SUBS     r4,r4,#0xff
00006a  4da7              LDR      r5,|L1.776|
00006c  3cf6              SUBS     r4,r4,#0xf6
00006e  6099              STR      r1,[r3,#8]  ; iTempDeltaZXD
000070  42ac              CMP      r4,r5
000072  d221              BCS      |L1.184|
;;;47     	{
;;;48     		unLastZXDetectedTime = iThisZXDetectedTime;
000074  6010              STR      r0,[r2,#0]  ; unLastZXDetectedTime
;;;49     		tMotor.structMotor.MSR.bThisPhaseDetectedZX = TRUE;
000076  489e              LDR      r0,|L1.752|
000078  8842              LDRH     r2,[r0,#2]  ; tMotor
00007a  2408              MOVS     r4,#8
00007c  4322              ORRS     r2,r2,r4
00007e  8042              STRH     r2,[r0,#2]
;;;50     //		iTestDetectedZX++;
;;;51     		if (TRUE == tMotor.structMotor.MSR.bLocked)
000080  8842              LDRH     r2,[r0,#2]  ; tMotor
000082  0752              LSLS     r2,r2,#29
000084  d516              BPL      |L1.180|
;;;52     		{
;;;53     			tMotor.structMotor.unActualPeriod = (iTempDeltaZXD + tMotor.structMotor.unActualPeriod) >> 1;
000086  6982              LDR      r2,[r0,#0x18]  ; tMotor
000088  1851              ADDS     r1,r2,r1
00008a  0849              LSRS     r1,r1,#1
00008c  6181              STR      r1,[r0,#0x18]  ; tMotor
;;;54     			iHalfPeriod = tMotor.structMotor.unActualPeriod >> 1;
00008e  6980              LDR      r0,[r0,#0x18]  ; tMotor
;;;55     			TIMER_SET_CMP_VALUE(TIMER0, TIMER0->TDR + (iHalfPeriod > TIME_DEBT) ? (iHalfPeriod - TIME_DEBT) : ZXD_BEFORE_PHCHG);
000090  4a95              LDR      r2,|L1.744|
000092  0840              LSRS     r0,r0,#1              ;54
000094  60d8              STR      r0,[r3,#0xc]  ; iHalfPeriod
000096  68d3              LDR      r3,[r2,#0xc]
000098  21ff              MOVS     r1,#0xff
00009a  3105              ADDS     r1,#5
00009c  4288              CMP      r0,r1
00009e  d901              BLS      |L1.164|
0000a0  2101              MOVS     r1,#1
0000a2  e000              B        |L1.166|
                  |L1.164|
0000a4  2100              MOVS     r1,#0
                  |L1.166|
0000a6  42cb              CMN      r3,r1
0000a8  d002              BEQ      |L1.176|
0000aa  38ff              SUBS     r0,r0,#0xff
0000ac  3805              SUBS     r0,#5
0000ae  e000              B        |L1.178|
                  |L1.176|
0000b0  2032              MOVS     r0,#0x32
                  |L1.178|
0000b2  6050              STR      r0,[r2,#4]
                  |L1.180|
;;;56     		}
;;;57     		return TRUE;
0000b4  2001              MOVS     r0,#1
;;;58     	}
;;;59     	else
;;;60     	{
;;;61     		return FALSE;
;;;62     	}
;;;63     }
0000b6  bd30              POP      {r4,r5,pc}
                  |L1.184|
0000b8  2000              MOVS     r0,#0                 ;61
0000ba  bd30              POP      {r4,r5,pc}
;;;64     
                          ENDP

                  TMR1_IRQHandler PROC
;;;65     // Used to set time reference and filter ZXD
;;;66     void TMR1_IRQHandler(void)                                   
0000bc  b5f0              PUSH     {r4-r7,lr}
;;;67     {
;;;68     //	TIMER_DisableInt(TIMER1);
;;;69     	TIMER1->TISR = ~0;    // Clear interrupt flag
0000be  2000              MOVS     r0,#0
0000c0  4989              LDR      r1,|L1.744|
0000c2  43c0              MVNS     r0,r0
0000c4  6288              STR      r0,[r1,#0x28]
;;;70     
;;;71     	if (ENUM_TIM1_AVOID_ZXD == FLAG_TIM1_USEAGE)
0000c6  488d              LDR      r0,|L1.764|
0000c8  7801              LDRB     r1,[r0,#0]  ; FLAG_TIM1_USEAGE
0000ca  4d87              LDR      r5,|L1.744|
0000cc  2701              MOVS     r7,#1
0000ce  077f              LSLS     r7,r7,#29
;;;72     	{
;;;73     		TIMER_DisableInt(TIMER1);	// ACMP interrupt will re-open TIM1's interrupt
;;;74     		FLAG_TIM1_USEAGE = ENUM_TIM1_ZXD_FILTER;
;;;75     		// Clear all ACMP changed flag happened before
;;;76     		ACMP->CMPSR |= ACMP_CMPSR_ACMPF0_Msk;
;;;77     		ACMP0_INT_ENABLE;
0000d0  2602              MOVS     r6,#2
0000d2  4c8e              LDR      r4,|L1.780|
0000d4  3520              ADDS     r5,r5,#0x20           ;76
0000d6  2900              CMP      r1,#0                 ;71
0000d8  d014              BEQ      |L1.260|
;;;78     	}
;;;79     	else
;;;80     	{	// for now can only be ENUM_TIM1_ZXD_FILTER
;;;81     		if (ACMP0_EDGE_MATCH)
0000da  488d              LDR      r0,|L1.784|
0000dc  6b80              LDR      r0,[r0,#0x38]
0000de  68a1              LDR      r1,[r4,#8]
0000e0  0600              LSLS     r0,r0,#24
0000e2  0fc0              LSRS     r0,r0,#31
0000e4  0749              LSLS     r1,r1,#29
0000e6  0fc9              LSRS     r1,r1,#31
0000e8  4288              CMP      r0,r1
0000ea  d10a              BNE      |L1.258|
0000ec  68e8              LDR      r0,[r5,#0xc]
;;;82     		{	
;;;83     			// No need to find the real ZXD time, we only care the delta 
;;;84     			if (TRUE == PhaseZXDedHandler(TIMER_GetCounter(TIMER1)))	//GET_TIMER_DIFF(ZXD_FILTER_TIME, TIMER_GetCounter(TIMER1))))
0000ee  f7fffffe          BL       PhaseZXDedHandler
0000f2  2801              CMP      r0,#1
0000f4  d105              BNE      |L1.258|
;;;85     			{
;;;86     				ACMP0_INT_DISABLE;  // This phase ACMP job done
0000f6  6820              LDR      r0,[r4,#0]
0000f8  43b0              BICS     r0,r0,r6
0000fa  6020              STR      r0,[r4,#0]
0000fc  6828              LDR      r0,[r5,#0]
0000fe  43b8              BICS     r0,r0,r7
000100  6028              STR      r0,[r5,#0]
                  |L1.258|
;;;87     				TIMER_DisableInt(TIMER1);
;;;88     			}
;;;89     		}
;;;90     	}
;;;91     }
000102  bdf0              POP      {r4-r7,pc}
                  |L1.260|
000104  6829              LDR      r1,[r5,#0]
000106  43b9              BICS     r1,r1,r7
000108  6029              STR      r1,[r5,#0]
00010a  2101              MOVS     r1,#1                 ;74
00010c  7001              STRB     r1,[r0,#0]            ;74
00010e  68a0              LDR      r0,[r4,#8]            ;76
000110  4308              ORRS     r0,r0,r1              ;76
000112  60a0              STR      r0,[r4,#8]            ;76
000114  6820              LDR      r0,[r4,#0]            ;77
000116  4330              ORRS     r0,r0,r6              ;77
000118  6020              STR      r0,[r4,#0]            ;77
00011a  bdf0              POP      {r4-r7,pc}
;;;92     
                          ENDP

                  ACMP_IRQHandler PROC
;;;93     void ACMP_IRQHandler(void)
00011c  487b              LDR      r0,|L1.780|
;;;94     {
;;;95     	ACMP->CMPSR |= ACMP_CMPSR_ACMPF0_Msk;
00011e  6881              LDR      r1,[r0,#8]
000120  2201              MOVS     r2,#1
000122  4311              ORRS     r1,r1,r2
000124  6081              STR      r1,[r0,#8]
;;;96     
;;;97     	// In case this was triggered by last phase
;;;98     	// and in TIM0 interrupt didin't successfully disabled this interrupt
;;;99     	if (ENUM_TIM1_ZXD_FILTER == FLAG_TIM1_USEAGE)
000126  4875              LDR      r0,|L1.764|
000128  7800              LDRB     r0,[r0,#0]  ; FLAG_TIM1_USEAGE
00012a  2801              CMP      r0,#1
00012c  d112              BNE      |L1.340|
;;;100    	{	 	
;;;101    		// Rising or falling edge will be put into TIM1 Interrupt handler because the following situation will have problem:
;;;102    		// First a matched edge happened, then an un-matched edge happened
;;;103    		// So do NOT check ACMP0_EDGE_MATCH here.
;;;104    
;;;105    		// Start count, if ACMP level can be stable for ZXD_FILTER_TIME
;;;106    		// we can consider real ZX happened
;;;107    		// If ACMP_IRQHandler was re-entered before ZXD_FILTER_TIME, TIM1's interrupt will be postponed
;;;108    		TIMER_SET_CMP_VALUE(TIMER1, GET_TIM1_CMP_VALUE(TIMER1->TDR + ZXD_FILTER_TIME));
00012e  496e              LDR      r1,|L1.744|
000130  6ac8              LDR      r0,[r1,#0x2c]
000132  4a70              LDR      r2,|L1.756|
000134  30c8              ADDS     r0,r0,#0xc8
000136  4290              CMP      r0,r2
000138  6ac8              LDR      r0,[r1,#0x2c]
00013a  d303              BCC      |L1.324|
00013c  4a6e              LDR      r2,|L1.760|
00013e  3228              ADDS     r2,r2,#0x28
000140  1880              ADDS     r0,r0,r2
000142  e000              B        |L1.326|
                  |L1.324|
000144  30c8              ADDS     r0,r0,#0xc8
                  |L1.326|
000146  6248              STR      r0,[r1,#0x24]
000148  4867              LDR      r0,|L1.744|
00014a  3020              ADDS     r0,r0,#0x20
00014c  6801              LDR      r1,[r0,#0]
00014e  0602              LSLS     r2,r0,#24
000150  4311              ORRS     r1,r1,r2
000152  6001              STR      r1,[r0,#0]
                  |L1.340|
;;;109    		TIMER_EnableInt(TIMER1);
;;;110    	}
;;;111    }
000154  4770              BX       lr
;;;112    
                          ENDP

                  ADC_IRQHandler PROC
;;;113    void ADC_IRQHandler(void)
000156  b5f8              PUSH     {r3-r7,lr}
;;;114    {
;;;115      static uint32_t iADC_ComparatorFlag;
;;;116    	static uint32_t iSystemTickTemp;
;;;117    	static uint16_t iBatteryLowCNT = 0;
;;;118      static uint32_t iBatteryLowLastTimeRCD = 0;
;;;119    
;;;120        // Get ADC comparator interrupt flag
;;;121      iADC_ComparatorFlag = ADC_GET_INT_FLAG(ADC, ADC_CURRENT_CMP_MSK | ADC_BATTERY_CMP_MSK | ADC_ADF_MSK);
000158  4e6e              LDR      r6,|L1.788|
00015a  6b30              LDR      r0,[r6,#0x30]
00015c  4c69              LDR      r4,|L1.772|
00015e  0740              LSLS     r0,r0,#29
000160  0f40              LSRS     r0,r0,#29
;;;122      if(iADC_ComparatorFlag & ADC_ADF_MSK)
000162  6120              STR      r0,[r4,#0x10]  ; iADC_ComparatorFlag
000164  07c1              LSLS     r1,r0,#31
000166  d01d              BEQ      |L1.420|
;;;123    	{
;;;124    		// Change ADC channel
;;;125    		if (ADC->ADCHER & ADC_CURRENT_CHN_MSK)
000168  6a71              LDR      r1,[r6,#0x24]
00016a  07ca              LSLS     r2,r1,#31
;;;126    		{
;;;127    			tMotor.structMotor.unCurrent = (uint16_t)(ADC_GET_CONVERSION_DATA(ADC, WHAT_EVER_DO_NOT_CARE));
00016c  4960              LDR      r1,|L1.752|
00016e  d008              BEQ      |L1.386|
000170  6832              LDR      r2,[r6,#0]
000172  0592              LSLS     r2,r2,#22
000174  0d92              LSRS     r2,r2,#22
000176  848a              STRH     r2,[r1,#0x24]
;;;128    			ADC_SET_INPUT_CHANNEL(ADC, ADC_BATTERY_CHN_MSK);		
000178  6a71              LDR      r1,[r6,#0x24]
00017a  0a09              LSRS     r1,r1,#8
00017c  0209              LSLS     r1,r1,#8
00017e  3180              ADDS     r1,r1,#0x80
000180  e00a              B        |L1.408|
                  |L1.386|
;;;129    		}
;;;130    		else if (ADC->ADCHER & ADC_BATTERY_CHN_MSK)
000182  6a72              LDR      r2,[r6,#0x24]
000184  0612              LSLS     r2,r2,#24
000186  d508              BPL      |L1.410|
;;;131    		{
;;;132    			tMotor.structMotor.unBattery = (uint16_t)(ADC_GET_CONVERSION_DATA(ADC, WHAT_EVER_DO_NOT_CARE));
000188  6832              LDR      r2,[r6,#0]
00018a  0592              LSLS     r2,r2,#22
00018c  0d92              LSRS     r2,r2,#22
00018e  844a              STRH     r2,[r1,#0x22]
;;;133    			ADC_SET_INPUT_CHANNEL(ADC, ADC_CURRENT_CHN_MSK);
000190  6a71              LDR      r1,[r6,#0x24]
000192  0a09              LSRS     r1,r1,#8
000194  0209              LSLS     r1,r1,#8
000196  1c49              ADDS     r1,r1,#1
                  |L1.408|
000198  6271              STR      r1,[r6,#0x24]
                  |L1.410|
;;;134    		}
;;;135    		ADC_START_CONV(ADC);
00019a  6a31              LDR      r1,[r6,#0x20]
00019c  2201              MOVS     r2,#1
00019e  02d2              LSLS     r2,r2,#11
0001a0  4311              ORRS     r1,r1,r2
0001a2  6231              STR      r1,[r6,#0x20]
                  |L1.420|
0001a4  4d50              LDR      r5,|L1.744|
;;;136    	}    
;;;137        if(iADC_ComparatorFlag & ADC_CURRENT_CMP_MSK)
0001a6  0780              LSLS     r0,r0,#30
0001a8  2700              MOVS     r7,#0
0001aa  3520              ADDS     r5,r5,#0x20
0001ac  2800              CMP      r0,#0
0001ae  da18              BGE      |L1.482|
;;;138    	{
;;;139    		// current too big
;;;140    		MOTOR_SHUT_DOWN;
0001b0  4859              LDR      r0,|L1.792|
0001b2  6207              STR      r7,[r0,#0x20]
0001b4  4956              LDR      r1,|L1.784|
0001b6  614f              STR      r7,[r1,#0x14]
0001b8  484b              LDR      r0,|L1.744|
0001ba  6803              LDR      r3,[r0,#0]
0001bc  0382              LSLS     r2,r0,#14
0001be  4393              BICS     r3,r3,r2
0001c0  6003              STR      r3,[r0,#0]
0001c2  682b              LDR      r3,[r5,#0]
0001c4  4393              BICS     r3,r3,r2
0001c6  602b              STR      r3,[r5,#0]
0001c8  6803              LDR      r3,[r0,#0]
0001ca  0342              LSLS     r2,r0,#13
0001cc  4393              BICS     r3,r3,r2
0001ce  6003              STR      r3,[r0,#0]
0001d0  6828              LDR      r0,[r5,#0]
0001d2  4390              BICS     r0,r0,r2
0001d4  6028              STR      r0,[r5,#0]
0001d6  20ff              MOVS     r0,#0xff
0001d8  63c8              STR      r0,[r1,#0x3c]
0001da  6388              STR      r0,[r1,#0x38]
;;;141    		setError(ERR_CURRENT_BURNING);
0001dc  2007              MOVS     r0,#7
0001de  f7fffffe          BL       setError
                  |L1.482|
;;;142    	}
;;;143        if(iADC_ComparatorFlag & ADC_BATTERY_CMP_MSK)
0001e2  7c20              LDRB     r0,[r4,#0x10]  ; iADC_ComparatorFlag
0001e4  0740              LSLS     r0,r0,#29
0001e6  d529              BPL      |L1.572|
;;;144    	{
;;;145        	// Longer filter for battery voltage
;;;146    		// if this time's battery low is near to the last one
;;;147    		// 0.64ms interval of each measurement
;;;148    		iSystemTickTemp = unSystemTick;
0001e8  484c              LDR      r0,|L1.796|
0001ea  6800              LDR      r0,[r0,#0]  ; unSystemTick
;;;149    		if ((uint32_t)(iSystemTickTemp - iBatteryLowLastTimeRCD) < BATTERY_LOW_MIN_INTERVAL)
0001ec  6160              STR      r0,[r4,#0x14]  ; iSystemTickTemp
0001ee  69a1              LDR      r1,[r4,#0x18]  ; iBatteryLowLastTimeRCD
0001f0  1a40              SUBS     r0,r0,r1
0001f2  280a              CMP      r0,#0xa
0001f4  d21f              BCS      |L1.566|
;;;150    		{
;;;151    			if (iBatteryLowCNT < MAX_BATT_LOW_CNT)
0001f6  8860              LDRH     r0,[r4,#2]  ; iBatteryLowCNT
0001f8  2832              CMP      r0,#0x32
0001fa  d202              BCS      |L1.514|
0001fc  1c40              ADDS     r0,r0,#1
;;;152    			{
;;;153    				iBatteryLowCNT++;
0001fe  8060              STRH     r0,[r4,#2]
000200  e01a              B        |L1.568|
                  |L1.514|
;;;154    			}
;;;155    			else
;;;156    			{
;;;157    				// battery really too low
;;;158    				MOTOR_SHUT_DOWN;
000202  4845              LDR      r0,|L1.792|
000204  6207              STR      r7,[r0,#0x20]
000206  4942              LDR      r1,|L1.784|
000208  614f              STR      r7,[r1,#0x14]
00020a  4837              LDR      r0,|L1.744|
00020c  6802              LDR      r2,[r0,#0]
00020e  0383              LSLS     r3,r0,#14
000210  439a              BICS     r2,r2,r3
000212  6002              STR      r2,[r0,#0]
000214  682a              LDR      r2,[r5,#0]
000216  439a              BICS     r2,r2,r3
000218  602a              STR      r2,[r5,#0]
00021a  6803              LDR      r3,[r0,#0]
00021c  0342              LSLS     r2,r0,#13
00021e  4393              BICS     r3,r3,r2
000220  6003              STR      r3,[r0,#0]
000222  6828              LDR      r0,[r5,#0]
000224  4390              BICS     r0,r0,r2
000226  6028              STR      r0,[r5,#0]
000228  20ff              MOVS     r0,#0xff
00022a  63c8              STR      r0,[r1,#0x3c]
00022c  6388              STR      r0,[r1,#0x38]
;;;159    				setError(ERR_BATTERY_LOW);
00022e  2005              MOVS     r0,#5
000230  f7fffffe          BL       setError
000234  e000              B        |L1.568|
                  |L1.566|
;;;160    			}
;;;161    		}
;;;162    		else
;;;163    		{
;;;164    			iBatteryLowCNT = 0;
000236  8067              STRH     r7,[r4,#2]
                  |L1.568|
;;;165    		}
;;;166    		iBatteryLowLastTimeRCD = iSystemTickTemp; 
000238  6960              LDR      r0,[r4,#0x14]  ; iSystemTickTemp
00023a  61a0              STR      r0,[r4,#0x18]  ; iBatteryLowLastTimeRCD
                  |L1.572|
;;;167    	}
;;;168        
;;;169        ADC_CLR_INT_FLAG(ADC, iADC_ComparatorFlag);
00023c  6b30              LDR      r0,[r6,#0x30]
00023e  6921              LDR      r1,[r4,#0x10]  ; iADC_ComparatorFlag
000240  08c0              LSRS     r0,r0,#3
000242  00c0              LSLS     r0,r0,#3
000244  4308              ORRS     r0,r0,r1
000246  6330              STR      r0,[r6,#0x30]
;;;170    }
000248  bdf8              POP      {r3-r7,pc}
;;;171    	
                          ENDP

                  SPI_IRQHandler PROC
;;;172    void SPI_IRQHandler(void)
00024a  b5f0              PUSH     {r4-r7,lr}
;;;173    {
;;;174    	static ENUM_SPI_RECEIVE_STATE tSPI_LastState = SPI_RCV_IDLE;
;;;175    	static uint16_t unSPI_RX_Value;
;;;176    //	static uint8_t unSelectedReg = 0;
;;;177    	
;;;178    	// Check if it is really finished one unit transfer
;;;179    	if ((SPI->SSR & SPI_SSR_LTRIG_FLAG_Msk) == SPI_SSR_LTRIG_FLAG_Msk)
00024c  4934              LDR      r1,|L1.800|
00024e  6888              LDR      r0,[r1,#8]
;;;180    	{
;;;181    		unSPI_RX_Value = SPI_READ_RX(SPI);
;;;182    		
;;;183    		if (tMotor.structMotor.MSR.bNewComFrameReceived == FALSE)
;;;184    		{
;;;185    			switch(tSPI_LastState)
000250  2201              MOVS     r2,#1
000252  0680              LSLS     r0,r0,#26             ;179
000254  2800              CMP      r0,#0                 ;179
000256  da38              BGE      |L1.714|
000258  6908              LDR      r0,[r1,#0x10]         ;173
00025a  4c2a              LDR      r4,|L1.772|
00025c  b280              UXTH     r0,r0                 ;181
00025e  4e24              LDR      r6,|L1.752|
000260  80a0              STRH     r0,[r4,#4]            ;181
000262  8873              LDRH     r3,[r6,#2]            ;183  ; tMotor
000264  06db              LSLS     r3,r3,#27             ;183
000266  d430              BMI      |L1.714|
000268  7827              LDRB     r7,[r4,#0]  ; tSPI_LastState
;;;186    			{	
;;;187    				case SPI_RCV_IDLE:
;;;188    				case SPI_RCV_CRC:
;;;189    					if (MTR_INVALID_MOTOR_CMD == unSPI_RX_Value)
;;;190    					{
;;;191    //						SPI_WRITE_TX(SPI, unReadValueCRC);
;;;192    						SPI_TRIGGER(SPI);
;;;193    						tSPI_LastState = SPI_RCV_IDLE;
;;;194    					}
;;;195    					else
;;;196    					{
;;;197    						if (IS_COMM_RD_CMD(unSPI_RX_Value))
;;;198    						{
;;;199    							unCOM_SPI_ReadData[0] = unSPI_RX_Value;
00026a  4d2e              LDR      r5,|L1.804|
00026c  003b              MOVS     r3,r7                 ;185
00026e  f7fffffe          BL       __ARM_common_switch8
000272  0504              DCB      0x05,0x04
000274  191b2104          DCB      0x19,0x1b,0x21,0x04
000278  2800              DCB      0x28,0x00
00027a  4b2b              LDR      r3,|L1.808|
00027c  4298              CMP      r0,r3                 ;189
00027e  d104              BNE      |L1.650|
000280  6808              LDR      r0,[r1,#0]            ;189
000282  4310              ORRS     r0,r0,r2              ;189
000284  6008              STR      r0,[r1,#0]            ;189
000286  2000              MOVS     r0,#0                 ;193
000288  e00a              B        |L1.672|
                  |L1.650|
00028a  0bc3              LSRS     r3,r0,#15             ;197
;;;200    //							tMotor.structMotor.MSR.bNewComFrameReceived = TRUE;
;;;201    							SPI_TRIGGER(SPI);
;;;202    							tSPI_LastState = SPI_RCV_RD_CMD;
;;;203    						}
;;;204    						else
;;;205    						{
;;;206    							unCOM_SPI_ReadData[0] = unSPI_RX_Value;
00028c  8028              STRH     r0,[r5,#0]
00028e  6808              LDR      r0,[r1,#0]
000290  d003              BEQ      |L1.666|
000292  4310              ORRS     r0,r0,r2              ;197
000294  6008              STR      r0,[r1,#0]            ;197
000296  7022              STRB     r2,[r4,#0]            ;202
000298  e01a              B        |L1.720|
                  |L1.666|
00029a  4310              ORRS     r0,r0,r2              ;202
00029c  6008              STR      r0,[r1,#0]            ;202
;;;207    //							SPI_WRITE_TX(SPI, 0);
;;;208    							SPI_TRIGGER(SPI);
;;;209    							tSPI_LastState = SPI_RCV_WR_CMD;
00029e  2002              MOVS     r0,#2
                  |L1.672|
0002a0  7020              STRB     r0,[r4,#0]
0002a2  e015              B        |L1.720|
;;;210    						}						
;;;211    					}	
;;;212    				break;
;;;213    			
;;;214    				case SPI_RCV_RD_CMD:
;;;215    					// If last time is read command, this time must be read CRC and next time must be 0xFFFF on MOSI to read
;;;216    					// So the data received is the CRC of read command, now the slave doesn't care
;;;217    					unCOM_SPI_ReadData[1] = unSPI_RX_Value;
0002a4  8068              STRH     r0,[r5,#2]
;;;218    //					SPI_WRITE_TX(SPI, unReadValueCRC);
;;;219    //					SPI_TRIGGER(SPI);		
;;;220    					tMotor.structMotor.MSR.bNewComFrameReceived = TRUE;				
;;;221    					tSPI_LastState = SPI_RCV_CRC;	
;;;222    				break;
0002a6  e006              B        |L1.694|
0002a8  680b              LDR      r3,[r1,#0]
0002aa  4313              ORRS     r3,r3,r2
0002ac  600b              STR      r3,[r1,#0]
;;;223    
;;;224    				case SPI_RCV_WR_CMD:
;;;225    					// No need to comment
;;;226    //					SPI_WRITE_TX(SPI, 0);
;;;227    					SPI_TRIGGER(SPI);
;;;228    					unCOM_SPI_ReadData[1] = unSPI_RX_Value;
0002ae  8068              STRH     r0,[r5,#2]
;;;229    					tSPI_LastState = SPI_RCV_WR_DATA;	
0002b0  2003              MOVS     r0,#3
;;;230    				break;
0002b2  e7f5              B        |L1.672|
;;;231    				
;;;232    				case SPI_RCV_WR_DATA:
;;;233    					// No need to comment
;;;234    					unCOM_SPI_ReadData[2] = unSPI_RX_Value;
0002b4  80a8              STRH     r0,[r5,#4]
                  |L1.694|
;;;235    					tMotor.structMotor.MSR.bNewComFrameReceived = TRUE;
0002b6  8870              LDRH     r0,[r6,#2]  ; tMotor
0002b8  2210              MOVS     r2,#0x10
0002ba  4310              ORRS     r0,r0,r2
0002bc  8070              STRH     r0,[r6,#2]
;;;236    					tSPI_LastState = SPI_RCV_CRC;	
0002be  2004              MOVS     r0,#4
0002c0  e7ee              B        |L1.672|
;;;237    				break;
;;;238    			
;;;239    				default:
;;;240    					unCOM_SPI_TransErrCNT++;
0002c2  481a              LDR      r0,|L1.812|
0002c4  6803              LDR      r3,[r0,#0]  ; unCOM_SPI_TransErrCNT
0002c6  1c5b              ADDS     r3,r3,#1
0002c8  6003              STR      r3,[r0,#0]  ; unCOM_SPI_TransErrCNT
                  |L1.714|
0002ca  6808              LDR      r0,[r1,#0]
0002cc  4310              ORRS     r0,r0,r2
0002ce  6008              STR      r0,[r1,#0]
                  |L1.720|
0002d0  6c48              LDR      r0,[r1,#0x44]
0002d2  2201              MOVS     r2,#1
0002d4  0412              LSLS     r2,r2,#16
0002d6  4310              ORRS     r0,r0,r2
0002d8  6448              STR      r0,[r1,#0x44]
;;;241    //					SPI_WRITE_TX(SPI, 0);
;;;242    					SPI_TRIGGER(SPI);
;;;243    				break;
;;;244    			}
;;;245    		}
;;;246    		else
;;;247    		{
;;;248    			SPI_TRIGGER(SPI);			
;;;249    		}		
;;;250    	}
;;;251    	else
;;;252    	{
;;;253    //		SPI_WRITE_TX(SPI, 0);
;;;254    		SPI_TRIGGER(SPI);
;;;255    	}
;;;256    
;;;257    	SPI_CLR_UNIT_TRANS_INT_FLAG(SPI);
;;;258    }
0002da  bdf0              POP      {r4-r7,pc}
;;;259    
                          ENDP

                  SysTick_Handler PROC
;;;407    
;;;408    void SysTick_Handler(void)
0002dc  480f              LDR      r0,|L1.796|
;;;409    {
;;;410    	unSystemTick += 5;
0002de  6801              LDR      r1,[r0,#0]  ; unSystemTick
0002e0  1d49              ADDS     r1,r1,#5
0002e2  6001              STR      r1,[r0,#0]  ; unSystemTick
;;;411    }
0002e4  4770              BX       lr
                          ENDP

0002e6  0000              DCW      0x0000
                  |L1.744|
                          DCD      0x40010000
                  |L1.748|
                          DCD      FLAG_PHASE_CHANGED
                  |L1.752|
                          DCD      tMotor
                  |L1.756|
                          DCD      0x00ffffff
                  |L1.760|
                          DCD      0xff0000a1
                  |L1.764|
                          DCD      FLAG_TIM1_USEAGE
                  |L1.768|
                          DCD      unLastZXDetectedTime
                  |L1.772|
                          DCD      ||.data||
                  |L1.776|
                          DCD      0x0000251b
                  |L1.780|
                          DCD      0x400d0000
                  |L1.784|
                          DCD      0x40040040
                  |L1.788|
                          DCD      0x400e0000
                  |L1.792|
                          DCD      0x50004240
                  |L1.796|
                          DCD      unSystemTick
                  |L1.800|
                          DCD      0x40030000
                  |L1.804|
                          DCD      unCOM_SPI_ReadData
                  |L1.808|
                          DCD      0x0000ffff
                  |L1.812|
                          DCD      unCOM_SPI_TransErrCNT

                          AREA ||.data||, DATA, ALIGN=2

                  tSPI_LastState
000000  0000              DCB      0x00,0x00
                  iBatteryLowCNT
000002  0000              DCW      0x0000
                  unSPI_RX_Value
000004  00000000          DCB      0x00,0x00,0x00,0x00
                  iTempDeltaZXD
                          DCD      0x00000000
                  iHalfPeriod
                          DCD      0x00000000
                  iADC_ComparatorFlag
                          DCD      0x00000000
                  iSystemTickTemp
                          DCD      0x00000000
                  iBatteryLowLastTimeRCD
                          DCD      0x00000000

                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d200              BCS      |L14.16|
00000e  461d              MOV      r5,r3
                  |L14.16|
000010  5d63              LDRB     r3,[r4,r5]
000012  005b              LSLS     r3,r3,#1
000014  18e3              ADDS     r3,r4,r3
000016  bc30              POP      {r4,r5}
000018  4718              BX       r3
                          ENDP


;*** Start embedded assembler ***

#line 1 "User\\it.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___4_it_c_d50ddd2d____REV16|
#line 118 ".\\CMSIS\\core_cmInstr.h"
|__asm___4_it_c_d50ddd2d____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___4_it_c_d50ddd2d____REVSH|
#line 132
|__asm___4_it_c_d50ddd2d____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
