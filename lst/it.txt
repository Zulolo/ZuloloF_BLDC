; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\it.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\it.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\Mini51Series\Include -I..\..\..\Library\StdDriver\inc -I.\StdDriver\inc -I.\CMSIS -IG:\Geek\Projects\Zulolo_F\Force\Code\Zulolo_F_Force\RTE -ID:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.0.7\Device\Mini51\Include -ID:\Keil_v5\ARM\CMSIS\Include -I\ -D__MICROLIB -D__UVISION_VERSION=518 --omf_browse=.\obj\it.crf User\it.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  TMR0_IRQHandler PROC
;;;14     // Timer 0 is used to change phase
;;;15     void TMR0_IRQHandler(void)                                   
000000  b510              PUSH     {r4,lr}
;;;16     {
;;;17     	TIMER0->TISR  = TIMER0->TISR;	//~0;    // Write 1 to clear interrupt flag
000002  49b0              LDR      r1,|L1.708|
000004  6888              LDR      r0,[r1,#8]
000006  6088              STR      r0,[r1,#8]
;;;18     
;;;19     	FLAG_PHASE_CHANGED = SET;
000008  4aaf              LDR      r2,|L1.712|
00000a  2001              MOVS     r0,#1
00000c  7010              STRB     r0,[r2,#0]
;;;20     
;;;21     	if (TRUE == tMotor.structMotor.MSR.bZeroCrossDetecting)
00000e  48af              LDR      r0,|L1.716|
000010  8840              LDRH     r0,[r0,#2]  ; tMotor
000012  0780              LSLS     r0,r0,#30
000014  d519              BPL      |L1.74|
000016  4aab              LDR      r2,|L1.708|
000018  3220              ADDS     r2,r2,#0x20           ;16
00001a  6810              LDR      r0,[r2,#0]            ;16
00001c  034b              LSLS     r3,r1,#13             ;16
00001e  4398              BICS     r0,r0,r3              ;16
000020  6010              STR      r0,[r2,#0]            ;16
;;;22     	{
;;;23     		// In case TIM1 interrupt was triggered but before TIM0 interrupt (phase change)
;;;24     		TIMER_DisableInt(TIMER1);
;;;25     		TIMER1->TISR  = ~0;    // Clear interrupt flag
000022  2000              MOVS     r0,#0
000024  43c0              MVNS     r0,r0
000026  6288              STR      r0,[r1,#0x28]
;;;26     		TIMER_SET_CMP_VALUE(TIMER1, GET_TIM1_CMP_VALUE(TIMER1->TDR + AVOID_ZXD_AFTER_PHCHG));	
000028  6ac8              LDR      r0,[r1,#0x2c]
00002a  4ca9              LDR      r4,|L1.720|
00002c  30a0              ADDS     r0,r0,#0xa0
00002e  42a0              CMP      r0,r4
000030  6ac8              LDR      r0,[r1,#0x2c]
000032  d302              BCC      |L1.58|
000034  4ca7              LDR      r4,|L1.724|
000036  1900              ADDS     r0,r0,r4
000038  e000              B        |L1.60|
                  |L1.58|
00003a  30a0              ADDS     r0,r0,#0xa0
                  |L1.60|
00003c  6248              STR      r0,[r1,#0x24]
;;;27     		// ****!! In future AVOID_ZXD_AFTER_PHCHG can be made to dynamic !!****
;;;28     		// ****!! which means at lower RPM, the AVOID_ZXD_AFTER_PHCHG will be longer than at higher RPM !!****
;;;29     		//GET_TIMER_DIFF(PWM_ZX_FILTER_TIME, GET_TIM1_CMP_VALUE(TIMER1->TDR + (tMotor.structMotor.ACT_PERIOD >> 1))));	
;;;30     		//(tMotor.structMotor.ACT_PERIOD >> 2)));
;;;31     		FLAG_TIM1_USEAGE = ENUM_TIM1_AVOID_ZXD;
00003e  49a6              LDR      r1,|L1.728|
000040  2000              MOVS     r0,#0
000042  7008              STRB     r0,[r1,#0]
000044  6810              LDR      r0,[r2,#0]
000046  4318              ORRS     r0,r0,r3
000048  6010              STR      r0,[r2,#0]
                  |L1.74|
;;;32     		TIMER_EnableInt(TIMER1);
;;;33     	}
;;;34     }
00004a  bd10              POP      {r4,pc}
;;;35     
                          ENDP

                  PhaseZXDedHandler PROC
;;;36     int32_t PhaseZXDedHandler(uint32_t iThisZXDetectedTime)
00004c  b530              PUSH     {r4,r5,lr}
;;;37     {
;;;38     	static uint32_t iTempDeltaZXD = 0;
;;;39     	static uint32_t iHalfPeriod = 0;
;;;40     //	static uint32_t iThisZXDetectedTime = 0;
;;;41     
;;;42     	//iThisZXDetectedTime = TIMER_GetCounter(TIMER1);
;;;43     
;;;44     	iTempDeltaZXD = GET_TIMER_DIFF(unLastZXDetectedTime, iThisZXDetectedTime);
00004e  4aa3              LDR      r2,|L1.732|
000050  6811              LDR      r1,[r2,#0]  ; unLastZXDetectedTime
000052  4288              CMP      r0,r1
000054  d902              BLS      |L1.92|
000056  6811              LDR      r1,[r2,#0]  ; unLastZXDetectedTime
000058  1a41              SUBS     r1,r0,r1
00005a  e003              B        |L1.100|
                  |L1.92|
00005c  6813              LDR      r3,[r2,#0]  ; unLastZXDetectedTime
00005e  499c              LDR      r1,|L1.720|
000060  1ac9              SUBS     r1,r1,r3
000062  1809              ADDS     r1,r1,r0
                  |L1.100|
;;;45     
;;;46     	if ((iTempDeltaZXD > MIN_PHASE_TIME) && (iTempDeltaZXD < MAX_PHASE_TIME))
000064  460c              MOV      r4,r1
000066  4b9e              LDR      r3,|L1.736|
000068  3cff              SUBS     r4,r4,#0xff
00006a  4d9e              LDR      r5,|L1.740|
00006c  3cf6              SUBS     r4,r4,#0xf6
00006e  6059              STR      r1,[r3,#4]  ; iTempDeltaZXD
000070  42ac              CMP      r4,r5
000072  d221              BCS      |L1.184|
;;;47     	{
;;;48     		unLastZXDetectedTime = iThisZXDetectedTime;
000074  6010              STR      r0,[r2,#0]  ; unLastZXDetectedTime
;;;49     		tMotor.structMotor.MSR.bThisPhaseDetectedZX = TRUE;
000076  4895              LDR      r0,|L1.716|
000078  8842              LDRH     r2,[r0,#2]  ; tMotor
00007a  2408              MOVS     r4,#8
00007c  4322              ORRS     r2,r2,r4
00007e  8042              STRH     r2,[r0,#2]
;;;50     //		iTestDetectedZX++;
;;;51     		if (TRUE == tMotor.structMotor.MSR.bLocked)
000080  8842              LDRH     r2,[r0,#2]  ; tMotor
000082  0752              LSLS     r2,r2,#29
000084  d516              BPL      |L1.180|
;;;52     		{
;;;53     			tMotor.structMotor.unActualPeriod = (iTempDeltaZXD + tMotor.structMotor.unActualPeriod) >> 1;
000086  6982              LDR      r2,[r0,#0x18]  ; tMotor
000088  1851              ADDS     r1,r2,r1
00008a  0849              LSRS     r1,r1,#1
00008c  6181              STR      r1,[r0,#0x18]  ; tMotor
;;;54     			iHalfPeriod = tMotor.structMotor.unActualPeriod >> 1;
00008e  6980              LDR      r0,[r0,#0x18]  ; tMotor
;;;55     			TIMER_SET_CMP_VALUE(TIMER0, TIMER0->TDR + (iHalfPeriod > TIME_DEBT) ? (iHalfPeriod - TIME_DEBT) : ZXD_BEFORE_PHCHG);
000090  4a8c              LDR      r2,|L1.708|
000092  0840              LSRS     r0,r0,#1              ;54
000094  6098              STR      r0,[r3,#8]  ; iHalfPeriod
000096  68d3              LDR      r3,[r2,#0xc]
000098  21ff              MOVS     r1,#0xff
00009a  3105              ADDS     r1,#5
00009c  4288              CMP      r0,r1
00009e  d901              BLS      |L1.164|
0000a0  2101              MOVS     r1,#1
0000a2  e000              B        |L1.166|
                  |L1.164|
0000a4  2100              MOVS     r1,#0
                  |L1.166|
0000a6  42cb              CMN      r3,r1
0000a8  d002              BEQ      |L1.176|
0000aa  38ff              SUBS     r0,r0,#0xff
0000ac  3805              SUBS     r0,#5
0000ae  e000              B        |L1.178|
                  |L1.176|
0000b0  2032              MOVS     r0,#0x32
                  |L1.178|
0000b2  6050              STR      r0,[r2,#4]
                  |L1.180|
;;;56     		}
;;;57     		return TRUE;
0000b4  2001              MOVS     r0,#1
;;;58     	}
;;;59     	else
;;;60     	{
;;;61     		return FALSE;
;;;62     	}
;;;63     }
0000b6  bd30              POP      {r4,r5,pc}
                  |L1.184|
0000b8  2000              MOVS     r0,#0                 ;61
0000ba  bd30              POP      {r4,r5,pc}
;;;64     
                          ENDP

                  TMR1_IRQHandler PROC
;;;65     // Used to set time reference and filter ZXD
;;;66     void TMR1_IRQHandler(void)                                   
0000bc  b5f0              PUSH     {r4-r7,lr}
;;;67     {
;;;68     //	TIMER_DisableInt(TIMER1);
;;;69     	TIMER1->TISR = ~0;    // Clear interrupt flag
0000be  2000              MOVS     r0,#0
0000c0  4980              LDR      r1,|L1.708|
0000c2  43c0              MVNS     r0,r0
0000c4  6288              STR      r0,[r1,#0x28]
;;;70     
;;;71     	if (ENUM_TIM1_AVOID_ZXD == FLAG_TIM1_USEAGE)
0000c6  4884              LDR      r0,|L1.728|
0000c8  7801              LDRB     r1,[r0,#0]  ; FLAG_TIM1_USEAGE
0000ca  4d7e              LDR      r5,|L1.708|
0000cc  2701              MOVS     r7,#1
0000ce  077f              LSLS     r7,r7,#29
;;;72     	{
;;;73     		TIMER_DisableInt(TIMER1);	// ACMP interrupt will re-open TIM1's interrupt
;;;74     		FLAG_TIM1_USEAGE = ENUM_TIM1_ZXD_FILTER;
;;;75     		// Clear all ACMP changed flag happened before
;;;76     		ACMP->CMPSR |= ACMP_CMPSR_ACMPF0_Msk;
;;;77     		ACMP0_INT_ENABLE;
0000d0  2602              MOVS     r6,#2
0000d2  4c85              LDR      r4,|L1.744|
0000d4  3520              ADDS     r5,r5,#0x20           ;76
0000d6  2900              CMP      r1,#0                 ;71
0000d8  d014              BEQ      |L1.260|
;;;78     	}
;;;79     	else
;;;80     	{	// for now can only be ENUM_TIM1_ZXD_FILTER
;;;81     		if (ACMP0_EDGE_MATCH)
0000da  4884              LDR      r0,|L1.748|
0000dc  6b80              LDR      r0,[r0,#0x38]
0000de  68a1              LDR      r1,[r4,#8]
0000e0  0600              LSLS     r0,r0,#24
0000e2  0fc0              LSRS     r0,r0,#31
0000e4  0749              LSLS     r1,r1,#29
0000e6  0fc9              LSRS     r1,r1,#31
0000e8  4288              CMP      r0,r1
0000ea  d10a              BNE      |L1.258|
0000ec  68e8              LDR      r0,[r5,#0xc]
;;;82     		{	
;;;83     			// No need to find the real ZXD time, we only care the delta 
;;;84     			if (TRUE == PhaseZXDedHandler(TIMER_GetCounter(TIMER1)))	//GET_TIMER_DIFF(ZXD_FILTER_TIME, TIMER_GetCounter(TIMER1))))
0000ee  f7fffffe          BL       PhaseZXDedHandler
0000f2  2801              CMP      r0,#1
0000f4  d105              BNE      |L1.258|
;;;85     			{
;;;86     				ACMP0_INT_DISABLE;  // This phase ACMP job done
0000f6  6820              LDR      r0,[r4,#0]
0000f8  43b0              BICS     r0,r0,r6
0000fa  6020              STR      r0,[r4,#0]
0000fc  6828              LDR      r0,[r5,#0]
0000fe  43b8              BICS     r0,r0,r7
000100  6028              STR      r0,[r5,#0]
                  |L1.258|
;;;87     				TIMER_DisableInt(TIMER1);
;;;88     			}
;;;89     		}
;;;90     	}
;;;91     }
000102  bdf0              POP      {r4-r7,pc}
                  |L1.260|
000104  6829              LDR      r1,[r5,#0]
000106  43b9              BICS     r1,r1,r7
000108  6029              STR      r1,[r5,#0]
00010a  2101              MOVS     r1,#1                 ;74
00010c  7001              STRB     r1,[r0,#0]            ;74
00010e  68a0              LDR      r0,[r4,#8]            ;76
000110  4308              ORRS     r0,r0,r1              ;76
000112  60a0              STR      r0,[r4,#8]            ;76
000114  6820              LDR      r0,[r4,#0]            ;77
000116  4330              ORRS     r0,r0,r6              ;77
000118  6020              STR      r0,[r4,#0]            ;77
00011a  bdf0              POP      {r4-r7,pc}
;;;92     
                          ENDP

                  ACMP_IRQHandler PROC
;;;93     void ACMP_IRQHandler(void)
00011c  4872              LDR      r0,|L1.744|
;;;94     {
;;;95     	ACMP->CMPSR |= ACMP_CMPSR_ACMPF0_Msk;
00011e  6881              LDR      r1,[r0,#8]
000120  2201              MOVS     r2,#1
000122  4311              ORRS     r1,r1,r2
000124  6081              STR      r1,[r0,#8]
;;;96     
;;;97     	// In case this was triggered by last phase
;;;98     	// and in TIM0 interrupt didin't successfully disabled this interrupt
;;;99     	if (ENUM_TIM1_ZXD_FILTER == FLAG_TIM1_USEAGE)
000126  486c              LDR      r0,|L1.728|
000128  7800              LDRB     r0,[r0,#0]  ; FLAG_TIM1_USEAGE
00012a  2801              CMP      r0,#1
00012c  d112              BNE      |L1.340|
;;;100    	{	 	
;;;101    		// Rising or falling edge will be put into TIM1 Interrupt handler because the following situation will have problem:
;;;102    		// First a matched edge happened, then an un-matched edge happened
;;;103    		// So do NOT check ACMP0_EDGE_MATCH here.
;;;104    
;;;105    		// Start count, if ACMP level can be stable for ZXD_FILTER_TIME
;;;106    		// we can consider real ZX happened
;;;107    		// If ACMP_IRQHandler was re-entered before ZXD_FILTER_TIME, TIM1's interrupt will be postponed
;;;108    		TIMER_SET_CMP_VALUE(TIMER1, GET_TIM1_CMP_VALUE(TIMER1->TDR + ZXD_FILTER_TIME));
00012e  4965              LDR      r1,|L1.708|
000130  6ac8              LDR      r0,[r1,#0x2c]
000132  4a67              LDR      r2,|L1.720|
000134  30c8              ADDS     r0,r0,#0xc8
000136  4290              CMP      r0,r2
000138  6ac8              LDR      r0,[r1,#0x2c]
00013a  d303              BCC      |L1.324|
00013c  4a65              LDR      r2,|L1.724|
00013e  3228              ADDS     r2,r2,#0x28
000140  1880              ADDS     r0,r0,r2
000142  e000              B        |L1.326|
                  |L1.324|
000144  30c8              ADDS     r0,r0,#0xc8
                  |L1.326|
000146  6248              STR      r0,[r1,#0x24]
000148  485e              LDR      r0,|L1.708|
00014a  3020              ADDS     r0,r0,#0x20
00014c  6801              LDR      r1,[r0,#0]
00014e  0602              LSLS     r2,r0,#24
000150  4311              ORRS     r1,r1,r2
000152  6001              STR      r1,[r0,#0]
                  |L1.340|
;;;109    		TIMER_EnableInt(TIMER1);
;;;110    	}
;;;111    }
000154  4770              BX       lr
;;;112    
                          ENDP

                  ADC_IRQHandler PROC
;;;113    void ADC_IRQHandler(void)
000156  b5f8              PUSH     {r3-r7,lr}
;;;114    {
;;;115        static uint32_t iADC_ComparatorFlag;
;;;116    	static uint32_t iSystemTickTemp;
;;;117    	static uint16_t iBatteryLowCNT = 0;
;;;118        static uint32_t iBatteryLowLastTimeRCD = 0;
;;;119    
;;;120        // Get ADC comparator interrupt flag
;;;121        iADC_ComparatorFlag = ADC_GET_INT_FLAG(ADC, ADC_CURRENT_CMP_MSK | ADC_BATTERY_CMP_MSK | ADC_ADF_MSK);
000158  4e65              LDR      r6,|L1.752|
00015a  6b30              LDR      r0,[r6,#0x30]
00015c  4c60              LDR      r4,|L1.736|
00015e  0740              LSLS     r0,r0,#29
000160  0f40              LSRS     r0,r0,#29
;;;122        if(iADC_ComparatorFlag & ADC_ADF_MSK)
000162  60e0              STR      r0,[r4,#0xc]  ; iADC_ComparatorFlag
000164  07c1              LSLS     r1,r0,#31
000166  d01d              BEQ      |L1.420|
;;;123    	{
;;;124    		// Change ADC channel
;;;125    		if (ADC->ADCHER & ADC_CURRENT_CHN_MSK)
000168  6a71              LDR      r1,[r6,#0x24]
00016a  07ca              LSLS     r2,r1,#31
;;;126    		{
;;;127    			tMotor.structMotor.unCurrent = (uint16_t)(ADC_GET_CONVERSION_DATA(ADC, WHAT_EVER_DO_NOT_CARE));
00016c  4957              LDR      r1,|L1.716|
00016e  d008              BEQ      |L1.386|
000170  6832              LDR      r2,[r6,#0]
000172  0592              LSLS     r2,r2,#22
000174  0d92              LSRS     r2,r2,#22
000176  848a              STRH     r2,[r1,#0x24]
;;;128    			ADC_SET_INPUT_CHANNEL(ADC, ADC_BATTERY_CHN_MSK);		
000178  6a71              LDR      r1,[r6,#0x24]
00017a  0a09              LSRS     r1,r1,#8
00017c  0209              LSLS     r1,r1,#8
00017e  3180              ADDS     r1,r1,#0x80
000180  e00a              B        |L1.408|
                  |L1.386|
;;;129    		}
;;;130    		else if (ADC->ADCHER & ADC_BATTERY_CHN_MSK)
000182  6a72              LDR      r2,[r6,#0x24]
000184  0612              LSLS     r2,r2,#24
000186  d508              BPL      |L1.410|
;;;131    		{
;;;132    			tMotor.structMotor.unBattery = (uint16_t)(ADC_GET_CONVERSION_DATA(ADC, WHAT_EVER_DO_NOT_CARE));
000188  6832              LDR      r2,[r6,#0]
00018a  0592              LSLS     r2,r2,#22
00018c  0d92              LSRS     r2,r2,#22
00018e  844a              STRH     r2,[r1,#0x22]
;;;133    			ADC_SET_INPUT_CHANNEL(ADC, ADC_CURRENT_CHN_MSK);
000190  6a71              LDR      r1,[r6,#0x24]
000192  0a09              LSRS     r1,r1,#8
000194  0209              LSLS     r1,r1,#8
000196  1c49              ADDS     r1,r1,#1
                  |L1.408|
000198  6271              STR      r1,[r6,#0x24]
                  |L1.410|
;;;134    		}
;;;135    		ADC_START_CONV(ADC);
00019a  6a31              LDR      r1,[r6,#0x20]
00019c  2201              MOVS     r2,#1
00019e  02d2              LSLS     r2,r2,#11
0001a0  4311              ORRS     r1,r1,r2
0001a2  6231              STR      r1,[r6,#0x20]
                  |L1.420|
0001a4  4d47              LDR      r5,|L1.708|
;;;136    	}    
;;;137        if(iADC_ComparatorFlag & ADC_CURRENT_CMP_MSK)
0001a6  0780              LSLS     r0,r0,#30
0001a8  2700              MOVS     r7,#0
0001aa  3520              ADDS     r5,r5,#0x20
0001ac  2800              CMP      r0,#0
0001ae  da18              BGE      |L1.482|
;;;138    	{
;;;139    		// current too big
;;;140    		MOTOR_SHUT_DOWN;
0001b0  4850              LDR      r0,|L1.756|
0001b2  6207              STR      r7,[r0,#0x20]
0001b4  494d              LDR      r1,|L1.748|
0001b6  614f              STR      r7,[r1,#0x14]
0001b8  4842              LDR      r0,|L1.708|
0001ba  6803              LDR      r3,[r0,#0]
0001bc  0382              LSLS     r2,r0,#14
0001be  4393              BICS     r3,r3,r2
0001c0  6003              STR      r3,[r0,#0]
0001c2  682b              LDR      r3,[r5,#0]
0001c4  4393              BICS     r3,r3,r2
0001c6  602b              STR      r3,[r5,#0]
0001c8  6803              LDR      r3,[r0,#0]
0001ca  0342              LSLS     r2,r0,#13
0001cc  4393              BICS     r3,r3,r2
0001ce  6003              STR      r3,[r0,#0]
0001d0  6828              LDR      r0,[r5,#0]
0001d2  4390              BICS     r0,r0,r2
0001d4  6028              STR      r0,[r5,#0]
0001d6  20ff              MOVS     r0,#0xff
0001d8  63c8              STR      r0,[r1,#0x3c]
0001da  6388              STR      r0,[r1,#0x38]
;;;141    		setError(ERR_CURRENT_BURNING);
0001dc  2007              MOVS     r0,#7
0001de  f7fffffe          BL       setError
                  |L1.482|
;;;142    	}
;;;143        if(iADC_ComparatorFlag & ADC_BATTERY_CMP_MSK)
0001e2  7b20              LDRB     r0,[r4,#0xc]  ; iADC_ComparatorFlag
0001e4  0740              LSLS     r0,r0,#29
0001e6  d529              BPL      |L1.572|
;;;144    	{
;;;145        	// Longer filter for battery voltage
;;;146    		// if this time's battery low is near to the last one
;;;147    		// 0.64ms interval of each measurement
;;;148    		iSystemTickTemp = unSystemTick;
0001e8  4843              LDR      r0,|L1.760|
0001ea  6800              LDR      r0,[r0,#0]  ; unSystemTick
;;;149    		if ((uint32_t)(iSystemTickTemp - iBatteryLowLastTimeRCD) < BATTERY_LOW_MIN_INTERVAL)
0001ec  6120              STR      r0,[r4,#0x10]  ; iSystemTickTemp
0001ee  6961              LDR      r1,[r4,#0x14]  ; iBatteryLowLastTimeRCD
0001f0  1a40              SUBS     r0,r0,r1
0001f2  280a              CMP      r0,#0xa
0001f4  d21f              BCS      |L1.566|
;;;150    		{
;;;151    			if (iBatteryLowCNT < MAX_BATT_LOW_CNT)
0001f6  8820              LDRH     r0,[r4,#0]  ; iBatteryLowCNT
0001f8  2832              CMP      r0,#0x32
0001fa  d202              BCS      |L1.514|
0001fc  1c40              ADDS     r0,r0,#1
;;;152    			{
;;;153    				iBatteryLowCNT++;
0001fe  8020              STRH     r0,[r4,#0]
000200  e01a              B        |L1.568|
                  |L1.514|
;;;154    			}
;;;155    			else
;;;156    			{
;;;157    				// battery really too low
;;;158    				MOTOR_SHUT_DOWN;
000202  483c              LDR      r0,|L1.756|
000204  6207              STR      r7,[r0,#0x20]
000206  4939              LDR      r1,|L1.748|
000208  614f              STR      r7,[r1,#0x14]
00020a  482e              LDR      r0,|L1.708|
00020c  6802              LDR      r2,[r0,#0]
00020e  0383              LSLS     r3,r0,#14
000210  439a              BICS     r2,r2,r3
000212  6002              STR      r2,[r0,#0]
000214  682a              LDR      r2,[r5,#0]
000216  439a              BICS     r2,r2,r3
000218  602a              STR      r2,[r5,#0]
00021a  6803              LDR      r3,[r0,#0]
00021c  0342              LSLS     r2,r0,#13
00021e  4393              BICS     r3,r3,r2
000220  6003              STR      r3,[r0,#0]
000222  6828              LDR      r0,[r5,#0]
000224  4390              BICS     r0,r0,r2
000226  6028              STR      r0,[r5,#0]
000228  20ff              MOVS     r0,#0xff
00022a  63c8              STR      r0,[r1,#0x3c]
00022c  6388              STR      r0,[r1,#0x38]
;;;159    				setError(ERR_BATTERY_LOW);
00022e  2005              MOVS     r0,#5
000230  f7fffffe          BL       setError
000234  e000              B        |L1.568|
                  |L1.566|
;;;160    			}
;;;161    		}
;;;162    		else
;;;163    		{
;;;164    			iBatteryLowCNT = 0;
000236  8027              STRH     r7,[r4,#0]
                  |L1.568|
;;;165    		}
;;;166    		iBatteryLowLastTimeRCD = iSystemTickTemp; 
000238  6920              LDR      r0,[r4,#0x10]  ; iSystemTickTemp
00023a  6160              STR      r0,[r4,#0x14]  ; iBatteryLowLastTimeRCD
                  |L1.572|
;;;167    	}
;;;168        
;;;169        ADC_CLR_INT_FLAG(ADC, iADC_ComparatorFlag);
00023c  6b30              LDR      r0,[r6,#0x30]
00023e  68e1              LDR      r1,[r4,#0xc]  ; iADC_ComparatorFlag
000240  08c0              LSRS     r0,r0,#3
000242  00c0              LSLS     r0,r0,#3
000244  4308              ORRS     r0,r0,r1
000246  6330              STR      r0,[r6,#0x30]
;;;170    }
000248  bdf8              POP      {r3-r7,pc}
;;;171    
                          ENDP

                  SPI_IRQHandler PROC
;;;172    void SPI_IRQHandler(void)
00024a  b5f8              PUSH     {r3-r7,lr}
;;;173    {
;;;174    	uint32_t unSPI_RX_Value;
;;;175    	uint8_t unFIFO_RX_CNT;
;;;176    
;;;177    	if ((SPI->CNTRL & SPI_STATUS_IF_Msk) == SPI_STATUS_IF_Msk)
00024c  4c2b              LDR      r4,|L1.764|
00024e  6820              LDR      r0,[r4,#0]
000250  03c0              LSLS     r0,r0,#15
000252  d531              BPL      |L1.696|
;;;178    	{
;;;179    		// Check if it is really finished one unit transfer
;;;180    		if ((SPI->SSR & SPI_SSR_LTRIG_FLAG_Msk) == SPI_SSR_LTRIG_FLAG_Msk)
000254  68a0              LDR      r0,[r4,#8]
;;;181    		{
;;;182    			if (tMotor.structMotor.MSR.bNewComFrameReceived == FALSE)
;;;183    			{
;;;184    				unFIFO_RX_CNT = SPI_GET_RX_FIFO_COUNT(SPI);
;;;185    				if (unFIFO_RX_CNT == COMM_RD_CMD_CNT_IN_32BIT)
;;;186    				{
;;;187    					// Received 2 uint16, copy to RAM buffer and infor communication manager
;;;188    					unSPI_RX_Value = SPI_READ_RX(SPI);
;;;189    					unCOM_SPI_ReadData[0] = (uint16_t)(unSPI_RX_Value >> 16);
;;;190    					unCOM_SPI_ReadData[1] = (uint16_t)unSPI_RX_Value;
;;;191    
;;;192    					if (IS_COMM_RD_CMD(unCOM_SPI_ReadData[0]))
;;;193    					{
;;;194    						tMotor.structMotor.MSR.bNewComFrameReceived = TRUE;
;;;195    					}
;;;196    					else
;;;197    					{
;;;198    						unCOM_SPI_TransErrCNT++;
000256  4a2a              LDR      r2,|L1.768|
000258  0680              LSLS     r0,r0,#26             ;180
00025a  6811              LDR      r1,[r2,#0]
00025c  1c49              ADDS     r1,r1,#1
00025e  2800              CMP      r0,#0                 ;180
000260  da21              BGE      |L1.678|
000262  4e1a              LDR      r6,|L1.716|
000264  8870              LDRH     r0,[r6,#2]            ;182  ; tMotor
000266  06c0              LSLS     r0,r0,#27             ;182
000268  d41d              BMI      |L1.678|
00026a  6c60              LDR      r0,[r4,#0x44]         ;182
00026c  4d25              LDR      r5,|L1.772|
00026e  0400              LSLS     r0,r0,#16             ;189
000270  0f00              LSRS     r0,r0,#28             ;189
000272  2801              CMP      r0,#1                 ;185
000274  d002              BEQ      |L1.636|
;;;199    					}
;;;200    				}
;;;201    				else if (unFIFO_RX_CNT == COMM_WR_CMD_CNT_IN_32BIT)
000276  2802              CMP      r0,#2
000278  d00b              BEQ      |L1.658|
00027a  e014              B        |L1.678|
                  |L1.636|
00027c  6920              LDR      r0,[r4,#0x10]
00027e  0c03              LSRS     r3,r0,#16             ;189
000280  802b              STRH     r3,[r5,#0]            ;189
000282  8068              STRH     r0,[r5,#2]            ;190
000284  0bd8              LSRS     r0,r3,#15             ;192
000286  d00e              BEQ      |L1.678|
                  |L1.648|
000288  8870              LDRH     r0,[r6,#2]            ;194  ; tMotor
00028a  2110              MOVS     r1,#0x10              ;194
00028c  4308              ORRS     r0,r0,r1              ;194
00028e  8070              STRH     r0,[r6,#2]            ;194
000290  e00a              B        |L1.680|
                  |L1.658|
000292  6923              LDR      r3,[r4,#0x10]         ;194
;;;202    				{
;;;203    					// Received 4 uint16, copy to RAM buffer and infor communication manager
;;;204    					unSPI_RX_Value = SPI_READ_RX(SPI);
;;;205    					unCOM_SPI_ReadData[0] = (uint16_t)(unSPI_RX_Value >> 16);
000294  0c18              LSRS     r0,r3,#16
000296  8028              STRH     r0,[r5,#0]
;;;206    					unCOM_SPI_ReadData[1] = (uint16_t)unSPI_RX_Value;
000298  806b              STRH     r3,[r5,#2]
00029a  6923              LDR      r3,[r4,#0x10]
;;;207    					unSPI_RX_Value = SPI_READ_RX(SPI);
;;;208    					unCOM_SPI_ReadData[2] = (uint16_t)(unSPI_RX_Value >> 16);
00029c  0c1f              LSRS     r7,r3,#16
00029e  80af              STRH     r7,[r5,#4]
;;;209    					unCOM_SPI_ReadData[3] = (uint16_t)unSPI_RX_Value;					
0002a0  80eb              STRH     r3,[r5,#6]
;;;210    					if (IS_COMM_WR_CMD(unCOM_SPI_ReadData[0]))
0002a2  0400              LSLS     r0,r0,#16
0002a4  d5f0              BPL      |L1.648|
                  |L1.678|
;;;211    					{
;;;212    						tMotor.structMotor.MSR.bNewComFrameReceived = TRUE;
;;;213    					}
;;;214    					else
;;;215    					{
;;;216    						unCOM_SPI_TransErrCNT++;
;;;217    					}
;;;218    				}
;;;219    				else
;;;220    				{
;;;221    					unCOM_SPI_TransErrCNT++;
;;;222    				}
;;;223    			}
;;;224    			else
;;;225    			{
;;;226    				unCOM_SPI_TransErrCNT++;
0002a6  6011              STR      r1,[r2,#0]  ; unCOM_SPI_TransErrCNT
                  |L1.680|
;;;227    			}
;;;228    			// Clear Receive FIFO interrupt
;;;229    			// I don't know how to clear. Maybe just after I read out the data in FIFO and it is below threshold it will be OK
;;;230    		}
;;;231    		else
;;;232    		{	// Receive FIFO interrupt should be the only interrupt enabled for SPI
;;;233    			// So something strange happened
;;;234    			unCOM_SPI_TransErrCNT++;
;;;235    		}		
;;;236    		SPI_ClearRxFIFO(SPI);
0002a8  4620              MOV      r0,r4
0002aa  f7fffffe          BL       SPI_ClearRxFIFO
0002ae  6c61              LDR      r1,[r4,#0x44]
0002b0  2201              MOVS     r2,#1
0002b2  0412              LSLS     r2,r2,#16
0002b4  4311              ORRS     r1,r1,r2
0002b6  6461              STR      r1,[r4,#0x44]
                  |L1.696|
;;;237    		SPI_CLR_UNIT_TRANS_INT_FLAG(SPI);
;;;238    	}
;;;239    }
0002b8  bdf8              POP      {r3-r7,pc}
;;;240    
                          ENDP

                  SysTick_Handler PROC
;;;241    void SysTick_Handler(void)
0002ba  480f              LDR      r0,|L1.760|
;;;242    {
;;;243    	unSystemTick += 5;
0002bc  6801              LDR      r1,[r0,#0]  ; unSystemTick
0002be  1d49              ADDS     r1,r1,#5
0002c0  6001              STR      r1,[r0,#0]  ; unSystemTick
;;;244    }
0002c2  4770              BX       lr
                          ENDP

                  |L1.708|
                          DCD      0x40010000
                  |L1.712|
                          DCD      FLAG_PHASE_CHANGED
                  |L1.716|
                          DCD      tMotor
                  |L1.720|
                          DCD      0x00ffffff
                  |L1.724|
                          DCD      0xff0000a1
                  |L1.728|
                          DCD      FLAG_TIM1_USEAGE
                  |L1.732|
                          DCD      unLastZXDetectedTime
                  |L1.736|
                          DCD      ||.data||
                  |L1.740|
                          DCD      0x0000251b
                  |L1.744|
                          DCD      0x400d0000
                  |L1.748|
                          DCD      0x40040040
                  |L1.752|
                          DCD      0x400e0000
                  |L1.756|
                          DCD      0x50004240
                  |L1.760|
                          DCD      unSystemTick
                  |L1.764|
                          DCD      0x40030000
                  |L1.768|
                          DCD      unCOM_SPI_TransErrCNT
                  |L1.772|
                          DCD      unCOM_SPI_ReadData

                          AREA ||.data||, DATA, ALIGN=2

                  iBatteryLowCNT
000000  0000              DCW      0x0000
000002  0000              DCB      0x00,0x00
                  iTempDeltaZXD
                          DCD      0x00000000
                  iHalfPeriod
                          DCD      0x00000000
                  iADC_ComparatorFlag
                          DCD      0x00000000
                  iSystemTickTemp
                          DCD      0x00000000
                  iBatteryLowLastTimeRCD
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "User\\it.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___4_it_c_d50ddd2d____REV16|
#line 118 ".\\CMSIS\\core_cmInstr.h"
|__asm___4_it_c_d50ddd2d____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___4_it_c_d50ddd2d____REVSH|
#line 132
|__asm___4_it_c_d50ddd2d____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
