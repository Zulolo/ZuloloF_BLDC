; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\pwm.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\pwm.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\Mini51Series\Include -I..\..\..\Library\StdDriver\inc -I.\StdDriver\inc -I.\CMSIS -IG:\Geek\Projects\Zulolo_F\Force\Code\Zulolo_F_Force\RTE -ID:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.0.2\Device\Mini51\Include -ID:\Keil_v5\ARM\CMSIS\Include -I\ -D__MICROLIB -D__UVISION_VERSION=518 --omf_browse=.\obj\pwm.crf StdDriver\src\pwm.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  PWM_ConfigOutputChannel PROC
;;;35      */
;;;36     uint32_t PWM_ConfigOutputChannel (PWM_T *pwm, 
000000  b5ff              PUSH     {r0-r7,lr}
;;;37                                       uint32_t u32ChannelNum, 
;;;38                                       uint32_t u32Frequncy, 
;;;39                                       uint32_t u32DutyCycle)
;;;40     {
;;;41         uint32_t i = SystemCoreClock / u32Frequncy;
000002  48be              LDR      r0,|L1.764|
000004  b083              SUB      sp,sp,#0xc            ;40
000006  460e              MOV      r6,r1                 ;40
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000a  4611              MOV      r1,r2
00000c  9001              STR      r0,[sp,#4]
00000e  f7fffffe          BL       __aeabi_uidivmod
;;;42         uint8_t  u8Divider = 1, u8Prescale = 0xFF;
000012  2401              MOVS     r4,#1
;;;43         uint16_t u16CNR = 0xFFFF;
000014  4dba              LDR      r5,|L1.768|
000016  27ff              MOVS     r7,#0xff              ;42
000018  9000              STR      r0,[sp,#0]
                  |L1.26|
;;;44         
;;;45         for(; u8Divider < 17; u8Divider <<= 1) {  // clk divider could only be 1, 2, 4, 8, 16
;;;46             i = (SystemCoreClock / u32Frequncy) / u8Divider;
00001a  4621              MOV      r1,r4
00001c  9800              LDR      r0,[sp,#0]
00001e  f7fffffe          BL       __aeabi_uidivmod
;;;47             // If target value is larger than CNR * prescale, need to use a larger divider
;;;48             if(i > (0x10000 * 0x100))   
000022  2101              MOVS     r1,#1
000024  0609              LSLS     r1,r1,#24
000026  4288              CMP      r0,r1
000028  d812              BHI      |L1.80|
;;;49                 continue;
;;;50             
;;;51             // CNR = 0xFFFF + 1, get a prescaler that CNR value is below 0xFFFF
;;;52             u8Prescale = (i + 0xFFFF)/ 0x10000; 
00002a  1941              ADDS     r1,r0,r5
00002c  0209              LSLS     r1,r1,#8
00002e  0e0f              LSRS     r7,r1,#24
;;;53             
;;;54             // u8Prescale must at least be 2, otherwise the output stop
;;;55             if(u8Prescale < 3)
000030  2f03              CMP      r7,#3
000032  d200              BCS      |L1.54|
;;;56                 u8Prescale = 2;
000034  2702              MOVS     r7,#2
                  |L1.54|
;;;57             
;;;58             i /= u8Prescale;
000036  4639              MOV      r1,r7
000038  f7fffffe          BL       __aeabi_uidivmod
;;;59             
;;;60             if(i <= 0x10000) {
00003c  2101              MOVS     r1,#1
00003e  0409              LSLS     r1,r1,#16
000040  4288              CMP      r0,r1
000042  d805              BHI      |L1.80|
;;;61                 if(i == 1)
000044  2801              CMP      r0,#1
000046  d001              BEQ      |L1.76|
;;;62                     u16CNR = 1;     // Too fast, and PWM cannot generat expected frequency...
;;;63                 else
;;;64                     u16CNR = i;
000048  b285              UXTH     r5,r0
00004a  e005              B        |L1.88|
                  |L1.76|
00004c  2501              MOVS     r5,#1                 ;62
00004e  e003              B        |L1.88|
                  |L1.80|
000050  0660              LSLS     r0,r4,#25             ;45
000052  0e04              LSRS     r4,r0,#24             ;45
000054  2c11              CMP      r4,#0x11              ;45
000056  d3e0              BCC      |L1.26|
                  |L1.88|
;;;65                 break;
;;;66             }
;;;67             
;;;68         }
;;;69         // Store return value here 'cos we're gonna change u8Divider & u8Prescale & u16CNR to the real value to fill into register
;;;70         i = SystemCoreClock / (u8Prescale * u8Divider * u16CNR);
000058  4639              MOV      r1,r7
00005a  4361              MULS     r1,r4,r1
00005c  4369              MULS     r1,r5,r1
00005e  9801              LDR      r0,[sp,#4]
000060  f7fffffe          BL       __aeabi_uidivmod
000064  1e7f              SUBS     r7,r7,#1
;;;71         
;;;72         u8Prescale -= 1;
000066  1e6d              SUBS     r5,r5,#1
000068  b2fa              UXTB     r2,r7
;;;73         u16CNR -= 1;
00006a  b2ad              UXTH     r5,r5
;;;74         // convert to real register value
;;;75         if(u8Divider == 1)
00006c  9000              STR      r0,[sp,#0]
00006e  2c01              CMP      r4,#1
000070  d02a              BEQ      |L1.200|
;;;76             u8Divider = 4;
;;;77         else if (u8Divider == 2)
000072  2c02              CMP      r4,#2
000074  d02a              BEQ      |L1.204|
;;;78             u8Divider = 0;
;;;79         else if (u8Divider == 4)
000076  2c04              CMP      r4,#4
000078  d02a              BEQ      |L1.208|
;;;80             u8Divider = 1;
;;;81         else if (u8Divider == 8)
00007a  2c08              CMP      r4,#8
00007c  d02a              BEQ      |L1.212|
;;;82             u8Divider = 2;     
;;;83         else // 16
;;;84             u8Divider = 3;        
00007e  2003              MOVS     r0,#3
                  |L1.128|
;;;85         
;;;86         // every two channels share a prescaler
;;;87         PWM->PPR = (PWM->PPR & ~(PWM_PPR_CP01_Msk << ((u32ChannelNum >> 1) * 8))) | (u8Prescale << ((u32ChannelNum >> 1) * 8));
000080  4ca0              LDR      r4,|L1.772|
000082  6823              LDR      r3,[r4,#0]
000084  0871              LSRS     r1,r6,#1
000086  00c9              LSLS     r1,r1,#3
000088  27ff              MOVS     r7,#0xff
00008a  408f              LSLS     r7,r7,r1
00008c  43bb              BICS     r3,r3,r7
00008e  408a              LSLS     r2,r2,r1
000090  4313              ORRS     r3,r3,r2
000092  6023              STR      r3,[r4,#0]
;;;88         PWM->CSR = (PWM->CSR & ~(PWM_CSR_CSR0_Msk << (4 * u32ChannelNum))) | (u8Divider << (4 * u32ChannelNum));
000094  6861              LDR      r1,[r4,#4]
000096  00b6              LSLS     r6,r6,#2
000098  2207              MOVS     r2,#7
00009a  40b2              LSLS     r2,r2,r6
00009c  4391              BICS     r1,r1,r2
00009e  40b0              LSLS     r0,r0,r6
0000a0  4301              ORRS     r1,r1,r0
0000a2  6061              STR      r1,[r4,#4]
;;;89         PWM->PCR |= PWM_PCR_CH0MOD_Msk << (4 * u32ChannelNum);
0000a4  68a0              LDR      r0,[r4,#8]
0000a6  2108              MOVS     r1,#8
0000a8  40b1              LSLS     r1,r1,r6
0000aa  4308              ORRS     r0,r0,r1
0000ac  60a0              STR      r0,[r4,#8]
;;;90         PWM->CMR[u32ChannelNum] = u32DutyCycle * (u16CNR + 1) / 100 - 1;
0000ae  9806              LDR      r0,[sp,#0x18]
0000b0  1c69              ADDS     r1,r5,#1
0000b2  4348              MULS     r0,r1,r0
0000b4  2164              MOVS     r1,#0x64
0000b6  f7fffffe          BL       __aeabi_uidivmod
0000ba  1931              ADDS     r1,r6,r4
0000bc  1e40              SUBS     r0,r0,#1
0000be  6248              STR      r0,[r1,#0x24]
;;;91         PWM->CNR[u32ChannelNum] = u16CNR;
0000c0  60cd              STR      r5,[r1,#0xc]
;;;92         
;;;93         return(i);
0000c2  9800              LDR      r0,[sp,#0]
;;;94     }
0000c4  b007              ADD      sp,sp,#0x1c
0000c6  bdf0              POP      {r4-r7,pc}
                  |L1.200|
0000c8  2004              MOVS     r0,#4                 ;76
0000ca  e7d9              B        |L1.128|
                  |L1.204|
0000cc  2000              MOVS     r0,#0                 ;78
0000ce  e7d7              B        |L1.128|
                  |L1.208|
0000d0  2001              MOVS     r0,#1                 ;80
0000d2  e7d5              B        |L1.128|
                  |L1.212|
0000d4  2002              MOVS     r0,#2                 ;82
0000d6  e7d3              B        |L1.128|
;;;95                                       
                          ENDP

                  PWM_Start PROC
;;;103     */ 
;;;104    void PWM_Start (PWM_T *pwm, uint32_t u32ChannelMask)
0000d8  b530              PUSH     {r4,r5,lr}
;;;105    {
;;;106        uint32_t u32Mask = 0, i;
0000da  2200              MOVS     r2,#0
;;;107        for(i = 0; i < PWM_CHANNEL_NUM; i ++) {
0000dc  4610              MOV      r0,r2
;;;108            if(u32ChannelMask & (1 << i)) {
0000de  2401              MOVS     r4,#1
                  |L1.224|
0000e0  4623              MOV      r3,r4
0000e2  4083              LSLS     r3,r3,r0
0000e4  420b              TST      r3,r1
0000e6  d003              BEQ      |L1.240|
;;;109                u32Mask |= (PWM_PCR_CH0EN_Msk << (i * 4));
0000e8  0085              LSLS     r5,r0,#2
0000ea  4623              MOV      r3,r4
0000ec  40ab              LSLS     r3,r3,r5
0000ee  431a              ORRS     r2,r2,r3
                  |L1.240|
0000f0  1c40              ADDS     r0,r0,#1
0000f2  2806              CMP      r0,#6                 ;107
0000f4  d3f4              BCC      |L1.224|
;;;110            }
;;;111        }
;;;112        
;;;113        PWM->PCR |= u32Mask;
0000f6  4983              LDR      r1,|L1.772|
0000f8  6888              LDR      r0,[r1,#8]
0000fa  4310              ORRS     r0,r0,r2
0000fc  6088              STR      r0,[r1,#8]
;;;114    }
0000fe  bd30              POP      {r4,r5,pc}
;;;115    
                          ENDP

                  PWM_Stop PROC
;;;122     */
;;;123    void PWM_Stop (PWM_T *pwm, uint32_t u32ChannelMask)
000100  b530              PUSH     {r4,r5,lr}
;;;124    {
;;;125        uint32_t i;
;;;126        for(i = 0; i < PWM_CHANNEL_NUM; i ++) {
000102  2000              MOVS     r0,#0
;;;127            if(u32ChannelMask & (1 << i)) {
;;;128                PWM->CNR[i] = 0;
000104  4c7f              LDR      r4,|L1.772|
000106  2501              MOVS     r5,#1                 ;127
000108  4603              MOV      r3,r0                 ;127
                  |L1.266|
00010a  462a              MOV      r2,r5                 ;127
00010c  4082              LSLS     r2,r2,r0              ;127
00010e  420a              TST      r2,r1                 ;127
000110  d002              BEQ      |L1.280|
000112  0082              LSLS     r2,r0,#2
000114  1912              ADDS     r2,r2,r4
000116  60d3              STR      r3,[r2,#0xc]
                  |L1.280|
000118  1c40              ADDS     r0,r0,#1
00011a  2806              CMP      r0,#6                 ;126
00011c  d3f5              BCC      |L1.266|
;;;129            }
;;;130        }
;;;131    
;;;132    }
00011e  bd30              POP      {r4,r5,pc}
;;;133    
                          ENDP

                  PWM_ForceStop PROC
;;;140     */
;;;141    void PWM_ForceStop (PWM_T *pwm, uint32_t u32ChannelMask)
000120  b530              PUSH     {r4,r5,lr}
;;;142    {
;;;143        uint32_t u32Mask = 0, i;
000122  2200              MOVS     r2,#0
;;;144        for(i = 0; i < PWM_CHANNEL_NUM; i ++) {
000124  4610              MOV      r0,r2
;;;145            if(u32ChannelMask & (1 << i)) {
000126  2401              MOVS     r4,#1
                  |L1.296|
000128  4623              MOV      r3,r4
00012a  4083              LSLS     r3,r3,r0
00012c  420b              TST      r3,r1
00012e  d003              BEQ      |L1.312|
;;;146                u32Mask |= (PWM_PCR_CH0EN_Msk << (i * 4));
000130  0085              LSLS     r5,r0,#2
000132  4623              MOV      r3,r4
000134  40ab              LSLS     r3,r3,r5
000136  431a              ORRS     r2,r2,r3
                  |L1.312|
000138  1c40              ADDS     r0,r0,#1
00013a  2806              CMP      r0,#6                 ;144
00013c  d3f4              BCC      |L1.296|
;;;147            }
;;;148        }
;;;149        
;;;150        PWM->PCR &= ~u32Mask;
00013e  4971              LDR      r1,|L1.772|
000140  6888              LDR      r0,[r1,#8]
000142  4390              BICS     r0,r0,r2
000144  6088              STR      r0,[r1,#8]
;;;151    }
000146  bd30              POP      {r4,r5,pc}
;;;152    
                          ENDP

                  PWM_EnableADCTrigger PROC
;;;163     */
;;;164    void PWM_EnableADCTrigger (PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition)
000148  b510              PUSH     {r4,lr}
;;;165    {
;;;166        if(u32ChannelNum < 4) {
;;;167            PWM->TRGCON0 = (PWM->TRGCON0 & ~((PWM_TRIGGER_ADC_CNTR_IS_0 |
00014a  4c6e              LDR      r4,|L1.772|
00014c  230f              MOVS     r3,#0xf
00014e  3440              ADDS     r4,r4,#0x40
000150  00c8              LSLS     r0,r1,#3
000152  2904              CMP      r1,#4                 ;166
000154  d206              BCS      |L1.356|
000156  6aa1              LDR      r1,[r4,#0x28]
000158  4083              LSLS     r3,r3,r0
00015a  4399              BICS     r1,r1,r3
00015c  4082              LSLS     r2,r2,r0
00015e  4311              ORRS     r1,r1,r2
000160  62a1              STR      r1,[r4,#0x28]
;;;168                                              PWM_TRIGGER_ADC_CNTR_IS_CMR_D |
;;;169                                              PWM_TRIGGER_ADC_CNTR_IS_CNR |
;;;170                                              PWM_TRIGGER_ADC_CNTR_IS_CMR_U ) << (8 * u32ChannelNum))) | (u32Condition << (8 * u32ChannelNum));
;;;171        } else {
;;;172            PWM->TRGCON1 = (PWM->TRGCON1 & ~((PWM_TRIGGER_ADC_CNTR_IS_0 |
;;;173                                              PWM_TRIGGER_ADC_CNTR_IS_CMR_D |
;;;174                                              PWM_TRIGGER_ADC_CNTR_IS_CNR |
;;;175                                              PWM_TRIGGER_ADC_CNTR_IS_CMR_U ) << (8 * (u32ChannelNum - 4)))) | (u32Condition << (8 * (u32ChannelNum - 4)));
;;;176    
;;;177        }
;;;178    }
000162  bd10              POP      {r4,pc}
                  |L1.356|
000164  3820              SUBS     r0,r0,#0x20
000166  6ae1              LDR      r1,[r4,#0x2c]         ;172
000168  4083              LSLS     r3,r3,r0              ;172
00016a  4399              BICS     r1,r1,r3              ;172
00016c  4082              LSLS     r2,r2,r0              ;172
00016e  4311              ORRS     r1,r1,r2              ;172
000170  62e1              STR      r1,[r4,#0x2c]         ;172
000172  bd10              POP      {r4,pc}
;;;179    
                          ENDP

                  PWM_DisableADCTrigger PROC
;;;185     */
;;;186    void PWM_DisableADCTrigger (PWM_T *pwm, uint32_t u32ChannelNum)
000174  4a63              LDR      r2,|L1.772|
;;;187    {
;;;188        if(u32ChannelNum < 4) {
;;;189                PWM->TRGCON0 = (PWM->TRGCON0 & ~((PWM_TRIGGER_ADC_CNTR_IS_0 |
000176  00c8              LSLS     r0,r1,#3
000178  3240              ADDS     r2,r2,#0x40
00017a  230f              MOVS     r3,#0xf
00017c  2904              CMP      r1,#4                 ;188
00017e  d204              BCS      |L1.394|
000180  6a91              LDR      r1,[r2,#0x28]
000182  4083              LSLS     r3,r3,r0
000184  4399              BICS     r1,r1,r3
000186  6291              STR      r1,[r2,#0x28]
;;;190                                              PWM_TRIGGER_ADC_CNTR_IS_CMR_D |
;;;191                                              PWM_TRIGGER_ADC_CNTR_IS_CNR |
;;;192                                              PWM_TRIGGER_ADC_CNTR_IS_CMR_U ) << (8 * u32ChannelNum)));
;;;193        } else {
;;;194                PWM->TRGCON1 = (PWM->TRGCON1 & ~((PWM_TRIGGER_ADC_CNTR_IS_0 |
;;;195                                              PWM_TRIGGER_ADC_CNTR_IS_CMR_D |
;;;196                                              PWM_TRIGGER_ADC_CNTR_IS_CNR |
;;;197                                              PWM_TRIGGER_ADC_CNTR_IS_CMR_U ) << (8 * (u32ChannelNum - 4))));
;;;198        }
;;;199    }
000188  4770              BX       lr
                  |L1.394|
00018a  3820              SUBS     r0,r0,#0x20
00018c  4083              LSLS     r3,r3,r0              ;194
00018e  6ad0              LDR      r0,[r2,#0x2c]         ;194
000190  4398              BICS     r0,r0,r3              ;194
000192  62d0              STR      r0,[r2,#0x2c]         ;194
000194  4770              BX       lr
;;;200    
                          ENDP

                  PWM_ClearADCTriggerFlag PROC
;;;211     */
;;;212    void PWM_ClearADCTriggerFlag (PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition)
000196  4b5b              LDR      r3,|L1.772|
;;;213    {
;;;214        if(u32ChannelNum < 4) {
;;;215                PWM->TRGSTS0 |= (u32Condition << (8 * u32ChannelNum));
000198  00c8              LSLS     r0,r1,#3
00019a  3340              ADDS     r3,r3,#0x40
00019c  2904              CMP      r1,#4                 ;214
00019e  d204              BCS      |L1.426|
0001a0  6b19              LDR      r1,[r3,#0x30]
0001a2  4082              LSLS     r2,r2,r0
0001a4  4311              ORRS     r1,r1,r2
0001a6  6319              STR      r1,[r3,#0x30]
;;;216        } else {
;;;217                PWM->TRGSTS1 |= (u32Condition << (8 * (u32ChannelNum - 4)));
;;;218        }
;;;219    }
0001a8  4770              BX       lr
                  |L1.426|
0001aa  3820              SUBS     r0,r0,#0x20
0001ac  4082              LSLS     r2,r2,r0              ;217
0001ae  6b58              LDR      r0,[r3,#0x34]         ;217
0001b0  4302              ORRS     r2,r2,r0              ;217
0001b2  635a              STR      r2,[r3,#0x34]         ;217
0001b4  4770              BX       lr
;;;220    
                          ENDP

                  PWM_GetADCTriggerFlag PROC
;;;230     */
;;;231    uint32_t PWM_GetADCTriggerFlag (PWM_T *pwm, uint32_t u32ChannelNum)
0001b6  4853              LDR      r0,|L1.772|
;;;232    {
;;;233        uint32_t u32Ret;
;;;234    
;;;235        if(u32ChannelNum < 4) {
;;;236                u32Ret = PWM->TRGSTS0 >> (8 * u32ChannelNum);
0001b8  00ca              LSLS     r2,r1,#3
0001ba  3040              ADDS     r0,r0,#0x40
0001bc  2904              CMP      r1,#4                 ;235
0001be  d201              BCS      |L1.452|
0001c0  6b00              LDR      r0,[r0,#0x30]
0001c2  e001              B        |L1.456|
                  |L1.452|
;;;237        } else {
;;;238                u32Ret = PWM->TRGSTS1 >> (8 * (u32ChannelNum - 4 ));
0001c4  6b40              LDR      r0,[r0,#0x34]
0001c6  3a20              SUBS     r2,r2,#0x20
                  |L1.456|
0001c8  40d0              LSRS     r0,r0,r2
;;;239        }
;;;240        
;;;241        return (u32Ret & (PWM_TRIGGER_ADC_CNTR_IS_0 |
0001ca  0700              LSLS     r0,r0,#28
0001cc  0f00              LSRS     r0,r0,#28
;;;242                          PWM_TRIGGER_ADC_CNTR_IS_CMR_D |
;;;243                          PWM_TRIGGER_ADC_CNTR_IS_CNR |
;;;244                          PWM_TRIGGER_ADC_CNTR_IS_CMR_U));
;;;245    }
0001ce  4770              BX       lr
;;;246    
                          ENDP

                  PWM_EnableFaultBreak PROC
;;;260     */
;;;261    void PWM_EnableFaultBreak (PWM_T *pwm, 
0001d0  0610              LSLS     r0,r2,#24
;;;262                               uint32_t u32ChannelMask, 
;;;263                               uint32_t u32LevelMask, 
;;;264                               uint32_t u32BreakSource)
;;;265    {
;;;266        PWM->PFBCON = (u32LevelMask << PWM_PFBCON_PWMBKO0_Pos) | u32BreakSource;
0001d2  494c              LDR      r1,|L1.772|
0001d4  4318              ORRS     r0,r0,r3
0001d6  3140              ADDS     r1,r1,#0x40
0001d8  6208              STR      r0,[r1,#0x20]
;;;267    }
0001da  4770              BX       lr
;;;268    
                          ENDP

                  PWM_ClearFaultBreakFlag PROC
;;;275     */
;;;276    void PWM_ClearFaultBreakFlag (PWM_T *pwm, uint32_t u32BreakSource)
0001dc  4949              LDR      r1,|L1.772|
;;;277    {
;;;278        PWM->PFBCON = PWM_PFBCON_BKF_Msk;
0001de  2080              MOVS     r0,#0x80
0001e0  3140              ADDS     r1,r1,#0x40
0001e2  6208              STR      r0,[r1,#0x20]
;;;279    }
0001e4  4770              BX       lr
;;;280    
                          ENDP

                  PWM_EnableOutput PROC
;;;287     */
;;;288    void PWM_EnableOutput (PWM_T *pwm, uint32_t u32ChannelMask)
0001e6  4847              LDR      r0,|L1.772|
;;;289    {
;;;290        PWM->POE |= u32ChannelMask;
0001e8  3040              ADDS     r0,r0,#0x40
0001ea  69c2              LDR      r2,[r0,#0x1c]
0001ec  430a              ORRS     r2,r2,r1
0001ee  61c2              STR      r2,[r0,#0x1c]
;;;291    }
0001f0  4770              BX       lr
;;;292    
                          ENDP

                  PWM_DisableOutput PROC
;;;299     */
;;;300    void PWM_DisableOutput (PWM_T *pwm, uint32_t u32ChannelMask)
0001f2  4844              LDR      r0,|L1.772|
;;;301    {
;;;302        PWM->POE &= ~u32ChannelMask;
0001f4  3040              ADDS     r0,r0,#0x40
0001f6  69c2              LDR      r2,[r0,#0x1c]
0001f8  438a              BICS     r2,r2,r1
0001fa  61c2              STR      r2,[r0,#0x1c]
;;;303    }
0001fc  4770              BX       lr
;;;304    
                          ENDP

                  PWM_EnableDeadZone PROC
;;;312     */
;;;313    void PWM_EnableDeadZone (PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Duration)
0001fe  b530              PUSH     {r4,r5,lr}
;;;314    {
;;;315        // every two channels shares the same setting
;;;316        u32ChannelNum >>= 1;    
;;;317        // set duration
;;;318        PWM->PDZIR = (PWM->PDZIR & ~(PWM_DZIR_DZI01_Msk << (8 * u32ChannelNum))) | (u32Duration << (8 * u32ChannelNum));
000200  4c40              LDR      r4,|L1.772|
000202  0848              LSRS     r0,r1,#1              ;316
000204  3440              ADDS     r4,r4,#0x40
000206  6a63              LDR      r3,[r4,#0x24]
000208  00c1              LSLS     r1,r0,#3
00020a  25ff              MOVS     r5,#0xff
00020c  408d              LSLS     r5,r5,r1
00020e  43ab              BICS     r3,r3,r5
000210  408a              LSLS     r2,r2,r1
000212  4313              ORRS     r3,r3,r2
000214  6263              STR      r3,[r4,#0x24]
;;;319        // enable dead zone
;;;320        PWM->PCR |= (PWM_PCR_DZEN01_Msk << u32ChannelNum);
000216  0323              LSLS     r3,r4,#12
000218  689a              LDR      r2,[r3,#8]
00021a  0199              LSLS     r1,r3,#6
00021c  4081              LSLS     r1,r1,r0
00021e  430a              ORRS     r2,r2,r1
000220  609a              STR      r2,[r3,#8]
;;;321    }
000222  bd30              POP      {r4,r5,pc}
;;;322    
                          ENDP

                  PWM_DisableDeadZone PROC
;;;328     */
;;;329    void PWM_DisableDeadZone (PWM_T *pwm, uint32_t u32ChannelNum)
000224  0848              LSRS     r0,r1,#1
;;;330    {
;;;331        // every two channels shares the same setting
;;;332        u32ChannelNum >>= 1;  
;;;333        // enable dead zone
;;;334        PWM->PCR &= ~(PWM_PCR_DZEN01_Msk << u32ChannelNum);    
000226  4937              LDR      r1,|L1.772|
000228  688a              LDR      r2,[r1,#8]
00022a  018b              LSLS     r3,r1,#6
00022c  4083              LSLS     r3,r3,r0
00022e  439a              BICS     r2,r2,r3
000230  608a              STR      r2,[r1,#8]
;;;335    }
000232  4770              BX       lr
;;;336    
                          ENDP

                  PWM_EnableDutyInt PROC
;;;343     */
;;;344    void PWM_EnableDutyInt (PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32IntDutyType)
000234  4833              LDR      r0,|L1.772|
;;;345    {
;;;346        PWM->PIER |= (PWM_PIER_PWMDIE0_Msk << u32ChannelNum);
000236  3040              ADDS     r0,r0,#0x40
000238  6942              LDR      r2,[r0,#0x14]
00023a  1583              ASRS     r3,r0,#22
00023c  408b              LSLS     r3,r3,r1
00023e  431a              ORRS     r2,r2,r3
000240  6142              STR      r2,[r0,#0x14]
;;;347    }
000242  4770              BX       lr
;;;348    
                          ENDP

                  PWM_DisableDutyInt PROC
;;;354     */
;;;355    void PWM_DisableDutyInt (PWM_T *pwm, uint32_t u32ChannelNum)
000244  482f              LDR      r0,|L1.772|
;;;356    {
;;;357        PWM->PIER &= ~(PWM_PIER_PWMDIE0_Msk << u32ChannelNum);
000246  3040              ADDS     r0,r0,#0x40
000248  6942              LDR      r2,[r0,#0x14]
00024a  1583              ASRS     r3,r0,#22
00024c  408b              LSLS     r3,r3,r1
00024e  439a              BICS     r2,r2,r3
000250  6142              STR      r2,[r0,#0x14]
;;;358    }
000252  4770              BX       lr
;;;359    
                          ENDP

                  PWM_ClearDutyIntFlag PROC
;;;365     */
;;;366    void PWM_ClearDutyIntFlag (PWM_T *pwm, uint32_t u32ChannelNum)
000254  482b              LDR      r0,|L1.772|
;;;367    {
;;;368         PWM->PIIR &= ~(PWM_PIIR_PWMDIF0_Msk << u32ChannelNum);   
000256  3040              ADDS     r0,r0,#0x40
000258  6982              LDR      r2,[r0,#0x18]
00025a  1583              ASRS     r3,r0,#22
00025c  408b              LSLS     r3,r3,r1
00025e  439a              BICS     r2,r2,r3
000260  6182              STR      r2,[r0,#0x18]
;;;369    }
000262  4770              BX       lr
;;;370    
                          ENDP

                  PWM_GetDutyIntFlag PROC
;;;378     */
;;;379    uint32_t PWM_GetDutyIntFlag (PWM_T *pwm, uint32_t u32ChannelNum)
000264  4827              LDR      r0,|L1.772|
;;;380    {
;;;381         return(PWM->PIIR & (PWM_PIIR_PWMDIF0_Msk << u32ChannelNum) ? 1 : 0);  
000266  3040              ADDS     r0,r0,#0x40
000268  6980              LDR      r0,[r0,#0x18]
00026a  22ff              MOVS     r2,#0xff
00026c  3201              ADDS     r2,#1
00026e  408a              LSLS     r2,r2,r1
000270  4010              ANDS     r0,r0,r2
000272  d000              BEQ      |L1.630|
000274  2001              MOVS     r0,#1
                  |L1.630|
;;;382    }
000276  4770              BX       lr
;;;383    
                          ENDP

                  PWM_EnableFaultBreakInt PROC
;;;389     */
;;;390    void PWM_EnableFaultBreakInt (PWM_T *pwm, uint32_t u32BreakSource)
000278  4822              LDR      r0,|L1.772|
;;;391    {
;;;392        PWM->PIER |= PWM_PIER_BRKIE_Msk;
00027a  3040              ADDS     r0,r0,#0x40
00027c  6941              LDR      r1,[r0,#0x14]
00027e  2201              MOVS     r2,#1
000280  0412              LSLS     r2,r2,#16
000282  4311              ORRS     r1,r1,r2
000284  6141              STR      r1,[r0,#0x14]
;;;393    }
000286  4770              BX       lr
;;;394    
                          ENDP

                  PWM_DisableFaultBreakInt PROC
;;;400     */
;;;401    void PWM_DisableFaultBreakInt (PWM_T *pwm, uint32_t u32BreakSource)
000288  481e              LDR      r0,|L1.772|
;;;402    {
;;;403        PWM->PIER &= ~PWM_PIER_BRKIE_Msk;
00028a  3040              ADDS     r0,r0,#0x40
00028c  6941              LDR      r1,[r0,#0x14]
00028e  2201              MOVS     r2,#1
000290  0412              LSLS     r2,r2,#16
000292  4391              BICS     r1,r1,r2
000294  6141              STR      r1,[r0,#0x14]
;;;404    }
000296  4770              BX       lr
;;;405    
                          ENDP

                  PWM_ClearFaultBreakIntFlag PROC
;;;413     */
;;;414    void PWM_ClearFaultBreakIntFlag (PWM_T *pwm, uint32_t u32BreakSource)
000298  481a              LDR      r0,|L1.772|
;;;415    {
;;;416        PWM->PIIR = u32BreakSource;
00029a  3040              ADDS     r0,r0,#0x40
00029c  6181              STR      r1,[r0,#0x18]
;;;417    }
00029e  4770              BX       lr
;;;418    
                          ENDP

                  PWM_GetFaultBreakIntFlag PROC
;;;428     */
;;;429    uint32_t PWM_GetFaultBreakIntFlag (PWM_T *pwm, uint32_t u32BreakSource)
0002a0  4818              LDR      r0,|L1.772|
;;;430    {
;;;431        return (PWM->PIIR & u32BreakSource ? 1 : 0);
0002a2  3040              ADDS     r0,r0,#0x40
0002a4  6980              LDR      r0,[r0,#0x18]
0002a6  4008              ANDS     r0,r0,r1
0002a8  d000              BEQ      |L1.684|
0002aa  2001              MOVS     r0,#1
                  |L1.684|
;;;432    }
0002ac  4770              BX       lr
;;;433    
                          ENDP

                  PWM_EnablePeriodInt PROC
;;;443     */
;;;444    void PWM_EnablePeriodInt (PWM_T *pwm, uint32_t u32ChannelNum,  uint32_t u32IntPeriodType)
0002ae  b510              PUSH     {r4,lr}
;;;445    {
;;;446        PWM->PIER = (PWM->PIER & ~PWM_PIER_INT_TYPE_Msk) | (PWM_PIER_PWMPIE0_Msk << u32ChannelNum) | u32IntPeriodType;
0002b0  4c14              LDR      r4,|L1.772|
0002b2  3440              ADDS     r4,r4,#0x40
0002b4  6960              LDR      r0,[r4,#0x14]
0002b6  2301              MOVS     r3,#1
0002b8  045b              LSLS     r3,r3,#17
0002ba  4398              BICS     r0,r0,r3
0002bc  2301              MOVS     r3,#1
0002be  408b              LSLS     r3,r3,r1
0002c0  4318              ORRS     r0,r0,r3
0002c2  4310              ORRS     r0,r0,r2
0002c4  6160              STR      r0,[r4,#0x14]
;;;447    }
0002c6  bd10              POP      {r4,pc}
;;;448    
                          ENDP

                  PWM_DisablePeriodInt PROC
;;;454     */
;;;455    void PWM_DisablePeriodInt (PWM_T *pwm, uint32_t u32ChannelNum)
0002c8  480e              LDR      r0,|L1.772|
;;;456    {
;;;457        PWM->PIER &= ~(PWM_PIER_PWMPIE0_Msk << u32ChannelNum);
0002ca  3040              ADDS     r0,r0,#0x40
0002cc  6942              LDR      r2,[r0,#0x14]
0002ce  2301              MOVS     r3,#1
0002d0  408b              LSLS     r3,r3,r1
0002d2  439a              BICS     r2,r2,r3
0002d4  6142              STR      r2,[r0,#0x14]
;;;458    }
0002d6  4770              BX       lr
;;;459    
                          ENDP

                  PWM_ClearPeriodIntFlag PROC
;;;465     */
;;;466    void PWM_ClearPeriodIntFlag (PWM_T *pwm, uint32_t u32ChannelNum)
0002d8  480a              LDR      r0,|L1.772|
;;;467    {
;;;468        PWM->PIIR |= (PWM_PIIR_PWMPIF0_Msk << u32ChannelNum);
0002da  3040              ADDS     r0,r0,#0x40
0002dc  6982              LDR      r2,[r0,#0x18]
0002de  2301              MOVS     r3,#1
0002e0  408b              LSLS     r3,r3,r1
0002e2  431a              ORRS     r2,r2,r3
0002e4  6182              STR      r2,[r0,#0x18]
;;;469    }
0002e6  4770              BX       lr
;;;470    
                          ENDP

                  PWM_GetPeriodIntFlag PROC
;;;478     */
;;;479    uint32_t PWM_GetPeriodIntFlag (PWM_T *pwm, uint32_t u32ChannelNum)
0002e8  4806              LDR      r0,|L1.772|
;;;480    {
;;;481        return(PWM->PIIR & (PWM_PIIR_PWMPIF0_Msk << u32ChannelNum) ? 1 : 0);
0002ea  3040              ADDS     r0,r0,#0x40
0002ec  6980              LDR      r0,[r0,#0x18]
0002ee  2201              MOVS     r2,#1
0002f0  408a              LSLS     r2,r2,r1
0002f2  4010              ANDS     r0,r0,r2
0002f4  d000              BEQ      |L1.760|
0002f6  2001              MOVS     r0,#1
                  |L1.760|
;;;482    }
0002f8  4770              BX       lr
;;;483    
                          ENDP

0002fa  0000              DCW      0x0000
                  |L1.764|
                          DCD      SystemCoreClock
                  |L1.768|
                          DCD      0x0000ffff
                  |L1.772|
                          DCD      0x40040000

;*** Start embedded assembler ***

#line 1 "StdDriver\\src\\pwm.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_pwm_c_03ee09af____REV16|
#line 118 ".\\CMSIS\\core_cmInstr.h"
|__asm___5_pwm_c_03ee09af____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_pwm_c_03ee09af____REVSH|
#line 132
|__asm___5_pwm_c_03ee09af____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
