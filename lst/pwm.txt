; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\pwm.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\pwm.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\Mini51Series\Include -I..\..\..\Library\StdDriver\inc -I.\StdDriver\inc -I.\CMSIS -I.\RTE\Device\Mini54ZDE -I.\RTE\_BLDC_driver -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.1.0\Device\Mini51\Driver -IC:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.1.0\Device\Mini51\Include -D__MICROLIB -D__UVISION_VERSION=524 -D_RTE_ -DCLK_APBCLK_ACMP_EN_Pos=CLK_APBCLK_CMP_EN_Pos -DFOR_CAR --omf_browse=.\obj\pwm.crf C:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.1.0\Device\Mini51\Driver\pwm.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  PWM_ConfigOutputChannel PROC
;;;35      */
;;;36     uint32_t PWM_ConfigOutputChannel (PWM_T *pwm,
000000  b5ff              PUSH     {r0-r7,lr}
;;;37                                       uint32_t u32ChannelNum,
;;;38                                       uint32_t u32Frequency,
;;;39                                       uint32_t u32DutyCycle)
;;;40     {
;;;41         uint32_t i = SystemCoreClock / u32Frequency;
000002  48c0              LDR      r0,|L1.772|
000004  b083              SUB      sp,sp,#0xc            ;40
000006  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000008  461d              MOV      r5,r3                 ;40
00000a  4611              MOV      r1,r2
00000c  9001              STR      r0,[sp,#4]
00000e  f7fffffe          BL       __aeabi_uidivmod
;;;42         uint8_t  u8Divider = 1, u8Prescale = 0xFF;
000012  2601              MOVS     r6,#1
;;;43         uint16_t u16CNR = 0xFFFF;
000014  4cbc              LDR      r4,|L1.776|
000016  27ff              MOVS     r7,#0xff              ;42
000018  9000              STR      r0,[sp,#0]
                  |L1.26|
;;;44     
;;;45         for(; u8Divider < 17; u8Divider <<= 1) {  // clk divider could only be 1, 2, 4, 8, 16
;;;46             i = (SystemCoreClock / u32Frequency) / u8Divider;
00001a  4631              MOV      r1,r6
00001c  9800              LDR      r0,[sp,#0]
00001e  f7fffffe          BL       __aeabi_uidivmod
;;;47             // If target value is larger than CNR * prescale, need to use a larger divider
;;;48             if(i > (0x10000 * 0x100))
000022  2101              MOVS     r1,#1
000024  0609              LSLS     r1,r1,#24
000026  4288              CMP      r0,r1
000028  d812              BHI      |L1.80|
;;;49                 continue;
;;;50     
;;;51             // CNR = 0xFFFF + 1, get a prescaler that CNR value is below 0xFFFF
;;;52             u8Prescale = (i + 0xFFFF)/ 0x10000;
00002a  1901              ADDS     r1,r0,r4
00002c  0209              LSLS     r1,r1,#8
00002e  0e0f              LSRS     r7,r1,#24
;;;53     
;;;54             // u8Prescale must at least be 2, otherwise the output stop
;;;55             if(u8Prescale < 3)
000030  2f03              CMP      r7,#3
000032  d200              BCS      |L1.54|
;;;56                 u8Prescale = 2;
000034  2702              MOVS     r7,#2
                  |L1.54|
;;;57     
;;;58             i /= u8Prescale;
000036  4639              MOV      r1,r7
000038  f7fffffe          BL       __aeabi_uidivmod
;;;59     
;;;60             if(i <= 0x10000) {
00003c  2101              MOVS     r1,#1
00003e  0409              LSLS     r1,r1,#16
000040  4288              CMP      r0,r1
000042  d805              BHI      |L1.80|
;;;61                 if(i == 1)
000044  2801              CMP      r0,#1
000046  d001              BEQ      |L1.76|
;;;62                     u16CNR = 1;     // Too fast, and PWM cannot generate expected frequency...
;;;63                 else
;;;64                     u16CNR = i;
000048  b284              UXTH     r4,r0
00004a  e005              B        |L1.88|
                  |L1.76|
00004c  2401              MOVS     r4,#1                 ;62
00004e  e003              B        |L1.88|
                  |L1.80|
000050  0670              LSLS     r0,r6,#25             ;45
000052  0e06              LSRS     r6,r0,#24             ;45
000054  2e11              CMP      r6,#0x11              ;45
000056  d3e0              BCC      |L1.26|
                  |L1.88|
;;;65                 break;
;;;66             }
;;;67     
;;;68         }
;;;69         // Store return value here 'cos we're gonna change u8Divider & u8Prescale & u16CNR to the real value to fill into register
;;;70         i = SystemCoreClock / (u8Prescale * u8Divider * u16CNR);
000058  4639              MOV      r1,r7
00005a  4371              MULS     r1,r6,r1
00005c  4361              MULS     r1,r4,r1
00005e  9801              LDR      r0,[sp,#4]
000060  f7fffffe          BL       __aeabi_uidivmod
000064  1e7f              SUBS     r7,r7,#1
;;;71     
;;;72         u8Prescale -= 1;
000066  1e64              SUBS     r4,r4,#1
000068  b2fb              UXTB     r3,r7
;;;73         u16CNR -= 1;
00006a  b2a4              UXTH     r4,r4
;;;74         // convert to real register value
;;;75         if(u8Divider == 1)
00006c  9000              STR      r0,[sp,#0]
00006e  2e01              CMP      r6,#1
000070  d030              BEQ      |L1.212|
;;;76             u8Divider = 4;
;;;77         else if (u8Divider == 2)
000072  2e02              CMP      r6,#2
000074  d030              BEQ      |L1.216|
;;;78             u8Divider = 0;
;;;79         else if (u8Divider == 4)
000076  2e04              CMP      r6,#4
000078  d030              BEQ      |L1.220|
;;;80             u8Divider = 1;
;;;81         else if (u8Divider == 8)
00007a  2e08              CMP      r6,#8
00007c  d030              BEQ      |L1.224|
;;;82             u8Divider = 2;
;;;83         else // 16
;;;84             u8Divider = 3;
00007e  2103              MOVS     r1,#3
                  |L1.128|
;;;85     
;;;86         // every two channels share a prescaler
;;;87         PWM->PPR = (PWM->PPR & ~(PWM_PPR_CP01_Msk << ((u32ChannelNum >> 1) * 8))) | (u8Prescale << ((u32ChannelNum >> 1) * 8));
000080  4aa2              LDR      r2,|L1.780|
000082  6816              LDR      r6,[r2,#0]
000084  9804              LDR      r0,[sp,#0x10]
000086  27ff              MOVS     r7,#0xff
000088  0840              LSRS     r0,r0,#1
00008a  00c0              LSLS     r0,r0,#3
00008c  4087              LSLS     r7,r7,r0
00008e  43be              BICS     r6,r6,r7
000090  4083              LSLS     r3,r3,r0
000092  431e              ORRS     r6,r6,r3
000094  6016              STR      r6,[r2,#0]
;;;88         PWM->CSR = (PWM->CSR & ~(PWM_CSR_CSR0_Msk << (4 * u32ChannelNum))) | (u8Divider << (4 * u32ChannelNum));
000096  6853              LDR      r3,[r2,#4]
000098  9804              LDR      r0,[sp,#0x10]
00009a  2607              MOVS     r6,#7
00009c  0080              LSLS     r0,r0,#2
00009e  4086              LSLS     r6,r6,r0
0000a0  43b3              BICS     r3,r3,r6
0000a2  4081              LSLS     r1,r1,r0
0000a4  430b              ORRS     r3,r3,r1
0000a6  6053              STR      r3,[r2,#4]
;;;89         PWM->PCR = (PWM->PCR & ~PWM_PCR_PWMTYPE_Msk) | (PWM_PCR_CH0MOD_Msk << (4 * u32ChannelNum));
0000a8  6891              LDR      r1,[r2,#8]
0000aa  2308              MOVS     r3,#8
0000ac  0049              LSLS     r1,r1,#1
0000ae  0849              LSRS     r1,r1,#1
0000b0  4083              LSLS     r3,r3,r0
0000b2  4319              ORRS     r1,r1,r3
0000b4  6091              STR      r1,[r2,#8]
0000b6  4611              MOV      r1,r2                 ;87
;;;90         if(u32DutyCycle == 0)
;;;91             PWM->CMR[u32ChannelNum] = 0;
0000b8  1846              ADDS     r6,r0,r1
0000ba  2d00              CMP      r5,#0                 ;90
0000bc  d012              BEQ      |L1.228|
;;;92         else
;;;93             PWM->CMR[u32ChannelNum] = u32DutyCycle * (u16CNR + 1) / 100 - 1;
0000be  1c60              ADDS     r0,r4,#1
0000c0  4368              MULS     r0,r5,r0
0000c2  2164              MOVS     r1,#0x64
0000c4  f7fffffe          BL       __aeabi_uidivmod
0000c8  1e40              SUBS     r0,r0,#1
                  |L1.202|
0000ca  6270              STR      r0,[r6,#0x24]
;;;94         PWM->CNR[u32ChannelNum] = u16CNR;
0000cc  60f4              STR      r4,[r6,#0xc]
;;;95     
;;;96         return(i);
0000ce  9800              LDR      r0,[sp,#0]
;;;97     }
0000d0  b007              ADD      sp,sp,#0x1c
0000d2  bdf0              POP      {r4-r7,pc}
                  |L1.212|
0000d4  2104              MOVS     r1,#4                 ;76
0000d6  e7d3              B        |L1.128|
                  |L1.216|
0000d8  2100              MOVS     r1,#0                 ;78
0000da  e7d1              B        |L1.128|
                  |L1.220|
0000dc  2101              MOVS     r1,#1                 ;80
0000de  e7cf              B        |L1.128|
                  |L1.224|
0000e0  2102              MOVS     r1,#2                 ;82
0000e2  e7cd              B        |L1.128|
                  |L1.228|
0000e4  2000              MOVS     r0,#0                 ;91
0000e6  e7f0              B        |L1.202|
;;;98     
                          ENDP

                  PWM_Start PROC
;;;106     */
;;;107    void PWM_Start (PWM_T *pwm, uint32_t u32ChannelMask)
0000e8  b530              PUSH     {r4,r5,lr}
;;;108    {
;;;109        uint32_t u32Mask = 0, i;
0000ea  2200              MOVS     r2,#0
;;;110        for(i = 0; i < PWM_CHANNEL_NUM; i ++) {
0000ec  4610              MOV      r0,r2
;;;111            if(u32ChannelMask & (1 << i)) {
0000ee  2401              MOVS     r4,#1
                  |L1.240|
0000f0  4623              MOV      r3,r4
0000f2  4083              LSLS     r3,r3,r0
0000f4  420b              TST      r3,r1
0000f6  d003              BEQ      |L1.256|
;;;112                u32Mask |= (PWM_PCR_CH0EN_Msk << (i * 4));
0000f8  0085              LSLS     r5,r0,#2
0000fa  4623              MOV      r3,r4
0000fc  40ab              LSLS     r3,r3,r5
0000fe  431a              ORRS     r2,r2,r3
                  |L1.256|
000100  1c40              ADDS     r0,r0,#1
000102  2806              CMP      r0,#6                 ;110
000104  d3f4              BCC      |L1.240|
;;;113            }
;;;114        }
;;;115    
;;;116        PWM->PCR |= u32Mask;
000106  4981              LDR      r1,|L1.780|
000108  6888              LDR      r0,[r1,#8]
00010a  4310              ORRS     r0,r0,r2
00010c  6088              STR      r0,[r1,#8]
;;;117    }
00010e  bd30              POP      {r4,r5,pc}
;;;118    
                          ENDP

                  PWM_Stop PROC
;;;125     */
;;;126    void PWM_Stop (PWM_T *pwm, uint32_t u32ChannelMask)
000110  b530              PUSH     {r4,r5,lr}
;;;127    {
;;;128        uint32_t i;
;;;129        for(i = 0; i < PWM_CHANNEL_NUM; i ++) {
000112  2000              MOVS     r0,#0
;;;130            if(u32ChannelMask & (1 << i)) {
;;;131                PWM->CNR[i] = 0;
000114  4c7d              LDR      r4,|L1.780|
000116  2501              MOVS     r5,#1                 ;130
000118  4603              MOV      r3,r0                 ;130
                  |L1.282|
00011a  462a              MOV      r2,r5                 ;130
00011c  4082              LSLS     r2,r2,r0              ;130
00011e  420a              TST      r2,r1                 ;130
000120  d002              BEQ      |L1.296|
000122  0082              LSLS     r2,r0,#2
000124  1912              ADDS     r2,r2,r4
000126  60d3              STR      r3,[r2,#0xc]
                  |L1.296|
000128  1c40              ADDS     r0,r0,#1
00012a  2806              CMP      r0,#6                 ;129
00012c  d3f5              BCC      |L1.282|
;;;132            }
;;;133        }
;;;134    
;;;135    }
00012e  bd30              POP      {r4,r5,pc}
;;;136    
                          ENDP

                  PWM_ForceStop PROC
;;;143     */
;;;144    void PWM_ForceStop (PWM_T *pwm, uint32_t u32ChannelMask)
000130  b530              PUSH     {r4,r5,lr}
;;;145    {
;;;146        uint32_t u32Mask = 0, i;
000132  2200              MOVS     r2,#0
;;;147        for(i = 0; i < PWM_CHANNEL_NUM; i ++) {
000134  4610              MOV      r0,r2
;;;148            if(u32ChannelMask & (1 << i)) {
000136  2401              MOVS     r4,#1
                  |L1.312|
000138  4623              MOV      r3,r4
00013a  4083              LSLS     r3,r3,r0
00013c  420b              TST      r3,r1
00013e  d003              BEQ      |L1.328|
;;;149                u32Mask |= (PWM_PCR_CH0EN_Msk << (i * 4));
000140  0085              LSLS     r5,r0,#2
000142  4623              MOV      r3,r4
000144  40ab              LSLS     r3,r3,r5
000146  431a              ORRS     r2,r2,r3
                  |L1.328|
000148  1c40              ADDS     r0,r0,#1
00014a  2806              CMP      r0,#6                 ;147
00014c  d3f4              BCC      |L1.312|
;;;150            }
;;;151        }
;;;152    
;;;153        PWM->PCR &= ~u32Mask;
00014e  496f              LDR      r1,|L1.780|
000150  6888              LDR      r0,[r1,#8]
000152  4390              BICS     r0,r0,r2
000154  6088              STR      r0,[r1,#8]
;;;154    }
000156  bd30              POP      {r4,r5,pc}
;;;155    
                          ENDP

                  PWM_EnableADCTrigger PROC
;;;166     */
;;;167    void PWM_EnableADCTrigger (PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition)
000158  b510              PUSH     {r4,lr}
;;;168    {
;;;169        if(u32ChannelNum < 4) {
;;;170            PWM->TRGCON0 = (PWM->TRGCON0 & ~((PWM_TRIGGER_ADC_CNTR_IS_0 |
00015a  4c6c              LDR      r4,|L1.780|
00015c  230f              MOVS     r3,#0xf
00015e  3440              ADDS     r4,r4,#0x40
000160  00c8              LSLS     r0,r1,#3
000162  2904              CMP      r1,#4                 ;169
000164  d206              BCS      |L1.372|
000166  6aa1              LDR      r1,[r4,#0x28]
000168  4083              LSLS     r3,r3,r0
00016a  4399              BICS     r1,r1,r3
00016c  4082              LSLS     r2,r2,r0
00016e  4311              ORRS     r1,r1,r2
000170  62a1              STR      r1,[r4,#0x28]
;;;171                                              PWM_TRIGGER_ADC_CNTR_IS_CMR_D |
;;;172                                              PWM_TRIGGER_ADC_CNTR_IS_CNR |
;;;173                                              PWM_TRIGGER_ADC_CNTR_IS_CMR_U ) << (8 * u32ChannelNum))) | (u32Condition << (8 * u32ChannelNum));
;;;174        } else {
;;;175            PWM->TRGCON1 = (PWM->TRGCON1 & ~((PWM_TRIGGER_ADC_CNTR_IS_0 |
;;;176                                              PWM_TRIGGER_ADC_CNTR_IS_CMR_D |
;;;177                                              PWM_TRIGGER_ADC_CNTR_IS_CNR |
;;;178                                              PWM_TRIGGER_ADC_CNTR_IS_CMR_U ) << (8 * (u32ChannelNum - 4)))) | (u32Condition << (8 * (u32ChannelNum - 4)));
;;;179    
;;;180        }
;;;181    }
000172  bd10              POP      {r4,pc}
                  |L1.372|
000174  3820              SUBS     r0,r0,#0x20
000176  6ae1              LDR      r1,[r4,#0x2c]         ;175
000178  4083              LSLS     r3,r3,r0              ;175
00017a  4399              BICS     r1,r1,r3              ;175
00017c  4082              LSLS     r2,r2,r0              ;175
00017e  4311              ORRS     r1,r1,r2              ;175
000180  62e1              STR      r1,[r4,#0x2c]         ;175
000182  bd10              POP      {r4,pc}
;;;182    
                          ENDP

                  PWM_DisableADCTrigger PROC
;;;188     */
;;;189    void PWM_DisableADCTrigger (PWM_T *pwm, uint32_t u32ChannelNum)
000184  4a61              LDR      r2,|L1.780|
;;;190    {
;;;191        if(u32ChannelNum < 4) {
;;;192            PWM->TRGCON0 = (PWM->TRGCON0 & ~((PWM_TRIGGER_ADC_CNTR_IS_0 |
000186  00c8              LSLS     r0,r1,#3
000188  3240              ADDS     r2,r2,#0x40
00018a  230f              MOVS     r3,#0xf
00018c  2904              CMP      r1,#4                 ;191
00018e  d204              BCS      |L1.410|
000190  6a91              LDR      r1,[r2,#0x28]
000192  4083              LSLS     r3,r3,r0
000194  4399              BICS     r1,r1,r3
000196  6291              STR      r1,[r2,#0x28]
;;;193                                              PWM_TRIGGER_ADC_CNTR_IS_CMR_D |
;;;194                                              PWM_TRIGGER_ADC_CNTR_IS_CNR |
;;;195                                              PWM_TRIGGER_ADC_CNTR_IS_CMR_U ) << (8 * u32ChannelNum)));
;;;196        } else {
;;;197            PWM->TRGCON1 = (PWM->TRGCON1 & ~((PWM_TRIGGER_ADC_CNTR_IS_0 |
;;;198                                              PWM_TRIGGER_ADC_CNTR_IS_CMR_D |
;;;199                                              PWM_TRIGGER_ADC_CNTR_IS_CNR |
;;;200                                              PWM_TRIGGER_ADC_CNTR_IS_CMR_U ) << (8 * (u32ChannelNum - 4))));
;;;201        }
;;;202    }
000198  4770              BX       lr
                  |L1.410|
00019a  3820              SUBS     r0,r0,#0x20
00019c  4083              LSLS     r3,r3,r0              ;197
00019e  6ad0              LDR      r0,[r2,#0x2c]         ;197
0001a0  4398              BICS     r0,r0,r3              ;197
0001a2  62d0              STR      r0,[r2,#0x2c]         ;197
0001a4  4770              BX       lr
;;;203    
                          ENDP

                  PWM_ClearADCTriggerFlag PROC
;;;214     */
;;;215    void PWM_ClearADCTriggerFlag (PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition)
0001a6  4b59              LDR      r3,|L1.780|
;;;216    {
;;;217        if(u32ChannelNum < 4) {
;;;218            PWM->TRGSTS0 |= (u32Condition << (8 * u32ChannelNum));
0001a8  00c8              LSLS     r0,r1,#3
0001aa  3340              ADDS     r3,r3,#0x40
0001ac  2904              CMP      r1,#4                 ;217
0001ae  d204              BCS      |L1.442|
0001b0  6b19              LDR      r1,[r3,#0x30]
0001b2  4082              LSLS     r2,r2,r0
0001b4  4311              ORRS     r1,r1,r2
0001b6  6319              STR      r1,[r3,#0x30]
;;;219        } else {
;;;220            PWM->TRGSTS1 |= (u32Condition << (8 * (u32ChannelNum - 4)));
;;;221        }
;;;222    }
0001b8  4770              BX       lr
                  |L1.442|
0001ba  3820              SUBS     r0,r0,#0x20
0001bc  4082              LSLS     r2,r2,r0              ;220
0001be  6b58              LDR      r0,[r3,#0x34]         ;220
0001c0  4302              ORRS     r2,r2,r0              ;220
0001c2  635a              STR      r2,[r3,#0x34]         ;220
0001c4  4770              BX       lr
;;;223    
                          ENDP

                  PWM_GetADCTriggerFlag PROC
;;;233     */
;;;234    uint32_t PWM_GetADCTriggerFlag (PWM_T *pwm, uint32_t u32ChannelNum)
0001c6  4851              LDR      r0,|L1.780|
;;;235    {
;;;236        uint32_t u32Ret;
;;;237    
;;;238        if(u32ChannelNum < 4) {
;;;239            u32Ret = PWM->TRGSTS0 >> (8 * u32ChannelNum);
0001c8  00ca              LSLS     r2,r1,#3
0001ca  3040              ADDS     r0,r0,#0x40
0001cc  2904              CMP      r1,#4                 ;238
0001ce  d201              BCS      |L1.468|
0001d0  6b00              LDR      r0,[r0,#0x30]
0001d2  e001              B        |L1.472|
                  |L1.468|
;;;240        } else {
;;;241            u32Ret = PWM->TRGSTS1 >> (8 * (u32ChannelNum - 4 ));
0001d4  6b40              LDR      r0,[r0,#0x34]
0001d6  3a20              SUBS     r2,r2,#0x20
                  |L1.472|
0001d8  40d0              LSRS     r0,r0,r2
;;;242        }
;;;243    
;;;244        return (u32Ret & (PWM_TRIGGER_ADC_CNTR_IS_0 |
0001da  0700              LSLS     r0,r0,#28
0001dc  0f00              LSRS     r0,r0,#28
;;;245                          PWM_TRIGGER_ADC_CNTR_IS_CMR_D |
;;;246                          PWM_TRIGGER_ADC_CNTR_IS_CNR |
;;;247                          PWM_TRIGGER_ADC_CNTR_IS_CMR_U));
;;;248    }
0001de  4770              BX       lr
;;;249    
                          ENDP

                  PWM_EnableFaultBrake PROC
;;;263     */
;;;264    void PWM_EnableFaultBrake (PWM_T *pwm,
0001e0  0610              LSLS     r0,r2,#24
;;;265                               uint32_t u32ChannelMask,
;;;266                               uint32_t u32LevelMask,
;;;267                               uint32_t u32BrakeSource)
;;;268    {
;;;269        PWM->PFBCON = (u32LevelMask << PWM_PFBCON_PWMBKO0_Pos) | u32BrakeSource;
0001e2  494a              LDR      r1,|L1.780|
0001e4  4318              ORRS     r0,r0,r3
0001e6  3140              ADDS     r1,r1,#0x40
0001e8  6208              STR      r0,[r1,#0x20]
;;;270    }
0001ea  4770              BX       lr
;;;271    
                          ENDP

                  PWM_ClearFaultBrakeFlag PROC
;;;278     */
;;;279    void PWM_ClearFaultBrakeFlag (PWM_T *pwm, uint32_t u32BrakeSource)
0001ec  4947              LDR      r1,|L1.780|
;;;280    {
;;;281        PWM->PFBCON = PWM_PFBCON_BKF_Msk;
0001ee  2080              MOVS     r0,#0x80
0001f0  3140              ADDS     r1,r1,#0x40
0001f2  6208              STR      r0,[r1,#0x20]
;;;282    }
0001f4  4770              BX       lr
;;;283    
                          ENDP

                  PWM_EnableOutput PROC
;;;290     */
;;;291    void PWM_EnableOutput (PWM_T *pwm, uint32_t u32ChannelMask)
0001f6  4845              LDR      r0,|L1.780|
;;;292    {
;;;293        PWM->POE |= u32ChannelMask;
0001f8  3040              ADDS     r0,r0,#0x40
0001fa  69c2              LDR      r2,[r0,#0x1c]
0001fc  430a              ORRS     r2,r2,r1
0001fe  61c2              STR      r2,[r0,#0x1c]
;;;294    }
000200  4770              BX       lr
;;;295    
                          ENDP

                  PWM_DisableOutput PROC
;;;302     */
;;;303    void PWM_DisableOutput (PWM_T *pwm, uint32_t u32ChannelMask)
000202  4842              LDR      r0,|L1.780|
;;;304    {
;;;305        PWM->POE &= ~u32ChannelMask;
000204  3040              ADDS     r0,r0,#0x40
000206  69c2              LDR      r2,[r0,#0x1c]
000208  438a              BICS     r2,r2,r1
00020a  61c2              STR      r2,[r0,#0x1c]
;;;306    }
00020c  4770              BX       lr
;;;307    
                          ENDP

                  PWM_EnableDeadZone PROC
;;;315     */
;;;316    void PWM_EnableDeadZone (PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Duration)
00020e  b530              PUSH     {r4,r5,lr}
;;;317    {
;;;318        // every two channels shares the same setting
;;;319        u32ChannelNum >>= 1;
;;;320        // set duration
;;;321        PWM->PDZIR = (PWM->PDZIR & ~(PWM_DZIR_DZI01_Msk << (8 * u32ChannelNum))) | (u32Duration << (8 * u32ChannelNum));
000210  4c3e              LDR      r4,|L1.780|
000212  0848              LSRS     r0,r1,#1              ;319
000214  3440              ADDS     r4,r4,#0x40
000216  6a63              LDR      r3,[r4,#0x24]
000218  00c1              LSLS     r1,r0,#3
00021a  25ff              MOVS     r5,#0xff
00021c  408d              LSLS     r5,r5,r1
00021e  43ab              BICS     r3,r3,r5
000220  408a              LSLS     r2,r2,r1
000222  4313              ORRS     r3,r3,r2
000224  6263              STR      r3,[r4,#0x24]
;;;322        // enable dead zone
;;;323        PWM->PCR |= (PWM_PCR_DZEN01_Msk << u32ChannelNum);
000226  0323              LSLS     r3,r4,#12
000228  689a              LDR      r2,[r3,#8]
00022a  0199              LSLS     r1,r3,#6
00022c  4081              LSLS     r1,r1,r0
00022e  430a              ORRS     r2,r2,r1
000230  609a              STR      r2,[r3,#8]
;;;324    }
000232  bd30              POP      {r4,r5,pc}
;;;325    
                          ENDP

                  PWM_DisableDeadZone PROC
;;;331     */
;;;332    void PWM_DisableDeadZone (PWM_T *pwm, uint32_t u32ChannelNum)
000234  0848              LSRS     r0,r1,#1
;;;333    {
;;;334        // every two channels shares the same setting
;;;335        u32ChannelNum >>= 1;
;;;336        // enable dead zone
;;;337        PWM->PCR &= ~(PWM_PCR_DZEN01_Msk << u32ChannelNum);
000236  4935              LDR      r1,|L1.780|
000238  688a              LDR      r2,[r1,#8]
00023a  018b              LSLS     r3,r1,#6
00023c  4083              LSLS     r3,r3,r0
00023e  439a              BICS     r2,r2,r3
000240  608a              STR      r2,[r1,#8]
;;;338    }
000242  4770              BX       lr
;;;339    
                          ENDP

                  PWM_EnableDutyInt PROC
;;;346     */
;;;347    void PWM_EnableDutyInt (PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32IntDutyType)
000244  4831              LDR      r0,|L1.780|
;;;348    {
;;;349        PWM->PIER |= (PWM_PIER_PWMDIE0_Msk << u32ChannelNum);
000246  3040              ADDS     r0,r0,#0x40
000248  6942              LDR      r2,[r0,#0x14]
00024a  1583              ASRS     r3,r0,#22
00024c  408b              LSLS     r3,r3,r1
00024e  431a              ORRS     r2,r2,r3
000250  6142              STR      r2,[r0,#0x14]
;;;350    }
000252  4770              BX       lr
;;;351    
                          ENDP

                  PWM_DisableDutyInt PROC
;;;357     */
;;;358    void PWM_DisableDutyInt (PWM_T *pwm, uint32_t u32ChannelNum)
000254  482d              LDR      r0,|L1.780|
;;;359    {
;;;360        PWM->PIER &= ~(PWM_PIER_PWMDIE0_Msk << u32ChannelNum);
000256  3040              ADDS     r0,r0,#0x40
000258  6942              LDR      r2,[r0,#0x14]
00025a  1583              ASRS     r3,r0,#22
00025c  408b              LSLS     r3,r3,r1
00025e  439a              BICS     r2,r2,r3
000260  6142              STR      r2,[r0,#0x14]
;;;361    }
000262  4770              BX       lr
;;;362    
                          ENDP

                  PWM_ClearDutyIntFlag PROC
;;;368     */
;;;369    void PWM_ClearDutyIntFlag (PWM_T *pwm, uint32_t u32ChannelNum)
000264  20ff              MOVS     r0,#0xff
;;;370    {
;;;371        PWM->PIIR = (PWM_PIIR_PWMDIF0_Msk << u32ChannelNum);
000266  3001              ADDS     r0,#1
000268  4088              LSLS     r0,r0,r1
00026a  4928              LDR      r1,|L1.780|
00026c  3140              ADDS     r1,r1,#0x40
00026e  6188              STR      r0,[r1,#0x18]
;;;372    }
000270  4770              BX       lr
;;;373    
                          ENDP

                  PWM_GetDutyIntFlag PROC
;;;381     */
;;;382    uint32_t PWM_GetDutyIntFlag (PWM_T *pwm, uint32_t u32ChannelNum)
000272  4826              LDR      r0,|L1.780|
;;;383    {
;;;384        return(PWM->PIIR & (PWM_PIIR_PWMDIF0_Msk << u32ChannelNum) ? 1 : 0);
000274  3040              ADDS     r0,r0,#0x40
000276  6980              LDR      r0,[r0,#0x18]
000278  22ff              MOVS     r2,#0xff
00027a  3201              ADDS     r2,#1
00027c  408a              LSLS     r2,r2,r1
00027e  4010              ANDS     r0,r0,r2
000280  d000              BEQ      |L1.644|
000282  2001              MOVS     r0,#1
                  |L1.644|
;;;385    }
000284  4770              BX       lr
;;;386    
                          ENDP

                  PWM_EnableFaultBrakeInt PROC
;;;392     */
;;;393    void PWM_EnableFaultBrakeInt (PWM_T *pwm, uint32_t u32BrakeSource)
000286  4821              LDR      r0,|L1.780|
;;;394    {
;;;395        PWM->PIER |= PWM_PIER_BRKIE_Msk;
000288  3040              ADDS     r0,r0,#0x40
00028a  6941              LDR      r1,[r0,#0x14]
00028c  2201              MOVS     r2,#1
00028e  0412              LSLS     r2,r2,#16
000290  4311              ORRS     r1,r1,r2
000292  6141              STR      r1,[r0,#0x14]
;;;396    }
000294  4770              BX       lr
;;;397    
                          ENDP

                  PWM_DisableFaultBrakeInt PROC
;;;403     */
;;;404    void PWM_DisableFaultBrakeInt (PWM_T *pwm, uint32_t u32BrakeSource)
000296  481d              LDR      r0,|L1.780|
;;;405    {
;;;406        PWM->PIER &= ~PWM_PIER_BRKIE_Msk;
000298  3040              ADDS     r0,r0,#0x40
00029a  6941              LDR      r1,[r0,#0x14]
00029c  2201              MOVS     r2,#1
00029e  0412              LSLS     r2,r2,#16
0002a0  4391              BICS     r1,r1,r2
0002a2  6141              STR      r1,[r0,#0x14]
;;;407    }
0002a4  4770              BX       lr
;;;408    
                          ENDP

                  PWM_ClearFaultBrakeIntFlag PROC
;;;416     */
;;;417    void PWM_ClearFaultBrakeIntFlag (PWM_T *pwm, uint32_t u32BrakeSource)
0002a6  4819              LDR      r0,|L1.780|
;;;418    {
;;;419        PWM->PIIR = u32BrakeSource;
0002a8  3040              ADDS     r0,r0,#0x40
0002aa  6181              STR      r1,[r0,#0x18]
;;;420    }
0002ac  4770              BX       lr
;;;421    
                          ENDP

                  PWM_GetFaultBrakeIntFlag PROC
;;;431     */
;;;432    uint32_t PWM_GetFaultBrakeIntFlag (PWM_T *pwm, uint32_t u32BrakeSource)
0002ae  4817              LDR      r0,|L1.780|
;;;433    {
;;;434        return (PWM->PIIR & u32BrakeSource ? 1 : 0);
0002b0  3040              ADDS     r0,r0,#0x40
0002b2  6980              LDR      r0,[r0,#0x18]
0002b4  4008              ANDS     r0,r0,r1
0002b6  d000              BEQ      |L1.698|
0002b8  2001              MOVS     r0,#1
                  |L1.698|
;;;435    }
0002ba  4770              BX       lr
;;;436    
                          ENDP

                  PWM_EnablePeriodInt PROC
;;;446     */
;;;447    void PWM_EnablePeriodInt (PWM_T *pwm, uint32_t u32ChannelNum,  uint32_t u32IntPeriodType)
0002bc  b510              PUSH     {r4,lr}
;;;448    {
;;;449        PWM->PIER = (PWM->PIER & ~PWM_PIER_INT_TYPE_Msk) | (PWM_PIER_PWMPIE0_Msk << u32ChannelNum) | u32IntPeriodType;
0002be  4c13              LDR      r4,|L1.780|
0002c0  3440              ADDS     r4,r4,#0x40
0002c2  6960              LDR      r0,[r4,#0x14]
0002c4  2301              MOVS     r3,#1
0002c6  045b              LSLS     r3,r3,#17
0002c8  4398              BICS     r0,r0,r3
0002ca  2301              MOVS     r3,#1
0002cc  408b              LSLS     r3,r3,r1
0002ce  4318              ORRS     r0,r0,r3
0002d0  4310              ORRS     r0,r0,r2
0002d2  6160              STR      r0,[r4,#0x14]
;;;450    }
0002d4  bd10              POP      {r4,pc}
;;;451    
                          ENDP

                  PWM_DisablePeriodInt PROC
;;;457     */
;;;458    void PWM_DisablePeriodInt (PWM_T *pwm, uint32_t u32ChannelNum)
0002d6  480d              LDR      r0,|L1.780|
;;;459    {
;;;460        PWM->PIER &= ~(PWM_PIER_PWMPIE0_Msk << u32ChannelNum);
0002d8  3040              ADDS     r0,r0,#0x40
0002da  6942              LDR      r2,[r0,#0x14]
0002dc  2301              MOVS     r3,#1
0002de  408b              LSLS     r3,r3,r1
0002e0  439a              BICS     r2,r2,r3
0002e2  6142              STR      r2,[r0,#0x14]
;;;461    }
0002e4  4770              BX       lr
;;;462    
                          ENDP

                  PWM_ClearPeriodIntFlag PROC
;;;468     */
;;;469    void PWM_ClearPeriodIntFlag (PWM_T *pwm, uint32_t u32ChannelNum)
0002e6  2001              MOVS     r0,#1
;;;470    {
;;;471        PWM->PIIR = (PWM_PIIR_PWMPIF0_Msk << u32ChannelNum);
0002e8  4088              LSLS     r0,r0,r1
0002ea  4908              LDR      r1,|L1.780|
0002ec  3140              ADDS     r1,r1,#0x40
0002ee  6188              STR      r0,[r1,#0x18]
;;;472    }
0002f0  4770              BX       lr
;;;473    
                          ENDP

                  PWM_GetPeriodIntFlag PROC
;;;481     */
;;;482    uint32_t PWM_GetPeriodIntFlag (PWM_T *pwm, uint32_t u32ChannelNum)
0002f2  4806              LDR      r0,|L1.780|
;;;483    {
;;;484        return(PWM->PIIR & (PWM_PIIR_PWMPIF0_Msk << u32ChannelNum) ? 1 : 0);
0002f4  3040              ADDS     r0,r0,#0x40
0002f6  6980              LDR      r0,[r0,#0x18]
0002f8  2201              MOVS     r2,#1
0002fa  408a              LSLS     r2,r2,r1
0002fc  4010              ANDS     r0,r0,r2
0002fe  d000              BEQ      |L1.770|
000300  2001              MOVS     r0,#1
                  |L1.770|
;;;485    }
000302  4770              BX       lr
;;;486    
                          ENDP

                  |L1.772|
                          DCD      SystemCoreClock
                  |L1.776|
                          DCD      0x0000ffff
                  |L1.780|
                          DCD      0x40040000

;*** Start embedded assembler ***

#line 1 "C:\\Keil_v5\\ARM\\PACK\\Nuvoton\\NuMicro_DFP\\1.1.0\\Device\\Mini51\\Driver\\pwm.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_pwm_c_03ee09af____REV16|
#line 464 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.1.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_pwm_c_03ee09af____REV16| PROC
#line 465

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_pwm_c_03ee09af____REVSH|
#line 479
|__asm___5_pwm_c_03ee09af____REVSH| PROC
#line 480

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
