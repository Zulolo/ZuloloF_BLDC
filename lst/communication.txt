; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\communication.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\communication.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\Mini51Series\Include -I..\..\..\Library\StdDriver\inc -I.\StdDriver\inc -I.\CMSIS -I.\RTE\_Template -IC:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.1.0\Device\Mini51\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=524 --omf_browse=.\obj\communication.crf User\Communication.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  calCRC16 PROC
;;;36     
;;;37     uint16_t calCRC16(uint8_t* pBytes, uint32_t unLength)
000000  b570              PUSH     {r4-r6,lr}
;;;38     {
000002  4605              MOV      r5,r0
;;;39     	uint16_t crc = 0;
000004  2000              MOVS     r0,#0
;;;40     	uint32_t unIndex;
;;;41     	uint8_t unPosInTable;
;;;42     	
;;;43     	for (unIndex = 0; unIndex < unLength; unIndex++)
000006  4602              MOV      r2,r0
;;;44     	{
;;;45     		/* XOR-in next input byte into MSB of crc, that's our new intermediate divident */
;;;46     		unPosInTable = (uint8_t)((crc >> 8) ^ (*(pBytes + REVS_BYTE_ORDER(unIndex)))); /* equal: ((crc ^ (b << 8)) >> 8) */
;;;47     		/* Shift out the MSB used for division per lookuptable and XOR with the remainder */
;;;48     		crc = (uint16_t)((crc << 8) ^ (uint16_t)(CRC_TABLE16[unPosInTable]));
000008  4e6f              LDR      r6,|L1.456|
00000a  e00b              B        |L1.36|
                  |L1.12|
00000c  0a04              LSRS     r4,r0,#8              ;46
00000e  07d3              LSLS     r3,r2,#31             ;46
000010  d00b              BEQ      |L1.42|
000012  1e53              SUBS     r3,r2,#1              ;46
                  |L1.20|
000014  5ceb              LDRB     r3,[r5,r3]            ;46
000016  0200              LSLS     r0,r0,#8
000018  405c              EORS     r4,r4,r3              ;46
00001a  0063              LSLS     r3,r4,#1
00001c  5af3              LDRH     r3,[r6,r3]
00001e  4058              EORS     r0,r0,r3
000020  b280              UXTH     r0,r0
000022  1c52              ADDS     r2,r2,#1
                  |L1.36|
000024  428a              CMP      r2,r1                 ;43
000026  d3f1              BCC      |L1.12|
;;;49     	}
;;;50     
;;;51     	return crc;
;;;52     }
000028  bd70              POP      {r4-r6,pc}
                  |L1.42|
00002a  1c53              ADDS     r3,r2,#1              ;46
00002c  e7f2              B        |L1.20|
;;;53     
                          ENDP

                  nReadCommandHandler PROC
;;;54     int32_t nReadCommandHandler(uint16_t unReadCommand)
00002e  b510              PUSH     {r4,lr}
;;;55     {
;;;56     	static uint8_t unRegSelect;
;;;57     	static uint16_t unReadValue;	// tMotor.unValue may be changed in interrupt between SPI_WRITE_TX and calculating CRC
;;;58     	unRegSelect = COMM_GET_DATA(unReadCommand);
000030  4c65              LDR      r4,|L1.456|
000032  b2c0              UXTB     r0,r0
000034  3c18              SUBS     r4,r4,#0x18
000036  7020              STRB     r0,[r4,#0]
;;;59     	if (unRegSelect < MOTOR_READ_MAX)
000038  281a              CMP      r0,#0x1a
00003a  d20d              BCS      |L1.88|
;;;60     	{
;;;61     		unReadValue = tMotor.unValue[unRegSelect];
00003c  4963              LDR      r1,|L1.460|
00003e  0040              LSLS     r0,r0,#1
000040  5a08              LDRH     r0,[r1,r0]
000042  8060              STRH     r0,[r4,#2]
000044  4962              LDR      r1,|L1.464|
;;;62     		SPI_WRITE_TX(SPI, unReadValue);
000046  b280              UXTH     r0,r0
000048  6208              STR      r0,[r1,#0x20]
;;;63     		unReadValueCRC = calCRC16((uint8_t *)(&unReadValue), 2);
00004a  2102              MOVS     r1,#2
00004c  1ca0              ADDS     r0,r4,#2
00004e  f7fffffe          BL       calCRC16
000052  80e0              STRH     r0,[r4,#6]
;;;64     		return 0;
000054  2000              MOVS     r0,#0
;;;65     	}
;;;66     	else
;;;67     	{
;;;68     		unReadValueCRC = 0;
;;;69     		return -1;
;;;70     	}
;;;71     }
000056  bd10              POP      {r4,pc}
                  |L1.88|
000058  2000              MOVS     r0,#0                 ;68
00005a  80e0              STRH     r0,[r4,#6]            ;68
00005c  1e40              SUBS     r0,r0,#1              ;69
00005e  bd10              POP      {r4,pc}
;;;72     
                          ENDP

                  nWriteCommandHandler PROC
;;;73     int32_t nWriteCommandHandler(uint16_t* pCOM_Buff)
000060  b500              PUSH     {lr}
;;;74     {
;;;75     	switch(COMM_GET_DATA(pCOM_Buff[0]))
000062  8801              LDRH     r1,[r0,#0]
000064  044a              LSLS     r2,r1,#17
000066  0c52              LSRS     r2,r2,#17
;;;76     	{
;;;77     	case MOTOR_WRITE_MOTOR_NEED_TO_RUN:
;;;78     	case MOTOR_WRITE_ROTATE_DIRECTION:
;;;79     		tMotor.structMotor.MCR.bMotorNeedToRun = pCOM_Buff[1];
000068  4958              LDR      r1,|L1.460|
00006a  0013              MOVS     r3,r2                 ;75
00006c  f7fffffe          BL       __ARM_common_switch8
000070  09280606          DCB      0x09,0x28,0x06,0x06
000074  0f121518          DCB      0x0f,0x12,0x15,0x18
000078  1b202800          DCB      0x1b,0x20,0x28,0x00
00007c  884a              LDRH     r2,[r1,#2]  ; tMotor
00007e  7880              LDRB     r0,[r0,#2]
000080  0852              LSRS     r2,r2,#1
000082  0052              LSLS     r2,r2,#1
000084  07c0              LSLS     r0,r0,#31
000086  0fc0              LSRS     r0,r0,#31
000088  4302              ORRS     r2,r2,r0
00008a  804a              STRH     r2,[r1,#2]
;;;80     		break;
00008c  e016              B        |L1.188|
;;;81     	case MOTOR_WRITE_LOCATING_DUTY:
;;;82     		tMotor.structMotor.unLocatingDuty = pCOM_Buff[1];
00008e  8840              LDRH     r0,[r0,#2]
000090  8148              STRH     r0,[r1,#0xa]
;;;83     		break;
000092  e013              B        |L1.188|
;;;84     	case MOTOR_WRITE_RAMP_UP_DUTY:
;;;85     		tMotor.structMotor.unRampUpDuty = pCOM_Buff[1];
000094  8840              LDRH     r0,[r0,#2]
000096  8188              STRH     r0,[r1,#0xc]
;;;86     		break;
000098  e010              B        |L1.188|
;;;87     	case MOTOR_WRITE_TARGET_DUTY:
;;;88     		tMotor.structMotor.unTargetDuty = pCOM_Buff[1];
00009a  8840              LDRH     r0,[r0,#2]
00009c  81c8              STRH     r0,[r1,#0xe]
;;;89     		break;
00009e  e00d              B        |L1.188|
;;;90     	case MOTOR_WRITE_LOCATING_PERIOD:
;;;91     		tMotor.structMotor.unLocatingPeriod = pCOM_Buff[1];
0000a0  8840              LDRH     r0,[r0,#2]
0000a2  8248              STRH     r0,[r1,#0x12]
;;;92     		break;
0000a4  e00a              B        |L1.188|
;;;93     	case MOTOR_WRITE_RAMP_UP_PERIOD_LOW:
;;;94     		tMotor.structMotor.unRampUpPeriod = (tMotor.structMotor.unRampUpPeriod & LOW_REG_CLR_MASK) | ((uint32_t)(pCOM_Buff[1]));
0000a6  698a              LDR      r2,[r1,#0x18]  ; tMotor
0000a8  8840              LDRH     r0,[r0,#2]
0000aa  0c12              LSRS     r2,r2,#16
0000ac  0412              LSLS     r2,r2,#16
;;;95     		break;
0000ae  e003              B        |L1.184|
;;;96     	case MOTOR_WRITE_RAMP_UP_PERIOD_HIGH:
;;;97     		tMotor.structMotor.unRampUpPeriod = (tMotor.structMotor.unRampUpPeriod & HIGH_REG_CLR_MASK) | (((uint32_t)(pCOM_Buff[1])) << 16);
0000b0  698a              LDR      r2,[r1,#0x18]  ; tMotor
0000b2  8840              LDRH     r0,[r0,#2]
0000b4  b292              UXTH     r2,r2
0000b6  0400              LSLS     r0,r0,#16
                  |L1.184|
0000b8  4302              ORRS     r2,r2,r0              ;94
0000ba  618a              STR      r2,[r1,#0x18]         ;94  ; tMotor
                  |L1.188|
;;;98     		break;
;;;99     	default:
;;;100    
;;;101    		return -1;
;;;102    	}
;;;103    
;;;104    	return 0;
0000bc  2000              MOVS     r0,#0
;;;105    }
0000be  bd00              POP      {pc}
0000c0  2000              MOVS     r0,#0                 ;101
0000c2  43c0              MVNS     r0,r0                 ;101
0000c4  bd00              POP      {pc}
;;;106    
                          ENDP

                  COMM_Manager PROC
;;;108    
;;;109    void COMM_Manager(void)
0000c6  b5f8              PUSH     {r3-r7,lr}
;;;110    {
;;;111    	static uint32_t unLastFrameCNT = 0;
;;;112    	static uint32_t unLastCheckTime = 0;
;;;113    	static ENUM_SPI_RECEIVE_STATE tSPI_LastState = SPI_RCV_IDLE;
;;;114    	static uint16_t unSPI_RX_Value;
;;;115    	static uint16_t unCOM_SPI_ReadData[4];	//COMM_FIFO_LENGTH];	// 0 or 0xFFFF means no data
;;;116    	
;;;117    	// All transactions are handled in interrupt
;;;118    	if (tMotor.structMotor.MSR.bNewComFrameReceived == TRUE)
0000c8  4d40              LDR      r5,|L1.460|
0000ca  88a8              LDRH     r0,[r5,#4]  ; tMotor
;;;119    	{
;;;120    		tMotor.structMotor.MSR.bNewComFrameReceived = FALSE;	
;;;121    		unSPI_RX_Value = SPI_READ_RX(SPI);
0000cc  4c41              LDR      r4,|L1.468|
0000ce  4e40              LDR      r6,|L1.464|
0000d0  06c0              LSLS     r0,r0,#27             ;118
0000d2  d552              BPL      |L1.378|
0000d4  88a8              LDRH     r0,[r5,#4]            ;120  ; tMotor
0000d6  2110              MOVS     r1,#0x10              ;120
0000d8  4388              BICS     r0,r0,r1              ;120
0000da  80a8              STRH     r0,[r5,#4]            ;120
0000dc  6930              LDR      r0,[r6,#0x10]         ;120
;;;122    		
;;;123    		switch(tSPI_LastState)
;;;124    		{	
;;;125    			case SPI_RCV_IDLE:
;;;126    				if ((MTR_INVALID_MOTOR_CMD == unSPI_RX_Value) || (MTR_NULL_MOTOR_CMD == unSPI_RX_Value))
;;;127    				{
;;;128    					SPI_WRITE_TX(SPI, 0);
;;;129    					tSPI_LastState = SPI_RCV_IDLE;
;;;130    				}
;;;131    				else
;;;132    				{
;;;133    					unCOM_SPI_ReadData[0] = unSPI_RX_Value;
0000de  4627              MOV      r7,r4
0000e0  b280              UXTH     r0,r0                 ;121
0000e2  80a0              STRH     r0,[r4,#4]            ;121
0000e4  7861              LDRB     r1,[r4,#1]            ;123  ; tSPI_LastState
0000e6  4a3c              LDR      r2,|L1.472|
0000e8  3710              ADDS     r7,r7,#0x10
0000ea  000b              MOVS     r3,r1                 ;123
0000ec  f7fffffe          BL       __ARM_common_switch8
0000f0  0504212a          DCB      0x05,0x04,0x21,0x2a
0000f4  2d123e00          DCB      0x2d,0x12,0x3e,0x00
0000f8  4290              CMP      r0,r2                 ;126
0000fa  d006              BEQ      |L1.266|
0000fc  2800              CMP      r0,#0                 ;126
0000fe  d004              BEQ      |L1.266|
000100  8038              STRH     r0,[r7,#0]
;;;134    					if (IS_COMM_RD_CMD(unSPI_RX_Value))
000102  0bc0              LSRS     r0,r0,#15
000104  d004              BEQ      |L1.272|
;;;135    					{
;;;136    						tSPI_LastState = SPI_RCV_RD_CMD;
000106  2001              MOVS     r0,#1
000108  e011              B        |L1.302|
                  |L1.266|
00010a  2000              MOVS     r0,#0                 ;128
00010c  6230              STR      r0,[r6,#0x20]         ;128
00010e  e030              B        |L1.370|
                  |L1.272|
;;;137    					}
;;;138    					else
;;;139    					{
;;;140    						tSPI_LastState = SPI_RCV_WR_CMD;
000110  2002              MOVS     r0,#2
000112  e00c              B        |L1.302|
;;;141    					}						
;;;142    				}						
;;;143    			break;
;;;144    			
;;;145    			case SPI_RCV_CRC:
;;;146    				if (MTR_INVALID_MOTOR_CMD == unSPI_RX_Value)
000114  4290              CMP      r0,r2
000116  d102              BNE      |L1.286|
;;;147    				{	// After read command and CRC
;;;148    					SPI_WRITE_TX(SPI, unReadValueCRC);
000118  88e0              LDRH     r0,[r4,#6]  ; unReadValueCRC
00011a  6230              STR      r0,[r6,#0x20]
;;;149    					tSPI_LastState = SPI_RCV_IDLE;
00011c  e006              B        |L1.300|
                  |L1.286|
;;;150    				}
;;;151    				else if (IS_COMM_RD_CMD(unSPI_RX_Value))
00011e  0bc1              LSRS     r1,r0,#15
000120  d001              BEQ      |L1.294|
;;;152    				{
;;;153    					// write command after write CRC
;;;154    					unCOM_SPI_ReadData[0] = unSPI_RX_Value;
000122  8038              STRH     r0,[r7,#0]
;;;155    					tSPI_LastState = SPI_RCV_WR_CMD;
000124  e7f4              B        |L1.272|
                  |L1.294|
;;;156    				}
;;;157    				else
;;;158    				{
;;;159    					tMotor.structMotor.unCommErrCNT++;
000126  6b28              LDR      r0,[r5,#0x30]  ; tMotor
000128  1c40              ADDS     r0,r0,#1
00012a  6328              STR      r0,[r5,#0x30]  ; tMotor
                  |L1.300|
00012c  2000              MOVS     r0,#0                 ;149
                  |L1.302|
00012e  7060              STRB     r0,[r4,#1]            ;155
000130  e01f              B        |L1.370|
;;;160    					tSPI_LastState = SPI_RCV_IDLE;									
;;;161    				}	
;;;162    			break;
;;;163    		
;;;164    			case SPI_RCV_RD_CMD:
;;;165    				// If last time is read command, this time must be read CRC and next time must be 0xFFFF on MOSI to read
;;;166    				// So the data received is the CRC of read command, now the slave doesn't care
;;;167    				unCOM_SPI_ReadData[1] = unSPI_RX_Value;
000132  8078              STRH     r0,[r7,#2]
;;;168    				if (nReadCommandHandler(unCOM_SPI_ReadData[0]) == 0)
000134  8838              LDRH     r0,[r7,#0]  ; unCOM_SPI_ReadData
000136  f7fffffe          BL       nReadCommandHandler
00013a  e013              B        |L1.356|
                  |L1.316|
;;;169    				{
;;;170    					tMotor.structMotor.unCommOK_CNT++;
00013c  6ae8              LDR      r0,[r5,#0x2c]  ; tMotor
00013e  1c40              ADDS     r0,r0,#1
000140  62e8              STR      r0,[r5,#0x2c]  ; tMotor
000142  e011              B        |L1.360|
;;;171    				}				
;;;172    				tSPI_LastState = SPI_RCV_CRC;	
;;;173    			break;
;;;174    
;;;175    			case SPI_RCV_WR_CMD:
;;;176    				// No need to comment
;;;177    //					SPI_WRITE_TX(SPI, 0);
;;;178    				unCOM_SPI_ReadData[1] = unSPI_RX_Value;
000144  8078              STRH     r0,[r7,#2]
;;;179    				tSPI_LastState = SPI_RCV_WR_DATA;	
000146  2003              MOVS     r0,#3
;;;180    			break;
000148  e7f1              B        |L1.302|
;;;181    			
;;;182    			case SPI_RCV_WR_DATA:
;;;183    				// No need to comment
;;;184    				unCOM_SPI_ReadData[2] = unSPI_RX_Value;
00014a  80b8              STRH     r0,[r7,#4]
;;;185    				if (calCRC16((uint8_t *)unCOM_SPI_ReadData, 4) == unCOM_SPI_ReadData[2])
00014c  481e              LDR      r0,|L1.456|
00014e  2104              MOVS     r1,#4
000150  3808              SUBS     r0,r0,#8
000152  f7fffffe          BL       calCRC16
000156  88b9              LDRH     r1,[r7,#4]  ; unCOM_SPI_ReadData
000158  4288              CMP      r0,r1
00015a  d105              BNE      |L1.360|
;;;186    				{
;;;187    					if (nWriteCommandHandler(unCOM_SPI_ReadData) == 0)
00015c  481a              LDR      r0,|L1.456|
00015e  3808              SUBS     r0,r0,#8
000160  f7fffffe          BL       nWriteCommandHandler
                  |L1.356|
000164  2800              CMP      r0,#0                 ;168
000166  d0e9              BEQ      |L1.316|
                  |L1.360|
;;;188    					{
;;;189    						tMotor.structMotor.unCommOK_CNT++;
;;;190    					}
;;;191    					else
;;;192    					{
;;;193    //						unCOM_SPI_TransErrCNT++;
;;;194    					}
;;;195    				}
;;;196    				tSPI_LastState = SPI_RCV_CRC;	
000168  2004              MOVS     r0,#4
;;;197    			break;
00016a  e7e0              B        |L1.302|
;;;198    		
;;;199    			default:
;;;200    				tMotor.structMotor.unCommErrCNT++;
00016c  6b28              LDR      r0,[r5,#0x30]  ; tMotor
00016e  1c40              ADDS     r0,r0,#1
000170  6328              STR      r0,[r5,#0x30]  ; tMotor
                  |L1.370|
000172  6830              LDR      r0,[r6,#0]
000174  2101              MOVS     r1,#1
000176  4308              ORRS     r0,r0,r1
000178  6030              STR      r0,[r6,#0]
                  |L1.378|
;;;201    			break;
;;;202    		}
;;;203    		SPI_TRIGGER(SPI);
;;;204    	}
;;;205    	
;;;206    	// Comm protection 1: If have NOT received any frame in 500ms, error
;;;207    	if ((uint32_t)(unSystemTick - unLastCheckTime) > 500)
00017a  4818              LDR      r0,|L1.476|
00017c  6801              LDR      r1,[r0,#0]  ; unSystemTick
00017e  68e2              LDR      r2,[r4,#0xc]  ; unLastCheckTime
000180  1a89              SUBS     r1,r1,r2
000182  22ff              MOVS     r2,#0xff
000184  32f5              ADDS     r2,r2,#0xf5
000186  4291              CMP      r1,r2
000188  d910              BLS      |L1.428|
;;;208    	{
;;;209    		unLastCheckTime = unSystemTick;
00018a  6800              LDR      r0,[r0,#0]  ; unSystemTick
;;;210    		if ((uint32_t)(tMotor.structMotor.unCommOK_CNT - unLastFrameCNT) < 1)
00018c  60e0              STR      r0,[r4,#0xc]  ; unLastCheckTime
00018e  6ae8              LDR      r0,[r5,#0x2c]  ; tMotor
000190  68a1              LDR      r1,[r4,#8]  ; unLastFrameCNT
000192  4288              CMP      r0,r1
000194  d108              BNE      |L1.424|
;;;211    		{
;;;212    			BLDC_stopMotor();
000196  f7fffffe          BL       BLDC_stopMotor
;;;213    			setError(ERR_COMMUNICATION_FAIL);
00019a  2002              MOVS     r0,#2
00019c  f7fffffe          BL       setError
0001a0  6830              LDR      r0,[r6,#0]
0001a2  2101              MOVS     r1,#1
0001a4  4308              ORRS     r0,r0,r1
0001a6  6030              STR      r0,[r6,#0]
                  |L1.424|
;;;214    			// I don't know why,
;;;215    			// But seems every time enter here, the GO_BUSY bit of SPI Control register will be reset
;;;216    			SPI_TRIGGER(SPI);			
;;;217    		}
;;;218    		unLastFrameCNT = tMotor.structMotor.unCommOK_CNT;
0001a8  6ae8              LDR      r0,[r5,#0x2c]  ; tMotor
0001aa  60a0              STR      r0,[r4,#8]  ; unLastFrameCNT
                  |L1.428|
;;;219    	}
;;;220    	// Comm protection 2: If received error frame exceed some threshold, error
;;;221    	if (tMotor.structMotor.unCommErrCNT > COM_SPI_TRANS_ERR_THRESHOLD)
0001ac  6b28              LDR      r0,[r5,#0x30]  ; tMotor
0001ae  2806              CMP      r0,#6
0001b0  d908              BLS      |L1.452|
;;;222    	{
;;;223    		BLDC_stopMotor();
0001b2  f7fffffe          BL       BLDC_stopMotor
;;;224    		setError(ERR_COMMUNICATION_FAIL);
0001b6  2002              MOVS     r0,#2
0001b8  f7fffffe          BL       setError
0001bc  6830              LDR      r0,[r6,#0]
0001be  2101              MOVS     r1,#1
0001c0  4308              ORRS     r0,r0,r1
0001c2  6030              STR      r0,[r6,#0]
                  |L1.452|
;;;225    		SPI_TRIGGER(SPI);	
;;;226    	}
;;;227    }
0001c4  bdf8              POP      {r3-r7,pc}
                          ENDP

0001c6  0000              DCW      0x0000
                  |L1.456|
                          DCD      ||.data||+0x18
                  |L1.460|
                          DCD      tMotor
                  |L1.464|
                          DCD      0x40030000
                  |L1.468|
                          DCD      ||.data||
                  |L1.472|
                          DCD      0x0000ffff
                  |L1.476|
                          DCD      unSystemTick

                          AREA ||.data||, DATA, ALIGN=2

                  unRegSelect
000000  00                DCB      0x00
                  tSPI_LastState
000001  00                DCB      0x00
                  unReadValue
000002  0000              DCB      0x00,0x00
                  unSPI_RX_Value
000004  0000              DCB      0x00,0x00
                  unReadValueCRC
000006  0000              DCB      0x00,0x00
                  unLastFrameCNT
                          DCD      0x00000000
                  unLastCheckTime
                          DCD      0x00000000
                  unCOM_SPI_ReadData
                          %        8
                  CRC_TABLE16
000018  00008005          DCW      0x0000,0x8005
00001c  800f000a          DCW      0x800f,0x000a
000020  801b001e          DCW      0x801b,0x001e
000024  00148011          DCW      0x0014,0x8011
000028  80330036          DCW      0x8033,0x0036
00002c  003c8039          DCW      0x003c,0x8039
000030  0028802d          DCW      0x0028,0x802d
000034  80270022          DCW      0x8027,0x0022
000038  80630066          DCW      0x8063,0x0066
00003c  006c8069          DCW      0x006c,0x8069
000040  0078807d          DCW      0x0078,0x807d
000044  80770072          DCW      0x8077,0x0072
000048  00508055          DCW      0x0050,0x8055
00004c  805f005a          DCW      0x805f,0x005a
000050  804b004e          DCW      0x804b,0x004e
000054  00448041          DCW      0x0044,0x8041
000058  80c300c6          DCW      0x80c3,0x00c6
00005c  00cc80c9          DCW      0x00cc,0x80c9
000060  00d880dd          DCW      0x00d8,0x80dd
000064  80d700d2          DCW      0x80d7,0x00d2
000068  00f080f5          DCW      0x00f0,0x80f5
00006c  80ff00fa          DCW      0x80ff,0x00fa
000070  80eb00ee          DCW      0x80eb,0x00ee
000074  00e480e1          DCW      0x00e4,0x80e1
000078  00a080a5          DCW      0x00a0,0x80a5
00007c  80af00aa          DCW      0x80af,0x00aa
000080  80bb00be          DCW      0x80bb,0x00be
000084  00b480b1          DCW      0x00b4,0x80b1
000088  80930096          DCW      0x8093,0x0096
00008c  009c8099          DCW      0x009c,0x8099
000090  0088808d          DCW      0x0088,0x808d
000094  80870082          DCW      0x8087,0x0082
000098  81830186          DCW      0x8183,0x0186
00009c  018c8189          DCW      0x018c,0x8189
0000a0  0198819d          DCW      0x0198,0x819d
0000a4  81970192          DCW      0x8197,0x0192
0000a8  01b081b5          DCW      0x01b0,0x81b5
0000ac  81bf01ba          DCW      0x81bf,0x01ba
0000b0  81ab01ae          DCW      0x81ab,0x01ae
0000b4  01a481a1          DCW      0x01a4,0x81a1
0000b8  01e081e5          DCW      0x01e0,0x81e5
0000bc  81ef01ea          DCW      0x81ef,0x01ea
0000c0  81fb01fe          DCW      0x81fb,0x01fe
0000c4  01f481f1          DCW      0x01f4,0x81f1
0000c8  81d301d6          DCW      0x81d3,0x01d6
0000cc  01dc81d9          DCW      0x01dc,0x81d9
0000d0  01c881cd          DCW      0x01c8,0x81cd
0000d4  81c701c2          DCW      0x81c7,0x01c2
0000d8  01408145          DCW      0x0140,0x8145
0000dc  814f014a          DCW      0x814f,0x014a
0000e0  815b015e          DCW      0x815b,0x015e
0000e4  01548151          DCW      0x0154,0x8151
0000e8  81730176          DCW      0x8173,0x0176
0000ec  017c8179          DCW      0x017c,0x8179
0000f0  0168816d          DCW      0x0168,0x816d
0000f4  81670162          DCW      0x8167,0x0162
0000f8  81230126          DCW      0x8123,0x0126
0000fc  012c8129          DCW      0x012c,0x8129
000100  0138813d          DCW      0x0138,0x813d
000104  81370132          DCW      0x8137,0x0132
000108  01108115          DCW      0x0110,0x8115
00010c  811f011a          DCW      0x811f,0x011a
000110  810b010e          DCW      0x810b,0x010e
000114  01048101          DCW      0x0104,0x8101
000118  83030306          DCW      0x8303,0x0306
00011c  030c8309          DCW      0x030c,0x8309
000120  0318831d          DCW      0x0318,0x831d
000124  83170312          DCW      0x8317,0x0312
000128  03308335          DCW      0x0330,0x8335
00012c  833f033a          DCW      0x833f,0x033a
000130  832b032e          DCW      0x832b,0x032e
000134  03248321          DCW      0x0324,0x8321
000138  03608365          DCW      0x0360,0x8365
00013c  836f036a          DCW      0x836f,0x036a
000140  837b037e          DCW      0x837b,0x037e
000144  03748371          DCW      0x0374,0x8371
000148  83530356          DCW      0x8353,0x0356
00014c  035c8359          DCW      0x035c,0x8359
000150  0348834d          DCW      0x0348,0x834d
000154  83470342          DCW      0x8347,0x0342
000158  03c083c5          DCW      0x03c0,0x83c5
00015c  83cf03ca          DCW      0x83cf,0x03ca
000160  83db03de          DCW      0x83db,0x03de
000164  03d483d1          DCW      0x03d4,0x83d1
000168  83f303f6          DCW      0x83f3,0x03f6
00016c  03fc83f9          DCW      0x03fc,0x83f9
000170  03e883ed          DCW      0x03e8,0x83ed
000174  83e703e2          DCW      0x83e7,0x03e2
000178  83a303a6          DCW      0x83a3,0x03a6
00017c  03ac83a9          DCW      0x03ac,0x83a9
000180  03b883bd          DCW      0x03b8,0x83bd
000184  83b703b2          DCW      0x83b7,0x03b2
000188  03908395          DCW      0x0390,0x8395
00018c  839f039a          DCW      0x839f,0x039a
000190  838b038e          DCW      0x838b,0x038e
000194  03848381          DCW      0x0384,0x8381
000198  02808285          DCW      0x0280,0x8285
00019c  828f028a          DCW      0x828f,0x028a
0001a0  829b029e          DCW      0x829b,0x029e
0001a4  02948291          DCW      0x0294,0x8291
0001a8  82b302b6          DCW      0x82b3,0x02b6
0001ac  02bc82b9          DCW      0x02bc,0x82b9
0001b0  02a882ad          DCW      0x02a8,0x82ad
0001b4  82a702a2          DCW      0x82a7,0x02a2
0001b8  82e302e6          DCW      0x82e3,0x02e6
0001bc  02ec82e9          DCW      0x02ec,0x82e9
0001c0  02f882fd          DCW      0x02f8,0x82fd
0001c4  82f702f2          DCW      0x82f7,0x02f2
0001c8  02d082d5          DCW      0x02d0,0x82d5
0001cc  82df02da          DCW      0x82df,0x02da
0001d0  82cb02ce          DCW      0x82cb,0x02ce
0001d4  02c482c1          DCW      0x02c4,0x82c1
0001d8  82430246          DCW      0x8243,0x0246
0001dc  024c8249          DCW      0x024c,0x8249
0001e0  0258825d          DCW      0x0258,0x825d
0001e4  82570252          DCW      0x8257,0x0252
0001e8  02708275          DCW      0x0270,0x8275
0001ec  827f027a          DCW      0x827f,0x027a
0001f0  826b026e          DCW      0x826b,0x026e
0001f4  02648261          DCW      0x0264,0x8261
0001f8  02208225          DCW      0x0220,0x8225
0001fc  822f022a          DCW      0x822f,0x022a
000200  823b023e          DCW      0x823b,0x023e
000204  02348231          DCW      0x0234,0x8231
000208  82130216          DCW      0x8213,0x0216
00020c  021c8219          DCW      0x021c,0x8219
000210  0208820d          DCW      0x0208,0x820d
000214  82070202          DCW      0x8207,0x0202

                          AREA ||area_number.5||, DATA, ALIGN=1

                          EXPORTAS ||area_number.5||, ||.data||
                  unRegisterValue
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.6||, DATA, ALIGN=0

                          EXPORTAS ||area_number.6||, ||.data||
                  FlagRegisterNeedWrite
000000  00                DCB      0x00

                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d200              BCS      |L18.16|
00000e  461d              MOV      r5,r3
                  |L18.16|
000010  5d63              LDRB     r3,[r4,r5]
000012  005b              LSLS     r3,r3,#1
000014  18e3              ADDS     r3,r4,r3
000016  bc30              POP      {r4,r5}
000018  4718              BX       r3
                          ENDP


;*** Start embedded assembler ***

#line 1 "User\\Communication.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_Communication_c_6d0c631e____REV16|
#line 118 ".\\CMSIS\\core_cmInstr.h"
|__asm___15_Communication_c_6d0c631e____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_Communication_c_6d0c631e____REVSH|
#line 132
|__asm___15_Communication_c_6d0c631e____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
