; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\error.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\error.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\Mini51Series\Include -I..\..\..\Library\StdDriver\inc -I.\StdDriver\inc -I.\CMSIS -IG:\Geek\Projects\Zulolo_F\Force\Code\Zulolo_F_Force\RTE -ID:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.0.2\Device\Mini51\Include -ID:\Keil_v5\ARM\CMSIS\Include -I\ -D__MICROLIB -D__UVISION_VERSION=518 --omf_browse=.\obj\error.crf User\Error.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  clearError PROC
;;;13     
;;;14     void clearError(void)
000000  492e              LDR      r1,|L1.188|
;;;15     {
;;;16     	iErrorMaster = 0;
000002  2000              MOVS     r0,#0
000004  6088              STR      r0,[r1,#8]  ; iErrorMaster
;;;17     }
000006  4770              BX       lr
;;;18     
                          ENDP

                  resetError PROC
;;;19     void resetError(ENUM_ERROR_LEVEL enumErrorType)
000008  2800              CMP      r0,#0
;;;20     {
00000a  d006              BEQ      |L1.26|
;;;21     	if (ERR_NULL != enumErrorType)
;;;22     	{	
;;;23     		iErrorMaster &= ~(1UL << (enumErrorType - 1));
00000c  2101              MOVS     r1,#1
00000e  1e40              SUBS     r0,r0,#1
000010  4081              LSLS     r1,r1,r0
000012  482a              LDR      r0,|L1.188|
000014  6882              LDR      r2,[r0,#8]  ; iErrorMaster
000016  438a              BICS     r2,r2,r1
000018  6082              STR      r2,[r0,#8]  ; iErrorMaster
                  |L1.26|
;;;24     	}
;;;25     }
00001a  4770              BX       lr
;;;26     
                          ENDP

                  setError PROC
;;;27     void setError(ENUM_ERROR_LEVEL enumErrorType)
00001c  4927              LDR      r1,|L1.188|
;;;28     {
;;;29     	if (ERR_NULL == enumErrorType)
00001e  2800              CMP      r0,#0
000020  d006              BEQ      |L1.48|
;;;30     	{
;;;31     		iErrorMaster = 0;
;;;32     	}
;;;33     	else
;;;34     	{
;;;35     		iErrorMaster |= 1UL << (enumErrorType - 1); 
000022  2201              MOVS     r2,#1
000024  1e40              SUBS     r0,r0,#1
000026  4082              LSLS     r2,r2,r0
000028  6888              LDR      r0,[r1,#8]  ; iErrorMaster
00002a  4302              ORRS     r2,r2,r0
00002c  608a              STR      r2,[r1,#8]  ; iErrorMaster
;;;36     	}
;;;37     }
00002e  4770              BX       lr
                  |L1.48|
000030  2000              MOVS     r0,#0                 ;31
000032  6088              STR      r0,[r1,#8]            ;31  ; iErrorMaster
000034  4770              BX       lr
;;;38     
                          ENDP

                  getPrecedenceError PROC
;;;39     ENUM_ERROR_LEVEL getPrecedenceError(void)
000036  4921              LDR      r1,|L1.188|
;;;40     {
;;;41     	register ENUM_ERROR_LEVEL iVernier = ERR_BRD_FAULT;
000038  2007              MOVS     r0,#7
;;;42     	while (iVernier)
;;;43     	{
;;;44     		iVernier--; 
;;;45     		if (iErrorMaster >> iVernier)
00003a  688a              LDR      r2,[r1,#8]
                  |L1.60|
00003c  1e40              SUBS     r0,r0,#1
00003e  b2c0              UXTB     r0,r0                 ;44
000040  4611              MOV      r1,r2                 ;44
000042  40c1              LSRS     r1,r1,r0
000044  d002              BEQ      |L1.76|
000046  1c40              ADDS     r0,r0,#1
;;;46     		{
;;;47     			return (iVernier + 1);
000048  b2c0              UXTB     r0,r0
;;;48     		}		
;;;49     	}
;;;50     	return iVernier;
;;;51     }
00004a  4770              BX       lr
                  |L1.76|
00004c  2800              CMP      r0,#0                 ;42
00004e  d1f5              BNE      |L1.60|
000050  4770              BX       lr
;;;52     
                          ENDP

                  LEDBlinkHandler PROC
;;;53     void LEDBlinkHandler(ENUM_ERROR_LEVEL errorType, uint32_t iErrorStartTime)
000052  b5f8              PUSH     {r3-r7,lr}
;;;54     {
000054  2700              MOVS     r7,#0
;;;55     	uint16_t iLEDTime;
;;;56     	if (ERR_BRD_FAULT == errorType)
;;;57     	{
;;;58     		// Always ON
;;;59     		LED_ON;
000056  4c1a              LDR      r4,|L1.192|
000058  4605              MOV      r5,r0                 ;54
00005a  2807              CMP      r0,#7                 ;56
00005c  d010              BEQ      |L1.128|
;;;60     	}
;;;61     	else if (ERR_NULL == errorType)
;;;62     	{
;;;63     		// Always off
;;;64     		LED_OFF;
00005e  2601              MOVS     r6,#1
000060  2d00              CMP      r5,#0                 ;61
000062  d00f              BEQ      |L1.132|
;;;65     	}
;;;66     	else
;;;67     	{
;;;68     		iLEDTime = (uint16_t)(((uint32_t)(iSystemTick - iErrorStartTime)) % LED_PATTERN_INTERVAL);
000064  4817              LDR      r0,|L1.196|
000066  6800              LDR      r0,[r0,#0]  ; iSystemTick
000068  1a40              SUBS     r0,r0,r1
00006a  217d              MOVS     r1,#0x7d
00006c  0149              LSLS     r1,r1,#5
00006e  f7fffffe          BL       __aeabi_uidivmod
000072  4608              MOV      r0,r1
;;;69     		if (iLEDTime >= errorType * (LED_BLINK_INTERVAL))
000074  21ff              MOVS     r1,#0xff
000076  3191              ADDS     r1,r1,#0x91
000078  434d              MULS     r5,r1,r5
00007a  4285              CMP      r5,r0
00007c  d902              BLS      |L1.132|
00007e  e003              B        |L1.136|
                  |L1.128|
000080  6327              STR      r7,[r4,#0x30]         ;59
;;;70     		{
;;;71     			LED_OFF;
;;;72     		}
;;;73     		else
;;;74     		{
;;;75     			iLEDTime %= LED_BLINK_INTERVAL;
;;;76     			if (iLEDTime < LED_BLINK_ON_TIME)
;;;77     			{
;;;78     				LED_ON;
;;;79     			}
;;;80     			else
;;;81     			{
;;;82     				LED_OFF;
;;;83     			}
;;;84     		}
;;;85     	}
;;;86     }
000082  bdf8              POP      {r3-r7,pc}
                  |L1.132|
000084  6326              STR      r6,[r4,#0x30]         ;64
000086  bdf8              POP      {r3-r7,pc}
                  |L1.136|
000088  21ff              MOVS     r1,#0xff              ;75
00008a  3191              ADDS     r1,r1,#0x91           ;75
00008c  f7fffffe          BL       __aeabi_uidivmod
000090  29c8              CMP      r1,#0xc8              ;76
000092  d2f7              BCS      |L1.132|
000094  e7f4              B        |L1.128|
;;;87     
                          ENDP

                  ErrorManager PROC
;;;90     // to make sure then responding time will not burn the board
;;;91     void ErrorManager(void)
000096  b510              PUSH     {r4,lr}
;;;92     {
;;;93     	static uint32_t staLastErrorChangeTime;
;;;94     	static ENUM_ERROR_LEVEL lastErrorType = ERR_NULL;
;;;95     	ENUM_ERROR_LEVEL errorFetched;
;;;96     	errorFetched = getPrecedenceError();
000098  f7fffffe          BL       getPrecedenceError
;;;97     
;;;98     	if (lastErrorType != errorFetched)
00009c  4a07              LDR      r2,|L1.188|
00009e  7811              LDRB     r1,[r2,#0]  ; lastErrorType
0000a0  4281              CMP      r1,r0
0000a2  d004              BEQ      |L1.174|
;;;99     	{
;;;100    		lastErrorType = errorFetched;
;;;101    		// error type changed (maybe changed to no error)
;;;102    		staLastErrorChangeTime = iSystemTick;
0000a4  4907              LDR      r1,|L1.196|
0000a6  7010              STRB     r0,[r2,#0]            ;100
0000a8  6809              LDR      r1,[r1,#0]  ; iSystemTick
;;;103    		// No matter there is error or not, process!!
;;;104    		LEDBlinkHandler(errorFetched, staLastErrorChangeTime);
0000aa  6051              STR      r1,[r2,#4]  ; staLastErrorChangeTime
0000ac  e002              B        |L1.180|
                  |L1.174|
;;;105    	}
;;;106    	else
;;;107    	{
;;;108    		// Still same error (maybe no error)
;;;109    		// Only process when there is some error
;;;110    		if (ERR_NULL != errorFetched)
0000ae  2800              CMP      r0,#0
0000b0  d002              BEQ      |L1.184|
;;;111    		{
;;;112    			LEDBlinkHandler(errorFetched, staLastErrorChangeTime);
0000b2  6851              LDR      r1,[r2,#4]  ; staLastErrorChangeTime
                  |L1.180|
0000b4  f7fffffe          BL       LEDBlinkHandler
                  |L1.184|
;;;113    		}	
;;;114    	}
;;;115    	
;;;116    }
0000b8  bd10              POP      {r4,pc}
;;;117    
                          ENDP

0000ba  0000              DCW      0x0000
                  |L1.188|
                          DCD      ||.data||
                  |L1.192|
                          DCD      0x50004280
                  |L1.196|
                          DCD      iSystemTick

                          AREA ||.data||, DATA, ALIGN=2

                  lastErrorType
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  staLastErrorChangeTime
                          DCD      0x00000000
                  iErrorMaster
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "User\\Error.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_Error_c_ca138499____REV16|
#line 118 ".\\CMSIS\\core_cmInstr.h"
|__asm___7_Error_c_ca138499____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_Error_c_ca138499____REVSH|
#line 132
|__asm___7_Error_c_ca138499____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
