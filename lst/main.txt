; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\Mini51Series\Include -I..\..\..\Library\StdDriver\inc -I.\StdDriver\inc -I.\CMSIS -IG:\Geek\Projects\Zulolo_F\Force\Code\Zulolo_F_Force\RTE -ID:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.0.2\Device\Mini51\Include -ID:\Keil_v5\ARM\CMSIS\Include -I\ -D__MICROLIB -D__UVISION_VERSION=518 --omf_browse=.\obj\main.crf User\main.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  NVIC_SetPriority PROC
;;;570     */
;;;571    __STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
000000  0783              LSLS     r3,r0,#30
;;;572    {
;;;573      if(IRQn < 0) {
;;;574        SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
000002  22ff              MOVS     r2,#0xff
000004  0edb              LSRS     r3,r3,#27
000006  409a              LSLS     r2,r2,r3
000008  0789              LSLS     r1,r1,#30
00000a  0e09              LSRS     r1,r1,#24
00000c  4099              LSLS     r1,r1,r3
00000e  2800              CMP      r0,#0                 ;573
000010  da0b              BGE      |L1.42|
000012  0700              LSLS     r0,r0,#28
000014  0f00              LSRS     r0,r0,#28
000016  3808              SUBS     r0,r0,#8
000018  0883              LSRS     r3,r0,#2
00001a  48ff              LDR      r0,|L1.1048|
00001c  009b              LSLS     r3,r3,#2
00001e  1818              ADDS     r0,r3,r0
000020  69c3              LDR      r3,[r0,#0x1c]
000022  4393              BICS     r3,r3,r2
000024  430b              ORRS     r3,r3,r1
000026  61c3              STR      r3,[r0,#0x1c]
;;;575            (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
;;;576      else {
;;;577        NVIC->IP[_IP_IDX(IRQn)] = (NVIC->IP[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
;;;578            (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
;;;579    }
000028  4770              BX       lr
                  |L1.42|
00002a  0883              LSRS     r3,r0,#2              ;577
00002c  48fb              LDR      r0,|L1.1052|
00002e  009b              LSLS     r3,r3,#2              ;577
000030  1818              ADDS     r0,r3,r0              ;577
000032  6803              LDR      r3,[r0,#0]            ;577
000034  4393              BICS     r3,r3,r2              ;577
000036  430b              ORRS     r3,r3,r1              ;577
000038  6003              STR      r3,[r0,#0]            ;577
00003a  4770              BX       lr
;;;580    
                          ENDP

                  initClk PROC
;;;15     
;;;16     void initClk()
00003c  b5f8              PUSH     {r3-r7,lr}
;;;17     {
;;;18         /* Enable internal 22.1184MHz */
;;;19         CLK->PWRCON |= CLK_PWRCON_IRC22M_EN_Msk;
00003e  48f8              LDR      r0,|L1.1056|
000040  6801              LDR      r1,[r0,#0]
000042  2204              MOVS     r2,#4
000044  4311              ORRS     r1,r1,r2
000046  6001              STR      r1,[r0,#0]
;;;20     
;;;21         /* Waiting for clock ready */
;;;22         CLK_WaitClockReady(CLK_CLKSTATUS_IRC22M_STB_Msk);
000048  2010              MOVS     r0,#0x10
00004a  f7fffffe          BL       CLK_WaitClockReady
;;;23     
;;;24         // Configure HCLK to use 22.1184MHz HIRC and div by 1
;;;25         CLK_SetHCLK(CLK_CLKSEL0_HCLK_S_IRC22M, CLK_CLKDIV_HCLK(1));
00004e  2100              MOVS     r1,#0
000050  2007              MOVS     r0,#7
000052  f7fffffe          BL       CLK_SetHCLK
;;;26     //	CLK_DisableXtalRC(CLK_PWRCON_XTLCLK_EN_Msk);
;;;27     
;;;28         // Configure SysTick to use HIRC
;;;29     //	SetSysTickClockSrc(CLK_CLKSEL0_STCLK_S_IRC22M_DIV2);
;;;30     
;;;31     //    CLK_SetSysTickClockSrc(CLK_CLKSEL0_STCLK_S_HCLK_DIV2);
;;;32         CLK_SetModuleClock(WDT_MODULE, CLK_CLKSEL1_WDT_S_HCLK_DIV2048, WHAT_EVER_DO_NOT_CARE);
000056  4cf3              LDR      r4,|L1.1060|
000058  2201              MOVS     r2,#1
00005a  2102              MOVS     r1,#2
00005c  4620              MOV      r0,r4
00005e  f7fffffe          BL       CLK_SetModuleClock
;;;33         CLK_SetModuleClock(ADC_MODULE, CLK_CLKSEL1_ADC_S_IRC22M, CLK_CLKDIV_ADC(ADC_CLK_DIVIDER));
000062  4df1              LDR      r5,|L1.1064|
000064  2237              MOVS     r2,#0x37
000066  0492              LSLS     r2,r2,#18
000068  210c              MOVS     r1,#0xc
00006a  4628              MOV      r0,r5
00006c  f7fffffe          BL       CLK_SetModuleClock
;;;34         CLK_SetModuleClock(PWM01_MODULE, CLK_CLKSEL1_PWM01_S_HCLK, WHAT_EVER_DO_NOT_CARE);
000070  4eee              LDR      r6,|L1.1068|
000072  2201              MOVS     r2,#1
000074  0751              LSLS     r1,r2,#29
000076  4630              MOV      r0,r6
000078  f7fffffe          BL       CLK_SetModuleClock
;;;35         CLK_SetModuleClock(PWM23_MODULE, CLK_CLKSEL1_PWM23_S_HCLK, WHAT_EVER_DO_NOT_CARE);
00007c  4fec              LDR      r7,|L1.1072|
00007e  2201              MOVS     r2,#1
000080  07d1              LSLS     r1,r2,#31
000082  4638              MOV      r0,r7
000084  f7fffffe          BL       CLK_SetModuleClock
;;;36         CLK_SetModuleClock(PWM45_MODULE, CLK_CLKSEL2_PWM45_S_HCLK, WHAT_EVER_DO_NOT_CARE);
000088  2201              MOVS     r2,#1
00008a  2120              MOVS     r1,#0x20
00008c  48e9              LDR      r0,|L1.1076|
00008e  f7fffffe          BL       CLK_SetModuleClock
;;;37         CLK_SetModuleClock(UART_MODULE, CLK_CLKSEL1_UART_S_IRC22M, CLK_CLKDIV_UART(UART_CLK_DIVIDER));
000092  2101              MOVS     r1,#1
000094  2200              MOVS     r2,#0
000096  0649              LSLS     r1,r1,#25
000098  48e7              LDR      r0,|L1.1080|
00009a  f7fffffe          BL       CLK_SetModuleClock
;;;38         CLK_SetModuleClock(TMR0_MODULE, CLK_CLKSEL1_TMR0_S_HCLK , WHAT_EVER_DO_NOT_CARE);
00009e  2201              MOVS     r2,#1
0000a0  0251              LSLS     r1,r2,#9
0000a2  48e6              LDR      r0,|L1.1084|
0000a4  f7fffffe          BL       CLK_SetModuleClock
;;;39         CLK_SetModuleClock(TMR1_MODULE, CLK_CLKSEL1_TMR1_S_HCLK , WHAT_EVER_DO_NOT_CARE);
0000a8  2201              MOVS     r2,#1
0000aa  0351              LSLS     r1,r2,#13
0000ac  48e4              LDR      r0,|L1.1088|
0000ae  f7fffffe          BL       CLK_SetModuleClock
;;;40         CLK_SetModuleClock(SPI_MODULE, CLK_CLKSEL1_SPI_S_HCLK  , WHAT_EVER_DO_NOT_CARE);
0000b2  2201              MOVS     r2,#1
0000b4  4611              MOV      r1,r2
0000b6  48e3              LDR      r0,|L1.1092|
0000b8  f7fffffe          BL       CLK_SetModuleClock
;;;41     
;;;42         // Nai nai de seems can not use | | | to put all peripheral enable into one invoke
;;;43         CLK_EnableModuleClock(WDT_MODULE);
0000bc  4620              MOV      r0,r4
0000be  f7fffffe          BL       CLK_EnableModuleClock
;;;44         CLK_EnableModuleClock(TMR0_MODULE);
0000c2  48de              LDR      r0,|L1.1084|
0000c4  f7fffffe          BL       CLK_EnableModuleClock
;;;45         CLK_EnableModuleClock(TMR1_MODULE);
0000c8  48dd              LDR      r0,|L1.1088|
0000ca  f7fffffe          BL       CLK_EnableModuleClock
;;;46         CLK_EnableModuleClock(SPI_MODULE);
0000ce  48dd              LDR      r0,|L1.1092|
0000d0  f7fffffe          BL       CLK_EnableModuleClock
;;;47         CLK_EnableModuleClock(UART_MODULE);
0000d4  48d8              LDR      r0,|L1.1080|
0000d6  f7fffffe          BL       CLK_EnableModuleClock
;;;48         CLK_EnableModuleClock(PWM01_MODULE);
0000da  4630              MOV      r0,r6
0000dc  f7fffffe          BL       CLK_EnableModuleClock
;;;49         CLK_EnableModuleClock(PWM23_MODULE);
0000e0  4638              MOV      r0,r7
0000e2  f7fffffe          BL       CLK_EnableModuleClock
;;;50         CLK_EnableModuleClock(PWM45_MODULE);
0000e6  48d3              LDR      r0,|L1.1076|
0000e8  f7fffffe          BL       CLK_EnableModuleClock
;;;51         CLK_EnableModuleClock(ADC_MODULE);
0000ec  4628              MOV      r0,r5
0000ee  f7fffffe          BL       CLK_EnableModuleClock
;;;52         CLK_EnableModuleClock(ACMP_MODULE);
0000f2  48d5              LDR      r0,|L1.1096|
0000f4  f7fffffe          BL       CLK_EnableModuleClock
;;;53     }
0000f8  bdf8              POP      {r3-r7,pc}
;;;54     
                          ENDP

                  initIRQ PROC
;;;55     void initIRQ()
0000fa  b510              PUSH     {r4,lr}
;;;56     {
;;;57         NVIC_EnableIRQ(TMR0_IRQn);
0000fc  2008              MOVS     r0,#8
0000fe  f7fffffe          BL       NVIC_EnableIRQ
;;;58         NVIC_EnableIRQ(TMR1_IRQn);
000102  2009              MOVS     r0,#9
000104  f7fffffe          BL       NVIC_EnableIRQ
;;;59         NVIC_EnableIRQ(SPI_IRQn);
000108  200e              MOVS     r0,#0xe
00010a  f7fffffe          BL       NVIC_EnableIRQ
;;;60         NVIC_EnableIRQ(ACMP_IRQn);
00010e  2019              MOVS     r0,#0x19
000110  f7fffffe          BL       NVIC_EnableIRQ
;;;61         NVIC_EnableIRQ(EINT0_IRQn);
000114  2002              MOVS     r0,#2
000116  f7fffffe          BL       NVIC_EnableIRQ
;;;62         NVIC_EnableIRQ(ADC_IRQn);
00011a  201d              MOVS     r0,#0x1d
00011c  f7fffffe          BL       NVIC_EnableIRQ
;;;63     //    NVIC_EnableIRQ(PWM_IRQn);
;;;64     
;;;65         NVIC_SetPriority(TMR0_IRQn, 1);
000120  2101              MOVS     r1,#1
000122  2008              MOVS     r0,#8
000124  f7fffffe          BL       NVIC_SetPriority
;;;66         NVIC_SetPriority(TMR1_IRQn, 1);
000128  2101              MOVS     r1,#1
00012a  2009              MOVS     r0,#9
00012c  f7fffffe          BL       NVIC_SetPriority
;;;67         NVIC_SetPriority(SPI_IRQn, 3);
000130  2103              MOVS     r1,#3
000132  200e              MOVS     r0,#0xe
000134  f7fffffe          BL       NVIC_SetPriority
;;;68         NVIC_SetPriority(ACMP_IRQn, 2);
000138  2102              MOVS     r1,#2
00013a  2019              MOVS     r0,#0x19
00013c  f7fffffe          BL       NVIC_SetPriority
;;;69         NVIC_SetPriority(EINT0_IRQn, 0);
000140  2100              MOVS     r1,#0
000142  2002              MOVS     r0,#2
000144  f7fffffe          BL       NVIC_SetPriority
;;;70         NVIC_SetPriority(ADC_IRQn, 3);
000148  2103              MOVS     r1,#3
00014a  201d              MOVS     r0,#0x1d
00014c  f7fffffe          BL       NVIC_SetPriority
;;;71     //    NVIC_SetPriority(PWM_IRQn, 2);
;;;72     
;;;73         GPIO_EnableEINT0(BRG_FAULT_PORT, BRG_FAULT_PIN, GPIO_INT_FALLING);
000150  2201              MOVS     r2,#1
000152  2104              MOVS     r1,#4
000154  48bd              LDR      r0,|L1.1100|
000156  f7fffffe          BL       GPIO_EnableInt
;;;74     }
00015a  bd10              POP      {r4,pc}
;;;75     
                          ENDP

                  initGPIO PROC
;;;76     void initGPIO()
00015c  b5f8              PUSH     {r3-r7,lr}
;;;77     {
;;;78     /*---------------------------------------------------------------------------------------------------------*/
;;;79     /* GPIO configuration                                                                                 	   */
;;;80     /*---------------------------------------------------------------------------------------------------------*/
;;;81         // LED Pin
;;;82         GPIO_SetMode(LED_PORT, LED_PIN, GPIO_PMD_OUTPUT);
00015e  4cbb              LDR      r4,|L1.1100|
000160  2201              MOVS     r2,#1
000162  3480              ADDS     r4,r4,#0x80
000164  2110              MOVS     r1,#0x10
000166  4620              MOV      r0,r4
000168  f7fffffe          BL       GPIO_SetMode
;;;83     
;;;84         // Bridge Enable Pin
;;;85         GPIO_SetMode(BRG_EN_PORT, BRG_EN_PIN, GPIO_PMD_OUTPUT);
00016c  4db7              LDR      r5,|L1.1100|
00016e  2201              MOVS     r2,#1
000170  4611              MOV      r1,r2
000172  4628              MOV      r0,r5
000174  f7fffffe          BL       GPIO_SetMode
;;;86         BRG_DISABLE;
000178  48b5              LDR      r0,|L1.1104|
00017a  2700              MOVS     r7,#0
00017c  6207              STR      r7,[r0,#0x20]
;;;87     
;;;88         // Bridge Fault Pin
;;;89         GPIO_SetMode(BRG_FAULT_PORT, BRG_FAULT_PIN, GPIO_PMD_INPUT);
00017e  463a              MOV      r2,r7
000180  2104              MOVS     r1,#4
000182  4628              MOV      r0,r5
000184  f7fffffe          BL       GPIO_SetMode
;;;90     
;;;91         // PWM Pin
;;;92         GPIO_SetMode(MOSFET_DRV_0_4_PORT, MOSFET_DRV_0_PIN | MOSFET_DRV_1_PIN | MOSFET_DRV_2_PIN | 
000188  48b0              LDR      r0,|L1.1100|
00018a  2201              MOVS     r2,#1
00018c  217c              MOVS     r1,#0x7c
00018e  3840              SUBS     r0,r0,#0x40
000190  f7fffffe          BL       GPIO_SetMode
;;;93     			     MOSFET_DRV_3_PIN | MOSFET_DRV_4_PIN, GPIO_PMD_OUTPUT);
;;;94         GPIO_SetMode(MOSFET_DRV_5_PORT, MOSFET_DRV_5_PIN, GPIO_PMD_OUTPUT);
000194  4ead              LDR      r6,|L1.1100|
000196  2201              MOVS     r2,#1
000198  3ec0              SUBS     r6,r6,#0xc0
00019a  2110              MOVS     r1,#0x10
00019c  4630              MOV      r0,r6
00019e  f7fffffe          BL       GPIO_SetMode
;;;95     
;;;96         // SPI, I am slave
;;;97         GPIO_SetMode(COMM_PORT, COMM_CLK_PIN | COMM_CS_PIN | COMM_RX_PIN, GPIO_PMD_INPUT);
0001a2  2200              MOVS     r2,#0
0001a4  21a2              MOVS     r1,#0xa2
0001a6  4630              MOV      r0,r6
0001a8  f7fffffe          BL       GPIO_SetMode
;;;98         GPIO_SetMode(COMM_PORT, COMM_TX_PIN, GPIO_PMD_OUTPUT);
0001ac  2201              MOVS     r2,#1
0001ae  2140              MOVS     r1,#0x40
0001b0  4630              MOV      r0,r6
0001b2  f7fffffe          BL       GPIO_SetMode
;;;99     
;;;100        // UART Pin
;;;101        GPIO_SetMode(DEBUG_TX_PORT, DEBUG_TX_PIN, GPIO_PMD_OUTPUT);
0001b6  2201              MOVS     r2,#1
0001b8  4611              MOV      r1,r2
0001ba  4630              MOV      r0,r6
0001bc  f7fffffe          BL       GPIO_SetMode
;;;102        GPIO_SetMode(DEBUG_RX_PORT, DEBUG_RX_PIN, GPIO_PMD_INPUT);
0001c0  4ea2              LDR      r6,|L1.1100|
0001c2  2200              MOVS     r2,#0
0001c4  3e80              SUBS     r6,r6,#0x80
0001c6  2104              MOVS     r1,#4
0001c8  4630              MOV      r0,r6
0001ca  f7fffffe          BL       GPIO_SetMode
;;;103    
;;;104        // DEBUG for ACMP Output Pin
;;;105        GPIO_SetMode(DEBUG_ACMP_OUT_PORT, DEBUG_ACMP_OUT_PIN, GPIO_PMD_OUTPUT);
0001ce  2201              MOVS     r2,#1
0001d0  2140              MOVS     r1,#0x40
0001d2  4628              MOV      r0,r5
0001d4  f7fffffe          BL       GPIO_SetMode
;;;106    	GPIO_SetMode(DEBUG_GPIO_PORT, DEBUG_GPIO_PIN, GPIO_PMD_OUTPUT);
0001d8  2201              MOVS     r2,#1
0001da  4611              MOV      r1,r2
0001dc  4620              MOV      r0,r4
0001de  f7fffffe          BL       GPIO_SetMode
;;;107    	P50 = 0;
0001e2  489b              LDR      r0,|L1.1104|
0001e4  3040              ADDS     r0,r0,#0x40
0001e6  6207              STR      r7,[r0,#0x20]
;;;108    
;;;109        // ADC for current Pin
;;;110        GPIO_DISABLE_DIGITAL_PATH(CURRENT_PORT, CURRENT_PIN << GPIO_OFFD_OFF_SET);
0001e8  6860              LDR      r0,[r4,#4]
0001ea  2101              MOVS     r1,#1
0001ec  04c9              LSLS     r1,r1,#19
0001ee  4308              ORRS     r0,r0,r1
0001f0  6060              STR      r0,[r4,#4]
;;;111        GPIO_SetMode(CURRENT_PORT, CURRENT_PIN, GPIO_PMD_INPUT);
0001f2  2200              MOVS     r2,#0
0001f4  2108              MOVS     r1,#8
0001f6  4620              MOV      r0,r4
0001f8  f7fffffe          BL       GPIO_SetMode
;;;112        // ADC for battery Pin
;;;113        GPIO_DISABLE_DIGITAL_PATH(BATTERY_V_PORT, BATTERY_V_PIN << GPIO_OFFD_OFF_SET);
0001fc  6868              LDR      r0,[r5,#4]
0001fe  2101              MOVS     r1,#1
000200  0449              LSLS     r1,r1,#17
000202  4308              ORRS     r0,r0,r1
000204  6068              STR      r0,[r5,#4]
;;;114        GPIO_SetMode(BATTERY_V_PORT, BATTERY_V_PIN, GPIO_PMD_INPUT);
000206  2200              MOVS     r2,#0
000208  2102              MOVS     r1,#2
00020a  4628              MOV      r0,r5
00020c  f7fffffe          BL       GPIO_SetMode
;;;115    	    
;;;116        // ACMP Pin
;;;117        GPIO_DISABLE_DIGITAL_PATH(ZERO_DETECT_PORT, (ZERO_DETECT_A_PIN | ZERO_DETECT_B_PIN |
000210  6870              LDR      r0,[r6,#4]
000212  2139              MOVS     r1,#0x39
000214  0409              LSLS     r1,r1,#16
000216  4308              ORRS     r0,r0,r1
000218  6070              STR      r0,[r6,#4]
;;;118    			      ZERO_DETECT_C_PIN | ZERO_DETECT_M_PIN) << GPIO_OFFD_OFF_SET);
;;;119        GPIO_SetMode(ZERO_DETECT_PORT, ZERO_DETECT_A_PIN | ZERO_DETECT_B_PIN |
00021a  2200              MOVS     r2,#0
00021c  2139              MOVS     r1,#0x39
00021e  4630              MOV      r0,r6
000220  f7fffffe          BL       GPIO_SetMode
;;;120    		 ZERO_DETECT_C_PIN | ZERO_DETECT_M_PIN, GPIO_PMD_INPUT);
;;;121    /*---------------------------------------------------------------------------------------------------------*/
;;;122    /* Init I/O Multi-function                                                                                 */
;;;123    /*---------------------------------------------------------------------------------------------------------*/
;;;124        /* Set multi-function pins for UART RXD and TXD */
;;;125        SYS->P0_MFP &= ~SYS_MFP_P00_Msk;
000224  05a0              LSLS     r0,r4,#22
000226  6b01              LDR      r1,[r0,#0x30]
000228  4a8a              LDR      r2,|L1.1108|
00022a  4011              ANDS     r1,r1,r2
00022c  6301              STR      r1,[r0,#0x30]
;;;126        SYS->P0_MFP |= SYS_MFP_P00_TXD;  
00022e  6b01              LDR      r1,[r0,#0x30]
000230  24ff              MOVS     r4,#0xff
000232  3402              ADDS     r4,#2
000234  4321              ORRS     r1,r1,r4
000236  6301              STR      r1,[r0,#0x30]
;;;127        SYS->P1_MFP &= ~SYS_MFP_P12_Msk;
000238  6b41              LDR      r1,[r0,#0x34]
00023a  4b87              LDR      r3,|L1.1112|
00023c  4019              ANDS     r1,r1,r3
00023e  6341              STR      r1,[r0,#0x34]
;;;128        SYS->P1_MFP |= SYS_MFP_P12_RXD; 
000240  6b41              LDR      r1,[r0,#0x34]
000242  2201              MOVS     r2,#1
000244  0292              LSLS     r2,r2,#10
000246  4311              ORRS     r1,r1,r2
000248  6341              STR      r1,[r0,#0x34]
;;;129    	 
;;;130    	/* Set multi-function pins for SPI */
;;;131        SYS->P0_MFP &= ~(SYS_MFP_P01_Msk | SYS_MFP_P05_Msk | SYS_MFP_P06_Msk | SYS_MFP_P07_Msk);
00024a  6b01              LDR      r1,[r0,#0x30]
00024c  4a83              LDR      r2,|L1.1116|
00024e  4011              ANDS     r1,r1,r2
000250  6301              STR      r1,[r0,#0x30]
;;;132        SYS->P0_MFP |= (SYS_MFP_P01_SPISS | SYS_MFP_P05_MOSI | SYS_MFP_P06_MISO | SYS_MFP_P07_SPICLK); 
000252  6b01              LDR      r1,[r0,#0x30]
000254  4a82              LDR      r2,|L1.1120|
000256  4311              ORRS     r1,r1,r2
000258  6301              STR      r1,[r0,#0x30]
;;;133    
;;;134    	/* Set multi-function pins for ADC for current */
;;;135        SYS->P5_MFP &= ~SYS_MFP_P53_Msk;
00025a  4982              LDR      r1,|L1.1124|
00025c  684a              LDR      r2,[r1,#4]
00025e  4d82              LDR      r5,|L1.1128|
000260  402a              ANDS     r2,r2,r5
000262  604a              STR      r2,[r1,#4]
;;;136        SYS->P5_MFP |= SYS_MFP_P53_AIN0;  
000264  684a              LDR      r2,[r1,#4]
000266  2508              MOVS     r5,#8
000268  432a              ORRS     r2,r2,r5
00026a  604a              STR      r2,[r1,#4]
;;;137    
;;;138    	/* Set multi-function pins for ADC for battery */
;;;139        SYS->P3_MFP &= ~SYS_MFP_P31_Msk;
00026c  6bc2              LDR      r2,[r0,#0x3c]
00026e  105d              ASRS     r5,r3,#1
000270  402a              ANDS     r2,r2,r5
000272  63c2              STR      r2,[r0,#0x3c]
;;;140        SYS->P3_MFP |= SYS_MFP_P31_AIN7;  
000274  6bc2              LDR      r2,[r0,#0x3c]
000276  0065              LSLS     r5,r4,#1
000278  432a              ORRS     r2,r2,r5
00027a  63c2              STR      r2,[r0,#0x3c]
;;;141    
;;;142    	/* Set multi-function pins for ACMP output for debug */
;;;143        SYS->P3_MFP &= ~SYS_MFP_P36_Msk;
00027c  6bc2              LDR      r2,[r0,#0x3c]
00027e  4d7b              LDR      r5,|L1.1132|
000280  402a              ANDS     r2,r2,r5
000282  63c2              STR      r2,[r0,#0x3c]
;;;144        SYS->P3_MFP |= SYS_MFP_P36_CPO0;
000284  6bc2              LDR      r2,[r0,#0x3c]
000286  01a5              LSLS     r5,r4,#6
000288  432a              ORRS     r2,r2,r5
00028a  63c2              STR      r2,[r0,#0x3c]
;;;145        SYS->P5_MFP &= ~SYS_MFP_P50_Msk;
00028c  684a              LDR      r2,[r1,#4]
00028e  43a2              BICS     r2,r2,r4
000290  604a              STR      r2,[r1,#4]
;;;146        SYS->P5_MFP |= SYS_MFP_P50_GPIO;
000292  684a              LDR      r2,[r1,#4]
000294  604a              STR      r2,[r1,#4]
;;;147    
;;;148    	/* Set multi-function pins for ACMP */
;;;149        SYS->P1_MFP &= ~SYS_MFP_P14_Msk;
000296  6b41              LDR      r1,[r0,#0x34]
000298  4c75              LDR      r4,|L1.1136|
00029a  4021              ANDS     r1,r1,r4
00029c  6341              STR      r1,[r0,#0x34]
;;;150        SYS->P1_MFP |= SYS_MFP_P14_CPN0;  
00029e  6b42              LDR      r2,[r0,#0x34]
0002a0  10a9              ASRS     r1,r5,#2
0002a2  430a              ORRS     r2,r2,r1
0002a4  6342              STR      r2,[r0,#0x34]
;;;151    	// pp will changed in the 
;;;152    //    SYS->P1_MFP &= ~(SYS_MFP_P10_Msk | SYS_MFP_P13_Msk | SYS_MFP_P14_Msk | SYS_MFP_P15_Msk);
;;;153    //    SYS->P1_MFP |= (SYS_MFP_P10_CPP0 | SYS_MFP_P13_CPP0 | SYS_MFP_P14_CPN0 | SYS_MFP_P15_CPP0); 
;;;154    // 	          
;;;155        /* Set multi-function pins for PWM */
;;;156        SYS->P2_MFP &= ~(SYS_MFP_P22_Msk | SYS_MFP_P23_Msk | SYS_MFP_P24_Msk | SYS_MFP_P25_Msk | SYS_MFP_P26_Msk);
0002a6  6b82              LDR      r2,[r0,#0x38]
0002a8  4d72              LDR      r5,|L1.1140|
0002aa  402a              ANDS     r2,r2,r5
0002ac  6382              STR      r2,[r0,#0x38]
;;;157        SYS->P2_MFP = SYS_MFP_P22_PWM0 | SYS_MFP_P23_PWM1 | SYS_MFP_P24_PWM2 | SYS_MFP_P25_PWM3 |SYS_MFP_P26_PWM4;
0002ae  221f              MOVS     r2,#0x1f
0002b0  0292              LSLS     r2,r2,#10
0002b2  6382              STR      r2,[r0,#0x38]
;;;158        SYS->P0_MFP &= ~SYS_MFP_P04_Msk;
0002b4  6b02              LDR      r2,[r0,#0x30]
0002b6  4022              ANDS     r2,r2,r4
0002b8  6302              STR      r2,[r0,#0x30]
;;;159        SYS->P0_MFP |= SYS_MFP_P04_PWM5;  
0002ba  6b02              LDR      r2,[r0,#0x30]
0002bc  430a              ORRS     r2,r2,r1
0002be  6302              STR      r2,[r0,#0x30]
;;;160    
;;;161    	/* Set multi-function pins for EINT0 */
;;;162        SYS->P3_MFP &= ~SYS_MFP_P32_Msk;
0002c0  6bc1              LDR      r1,[r0,#0x3c]
0002c2  4019              ANDS     r1,r1,r3
0002c4  63c1              STR      r1,[r0,#0x3c]
;;;163        SYS->P3_MFP |= SYS_MFP_P32_INT0;  
0002c6  6bc1              LDR      r1,[r0,#0x3c]
0002c8  2204              MOVS     r2,#4
0002ca  4311              ORRS     r1,r1,r2
0002cc  63c1              STR      r1,[r0,#0x3c]
;;;164    	
;;;165    }
0002ce  bdf8              POP      {r3-r7,pc}
;;;166    
                          ENDP

                  configTIM PROC
;;;167    void configTIM(void)
0002d0  486a              LDR      r0,|L1.1148|
;;;168    {
;;;169    	// T0 used to change phase automatically
;;;170    	// T1 used to filter ZX
;;;171        TIMER0->TCSR  =  TIMER_TCSR_CRST_Msk | TIMER_PERIODIC_MODE | TIMER_TCSR_PERIODIC_SEL_Msk | TIMER_TCSR_TDR_EN_Msk + TIMER0_PRESCALE;   
0002d2  4969              LDR      r1,|L1.1144|
0002d4  6001              STR      r1,[r0,#0]
;;;172        TIMER1->TCSR  =  TIMER_TCSR_CRST_Msk | TIMER_CONTINUOUS_MODE | TIMER_TCSR_TDR_EN_Msk + TIMER1_PRESCALE; 
0002d6  496a              LDR      r1,|L1.1152|
0002d8  6201              STR      r1,[r0,#0x20]
;;;173        // TIMER1->TCSR |=  TIMER_TCSR_CEN_Msk ;    
;;;174    	//TIMER_EnableInt(TIMER0);                         
;;;175        //TIMER_EnableInt(TIMER1);
;;;176    }
0002da  4770              BX       lr
;;;177    
                          ENDP

                  configADC PROC
;;;178    void configADC(void)
0002dc  b510              PUSH     {r4,lr}
;;;179    {
;;;180    
;;;181        ADC_SetExtraSampleTime(ADC, 0 , ADC_SAMPLE_CLOCK_16);
0002de  4c69              LDR      r4,|L1.1156|
0002e0  2205              MOVS     r2,#5
0002e2  2100              MOVS     r1,#0
0002e4  4620              MOV      r0,r4
0002e6  f7fffffe          BL       ADC_SetExtraSampleTime
;;;182    
;;;183        // Enable channel 0 and 7 (Current and Battery)
;;;184    //    ADC_Open(ADC, 0, 0, ADC_BATTERY_CHN_MSK);	//ADC_CURRENT_CHN_MSK | ADC_BATTERY_CHN_MSK);	
;;;185    // Do NOT use this, it will clear all bit in ADCR
;;;186    
;;;187    
;;;188        // Power on ADC
;;;189        ADC_POWER_ON(ADC);
0002ea  6a20              LDR      r0,[r4,#0x20]
0002ec  2101              MOVS     r1,#1
0002ee  4308              ORRS     r0,r0,r1
0002f0  6220              STR      r0,[r4,#0x20]
;;;190    
;;;191        // ADC start triggered by TIM and take turn between current and battery
;;;192        // Use two ADC comparator to hardware trace the big cuurent or battery low
;;;193     
;;;194        // Configure and enable Comperator 0 to monitor channel 0(current) input greater or euqal to 93
;;;195        ADC_ENABLE_CMP0(ADC, ADC_CURRENT_CHN_IDX, ADC_CMP_GREATER_OR_EQUAL_TO, ADC_CURRENT_HIGH_THRS, ADC_CURRENT_HIGH_CNT);
0002f2  4865              LDR      r0,|L1.1160|
0002f4  62a0              STR      r0,[r4,#0x28]
;;;196        // Configure and enable Comperator 1 to monitor channel 7(battery) input less than 0x200	
;;;197        ADC_ENABLE_CMP1(ADC, ADC_BATTERY_CHN_IDX, ADC_CMP_LESS_THAN, ADC_BAT_LOW_THRS, ADC_BAT_LOW_CNT);    
0002f6  4865              LDR      r0,|L1.1164|
0002f8  62e0              STR      r0,[r4,#0x2c]
;;;198    
;;;199        // Enable ADC comparator 0 and 1 interrupt
;;;200        ADC_EnableInt(ADC, ADC_ADF_INT);
0002fa  4620              MOV      r0,r4
0002fc  f7fffffe          BL       ADC_EnableInt
;;;201        ADC_EnableInt(ADC, ADC_CMP0_INT);
000300  2102              MOVS     r1,#2
000302  4620              MOV      r0,r4
000304  f7fffffe          BL       ADC_EnableInt
;;;202        ADC_EnableInt(ADC, ADC_CMP1_INT);
000308  2104              MOVS     r1,#4
00030a  4620              MOV      r0,r4
00030c  f7fffffe          BL       ADC_EnableInt
;;;203    
;;;204        ADC_SET_INPUT_CHANNEL(ADC, ADC_BATTERY_CHN_MSK);
000310  6a60              LDR      r0,[r4,#0x24]
000312  0a00              LSRS     r0,r0,#8
000314  0200              LSLS     r0,r0,#8
000316  3080              ADDS     r0,r0,#0x80
000318  6260              STR      r0,[r4,#0x24]
;;;205        ADC_START_CONV(ADC);
00031a  6a20              LDR      r0,[r4,#0x20]
00031c  2101              MOVS     r1,#1
00031e  02c9              LSLS     r1,r1,#11
000320  4308              ORRS     r0,r0,r1
000322  6220              STR      r0,[r4,#0x20]
;;;206    }
000324  bd10              POP      {r4,pc}
;;;207    
                          ENDP

                  configSPI PROC
;;;208    void configSPI(void)
000326  b538              PUSH     {r3-r5,lr}
;;;209    {
;;;210    /*---------------------------------------------------------------------------------------------------------*/
;;;211    /* Init SPI                                                                                                */
;;;212    /*---------------------------------------------------------------------------------------------------------*/
;;;213        /* Configure as a slave, clock idle low, falling clock edge Tx, rising edge Rx and 32-bit transaction */
;;;214        /* Set IP clock divider. SPI clock rate = 10MHz */
;;;215        SPI_Close(SPI);
000328  4c59              LDR      r4,|L1.1168|
00032a  4620              MOV      r0,r4
00032c  f7fffffe          BL       SPI_Close
;;;216        SPI_ClearRxFIFO(SPI);
000330  4620              MOV      r0,r4
000332  f7fffffe          BL       SPI_ClearRxFIFO
;;;217        SPI_ClearTxFIFO(SPI);
000336  4620              MOV      r0,r4
000338  f7fffffe          BL       SPI_ClearTxFIFO
;;;218        // peripheral clock frequency of slave device must be faster than the bus clock frequency of the master
;;;219        SPI_Open(SPI, SPI_SLAVE, SPI_MODE_0, COMM_BIT_LENTH, COMM_BAUT_RATE);
00033c  4855              LDR      r0,|L1.1172|
00033e  2204              MOVS     r2,#4
000340  9000              STR      r0,[sp,#0]
000342  2310              MOVS     r3,#0x10
000344  0411              LSLS     r1,r2,#16
000346  4620              MOV      r0,r4
000348  f7fffffe          BL       SPI_Open
00034c  6820              LDR      r0,[r4,#0]
00034e  1521              ASRS     r1,r4,#20
000350  4388              BICS     r0,r0,r1
000352  6020              STR      r0,[r4,#0]
;;;220    
;;;221        SPI_SET_MSB_FIRST(SPI);
;;;222    
;;;223        // SS edge trigger
;;;224    //    // Set input slave select signal to level-trigger
;;;225    //    SPI->SSR |= SPI_SSR_SS_LTRIG_Msk;
;;;226    //    // Set slave select signal SPISS to be active at Low-level.
;;;227    //    SPI->SSR &= (~SPI_SSR_SS_LVL_Msk);
;;;228    
;;;229        /* Use FIFO */
;;;230        SPI_EnableFIFO(SPI, COMM_FIFO_LENGTH, COMM_FIFO_LENGTH - 1);
000354  2203              MOVS     r2,#3
000356  2104              MOVS     r1,#4
000358  4620              MOV      r0,r4
00035a  f7fffffe          BL       SPI_EnableFIFO
;;;231    
;;;232        /* Enable SPI Receive FIFO interrupt (interrupt when FIFO count is 4) */
;;;233        SPI_EnableInt(SPI, SPI_IE_MASK);
00035e  2101              MOVS     r1,#1
000360  4620              MOV      r0,r4
000362  f7fffffe          BL       SPI_EnableInt
;;;234    }
000366  bd38              POP      {r3-r5,pc}
;;;235    
                          ENDP

                  initPWM PROC
;;;241    
;;;242    void initPWM(void)
000368  b570              PUSH     {r4-r6,lr}
;;;243    {
;;;244        PWM_Stop(PWM, PWM_CHN_ALL_MSK);
00036a  4c4b              LDR      r4,|L1.1176|
00036c  213f              MOVS     r1,#0x3f
00036e  4620              MOV      r0,r4
000370  f7fffffe          BL       PWM_Stop
;;;245        PWM_SET_PRESCALER(PWM, 0, PWM_CHN01_PRESCALER);
000374  6820              LDR      r0,[r4,#0]
000376  0a00              LSRS     r0,r0,#8
000378  0200              LSLS     r0,r0,#8
00037a  1c40              ADDS     r0,r0,#1
00037c  6020              STR      r0,[r4,#0]
;;;246    //    PWM_SET_PRESCALER(PWM, 1, PWM_CHN01_PRESCALER);
;;;247        PWM_SET_PRESCALER(PWM, 2, PWM_CHN23_PRESCALER);
00037e  6820              LDR      r0,[r4,#0]
000380  21ff              MOVS     r1,#0xff
000382  0209              LSLS     r1,r1,#8
000384  4388              BICS     r0,r0,r1
000386  30ff              ADDS     r0,r0,#0xff
000388  3001              ADDS     r0,#1
00038a  6020              STR      r0,[r4,#0]
;;;248    //    PWM_SET_PRESCALER(PWM, 3, PWM_CHN23_PRESCALER);
;;;249        PWM_SET_PRESCALER(PWM, 4, PWM_CHN45_PRESCALER);
00038c  6820              LDR      r0,[r4,#0]
00038e  0209              LSLS     r1,r1,#8
000390  4388              BICS     r0,r0,r1
000392  2101              MOVS     r1,#1
000394  0409              LSLS     r1,r1,#16
000396  1840              ADDS     r0,r0,r1
000398  6020              STR      r0,[r4,#0]
;;;250    //    PWM_SET_PRESCALER(PWM, 5, PWM_CHN45_PRESCALER);
;;;251        PWM_SET_DIVIDER(PWM, 0, PWM_CLK_DIV_1);
00039a  6860              LDR      r0,[r4,#4]
00039c  08c0              LSRS     r0,r0,#3
00039e  00c0              LSLS     r0,r0,#3
0003a0  1d00              ADDS     r0,r0,#4
0003a2  6060              STR      r0,[r4,#4]
;;;252        PWM_SET_DIVIDER(PWM, 1, PWM_CLK_DIV_1);
0003a4  6860              LDR      r0,[r4,#4]
0003a6  2170              MOVS     r1,#0x70
0003a8  4388              BICS     r0,r0,r1
0003aa  3040              ADDS     r0,r0,#0x40
0003ac  6060              STR      r0,[r4,#4]
;;;253        PWM_SET_DIVIDER(PWM, 2, PWM_CLK_DIV_1);
0003ae  6860              LDR      r0,[r4,#4]
0003b0  0109              LSLS     r1,r1,#4
0003b2  4388              BICS     r0,r0,r1
0003b4  1521              ASRS     r1,r4,#20
0003b6  1840              ADDS     r0,r0,r1
0003b8  6060              STR      r0,[r4,#4]
;;;254        PWM_SET_DIVIDER(PWM, 3, PWM_CLK_DIV_1);
0003ba  6860              LDR      r0,[r4,#4]
0003bc  2107              MOVS     r1,#7
0003be  0309              LSLS     r1,r1,#12
0003c0  4388              BICS     r0,r0,r1
0003c2  2101              MOVS     r1,#1
0003c4  0389              LSLS     r1,r1,#14
0003c6  1840              ADDS     r0,r0,r1
0003c8  6060              STR      r0,[r4,#4]
;;;255        PWM_SET_DIVIDER(PWM, 4, PWM_CLK_DIV_1);
0003ca  6860              LDR      r0,[r4,#4]
0003cc  2107              MOVS     r1,#7
0003ce  0409              LSLS     r1,r1,#16
0003d0  4388              BICS     r0,r0,r1
0003d2  2101              MOVS     r1,#1
0003d4  0489              LSLS     r1,r1,#18
0003d6  1840              ADDS     r0,r0,r1
0003d8  6060              STR      r0,[r4,#4]
;;;256        PWM_SET_DIVIDER(PWM, 5, PWM_CLK_DIV_1);
0003da  6860              LDR      r0,[r4,#4]
0003dc  2107              MOVS     r1,#7
0003de  0509              LSLS     r1,r1,#20
0003e0  4388              BICS     r0,r0,r1
0003e2  0121              LSLS     r1,r4,#4
0003e4  1840              ADDS     r0,r0,r1
0003e6  6060              STR      r0,[r4,#4]
;;;257    
;;;258    //    PWM->PCR = PCR_CLR_COUNTER | PCR_DEBUG_MODE | PCR_CH_EN(0) | PCR_PERIOD_MODE(0) |
;;;259    //		PCR_CH_EN(1) | PCR_PERIOD_MODE(1) | PCR_CH_EN(2) | PCR_PERIOD_MODE(2) |
;;;260    //		PCR_CH_EN(3) | PCR_PERIOD_MODE(3) | PCR_CH_EN(4) | PCR_PERIOD_MODE(4) |
;;;261    //		PCR_CH_EN(5) | PCR_PERIOD_MODE(5) |
;;;262    //		PCR_INV_EN(0) | PCR_INV_EN(2) | PCR_INV_EN(4) |
;;;263    //		PCR_INV_EN(1) | PCR_INV_EN(3) | PCR_INV_EN(5);
;;;264        PWM->PCR = PCR_CLR_COUNTER | PCR_DEBUG_MODE |
0003e8  482c              LDR      r0,|L1.1180|
0003ea  60a0              STR      r0,[r4,#8]
;;;265    		PCR_CH_EN(0) | PCR_PERIOD_MODE(0) |  
;;;266    		PCR_CH_EN(1) | PCR_PERIOD_MODE(1) | 
;;;267    		PCR_CH_EN(2) | PCR_PERIOD_MODE(2) | 
;;;268    		PCR_CH_EN(3) | PCR_PERIOD_MODE(3) | 
;;;269    		PCR_CH_EN(4) | PCR_PERIOD_MODE(4) | 
;;;270    		PCR_CH_EN(5) | PCR_PERIOD_MODE(5) |
;;;271    		PCR_INV_EN(0) | PCR_INV_EN(2) | PCR_INV_EN(4) |
;;;272    		PCR_INV_EN(1) | PCR_INV_EN(3) | PCR_INV_EN(5);
;;;273    //    PWM_SET_ALIGNED_TYPE(PWM_EDGE_ALIGNED);
;;;274    //    PWM_ENABLE_GROUP_MODE(PWM);
;;;275        PWM->CMR[0] = 0;
0003ec  2500              MOVS     r5,#0
0003ee  6265              STR      r5,[r4,#0x24]
;;;276        PWM->CMR[1] = 0;
0003f0  62a5              STR      r5,[r4,#0x28]
;;;277        PWM->CMR[2] = 0;
0003f2  62e5              STR      r5,[r4,#0x2c]
;;;278        PWM->CMR[3] = 0;
0003f4  6325              STR      r5,[r4,#0x30]
;;;279        PWM->CMR[4] = 0;
0003f6  6365              STR      r5,[r4,#0x34]
;;;280        PWM->CMR[5] = 0;
0003f8  63a5              STR      r5,[r4,#0x38]
;;;281        PWM->CNR[0] = PWM_PERIOD; 
0003fa  4829              LDR      r0,|L1.1184|
0003fc  60e0              STR      r0,[r4,#0xc]
;;;282        PWM->CNR[1] = PWM_PERIOD;    
0003fe  6120              STR      r0,[r4,#0x10]
;;;283        PWM->CNR[2] = PWM_PERIOD;                                    
000400  6160              STR      r0,[r4,#0x14]
;;;284        PWM->CNR[3] = PWM_PERIOD;
000402  61a0              STR      r0,[r4,#0x18]
;;;285        PWM->CNR[4] = PWM_PERIOD; 
000404  61e0              STR      r0,[r4,#0x1c]
;;;286        PWM->CNR[5] = PWM_PERIOD;
000406  6220              STR      r0,[r4,#0x20]
;;;287        PWM_EnableOutput(PWM, PWM_CHN_ALL_MSK);
000408  213f              MOVS     r1,#0x3f
00040a  4620              MOV      r0,r4
00040c  f7fffffe          BL       PWM_EnableOutput
;;;288        PWM_INT_DISABLE;	// Disable all PWM interrupt 
000410  4821              LDR      r0,|L1.1176|
000412  3040              ADDS     r0,r0,#0x40
000414  6145              STR      r5,[r0,#0x14]
;;;289        BLDC_stopMotor();
000416  e045              B        |L1.1188|
                  |L1.1048|
                          DCD      0xe000ed00
                  |L1.1052|
                          DCD      0xe000e400
                  |L1.1056|
                          DCD      0x50000200
                  |L1.1060|
                          DCD      0x260c03e0
                  |L1.1064|
                          DCD      0x2623fe1c
                  |L1.1068|
                          DCD      0x27cc03f4
                  |L1.1072|
                          DCD      0x27ec03f5
                  |L1.1076|
                          DCD      0x664c03f6
                  |L1.1080|
                          DCD      0x27803d10
                  |L1.1084|
                          DCD      0x2e8c03e2
                  |L1.1088|
                          DCD      0x2ecc03e3
                  |L1.1092|
                          DCD      0x224c03ec
                  |L1.1096|
                          DCD      0x61fc03fe
                  |L1.1100|
                          DCD      0x500040c0
                  |L1.1104|
                          DCD      0x50004240
                  |L1.1108|
                          DCD      0xfefffefe
                  |L1.1112|
                          DCD      0xfffffbfb
                  |L1.1116|
                          DCD      0xfdff1d1d
                  |L1.1120|
                          DCD      0x0000e002
                  |L1.1124|
                          DCD      0x50000040
                  |L1.1128|
                          DCD      0xfffff7f7
                  |L1.1132|
                          DCD      0xffffbfbf
                  |L1.1136|
                          DCD      0xffffefef
                  |L1.1140|
                          DCD      0xffff8383
                  |L1.1144|
                          DCD      0x0c03000a
                  |L1.1148|
                          DCD      0x40010000
                  |L1.1152|
                          DCD      0x1c01000a
                  |L1.1156|
                          DCD      0x400e0000
                  |L1.1160|
                          DCD      0x00440b05
                  |L1.1164|
                          DCD      0x015c0f39
                  |L1.1168|
                          DCD      0x40030000
                  |L1.1172|
                          DCD      0x004c4b40
                  |L1.1176|
                          DCD      0x40040000
                  |L1.1180|
                          DCD      0x08dddddf
                  |L1.1184|
                          DCD      0x00000373
                  |L1.1188|
0004a4  f7fffffe          BL       BLDC_stopMotor
;;;290        //MOTOR_SHUT_DOWN;
;;;291    
;;;292        // PWM duty change every each phase for both ramp up and locked state
;;;293    //    PWM->INTACCUCTL = 0x41; // Every 4 PWM periods change duty
;;;294    			    // this will be used in locked time
;;;295    			    // During startup ramp, duty change every x E-Circle
;;;296        PWM->PHCHGMASK = PHCHG_CTL_CMP0;	// Input of ACMP0 is controlled by PHCHG
0004a8  4948              LDR      r1,|L1.1484|
0004aa  15a0              ASRS     r0,r4,#22
0004ac  6008              STR      r0,[r1,#0]
;;;297    }
0004ae  bd70              POP      {r4-r6,pc}
;;;298    
                          ENDP

                  initSys PROC
;;;299    void initSys(void)
0004b0  b510              PUSH     {r4,lr}
;;;300    {
;;;301        /* Unlock protected registers */
;;;302        SYS_UnlockReg();
0004b2  f7fffffe          BL       SYS_UnlockReg
;;;303        
;;;304        /* Clock initialization, Enable PWM, ADC, TIM, UART clock */
;;;305        initClk();
0004b6  f7fffffe          BL       initClk
;;;306        //CLK->APBCLK = CLK_APBCLK_UART_EN_Msk;
;;;307        
;;;308        /* Update System Core Clock */
;;;309        /* User can use SystemCoreClockUpdate() to calculate SystemCoreClock and cyclesPerUs automatically. */
;;;310        SystemCoreClockUpdate(); 
0004ba  f7fffffe          BL       SystemCoreClockUpdate
0004be  4c45              LDR      r4,|L1.1492|
0004c0  4843              LDR      r0,|L1.1488|
0004c2  6160              STR      r0,[r4,#0x14]
0004c4  2103              MOVS     r1,#3
0004c6  1f08              SUBS     r0,r1,#4
0004c8  f7fffffe          BL       NVIC_SetPriority
0004cc  2000              MOVS     r0,#0
0004ce  61a0              STR      r0,[r4,#0x18]
0004d0  2007              MOVS     r0,#7
0004d2  6120              STR      r0,[r4,#0x10]
;;;311    
;;;312        /* System tick Configuration */
;;;313        // SYS TICK interrupt will be entered every 5ms
;;;314        SysTick_Config(SYS_TICK_RELOAD_VALUE);
;;;315        
;;;316        /* PWM Configuration */
;;;317        // Close all MOSFET here first, then output GPIO
;;;318        initPWM();
0004d4  f7fffffe          BL       initPWM
;;;319          
;;;320        /* IO Configuration */
;;;321        initGPIO();
0004d8  f7fffffe          BL       initGPIO
;;;322    
;;;323        /* ACMP initialization */
;;;324        //ACMP_Config();
;;;325    
;;;326        /* ADC initialization */
;;;327        configADC();
0004dc  f7fffffe          BL       configADC
;;;328    
;;;329        /* TIM initialization */
;;;330        configTIM();
0004e0  f7fffffe          BL       configTIM
;;;331    
;;;332        /* SPI initialization */
;;;333        configSPI();
0004e4  f7fffffe          BL       configSPI
;;;334    
;;;335        /* Enable all interrupt from NVIC */
;;;336        initIRQ();
0004e8  f7fffffe          BL       initIRQ
;;;337    
;;;338        /* Lock protected registers */
;;;339        SYS_LockReg();
0004ec  f7fffffe          BL       SYS_LockReg
;;;340                             
;;;341    }    
0004f0  bd10              POP      {r4,pc}
;;;342    
                          ENDP

                  initEnv PROC
;;;343    void initEnv(void)
0004f2  4939              LDR      r1,|L1.1496|
;;;344    {
;;;345    	unCOM_SPI_TransCNT = 0;
0004f4  2000              MOVS     r0,#0
;;;346    	unCOM_SPI_TransErrCNT = 0;
0004f6  6008              STR      r0,[r1,#0]  ; unCOM_SPI_TransCNT
0004f8  4938              LDR      r1,|L1.1500|
;;;347    	unZXMatchCNT = 0;
0004fa  6008              STR      r0,[r1,#0]  ; unCOM_SPI_TransErrCNT
0004fc  4938              LDR      r1,|L1.1504|
0004fe  6008              STR      r0,[r1,#0]  ; unZXMatchCNT
;;;348    	tMotor.structMotor.MSR.bNewComFrameReceived = FALSE;
000500  4838              LDR      r0,|L1.1508|
000502  8841              LDRH     r1,[r0,#2]  ; tMotor
000504  2210              MOVS     r2,#0x10
000506  4391              BICS     r1,r1,r2
000508  8041              STRH     r1,[r0,#2]
;;;349    }
00050a  4770              BX       lr
;;;350    
                          ENDP

                  main PROC
;;;353    //	uint32_t iLeaveTime;
;;;354    int main()
00050c  f7fffffe          BL       initSys
;;;355    {
;;;356    
;;;357        initSys();
;;;358        initEnv();
000510  f7fffffe          BL       initEnv
;;;359    
;;;360        PTC_checkMotor();
000514  f7fffffe          BL       PTC_checkMotor
;;;361    
;;;362        /* ----==== Here is the parameter used for test ====----*/
;;;363        // Max PWM Duty is: PWM_PERIOD = 441
;;;364        // Max Period is:
;;;365        MOTOR_SHUT_DOWN;
000518  4933              LDR      r1,|L1.1512|
00051a  2000              MOVS     r0,#0
00051c  6208              STR      r0,[r1,#0x20]
00051e  4a2b              LDR      r2,|L1.1484|
000520  3a40              SUBS     r2,r2,#0x40
000522  6150              STR      r0,[r2,#0x14]
000524  4831              LDR      r0,|L1.1516|
000526  6801              LDR      r1,[r0,#0]
000528  0383              LSLS     r3,r0,#14
00052a  4399              BICS     r1,r1,r3
00052c  6001              STR      r1,[r0,#0]
00052e  492f              LDR      r1,|L1.1516|
000530  3120              ADDS     r1,r1,#0x20
000532  680c              LDR      r4,[r1,#0]
000534  439c              BICS     r4,r4,r3
000536  600c              STR      r4,[r1,#0]
000538  6804              LDR      r4,[r0,#0]
00053a  0343              LSLS     r3,r0,#13
00053c  439c              BICS     r4,r4,r3
00053e  6004              STR      r4,[r0,#0]
000540  6808              LDR      r0,[r1,#0]
000542  4398              BICS     r0,r0,r3
000544  6008              STR      r0,[r1,#0]
000546  20ff              MOVS     r0,#0xff
000548  63d0              STR      r0,[r2,#0x3c]
00054a  6390              STR      r0,[r2,#0x38]
;;;366    
;;;367        tMotor.structMotor.unLocatingDuty = 200;
00054c  4c25              LDR      r4,|L1.1508|
00054e  20c8              MOVS     r0,#0xc8
000550  80e0              STRH     r0,[r4,#6]
;;;368        tMotor.structMotor.unLocatingPeriod = 10;	// Unit ms
000552  200a              MOVS     r0,#0xa
000554  81e0              STRH     r0,[r4,#0xe]
;;;369        tMotor.structMotor.unRampUpDuty = 320;
000556  0140              LSLS     r0,r0,#5
000558  8120              STRH     r0,[r4,#8]
;;;370        tMotor.structMotor.unRampUpPeriod = 8000;	// Unit 2MH, 20ms, 500rpm
00055a  207d              MOVS     r0,#0x7d
00055c  0180              LSLS     r0,r0,#6
00055e  6160              STR      r0,[r4,#0x14]  ; tMotor
;;;371    	tMotor.structMotor.unTargetDuty = 400;
000560  20ff              MOVS     r0,#0xff
000562  3091              ADDS     r0,r0,#0x91
000564  8160              STRH     r0,[r4,#0xa]
;;;372    	tMotor.structMotor.MCR.bRotateDirection = ROTATE_CLOCKWISE;	// Clockwise
000566  8820              LDRH     r0,[r4,#0]  ; tMotor
000568  2102              MOVS     r1,#2
00056a  4388              BICS     r0,r0,r1
00056c  8020              STRH     r0,[r4,#0]
;;;373        tMotor.structMotor.MCR.bMotorNeedToRun = TRUE;
00056e  8820              LDRH     r0,[r4,#0]  ; tMotor
000570  2101              MOVS     r1,#1
000572  4308              ORRS     r0,r0,r1
000574  8020              STRH     r0,[r4,#0]
;;;374        /* ----=============== Test End ================---- */
;;;375    
;;;376        while(1)
;;;377        {
;;;378    //	if (TIMER_GetCounter(TIMER0) > 100 && TIMER_GetCounter(TIMER0) < 1000)
;;;379    //	{
;;;380    //	    imsTest = unSystemTick;
;;;381    //	}
;;;382    //	if (TIMER_GetCounter(TIMER0) > 30000 && TIMER_GetCounter(TIMER0) < 31000)
;;;383    //	{
;;;384    //	    imsTest = unSystemTick;
;;;385    //	}
;;;386    		BLDC_SensorLessManager();
;;;387    		COMM_Manager();
;;;388    		ERR_Manager();
;;;389    
;;;390    		// For test
;;;391    		if (TRUE == tMotor.structMotor.MSR.bLocked)
;;;392    		{
;;;393    			if (unSystemTick%5000 == 0)
000576  4f1e              LDR      r7,|L1.1520|
;;;394    			{
;;;395    				if (iTestSpeedLastTime != unSystemTick)
;;;396    				{
;;;397    					iTestSpeedLastTime = unSystemTick;
;;;398    					tMotor.structMotor.unTargetDuty = iTestSpeedSequence[iTestSpeedSequenIndex];
000578  4e1e              LDR      r6,|L1.1524|
00057a  4d1f              LDR      r5,|L1.1528|
                  |L1.1404|
00057c  f7fffffe          BL       BLDC_SensorLessManager
000580  f7fffffe          BL       COMM_Manager
000584  f7fffffe          BL       ERR_Manager
000588  8860              LDRH     r0,[r4,#2]            ;391  ; tMotor
00058a  0740              LSLS     r0,r0,#29             ;391
00058c  d5f6              BPL      |L1.1404|
00058e  4639              MOV      r1,r7                 ;393
000590  68a8              LDR      r0,[r5,#8]            ;393  ; unSystemTick
000592  f7fffffe          BL       __aeabi_uidivmod
000596  2900              CMP      r1,#0                 ;393
000598  d1f0              BNE      |L1.1404|
00059a  68a9              LDR      r1,[r5,#8]            ;395  ; unSystemTick
00059c  6868              LDR      r0,[r5,#4]            ;395  ; iTestSpeedLastTime
00059e  4288              CMP      r0,r1                 ;395
0005a0  d0ec              BEQ      |L1.1404|
0005a2  68a8              LDR      r0,[r5,#8]            ;397  ; unSystemTick
0005a4  6068              STR      r0,[r5,#4]  ; iTestSpeedLastTime
0005a6  7828              LDRB     r0,[r5,#0]  ; iTestSpeedSequenIndex
0005a8  0042              LSLS     r2,r0,#1
0005aa  5ab2              LDRH     r2,[r6,r2]
0005ac  8162              STRH     r2,[r4,#0xa]
;;;399    					INDEX_INCREASE(iTestSpeedSequenIndex, TEST_SPEED_SEQUENCE_NUM);
0005ae  280a              CMP      r0,#0xa
0005b0  d201              BCS      |L1.1462|
0005b2  1c40              ADDS     r0,r0,#1
0005b4  e000              B        |L1.1464|
                  |L1.1462|
0005b6  2000              MOVS     r0,#0
                  |L1.1464|
0005b8  7028              STRB     r0,[r5,#0]
0005ba  e7df              B        |L1.1404|
;;;400    				}
;;;401    			}
;;;402    		}
;;;403    	}
;;;404    
;;;405    }
;;;406    
                          ENDP

                  NVIC_EnableIRQ PROC
;;;503     */
;;;504    __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
0005bc  06c1              LSLS     r1,r0,#27
;;;505    {
;;;506      NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
0005be  0ec9              LSRS     r1,r1,#27
0005c0  2001              MOVS     r0,#1
0005c2  4088              LSLS     r0,r0,r1
0005c4  490d              LDR      r1,|L1.1532|
0005c6  6008              STR      r0,[r1,#0]
;;;507    }
0005c8  4770              BX       lr
;;;508    
                          ENDP

0005ca  0000              DCW      0x0000
                  |L1.1484|
                          DCD      0x40040080
                  |L1.1488|
                          DCD      0x0001affe
                  |L1.1492|
                          DCD      0xe000e000
                  |L1.1496|
                          DCD      unCOM_SPI_TransCNT
                  |L1.1500|
                          DCD      unCOM_SPI_TransErrCNT
                  |L1.1504|
                          DCD      unZXMatchCNT
                  |L1.1508|
                          DCD      tMotor
                  |L1.1512|
                          DCD      0x50004240
                  |L1.1516|
                          DCD      0x40010000
                  |L1.1520|
                          DCD      0x00001388
                  |L1.1524|
                          DCD      ||.constdata||
                  |L1.1528|
                          DCD      ||.data||
                  |L1.1532|
                          DCD      0xe000e100

                          AREA ||.constdata||, DATA, READONLY, ALIGN=1

                  iTestSpeedSequence
000000  00fa012c          DCW      0x00fa,0x012c
000004  015e0190          DCW      0x015e,0x0190
000008  01c2012c          DCW      0x01c2,0x012c
00000c  019000fa          DCW      0x0190,0x00fa
000010  00c801c2          DCW      0x00c8,0x01c2
000014  00c8              DCW      0x00c8

                          AREA ||.data||, DATA, ALIGN=2

                  iTestSpeedSequenIndex
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  iTestSpeedLastTime
                          DCD      0x00000000
                  unSystemTick
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "User\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_0ca38777____REV16|
#line 118 ".\\CMSIS\\core_cmInstr.h"
|__asm___6_main_c_0ca38777____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_0ca38777____REVSH|
#line 132
|__asm___6_main_c_0ca38777____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
