; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\Mini51Series\Include -I..\..\..\Library\StdDriver\inc -I.\StdDriver\inc -I.\CMSIS -I.\RTE\Device\Mini54ZDE -I.\RTE\_BLDC_driver -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.0\CMSIS\Include -ID:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.1.0\Device\Mini51\Driver -ID:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.1.0\Device\Mini51\Include -D__MICROLIB -D__UVISION_VERSION=524 -D_RTE_ -DCLK_APBCLK_ACMP_EN_Pos=CLK_APBCLK_CMP_EN_Pos -DFOR_CAR --omf_browse=.\obj\main.crf User\main.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  __NVIC_SetPriority PROC
;;;721     */
;;;722    __STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
000000  0783              LSLS     r3,r0,#30
;;;723    {
;;;724      if ((int32_t)(IRQn) >= 0)
;;;725      {
;;;726        NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
000002  22ff              MOVS     r2,#0xff
000004  0edb              LSRS     r3,r3,#27
000006  409a              LSLS     r2,r2,r3
000008  0789              LSLS     r1,r1,#30
00000a  0e09              LSRS     r1,r1,#24
00000c  4099              LSLS     r1,r1,r3
00000e  2800              CMP      r0,#0                 ;724
000010  db08              BLT      |L1.36|
000012  0883              LSRS     r3,r0,#2
000014  48fe              LDR      r0,|L1.1040|
000016  009b              LSLS     r3,r3,#2
000018  1818              ADDS     r0,r3,r0
00001a  6803              LDR      r3,[r0,#0]
00001c  4393              BICS     r3,r3,r2
00001e  430b              ORRS     r3,r3,r1
000020  6003              STR      r3,[r0,#0]
;;;727           (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
;;;728      }
;;;729      else
;;;730      {
;;;731        SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
;;;732           (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
;;;733      }
;;;734    }
000022  4770              BX       lr
                  |L1.36|
000024  0700              LSLS     r0,r0,#28             ;731
000026  0f00              LSRS     r0,r0,#28             ;731
000028  3808              SUBS     r0,r0,#8              ;731
00002a  0883              LSRS     r3,r0,#2              ;731
00002c  48f9              LDR      r0,|L1.1044|
00002e  009b              LSLS     r3,r3,#2              ;731
000030  1818              ADDS     r0,r3,r0              ;731
000032  69c3              LDR      r3,[r0,#0x1c]         ;731
000034  4393              BICS     r3,r3,r2              ;731
000036  430b              ORRS     r3,r3,r1              ;731
000038  61c3              STR      r3,[r0,#0x1c]         ;731
00003a  4770              BX       lr
;;;735    
                          ENDP

                  initClk PROC
;;;15     
;;;16     void initClk() {
00003c  b5f8              PUSH     {r3-r7,lr}
;;;17     	/* Enable internal 22.1184MHz */
;;;18     	CLK->PWRCON |= CLK_PWRCON_IRC22M_EN_Msk;
00003e  4cf6              LDR      r4,|L1.1048|
000040  6820              LDR      r0,[r4,#0]
000042  2104              MOVS     r1,#4
000044  4308              ORRS     r0,r0,r1
000046  6020              STR      r0,[r4,#0]
;;;19     
;;;20     	/* Waiting for clock ready */
;;;21     	CLK_WaitClockReady(CLK_CLKSTATUS_IRC22M_STB_Msk);
000048  2010              MOVS     r0,#0x10
00004a  f7fffffe          BL       CLK_WaitClockReady
;;;22     
;;;23     	// Configure HCLK to use 22.1184MHz HIRC and div by 1
;;;24     	CLK_SetHCLK(CLK_CLKSEL0_HCLK_S_IRC22M, CLK_CLKDIV_HCLK(1));
00004e  2100              MOVS     r1,#0
000050  2007              MOVS     r0,#7
000052  f7fffffe          BL       CLK_SetHCLK
;;;25     	//	CLK_DisableXtalRC(CLK_PWRCON_XTLCLK_EN_Msk);
;;;26     
;;;27     	// Configure SysTick to use HIRC
;;;28     	CLK_SetSysTickClockSrc(CLK_CLKSEL0_STCLK_S_IRC22M_DIV2);
000056  2038              MOVS     r0,#0x38
000058  f7fffffe          BL       CLK_SetSysTickClockSrc
;;;29     
;;;30     	//    CLK_SetSysTickClockSrc(CLK_CLKSEL0_STCLK_S_HCLK_DIV2);
;;;31     	CLK_SetModuleClock(WDT_MODULE, CLK_CLKSEL1_WDT_S_HCLK_DIV2048,WHAT_EVER_DO_NOT_CARE);
00005c  4def              LDR      r5,|L1.1052|
00005e  2201              MOVS     r2,#1
000060  2102              MOVS     r1,#2
000062  4628              MOV      r0,r5
000064  f7fffffe          BL       CLK_SetModuleClock
;;;32     	CLK_SetModuleClock(ADC_MODULE, CLK_CLKSEL1_ADC_S_IRC22M, CLK_CLKDIV_ADC(ADC_CLK_DIVIDER));
000068  4eed              LDR      r6,|L1.1056|
00006a  2237              MOVS     r2,#0x37
00006c  0492              LSLS     r2,r2,#18
00006e  210c              MOVS     r1,#0xc
000070  4630              MOV      r0,r6
000072  f7fffffe          BL       CLK_SetModuleClock
;;;33     	CLK_SetModuleClock(PWM01_MODULE, CLK_CLKSEL1_PWM01_S_HCLK, WHAT_EVER_DO_NOT_CARE);
000076  4feb              LDR      r7,|L1.1060|
000078  2201              MOVS     r2,#1
00007a  0751              LSLS     r1,r2,#29
00007c  4638              MOV      r0,r7
00007e  f7fffffe          BL       CLK_SetModuleClock
;;;34     	CLK_SetModuleClock(PWM23_MODULE, CLK_CLKSEL1_PWM23_S_HCLK,WHAT_EVER_DO_NOT_CARE);
000082  2201              MOVS     r2,#1
000084  07d1              LSLS     r1,r2,#31
000086  48e8              LDR      r0,|L1.1064|
000088  f7fffffe          BL       CLK_SetModuleClock
;;;35     	CLK_SetModuleClock(PWM45_MODULE, CLK_CLKSEL2_PWM45_S_HCLK,WHAT_EVER_DO_NOT_CARE);
00008c  2201              MOVS     r2,#1
00008e  2120              MOVS     r1,#0x20
000090  48e6              LDR      r0,|L1.1068|
000092  f7fffffe          BL       CLK_SetModuleClock
;;;36     	CLK_SetModuleClock(UART_MODULE, CLK_CLKSEL1_UART_S_IRC22M, CLK_CLKDIV_UART(UART_CLK_DIVIDER));
000096  2200              MOVS     r2,#0
000098  0421              LSLS     r1,r4,#16
00009a  48e5              LDR      r0,|L1.1072|
00009c  f7fffffe          BL       CLK_SetModuleClock
;;;37     	CLK_SetModuleClock(TMR0_MODULE, CLK_CLKSEL1_TMR0_S_HCLK,WHAT_EVER_DO_NOT_CARE);
0000a0  2201              MOVS     r2,#1
0000a2  0251              LSLS     r1,r2,#9
0000a4  48e3              LDR      r0,|L1.1076|
0000a6  f7fffffe          BL       CLK_SetModuleClock
;;;38     	CLK_SetModuleClock(TMR1_MODULE, CLK_CLKSEL1_TMR1_S_HCLK,WHAT_EVER_DO_NOT_CARE);
0000aa  2201              MOVS     r2,#1
0000ac  0351              LSLS     r1,r2,#13
0000ae  48e2              LDR      r0,|L1.1080|
0000b0  f7fffffe          BL       CLK_SetModuleClock
;;;39     //	CLK_SetModuleClock(SPI_MODULE, CLK_CLKSEL1_SPI_S_HCLK  , WHAT_EVER_DO_NOT_CARE);
;;;40     	CLK->CLKSEL1 |= (0x01 << 4);
0000b4  6960              LDR      r0,[r4,#0x14]
0000b6  2110              MOVS     r1,#0x10
0000b8  4308              ORRS     r0,r0,r1
0000ba  6160              STR      r0,[r4,#0x14]
;;;41     
;;;42     	// Nai nai de seems can not use | | | to put all peripheral enable into one invoke
;;;43     	CLK_EnableModuleClock(WDT_MODULE);
0000bc  4628              MOV      r0,r5
0000be  f7fffffe          BL       CLK_EnableModuleClock
;;;44     	CLK_EnableModuleClock(TMR0_MODULE);
0000c2  48dc              LDR      r0,|L1.1076|
0000c4  f7fffffe          BL       CLK_EnableModuleClock
;;;45     	CLK_EnableModuleClock(TMR1_MODULE);
0000c8  48db              LDR      r0,|L1.1080|
0000ca  f7fffffe          BL       CLK_EnableModuleClock
;;;46     	CLK_EnableModuleClock(SPI_MODULE);
0000ce  48db              LDR      r0,|L1.1084|
0000d0  f7fffffe          BL       CLK_EnableModuleClock
;;;47     	CLK_EnableModuleClock(UART_MODULE);
0000d4  48d6              LDR      r0,|L1.1072|
0000d6  f7fffffe          BL       CLK_EnableModuleClock
;;;48     	CLK_EnableModuleClock(PWM01_MODULE);
0000da  4638              MOV      r0,r7
0000dc  f7fffffe          BL       CLK_EnableModuleClock
;;;49     	CLK_EnableModuleClock(PWM23_MODULE);
0000e0  48d1              LDR      r0,|L1.1064|
0000e2  f7fffffe          BL       CLK_EnableModuleClock
;;;50     	CLK_EnableModuleClock(PWM45_MODULE);
0000e6  48d1              LDR      r0,|L1.1068|
0000e8  f7fffffe          BL       CLK_EnableModuleClock
;;;51     	CLK_EnableModuleClock(ADC_MODULE);
0000ec  4630              MOV      r0,r6
0000ee  f7fffffe          BL       CLK_EnableModuleClock
;;;52     	CLK_EnableModuleClock(ACMP_MODULE);
0000f2  48d3              LDR      r0,|L1.1088|
0000f4  f7fffffe          BL       CLK_EnableModuleClock
;;;53     //	CLK->APBCLK |= (0x01 << 12);
;;;54     }
0000f8  bdf8              POP      {r3-r7,pc}
;;;55     
                          ENDP

                  initIRQ PROC
;;;56     void initIRQ() {
0000fa  b510              PUSH     {r4,lr}
;;;57     	NVIC_EnableIRQ(TMR0_IRQn);
0000fc  2008              MOVS     r0,#8
0000fe  f7fffffe          BL       __NVIC_EnableIRQ
;;;58     	NVIC_EnableIRQ(TMR1_IRQn);
000102  2009              MOVS     r0,#9
000104  f7fffffe          BL       __NVIC_EnableIRQ
;;;59     	NVIC_EnableIRQ(SPI_IRQn);
000108  200e              MOVS     r0,#0xe
00010a  f7fffffe          BL       __NVIC_EnableIRQ
;;;60     	NVIC_EnableIRQ(ACMP_IRQn);
00010e  2019              MOVS     r0,#0x19
000110  f7fffffe          BL       __NVIC_EnableIRQ
;;;61     	NVIC_EnableIRQ(EINT0_IRQn);
000114  2002              MOVS     r0,#2
000116  f7fffffe          BL       __NVIC_EnableIRQ
;;;62     	NVIC_EnableIRQ(ADC_IRQn);
00011a  201d              MOVS     r0,#0x1d
00011c  f7fffffe          BL       __NVIC_EnableIRQ
;;;63     	//    NVIC_EnableIRQ(PWM_IRQn);
;;;64     
;;;65     	NVIC_SetPriority(TMR0_IRQn, 1);
000120  2101              MOVS     r1,#1
000122  2008              MOVS     r0,#8
000124  f7fffffe          BL       __NVIC_SetPriority
;;;66     	NVIC_SetPriority(TMR1_IRQn, 1);
000128  2101              MOVS     r1,#1
00012a  2009              MOVS     r0,#9
00012c  f7fffffe          BL       __NVIC_SetPriority
;;;67     	NVIC_SetPriority(SPI_IRQn, 3);
000130  2103              MOVS     r1,#3
000132  200e              MOVS     r0,#0xe
000134  f7fffffe          BL       __NVIC_SetPriority
;;;68     	NVIC_SetPriority(ACMP_IRQn, 2);
000138  2102              MOVS     r1,#2
00013a  2019              MOVS     r0,#0x19
00013c  f7fffffe          BL       __NVIC_SetPriority
;;;69     	NVIC_SetPriority(EINT0_IRQn, 0);
000140  2100              MOVS     r1,#0
000142  2002              MOVS     r0,#2
000144  f7fffffe          BL       __NVIC_SetPriority
;;;70     	NVIC_SetPriority(ADC_IRQn, 3);
000148  2103              MOVS     r1,#3
00014a  201d              MOVS     r0,#0x1d
00014c  f7fffffe          BL       __NVIC_SetPriority
;;;71     	//    NVIC_SetPriority(PWM_IRQn, 2);
;;;72     
;;;73     	GPIO_EnableEINT0(BRG_FAULT_PORT, BRG_FAULT_PIN, GPIO_INT_FALLING);
000150  2201              MOVS     r2,#1
000152  2104              MOVS     r1,#4
000154  48bb              LDR      r0,|L1.1092|
000156  f7fffffe          BL       GPIO_EnableInt
;;;74     }
00015a  bd10              POP      {r4,pc}
;;;75     
                          ENDP

                  initGPIO PROC
;;;76     void initGPIO() {
00015c  b5f8              PUSH     {r3-r7,lr}
;;;77     	/*---------------------------------------------------------------------------------------------------------*/
;;;78     	/* GPIO configuration                                                                                 	   */
;;;79     	/*---------------------------------------------------------------------------------------------------------*/
;;;80     	// LED Pin
;;;81     	GPIO_SetMode(LED_PORT, LED_PIN, GPIO_PMD_OUTPUT);
00015e  4cb9              LDR      r4,|L1.1092|
000160  2201              MOVS     r2,#1
000162  3480              ADDS     r4,r4,#0x80
000164  2110              MOVS     r1,#0x10
000166  4620              MOV      r0,r4
000168  f7fffffe          BL       GPIO_SetMode
;;;82     
;;;83     	// Bridge Enable Pin
;;;84     	GPIO_SetMode(BRG_EN_PORT, BRG_EN_PIN, GPIO_PMD_OUTPUT);
00016c  4db5              LDR      r5,|L1.1092|
00016e  2201              MOVS     r2,#1
000170  4611              MOV      r1,r2
000172  4628              MOV      r0,r5
000174  f7fffffe          BL       GPIO_SetMode
;;;85     	BRG_DISABLE;
000178  48b3              LDR      r0,|L1.1096|
00017a  2700              MOVS     r7,#0
00017c  6207              STR      r7,[r0,#0x20]
;;;86     
;;;87     	// Bridge Fault Pin
;;;88     	GPIO_SetMode(BRG_FAULT_PORT, BRG_FAULT_PIN, GPIO_PMD_INPUT);
00017e  463a              MOV      r2,r7
000180  2104              MOVS     r1,#4
000182  4628              MOV      r0,r5
000184  f7fffffe          BL       GPIO_SetMode
;;;89     
;;;90     	// PWM Pin
;;;91     	GPIO_SetMode(MOSFET_DRV_0_4_PORT,
000188  48ae              LDR      r0,|L1.1092|
00018a  2201              MOVS     r2,#1
00018c  217c              MOVS     r1,#0x7c
00018e  3840              SUBS     r0,r0,#0x40
000190  f7fffffe          BL       GPIO_SetMode
;;;92     	MOSFET_DRV_0_PIN | MOSFET_DRV_1_PIN | MOSFET_DRV_2_PIN |
;;;93     	MOSFET_DRV_3_PIN | MOSFET_DRV_4_PIN, GPIO_PMD_OUTPUT);
;;;94     	GPIO_SetMode(MOSFET_DRV_5_PORT, MOSFET_DRV_5_PIN, GPIO_PMD_OUTPUT);
000194  4eab              LDR      r6,|L1.1092|
000196  2201              MOVS     r2,#1
000198  3ec0              SUBS     r6,r6,#0xc0
00019a  2110              MOVS     r1,#0x10
00019c  4630              MOV      r0,r6
00019e  f7fffffe          BL       GPIO_SetMode
;;;95     
;;;96     	// SPI, I am slave
;;;97     	GPIO_SetMode(COMM_PORT, COMM_CLK_PIN | COMM_CS_PIN | COMM_RX_PIN,
0001a2  2200              MOVS     r2,#0
0001a4  21a2              MOVS     r1,#0xa2
0001a6  4630              MOV      r0,r6
0001a8  f7fffffe          BL       GPIO_SetMode
;;;98     	GPIO_PMD_INPUT);
;;;99     	GPIO_SetMode(COMM_PORT, COMM_TX_PIN, GPIO_PMD_OUTPUT);
0001ac  2201              MOVS     r2,#1
0001ae  2140              MOVS     r1,#0x40
0001b0  4630              MOV      r0,r6
0001b2  f7fffffe          BL       GPIO_SetMode
;;;100    
;;;101    	// UART Pin
;;;102    	GPIO_SetMode(DEBUG_TX_PORT, DEBUG_TX_PIN, GPIO_PMD_OUTPUT);
0001b6  2201              MOVS     r2,#1
0001b8  4611              MOV      r1,r2
0001ba  4630              MOV      r0,r6
0001bc  f7fffffe          BL       GPIO_SetMode
;;;103    	GPIO_SetMode(DEBUG_RX_PORT, DEBUG_RX_PIN, GPIO_PMD_INPUT);
0001c0  4ea0              LDR      r6,|L1.1092|
0001c2  2200              MOVS     r2,#0
0001c4  3e80              SUBS     r6,r6,#0x80
0001c6  2104              MOVS     r1,#4
0001c8  4630              MOV      r0,r6
0001ca  f7fffffe          BL       GPIO_SetMode
;;;104    
;;;105    	// DEBUG for ACMP Output Pin
;;;106    	GPIO_SetMode(DEBUG_ACMP_OUT_PORT, DEBUG_ACMP_OUT_PIN, GPIO_PMD_OUTPUT);
0001ce  2201              MOVS     r2,#1
0001d0  2140              MOVS     r1,#0x40
0001d2  4628              MOV      r0,r5
0001d4  f7fffffe          BL       GPIO_SetMode
;;;107    	GPIO_SetMode(DEBUG_GPIO_PORT, DEBUG_GPIO_PIN, GPIO_PMD_OUTPUT);
0001d8  2201              MOVS     r2,#1
0001da  4611              MOV      r1,r2
0001dc  4620              MOV      r0,r4
0001de  f7fffffe          BL       GPIO_SetMode
;;;108    	P50 = 0;
0001e2  4899              LDR      r0,|L1.1096|
0001e4  3040              ADDS     r0,r0,#0x40
0001e6  6207              STR      r7,[r0,#0x20]
;;;109    
;;;110    	// ADC for current Pin
;;;111    	GPIO_DISABLE_DIGITAL_PATH(CURRENT_PORT, CURRENT_PIN << GPIO_OFFD_OFF_SET);
0001e8  6860              LDR      r0,[r4,#4]
0001ea  6060              STR      r0,[r4,#4]
;;;112    	GPIO_SetMode(CURRENT_PORT, CURRENT_PIN, GPIO_PMD_INPUT);
0001ec  2200              MOVS     r2,#0
0001ee  2108              MOVS     r1,#8
0001f0  4620              MOV      r0,r4
0001f2  f7fffffe          BL       GPIO_SetMode
;;;113    	// ADC for battery Pin
;;;114    	GPIO_DISABLE_DIGITAL_PATH(BATTERY_V_PORT, BATTERY_V_PIN << GPIO_OFFD_OFF_SET);
0001f6  6868              LDR      r0,[r5,#4]
0001f8  6068              STR      r0,[r5,#4]
;;;115    	GPIO_SetMode(BATTERY_V_PORT, BATTERY_V_PIN, GPIO_PMD_INPUT);
0001fa  2200              MOVS     r2,#0
0001fc  2102              MOVS     r1,#2
0001fe  4628              MOV      r0,r5
000200  f7fffffe          BL       GPIO_SetMode
;;;116    
;;;117    	// ACMP Pin
;;;118    	GPIO_DISABLE_DIGITAL_PATH(ZERO_DETECT_PORT,
000204  6870              LDR      r0,[r6,#4]
000206  6070              STR      r0,[r6,#4]
;;;119    			(ZERO_DETECT_A_PIN | ZERO_DETECT_B_PIN | ZERO_DETECT_C_PIN | ZERO_DETECT_M_PIN) << GPIO_OFFD_OFF_SET);
;;;120    	GPIO_SetMode(ZERO_DETECT_PORT, ZERO_DETECT_A_PIN | ZERO_DETECT_B_PIN |
000208  2200              MOVS     r2,#0
00020a  2139              MOVS     r1,#0x39
00020c  4630              MOV      r0,r6
00020e  f7fffffe          BL       GPIO_SetMode
;;;121    	ZERO_DETECT_C_PIN | ZERO_DETECT_M_PIN, GPIO_PMD_INPUT);
;;;122    	/*---------------------------------------------------------------------------------------------------------*/
;;;123    	/* Init I/O Multi-function                                                                                 */
;;;124    	/*---------------------------------------------------------------------------------------------------------*/
;;;125    	/* Set multi-function pins for UART RXD and TXD */
;;;126    	SYS->P0_MFP &= ~SYS_MFP_P00_Msk;
000212  05a0              LSLS     r0,r4,#22
000214  6b01              LDR      r1,[r0,#0x30]
000216  4a8d              LDR      r2,|L1.1100|
000218  4011              ANDS     r1,r1,r2
00021a  6301              STR      r1,[r0,#0x30]
;;;127    	SYS->P0_MFP |= SYS_MFP_P00_TXD;
00021c  6b01              LDR      r1,[r0,#0x30]
00021e  23ff              MOVS     r3,#0xff
000220  3302              ADDS     r3,#2
000222  4319              ORRS     r1,r1,r3
000224  6301              STR      r1,[r0,#0x30]
;;;128    	SYS->P1_MFP &= ~SYS_MFP_P12_Msk;
000226  6b41              LDR      r1,[r0,#0x34]
000228  4a89              LDR      r2,|L1.1104|
00022a  4011              ANDS     r1,r1,r2
00022c  6341              STR      r1,[r0,#0x34]
;;;129    	SYS->P1_MFP |= SYS_MFP_P12_RXD;
00022e  6b41              LDR      r1,[r0,#0x34]
000230  2201              MOVS     r2,#1
000232  0292              LSLS     r2,r2,#10
000234  4311              ORRS     r1,r1,r2
000236  6341              STR      r1,[r0,#0x34]
;;;130    
;;;131    	/* Set multi-function pins for SPI */
;;;132    //    SYS->P0_MFP &= ~(SYS_MFP_P01_Msk | SYS_MFP_P05_Msk | SYS_MFP_P06_Msk | SYS_MFP_P07_Msk);
;;;133    	SYS->P0_MFP |= (SYS_MFP_P01_SPISS | SYS_MFP_P05_MOSI | SYS_MFP_P06_MISO | SYS_MFP_P07_SPICLK);
000238  6b01              LDR      r1,[r0,#0x30]
00023a  4a86              LDR      r2,|L1.1108|
00023c  4311              ORRS     r1,r1,r2
00023e  6301              STR      r1,[r0,#0x30]
;;;134    
;;;135    	/* Set multi-function pins for ADC for current */
;;;136    	SYS->P5_MFP &= ~SYS_MFP_P53_Msk;
000240  4985              LDR      r1,|L1.1112|
000242  684a              LDR      r2,[r1,#4]
000244  4c85              LDR      r4,|L1.1116|
000246  4022              ANDS     r2,r2,r4
000248  604a              STR      r2,[r1,#4]
;;;137    	SYS->P5_MFP |= SYS_MFP_P53_AIN0;
00024a  684a              LDR      r2,[r1,#4]
00024c  2408              MOVS     r4,#8
00024e  4322              ORRS     r2,r2,r4
000250  604a              STR      r2,[r1,#4]
;;;138    
;;;139    	/* Set multi-function pins for ADC for battery */
;;;140    	SYS->P3_MFP &= ~SYS_MFP_P31_Msk;
000252  6bc2              LDR      r2,[r0,#0x3c]
000254  4c82              LDR      r4,|L1.1120|
000256  4022              ANDS     r2,r2,r4
000258  63c2              STR      r2,[r0,#0x3c]
;;;141    	SYS->P3_MFP |= SYS_MFP_P31_AIN7;
00025a  6bc2              LDR      r2,[r0,#0x3c]
00025c  005c              LSLS     r4,r3,#1
00025e  4322              ORRS     r2,r2,r4
000260  63c2              STR      r2,[r0,#0x3c]
;;;142    
;;;143    	/* Set multi-function pins for ACMP output for debug */
;;;144    	SYS->P3_MFP &= ~SYS_MFP_P36_Msk;
000262  6bc2              LDR      r2,[r0,#0x3c]
000264  4c7f              LDR      r4,|L1.1124|
000266  4022              ANDS     r2,r2,r4
000268  63c2              STR      r2,[r0,#0x3c]
;;;145    	SYS->P3_MFP |= SYS_MFP_P36_CPO0;
00026a  6bc2              LDR      r2,[r0,#0x3c]
00026c  019c              LSLS     r4,r3,#6
00026e  4322              ORRS     r2,r2,r4
000270  63c2              STR      r2,[r0,#0x3c]
;;;146    	SYS->P5_MFP &= ~SYS_MFP_P50_Msk;
000272  684a              LDR      r2,[r1,#4]
000274  439a              BICS     r2,r2,r3
000276  604a              STR      r2,[r1,#4]
;;;147    	SYS->P5_MFP |= SYS_MFP_P50_GPIO;
000278  684a              LDR      r2,[r1,#4]
00027a  604a              STR      r2,[r1,#4]
;;;148    
;;;149    	/* Set multi-function pins for ACMP */
;;;150    	SYS->P1_MFP &= ~SYS_MFP_P14_Msk;
00027c  6b41              LDR      r1,[r0,#0x34]
00027e  4b7a              LDR      r3,|L1.1128|
000280  4019              ANDS     r1,r1,r3
000282  6341              STR      r1,[r0,#0x34]
;;;151    	SYS->P1_MFP |= SYS_MFP_P14_CPN0;
000284  6b42              LDR      r2,[r0,#0x34]
000286  10a1              ASRS     r1,r4,#2
000288  430a              ORRS     r2,r2,r1
00028a  6342              STR      r2,[r0,#0x34]
;;;152    	// pp will changed in the 
;;;153    //    SYS->P1_MFP &= ~(SYS_MFP_P10_Msk | SYS_MFP_P13_Msk | SYS_MFP_P14_Msk | SYS_MFP_P15_Msk);
;;;154    //    SYS->P1_MFP |= (SYS_MFP_P10_CPP0 | SYS_MFP_P13_CPP0 | SYS_MFP_P14_CPN0 | SYS_MFP_P15_CPP0); 
;;;155    // 	          
;;;156    	/* Set multi-function pins for PWM */
;;;157    	SYS->P2_MFP &= ~(SYS_MFP_P22_Msk | SYS_MFP_P23_Msk | SYS_MFP_P24_Msk | SYS_MFP_P25_Msk | SYS_MFP_P26_Msk);
00028c  6b82              LDR      r2,[r0,#0x38]
00028e  4c77              LDR      r4,|L1.1132|
000290  4022              ANDS     r2,r2,r4
000292  6382              STR      r2,[r0,#0x38]
;;;158    	SYS->P2_MFP = SYS_MFP_P22_PWM0 | SYS_MFP_P23_PWM1 | SYS_MFP_P24_PWM2 | SYS_MFP_P25_PWM3 | SYS_MFP_P26_PWM4;
000294  221f              MOVS     r2,#0x1f
000296  0292              LSLS     r2,r2,#10
000298  6382              STR      r2,[r0,#0x38]
;;;159    	SYS->P0_MFP &= ~SYS_MFP_P04_Msk;
00029a  6b02              LDR      r2,[r0,#0x30]
00029c  401a              ANDS     r2,r2,r3
00029e  6302              STR      r2,[r0,#0x30]
;;;160    	SYS->P0_MFP |= SYS_MFP_P04_PWM5;
0002a0  6b02              LDR      r2,[r0,#0x30]
0002a2  430a              ORRS     r2,r2,r1
0002a4  6302              STR      r2,[r0,#0x30]
;;;161    
;;;162    	/* Set multi-function pins for EINT0 */
;;;163    	SYS->P3_MFP &= ~SYS_MFP_P32_Msk;
0002a6  6bc1              LDR      r1,[r0,#0x3c]
0002a8  4a71              LDR      r2,|L1.1136|
0002aa  4011              ANDS     r1,r1,r2
0002ac  63c1              STR      r1,[r0,#0x3c]
;;;164    	SYS->P3_MFP |= SYS_MFP_P32_INT0;
0002ae  6bc1              LDR      r1,[r0,#0x3c]
0002b0  2204              MOVS     r2,#4
0002b2  4311              ORRS     r1,r1,r2
0002b4  63c1              STR      r1,[r0,#0x3c]
;;;165    
;;;166    }
0002b6  bdf8              POP      {r3-r7,pc}
;;;167    
                          ENDP

                  configTIM PROC
;;;168    void configTIM(void) {
0002b8  486f              LDR      r0,|L1.1144|
;;;169    	// T0 used to change phase automatically
;;;170    	// T1 used to filter ZX
;;;171    	TIMER0->TCSR = TIMER_TCSR_CRST_Msk | TIMER_PERIODIC_MODE | TIMER_TCSR_PERIODIC_SEL_Msk | TIMER_TCSR_TDR_EN_Msk + TIMER0_PRESCALE;
0002ba  496e              LDR      r1,|L1.1140|
0002bc  6001              STR      r1,[r0,#0]
;;;172    	TIMER1->TCSR = TIMER_TCSR_CRST_Msk | TIMER_CONTINUOUS_MODE | TIMER_TCSR_TDR_EN_Msk + TIMER1_PRESCALE;
0002be  496f              LDR      r1,|L1.1148|
0002c0  6201              STR      r1,[r0,#0x20]
;;;173    	// TIMER1->TCSR |=  TIMER_TCSR_CEN_Msk ;
;;;174    	//TIMER_EnableInt(TIMER0);                         
;;;175    	//TIMER_EnableInt(TIMER1);
;;;176    }
0002c2  4770              BX       lr
;;;177    
                          ENDP

                  configADC PROC
;;;178    void configADC(void) {
0002c4  b510              PUSH     {r4,lr}
;;;179    
;;;180    	ADC_SetExtraSampleTime(ADC, 0, ADC_SAMPLE_CLOCK_16);
0002c6  4c6e              LDR      r4,|L1.1152|
0002c8  2205              MOVS     r2,#5
0002ca  2100              MOVS     r1,#0
0002cc  4620              MOV      r0,r4
0002ce  f7fffffe          BL       ADC_SetExtraSampleTime
;;;181    
;;;182    	// Enable channel 0 and 7 (Current and Battery)
;;;183    //    ADC_Open(ADC, 0, 0, ADC_BATTERY_CHN_MSK);	//ADC_CURRENT_CHN_MSK | ADC_BATTERY_CHN_MSK);	
;;;184    // Do NOT use this, it will clear all bit in ADCR
;;;185    
;;;186    	// Power on ADC
;;;187    	ADC_POWER_ON(ADC);
0002d2  6a20              LDR      r0,[r4,#0x20]
0002d4  2101              MOVS     r1,#1
0002d6  4308              ORRS     r0,r0,r1
0002d8  6220              STR      r0,[r4,#0x20]
;;;188    
;;;189    	// ADC start triggered by TIM and take turn between current and battery
;;;190    	// Use two ADC comparator to hardware trace the big cuurent or battery low
;;;191    
;;;192    	// Configure and enable Comperator 0 to monitor channel 0(current) input greater or euqal to 93
;;;193    	ADC_ENABLE_CMP0(ADC, ADC_CURRENT_CHN_IDX, ADC_CMP_GREATER_OR_EQUAL_TO, ADC_CURRENT_HIGH_THRS, ADC_CURRENT_HIGH_CNT);
0002da  486a              LDR      r0,|L1.1156|
0002dc  62a0              STR      r0,[r4,#0x28]
;;;194    	// Configure and enable Comperator 1 to monitor channel 7(battery) input less than 0x200	
;;;195    	ADC_ENABLE_CMP1(ADC, ADC_BATTERY_CHN_IDX, ADC_CMP_LESS_THAN, ADC_BAT_LOW_THRS, ADC_BAT_LOW_CNT);
0002de  486a              LDR      r0,|L1.1160|
0002e0  62e0              STR      r0,[r4,#0x2c]
;;;196    
;;;197    	// Enable ADC comparator 0 and 1 interrupt
;;;198    	ADC_EnableInt(ADC, ADC_ADF_INT);
0002e2  4620              MOV      r0,r4
0002e4  f7fffffe          BL       ADC_EnableInt
;;;199    	ADC_EnableInt(ADC, ADC_CMP0_INT);
0002e8  2102              MOVS     r1,#2
0002ea  4620              MOV      r0,r4
0002ec  f7fffffe          BL       ADC_EnableInt
;;;200    	ADC_EnableInt(ADC, ADC_CMP1_INT);
0002f0  2104              MOVS     r1,#4
0002f2  4620              MOV      r0,r4
0002f4  f7fffffe          BL       ADC_EnableInt
;;;201    
;;;202    	ADC_SET_INPUT_CHANNEL(ADC, ADC_BATTERY_CHN_MSK);
0002f8  6a60              LDR      r0,[r4,#0x24]
0002fa  0a00              LSRS     r0,r0,#8
0002fc  0200              LSLS     r0,r0,#8
0002fe  3080              ADDS     r0,r0,#0x80
000300  6260              STR      r0,[r4,#0x24]
;;;203    	ADC_START_CONV(ADC);
000302  6a20              LDR      r0,[r4,#0x20]
000304  2101              MOVS     r1,#1
000306  02c9              LSLS     r1,r1,#11
000308  4308              ORRS     r0,r0,r1
00030a  6220              STR      r0,[r4,#0x20]
;;;204    }
00030c  bd10              POP      {r4,pc}
;;;205    
                          ENDP

                  configSPI PROC
;;;206    void configSPI(void) {
00030e  b538              PUSH     {r3-r5,lr}
;;;207    	/*---------------------------------------------------------------------------------------------------------*/
;;;208    	/* Init SPI                                                                                                */
;;;209    	/*---------------------------------------------------------------------------------------------------------*/
;;;210    
;;;211    	/* Fuck mini51's SPI, seems the TX DR will have influence on RX DR 
;;;212    	 SOOOOOOOO, when master is TXing, slave only receive.
;;;213    	 When master is RXing, master's MOSI need to be always high
;;;214    	 */
;;;215    
;;;216    	/* Configure as a slave, clock idle low, falling clock edge Tx, rising edge Rx and 32-bit transaction */
;;;217    	/* Set IP clock divider. SPI clock rate = 10MHz */
;;;218    	SPI_Close(SPI);
000310  4c5e              LDR      r4,|L1.1164|
000312  4620              MOV      r0,r4
000314  f7fffffe          BL       SPI_Close
;;;219    
;;;220    	// peripheral clock frequency of slave device must be faster than the bus clock frequency of the master
;;;221    	SPI_Open(SPI, SPI_SLAVE, SPI_MODE_0, COMM_BIT_LENTH, COMM_BAUT_RATE);
000318  2000              MOVS     r0,#0
00031a  2204              MOVS     r2,#4
00031c  9000              STR      r0,[sp,#0]
00031e  2310              MOVS     r3,#0x10
000320  0411              LSLS     r1,r2,#16
000322  4620              MOV      r0,r4
000324  f7fffffe          BL       SPI_Open
;;;222    
;;;223    //	  /* Enable the automatic hardware slave select function. Select the SS pin and configure as low-active. */
;;;224    //    SPI_EnableAutoSS(SPI, SPI_SS, SPI_SS_ACTIVE_LOW);
;;;225    
;;;226    	SPI_SET_MSB_FIRST(SPI);
000328  6820              LDR      r0,[r4,#0]
00032a  1521              ASRS     r1,r4,#20
00032c  4388              BICS     r0,r0,r1
00032e  6020              STR      r0,[r4,#0]
;;;227    
;;;228    	// SS level trigger
;;;229    	// Set input slave select signal to edge-trigger
;;;230    	SPI->SSR |= SPI_SSR_SS_LTRIG_Msk;
000330  68a0              LDR      r0,[r4,#8]
000332  2110              MOVS     r1,#0x10
000334  4308              ORRS     r0,r0,r1
000336  60a0              STR      r0,[r4,#8]
;;;231    	// Set slave select signal SPISS to be active at low level.
;;;232    	SPI->SSR &= (~SPI_SSR_SS_LVL_Msk);
000338  68a0              LDR      r0,[r4,#8]
00033a  2104              MOVS     r1,#4
00033c  4388              BICS     r0,r0,r1
00033e  60a0              STR      r0,[r4,#8]
;;;233    
;;;234    	/* Use FIFO */
;;;235    //	SPI_EnableFIFO(SPI, COMM_FIFO_LENGTH, COMM_FIFO_LENGTH);
;;;236    	/* Enable SPI unit transfer interrupt */
;;;237    	SPI_EnableInt(SPI, SPI_IE_MASK);
000340  2101              MOVS     r1,#1
000342  4620              MOV      r0,r4
000344  f7fffffe          BL       SPI_EnableInt
;;;238    
;;;239    //	SPI_ClearRxFIFO(SPI);
;;;240    //	SPI_ClearTxFIFO(SPI);	
;;;241    
;;;242    //	SPI_WRITE_TX(SPI, 0xFFFF);
;;;243    	SPI_TRIGGER(SPI);
000348  6820              LDR      r0,[r4,#0]
00034a  2101              MOVS     r1,#1
00034c  4308              ORRS     r0,r0,r1
00034e  6020              STR      r0,[r4,#0]
;;;244    }
000350  bd38              POP      {r3-r5,pc}
;;;245    
                          ENDP

                  initPWM PROC
;;;251    
;;;252    void initPWM(void) {
000352  b570              PUSH     {r4-r6,lr}
;;;253    	PWM_Stop(PWM, PWM_CHN_ALL_MSK);
000354  4c4e              LDR      r4,|L1.1168|
000356  213f              MOVS     r1,#0x3f
000358  4620              MOV      r0,r4
00035a  f7fffffe          BL       PWM_Stop
;;;254    	PWM_SET_PRESCALER(PWM, 0, PWM_CHN01_PRESCALER);
00035e  6820              LDR      r0,[r4,#0]
000360  0a00              LSRS     r0,r0,#8
000362  0200              LSLS     r0,r0,#8
000364  1c40              ADDS     r0,r0,#1
000366  6020              STR      r0,[r4,#0]
;;;255    //    PWM_SET_PRESCALER(PWM, 1, PWM_CHN01_PRESCALER);
;;;256    	PWM_SET_PRESCALER(PWM, 2, PWM_CHN23_PRESCALER);
000368  6820              LDR      r0,[r4,#0]
00036a  21ff              MOVS     r1,#0xff
00036c  0209              LSLS     r1,r1,#8
00036e  4388              BICS     r0,r0,r1
000370  30ff              ADDS     r0,r0,#0xff
000372  3001              ADDS     r0,#1
000374  6020              STR      r0,[r4,#0]
;;;257    //    PWM_SET_PRESCALER(PWM, 3, PWM_CHN23_PRESCALER);
;;;258    	PWM_SET_PRESCALER(PWM, 4, PWM_CHN45_PRESCALER);
000376  6820              LDR      r0,[r4,#0]
000378  0209              LSLS     r1,r1,#8
00037a  4388              BICS     r0,r0,r1
00037c  2101              MOVS     r1,#1
00037e  0409              LSLS     r1,r1,#16
000380  1840              ADDS     r0,r0,r1
000382  6020              STR      r0,[r4,#0]
;;;259    //    PWM_SET_PRESCALER(PWM, 5, PWM_CHN45_PRESCALER);
;;;260    	PWM_SET_DIVIDER(PWM, 0, PWM_CLK_DIV_1);
000384  6860              LDR      r0,[r4,#4]
000386  08c0              LSRS     r0,r0,#3
000388  00c0              LSLS     r0,r0,#3
00038a  1d00              ADDS     r0,r0,#4
00038c  6060              STR      r0,[r4,#4]
;;;261    	PWM_SET_DIVIDER(PWM, 1, PWM_CLK_DIV_1);
00038e  6860              LDR      r0,[r4,#4]
000390  2170              MOVS     r1,#0x70
000392  4388              BICS     r0,r0,r1
000394  3040              ADDS     r0,r0,#0x40
000396  6060              STR      r0,[r4,#4]
;;;262    	PWM_SET_DIVIDER(PWM, 2, PWM_CLK_DIV_1);
000398  6860              LDR      r0,[r4,#4]
00039a  0109              LSLS     r1,r1,#4
00039c  4388              BICS     r0,r0,r1
00039e  1521              ASRS     r1,r4,#20
0003a0  1840              ADDS     r0,r0,r1
0003a2  6060              STR      r0,[r4,#4]
;;;263    	PWM_SET_DIVIDER(PWM, 3, PWM_CLK_DIV_1);
0003a4  6860              LDR      r0,[r4,#4]
0003a6  2107              MOVS     r1,#7
0003a8  0309              LSLS     r1,r1,#12
0003aa  4388              BICS     r0,r0,r1
0003ac  2101              MOVS     r1,#1
0003ae  0389              LSLS     r1,r1,#14
0003b0  1840              ADDS     r0,r0,r1
0003b2  6060              STR      r0,[r4,#4]
;;;264    	PWM_SET_DIVIDER(PWM, 4, PWM_CLK_DIV_1);
0003b4  6860              LDR      r0,[r4,#4]
0003b6  2107              MOVS     r1,#7
0003b8  0409              LSLS     r1,r1,#16
0003ba  4388              BICS     r0,r0,r1
0003bc  2101              MOVS     r1,#1
0003be  0489              LSLS     r1,r1,#18
0003c0  1840              ADDS     r0,r0,r1
0003c2  6060              STR      r0,[r4,#4]
;;;265    	PWM_SET_DIVIDER(PWM, 5, PWM_CLK_DIV_1);
0003c4  6860              LDR      r0,[r4,#4]
0003c6  2107              MOVS     r1,#7
0003c8  0509              LSLS     r1,r1,#20
0003ca  4388              BICS     r0,r0,r1
0003cc  0121              LSLS     r1,r4,#4
0003ce  1840              ADDS     r0,r0,r1
0003d0  6060              STR      r0,[r4,#4]
;;;266    
;;;267    //    PWM->PCR = PCR_CLR_COUNTER | PCR_DEBUG_MODE | PCR_CH_EN(0) | PCR_PERIOD_MODE(0) |
;;;268    //		PCR_CH_EN(1) | PCR_PERIOD_MODE(1) | PCR_CH_EN(2) | PCR_PERIOD_MODE(2) |
;;;269    //		PCR_CH_EN(3) | PCR_PERIOD_MODE(3) | PCR_CH_EN(4) | PCR_PERIOD_MODE(4) |
;;;270    //		PCR_CH_EN(5) | PCR_PERIOD_MODE(5) |
;;;271    //		PCR_INV_EN(0) | PCR_INV_EN(2) | PCR_INV_EN(4) |
;;;272    //		PCR_INV_EN(1) | PCR_INV_EN(3) | PCR_INV_EN(5);
;;;273    	PWM->PCR = PCR_CLR_COUNTER | PCR_DEBUG_MODE | PCR_CH_EN(0) | PCR_PERIOD_MODE(0) |
0003d2  4830              LDR      r0,|L1.1172|
0003d4  60a0              STR      r0,[r4,#8]
;;;274    	PCR_CH_EN(1) | PCR_PERIOD_MODE(1) |
;;;275    	PCR_CH_EN(2) | PCR_PERIOD_MODE(2) |
;;;276    	PCR_CH_EN(3) | PCR_PERIOD_MODE(3) |
;;;277    	PCR_CH_EN(4) | PCR_PERIOD_MODE(4) |
;;;278    	PCR_CH_EN(5) | PCR_PERIOD_MODE(5) |
;;;279    	PCR_INV_EN(0) | PCR_INV_EN(2) | PCR_INV_EN(4) |
;;;280    	PCR_INV_EN(1) | PCR_INV_EN(3) | PCR_INV_EN(5);
;;;281    //    PWM_SET_ALIGNED_TYPE(PWM_EDGE_ALIGNED);
;;;282    //    PWM_ENABLE_GROUP_MODE(PWM);
;;;283    	PWM->CMR[0] = 0;
0003d6  2500              MOVS     r5,#0
0003d8  6265              STR      r5,[r4,#0x24]
;;;284    	PWM->CMR[1] = 0;
0003da  62a5              STR      r5,[r4,#0x28]
;;;285    	PWM->CMR[2] = 0;
0003dc  62e5              STR      r5,[r4,#0x2c]
;;;286    	PWM->CMR[3] = 0;
0003de  6325              STR      r5,[r4,#0x30]
;;;287    	PWM->CMR[4] = 0;
0003e0  6365              STR      r5,[r4,#0x34]
;;;288    	PWM->CMR[5] = 0;
0003e2  63a5              STR      r5,[r4,#0x38]
;;;289    	PWM->CNR[0] = PWM_PERIOD;
0003e4  482c              LDR      r0,|L1.1176|
0003e6  60e0              STR      r0,[r4,#0xc]
;;;290    	PWM->CNR[1] = PWM_PERIOD;
0003e8  6120              STR      r0,[r4,#0x10]
;;;291    	PWM->CNR[2] = PWM_PERIOD;
0003ea  6160              STR      r0,[r4,#0x14]
;;;292    	PWM->CNR[3] = PWM_PERIOD;
0003ec  61a0              STR      r0,[r4,#0x18]
;;;293    	PWM->CNR[4] = PWM_PERIOD;
0003ee  61e0              STR      r0,[r4,#0x1c]
;;;294    	PWM->CNR[5] = PWM_PERIOD;
0003f0  6220              STR      r0,[r4,#0x20]
;;;295    	PWM_EnableOutput(PWM, PWM_CHN_ALL_MSK);
0003f2  213f              MOVS     r1,#0x3f
0003f4  4620              MOV      r0,r4
0003f6  f7fffffe          BL       PWM_EnableOutput
;;;296    	PWM_INT_DISABLE;	// Disable all PWM interrupt
0003fa  4825              LDR      r0,|L1.1168|
0003fc  3040              ADDS     r0,r0,#0x40
0003fe  6145              STR      r5,[r0,#0x14]
;;;297    	BLDC_stopMotor();
000400  f7fffffe          BL       BLDC_stopMotor
;;;298    	//MOTOR_SHUT_DOWN;
;;;299    
;;;300    	// PWM duty change every each phase for both ramp up and locked state
;;;301    //    PWM->INTACCUCTL = 0x41; // Every 4 PWM periods change duty
;;;302    	// this will be used in locked time
;;;303    	// During startup ramp, duty change every x E-Circle
;;;304    	PWM->PHCHGMASK = PHCHG_CTL_CMP0;	// Input of ACMP0 is controlled by PHCHG
000404  4922              LDR      r1,|L1.1168|
000406  15a0              ASRS     r0,r4,#22
000408  3180              ADDS     r1,r1,#0x80
00040a  6008              STR      r0,[r1,#0]
;;;305    }
00040c  bd70              POP      {r4-r6,pc}
00040e  0000              DCW      0x0000
                  |L1.1040|
                          DCD      0xe000e400
                  |L1.1044|
                          DCD      0xe000ed00
                  |L1.1048|
                          DCD      0x50000200
                  |L1.1052|
                          DCD      0x260c03e0
                  |L1.1056|
                          DCD      0x2623fe1c
                  |L1.1060|
                          DCD      0x27cc03f4
                  |L1.1064|
                          DCD      0x27ec03f5
                  |L1.1068|
                          DCD      0x664c03f6
                  |L1.1072|
                          DCD      0x27803d10
                  |L1.1076|
                          DCD      0x2e8c03e2
                  |L1.1080|
                          DCD      0x2ecc03e3
                  |L1.1084|
                          DCD      0x224c03ec
                  |L1.1088|
                          DCD      0x61fc03fe
                  |L1.1092|
                          DCD      0x500040c0
                  |L1.1096|
                          DCD      0x50004240
                  |L1.1100|
                          DCD      0xfefffefe
                  |L1.1104|
                          DCD      0xfffffbfb
                  |L1.1108|
                          DCD      0x0000e002
                  |L1.1112|
                          DCD      0x50000040
                  |L1.1116|
                          DCD      0xfffff7f7
                  |L1.1120|
                          DCD      0xfffffdfd
                  |L1.1124|
                          DCD      0xffffbfbf
                  |L1.1128|
                          DCD      0xffffefef
                  |L1.1132|
                          DCD      0xffff8383
                  |L1.1136|
                          DCD      0xfefffbfb
                  |L1.1140|
                          DCD      0x0c03000a
                  |L1.1144|
                          DCD      0x40010000
                  |L1.1148|
                          DCD      0x1c01000a
                  |L1.1152|
                          DCD      0x400e0000
                  |L1.1156|
                          DCD      0x00440b05
                  |L1.1160|
                          DCD      0x015c0f39
                  |L1.1164|
                          DCD      0x40030000
                  |L1.1168|
                          DCD      0x40040000
                  |L1.1172|
                          DCD      0x08dddddf
                  |L1.1176|
                          DCD      0x00000373
                          ENDP

                  initSys PROC
;;;306    
;;;307    void initSys(void) {
00049c  b510              PUSH     {r4,lr}
;;;308    	/* Unlock protected registers */
;;;309    	SYS_UnlockReg();
00049e  f7fffffe          BL       SYS_UnlockReg
;;;310    
;;;311    	/* Clock initialization, Enable PWM, ADC, TIM, UART clock */
;;;312    	initClk();
0004a2  f7fffffe          BL       initClk
;;;313    	//CLK->APBCLK = CLK_APBCLK_UART_EN_Msk;
;;;314    
;;;315    	/* Update System Core Clock */
;;;316    	/* User can use SystemCoreClockUpdate() to calculate SystemCoreClock and cyclesPerUs automatically. */
;;;317    	SystemCoreClockUpdate();
0004a6  f7fffffe          BL       SystemCoreClockUpdate
0004aa  4c29              LDR      r4,|L1.1360|
;;;318    
;;;319    	/* System tick Configuration */
;;;320    	// SYS TICK interrupt will be entered every 5ms
;;;321    	SysTick_Config(SYS_TICK_RELOAD_VALUE);
;;;322    
;;;323    	/* PWM Configuration */
;;;324    	// Close all MOSFET here first, then output GPIO
;;;325    	initPWM();
;;;326    
;;;327    	/* IO Configuration */
;;;328    	initGPIO();
;;;329    
;;;330    	/* ACMP initialization */
;;;331    	//ACMP_Config();
;;;332    	/* ADC initialization */
;;;333    	configADC();
;;;334    
;;;335    	/* TIM initialization */
;;;336    	configTIM();
;;;337    
;;;338    	/* SPI initialization */
;;;339    	configSPI();
;;;340    
;;;341    	/* Enable all interrupt from NVIC */
;;;342    	initIRQ();
;;;343    
;;;344    	/* Lock protected registers */
;;;345    	SYS_LockReg();
;;;346    
;;;347    }
0004ac  4827              LDR      r0,|L1.1356|
0004ae  6160              STR      r0,[r4,#0x14]
0004b0  2103              MOVS     r1,#3
0004b2  1f08              SUBS     r0,r1,#4
0004b4  f7fffffe          BL       __NVIC_SetPriority
0004b8  2000              MOVS     r0,#0
0004ba  61a0              STR      r0,[r4,#0x18]
0004bc  2007              MOVS     r0,#7
0004be  6120              STR      r0,[r4,#0x10]
0004c0  f7fffffe          BL       initPWM
0004c4  f7fffffe          BL       initGPIO
0004c8  f7fffffe          BL       configADC
0004cc  f7fffffe          BL       configTIM
0004d0  f7fffffe          BL       configSPI
0004d4  f7fffffe          BL       initIRQ
0004d8  f7fffffe          BL       SYS_LockReg
0004dc  bd10              POP      {r4,pc}
;;;348    
                          ENDP

                  initEnv PROC
;;;349    void initEnv(void) {
0004de  481d              LDR      r0,|L1.1364|
;;;350    	tMotor.structMotor.unCommOK_CNT = 0;
0004e0  2100              MOVS     r1,#0
0004e2  62c1              STR      r1,[r0,#0x2c]  ; tMotor
;;;351    	tMotor.structMotor.unCommErrCNT = 0;
0004e4  6301              STR      r1,[r0,#0x30]  ; tMotor
;;;352    	unZXMatchCNT = 0;
0004e6  4a1c              LDR      r2,|L1.1368|
0004e8  6011              STR      r1,[r2,#0]  ; unZXMatchCNT
;;;353    	tMotor.structMotor.MSR.bNewComFrameReceived = FALSE;
0004ea  8881              LDRH     r1,[r0,#4]  ; tMotor
0004ec  2210              MOVS     r2,#0x10
0004ee  4391              BICS     r1,r1,r2
0004f0  8081              STRH     r1,[r0,#4]
;;;354    //	tSPI_LastState = SPI_RCV_IDLE;
;;;355    }
0004f2  4770              BX       lr
;;;356    uint32_t unWTF_Value = 0xA5D4;
                          ENDP

                  main PROC
;;;357    int main() {
0004f4  f7fffffe          BL       initSys
;;;358    
;;;359    	initSys();
;;;360    	initEnv();
0004f8  f7fffffe          BL       initEnv
;;;361    
;;;362    	PTC_checkMotor();
0004fc  f7fffffe          BL       PTC_checkMotor
;;;363    
;;;364    	/* ----==== Here is the parameter used for test ====----*/
;;;365    	// Max PWM Duty is: PWM_PERIOD = 441
;;;366    	// Max Period is:
;;;367    	MOTOR_SHUT_DOWN
000500  4916              LDR      r1,|L1.1372|
000502  2000              MOVS     r0,#0
000504  6208              STR      r0,[r1,#0x20]
000506  4a16              LDR      r2,|L1.1376|
000508  6150              STR      r0,[r2,#0x14]
00050a  4816              LDR      r0,|L1.1380|
00050c  6801              LDR      r1,[r0,#0]
00050e  0383              LSLS     r3,r0,#14
000510  4399              BICS     r1,r1,r3
000512  6001              STR      r1,[r0,#0]
000514  4913              LDR      r1,|L1.1380|
000516  3120              ADDS     r1,r1,#0x20
000518  680c              LDR      r4,[r1,#0]
00051a  439c              BICS     r4,r4,r3
00051c  600c              STR      r4,[r1,#0]
00051e  6804              LDR      r4,[r0,#0]
000520  0343              LSLS     r3,r0,#13
000522  439c              BICS     r4,r4,r3
000524  6004              STR      r4,[r0,#0]
000526  6808              LDR      r0,[r1,#0]
000528  4398              BICS     r0,r0,r3
00052a  6008              STR      r0,[r1,#0]
00052c  20ff              MOVS     r0,#0xff
00052e  63d0              STR      r0,[r2,#0x3c]
000530  6390              STR      r0,[r2,#0x38]
                  |L1.1330|
;;;368    	;
;;;369    
;;;370    	// Example parameter
;;;371    //    tMotor.structMotor.unLocatingDuty = 200;
;;;372    //    tMotor.structMotor.unLocatingPeriod = 10;	// Unit ms
;;;373    //    tMotor.structMotor.unRampUpDuty = 320;
;;;374    //    tMotor.structMotor.unRampUpPeriod = 8000;	// Unit 2MH, 20ms, 500rpm
;;;375    //	tMotor.structMotor.unTargetDuty = 400;
;;;376    //	tMotor.structMotor.MCR.bRotateDirection = ROTATE_CLOCKWISE;	// Clockwise
;;;377    //    tMotor.structMotor.MCR.bMotorNeedToRun = TRUE;
;;;378    	/* ----=============== Test End ================---- */
;;;379    
;;;380    	while (1) {
;;;381    //		BLDC_SensorLessManager();
;;;382    		COMM_Manager();
000532  f7fffffe          BL       COMM_Manager
000536  e7fc              B        |L1.1330|
;;;383    //		ERR_Manager();
;;;384    	}
;;;385    
;;;386    }
;;;387    
                          ENDP

                  __NVIC_EnableIRQ PROC
;;;614     */
;;;615    __STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
000538  2800              CMP      r0,#0
;;;616    {
00053a  db05              BLT      |L1.1352|
;;;617      if ((int32_t)(IRQn) >= 0)
;;;618      {
;;;619        NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
00053c  06c1              LSLS     r1,r0,#27
00053e  0ec9              LSRS     r1,r1,#27
000540  2001              MOVS     r0,#1
000542  4088              LSLS     r0,r0,r1
000544  4908              LDR      r1,|L1.1384|
000546  6008              STR      r0,[r1,#0]
                  |L1.1352|
;;;620      }
;;;621    }
000548  4770              BX       lr
;;;622    
                          ENDP

00054a  0000              DCW      0x0000
                  |L1.1356|
                          DCD      0x0001affe
                  |L1.1360|
                          DCD      0xe000e000
                  |L1.1364|
                          DCD      tMotor
                  |L1.1368|
                          DCD      unZXMatchCNT
                  |L1.1372|
                          DCD      0x50004240
                  |L1.1376|
                          DCD      0x40040040
                  |L1.1380|
                          DCD      0x40010000
                  |L1.1384|
                          DCD      0xe000e100

                          AREA ||.constdata||, DATA, READONLY, ALIGN=1

                  iTestSpeedSequence
000000  00fa012c          DCW      0x00fa,0x012c
000004  015e0190          DCW      0x015e,0x0190
000008  01c2012c          DCW      0x01c2,0x012c
00000c  019000fa          DCW      0x0190,0x00fa
000010  00c801c2          DCW      0x00c8,0x01c2
000014  00c8              DCW      0x00c8

                          AREA ||.data||, DATA, ALIGN=0

                  iTestSpeedSequenIndex
000000  00                DCB      0x00

                          AREA ||area_number.6||, DATA, ALIGN=2

                          EXPORTAS ||area_number.6||, ||.data||
                  iTestSpeedLastTime
                          DCD      0x00000000

                          AREA ||area_number.7||, DATA, ALIGN=2

                          EXPORTAS ||area_number.7||, ||.data||
                  unSystemTick
                          DCD      0x00000000

                          AREA ||area_number.8||, DATA, ALIGN=2

                          EXPORTAS ||area_number.8||, ||.data||
                  unWTF_Value
                          DCD      0x0000a5d4

;*** Start embedded assembler ***

#line 1 "User\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_0ca38777____REV16|
#line 464 "D:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.1.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_0ca38777____REV16| PROC
#line 465

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_0ca38777____REVSH|
#line 479
|__asm___6_main_c_0ca38777____REVSH| PROC
#line 480

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
