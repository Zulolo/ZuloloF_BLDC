L 1 "User\Error.c"
N/******************************************************************************
N * @file     Error.c
N * @version  V1.00
N * $Revision: 1 $
N * $Date: 14/12/15 21:13p $ 
N * @brief    BLDC Sensor Less controller for Mini51 series MCU
N *
N * @note
N * Copyright (C) 2014 Zulolo Technology Corp. All rights reserved.
N*****************************************************************************/
N
N#define __USED_BY_ERROR_C__
N#include "Error.h"
L 1 "User\Error.h" 1
N#ifndef __ERROR_H__
N#define __ERROR_H__
N
N#include "global.h"
L 1 "User\global.h" 1
N#ifndef __GLOBAL_H__
N#define __GLOBAL_H__
N
N#include "Mini51Series.h"
L 1 "C:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.1.0\Device\Mini51\Include\Mini51Series.h" 1
N/**************************************************************************//**
N * @file     Mini51Series.h
N * @version  V1.00
N * $Revision: 43 $
N * $Date: 16/06/08 1:55p $
N * @brief    Mini51 series peripheral access layer header file.
N *           This file contains all the peripheral register's definitions,
N *           bits definitions and memory mapping for NuMicro Mini51 series MCU.
N *
N * @note
N * Copyright (C) 2017 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N/**
N   \mainpage NuMicro Mini51DE Driver Reference Guide
N   *
N   * <b>Introduction</b>
N   *
N   * This user manual describes the usage of Mini51DE Series MCU device driver
N   *
N   * <b>Disclaimer</b>
N   *
N   * The Software is furnished "AS IS", without warranty as to performance or results, and
N   * the entire risk as to performance or results is assumed by YOU. Nuvoton disclaims all
N   * warranties, express, implied or otherwise, with regard to the Software, its use, or
N   * operation, including without limitation any and all warranties of merchantability, fitness
N   * for a particular purpose, and non-infringement of intellectual property rights.
N   *
N   * <b>Important Notice</b>
N   *
N   * Nuvoton Products are neither intended nor warranted for usage in systems or equipment,
N   * any malfunction or failure of which may cause loss of human life, bodily injury or severe
N   * property damage. Such applications are deemed, "Insecure Usage".
N   *
N   * Insecure usage includes, but is not limited to: equipment for surgical implementation,
N   * atomic energy control instruments, airplane or spaceship instruments, the control or
N   * operation of dynamic, brake or safety systems designed for vehicular use, traffic signal
N   * instruments, all types of safety devices, and other applications intended to support or
N   * sustain life.
N   *
N   * All Insecure Usage shall be made at customer's risk, and in the event that third parties
N   * lay claims to Nuvoton as a result of customer's Insecure Usage, customer shall indemnify
N   * the damages and liabilities thus incurred by Nuvoton.
N   *
N   * Please note that all data and specifications are subject to change without notice. All the
N   * trademarks of products and companies mentioned in this datasheet belong to their respective
N   * owners.
N   *
N   * <b>Copyright Notice</b>
N   *
N   * Copyright (C) 2013-2017 Nuvoton Technology Corp. All rights reserved.
N   */
N#ifndef __MINI51SERIES_H__
N#define __MINI51SERIES_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @addtogroup MINI51_Definitions MINI51 Definitions
N  This file defines all structures and symbols for Mini51:
N    - interrupt numbers
N    - registers and bit fields
N    - peripheral base address
N    - peripheral ID
N    - Peripheral definitions
N  @{
N*/
N
N/******************************************************************************/
N/*                Processor and Core Peripherals                              */
N/******************************************************************************/
N/** @addtogroup MINI51_CMSIS Device CMSIS Definitions
N  Configuration of the Cortex-M0 Processor and Core Peripherals
N  @{
N*/
N
N/**
N * @details  Interrupt Number Definition. The maximum of 32 Specific Interrupts are possible.
N */
Ntypedef enum IRQn {
N    /******  Cortex-M0 Processor Exceptions Numbers *****************************************/
N
N    NonMaskableInt_IRQn   = -14,    /*!< 2 Non Maskable Interrupt                           */
N    HardFault_IRQn        = -13,    /*!< 3 Cortex-M0 Hard Fault Interrupt                   */
N    SVCall_IRQn           = -5,     /*!< 11 Cortex-M0 SV Call Interrupt                     */
N    PendSV_IRQn           = -2,     /*!< 14 Cortex-M0 Pend SV Interrupt                     */
N    SysTick_IRQn          = -1,     /*!< 15 Cortex-M0 System Tick Interrupt                 */
N
N    /******  Mini51 specific Interrupt Numbers ***********************************************/
N
N    BOD_IRQn              = 0,      /*!< Brownout low voltage detected interrupt            */
N    WDT_IRQn              = 1,      /*!< Watch Dog Timer interrupt                          */
N    EINT0_IRQn            = 2,      /*!< External signal interrupt from P3.2 pin            */
N    EINT1_IRQn            = 3,      /*!< External signal interrupt from P3.3 pin            */
N    GPIO01_IRQn           = 4,      /*!< External signal interrupt from P0/P1               */
N    GPIO234_IRQn          = 5,      /*!< External interrupt from P2/P3/P4                   */
N    PWM_IRQn              = 6,      /*!< PWM interrupt                                      */
N    FB_IRQn               = 7,      /*!< Fault brake interrupt                              */
N    TMR0_IRQn             = 8,      /*!< Timer 0 interrupt                                  */
N    TMR1_IRQn             = 9,      /*!< Timer 1 interrupt                                  */
N    UART_IRQn             = 12,     /*!< UART interrupt                                     */
N    SPI_IRQn              = 14,     /*!< SPI interrupt                                      */
N    GPIO5_IRQn            = 16,     /*!< External interrupt from P5                         */
N    HIRC_IRQn             = 17,     /*!< HIRC trim interrupt                                */
N    I2C_IRQn              = 18,     /*!< I2C interrupt                                      */
N    ACMP_IRQn             = 25,     /*!< ACMP interrupt                                     */
N    PDWU_IRQn             = 28,     /*!< Power Down Wake up interrupt                       */
N    ADC_IRQn              = 29      /*!< ADC interrupt                                      */
N
N} IRQn_Type;
N
N
N/*
N * ==========================================================================
N * ----------- Processor and Core Peripheral Section ------------------------
N * ==========================================================================
N */
N
N
N/* Configuration of the Cortex-M0 Processor and Core Peripherals */
N#define __CM0_REV                0x0201    /*!< Core Revision r2p1                               */
N#define __NVIC_PRIO_BITS         2         /*!< Number of Bits used for Priority Levels          */
N#define __Vendor_SysTickConfig   0         /*!< Set to 1 if different SysTick Config is used     */
N#define __MPU_PRESENT            0         /*!< MPU present or not                               */
N#define __FPU_PRESENT            0         /*!< FPU present or not                               */
N
N/*@}*/ /* end of group MINI51_CMSIS */
N
N
N#include "core_cm0.h"                       /* Cortex-M0 processor and core peripherals           */
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include\core_cm0.h" 1
N/**************************************************************************//**
N * @file     core_cm0.h
N * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
N * @version  V5.0.2
N * @date     19. April 2017
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060528 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CM0_H_GENERIC
N#define __CORE_CM0_H_GENERIC
N
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060034
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 35 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include\core_cm0.h" 2
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/**
N  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/**
N  \ingroup Cortex_M0
N  @{
N */
N
N#include "cmsis_version.h"
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include\cmsis_version.h" 1
N/**************************************************************************//**
N * @file     cmsis_version.h
N * @brief    CMSIS Core(M) Version definitions
N * @version  V5.0.2
N * @date     19. April 2017
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#if   defined ( __ICCARM__ )
X#if   0L
S #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
X#elif 1L && (5060528 >= 6010050)
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CMSIS_VERSION_H
N#define __CMSIS_VERSION_H
N
N/*  CMSIS Version definitions */
N#define __CM_CMSIS_VERSION_MAIN  ( 5U)                                      /*!< [31:16] CMSIS Core(M) main version */
N#define __CM_CMSIS_VERSION_SUB   ( 0U)                                      /*!< [15:0]  CMSIS Core(M) sub version */
N#define __CM_CMSIS_VERSION       ((__CM_CMSIS_VERSION_MAIN << 16U) | \
N                                   __CM_CMSIS_VERSION_SUB           )       /*!< CMSIS Core(M) version number */
X#define __CM_CMSIS_VERSION       ((__CM_CMSIS_VERSION_MAIN << 16U) |                                    __CM_CMSIS_VERSION_SUB           )        
N#endif
L 64 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include\core_cm0.h" 2
N 
N/*  CMSIS CM0 definitions */
N#define __CM0_CMSIS_VERSION_MAIN  (__CM_CMSIS_VERSION_MAIN)              /*!< \deprecated [31:16] CMSIS HAL main version */
N#define __CM0_CMSIS_VERSION_SUB   (__CM_CMSIS_VERSION_SUB)               /*!< \deprecated [15:0]  CMSIS HAL sub version */
N#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16U) | \
N                                    __CM0_CMSIS_VERSION_SUB           )  /*!< \deprecated CMSIS HAL version number */
X#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16U) |                                     __CM0_CMSIS_VERSION_SUB           )   
N
N#define __CORTEX_M                (0U)                                   /*!< Cortex-M Core */
N
N/** __FPU_USED indicates whether an FPU is used or not.
N    This core does not support an FPU at all
N*/
N#define __FPU_USED       0U
N
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 0L
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
N  #endif
N
N#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #if defined __ARM_PCS_VFP
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TI_ARM__ )
S  #if defined __TI_VFP_SUPPORT__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __CSMC__ )
S  #if ( __CSMC__ & 0x400U)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
N#endif
N
N#include "cmsis_compiler.h"               /* CMSIS compiler specific defines */
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include\cmsis_compiler.h" 1
N/**************************************************************************//**
N * @file     cmsis_compiler.h
N * @brief    CMSIS compiler generic header file
N * @version  V5.0.2
N * @date     13. February 2017
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __CMSIS_COMPILER_H
N#define __CMSIS_COMPILER_H
N
N#include <stdint.h>
N
N/*
N * ARM Compiler 4/5
N */
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include\cmsis_armcc.h" 1
N/**************************************************************************//**
N * @file     cmsis_armcc.h
N * @brief    CMSIS compiler ARMCC (ARM compiler V5) header file
N * @version  V5.0.2
N * @date     13. February 2017
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2017 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __CMSIS_ARMCC_H
N#define __CMSIS_ARMCC_H
N
N
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 400677)
X#if 1L && (5060528 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* CMSIS compiler control architecture macros */
N#if ((defined (__TARGET_ARCH_6_M  ) && (__TARGET_ARCH_6_M   == 1)) || \
N     (defined (__TARGET_ARCH_6S_M ) && (__TARGET_ARCH_6S_M  == 1))   )
X#if ((0L && (__TARGET_ARCH_6_M   == 1)) ||      (1L && (1  == 1))   )
N  #define __ARM_ARCH_6M__           1
N#endif
N
N#if (defined (__TARGET_ARCH_7_M ) && (__TARGET_ARCH_7_M  == 1))
X#if (0L && (__TARGET_ARCH_7_M  == 1))
S  #define __ARM_ARCH_7M__           1
N#endif
N
N#if (defined (__TARGET_ARCH_7E_M) && (__TARGET_ARCH_7E_M == 1))
X#if (0L && (__TARGET_ARCH_7E_M == 1))
S  #define __ARM_ARCH_7EM__          1
N#endif
N
N  /* __ARM_ARCH_8M_BASE__  not applicable */
N  /* __ARM_ARCH_8M_MAIN__  not applicable */
N
N
N/* CMSIS compiler specific defines */
N#ifndef   __ASM
N  #define __ASM                                  __asm
N#endif
N#ifndef   __INLINE
N  #define __INLINE                               __inline
N#endif
N#ifndef   __STATIC_INLINE
N  #define __STATIC_INLINE                        static __inline
N#endif
N#ifndef   __NO_RETURN
N  #define __NO_RETURN                            __declspec(noreturn)
N#endif
N#ifndef   __USED
N  #define __USED                                 __attribute__((used))
N#endif
N#ifndef   __WEAK
N  #define __WEAK                                 __attribute__((weak))
N#endif
N#ifndef   __PACKED
N  #define __PACKED                               __attribute__((packed))
N#endif
N#ifndef   __PACKED_STRUCT
N  #define __PACKED_STRUCT                        __packed struct
N#endif
N#ifndef   __PACKED_UNION
N  #define __PACKED_UNION                         __packed union
N#endif
N#ifndef   __UNALIGNED_UINT32        /* deprecated */
N  #define __UNALIGNED_UINT32(x)                  (*((__packed uint32_t *)(x)))
N#endif
N#ifndef   __UNALIGNED_UINT16_WRITE
N  #define __UNALIGNED_UINT16_WRITE(addr, val)    ((*((__packed uint16_t *)(addr))) = (val))
N#endif
N#ifndef   __UNALIGNED_UINT16_READ
N  #define __UNALIGNED_UINT16_READ(addr)          (*((const __packed uint16_t *)(addr)))
N#endif
N#ifndef   __UNALIGNED_UINT32_WRITE
N  #define __UNALIGNED_UINT32_WRITE(addr, val)    ((*((__packed uint32_t *)(addr))) = (val))
N#endif
N#ifndef   __UNALIGNED_UINT32_READ
N  #define __UNALIGNED_UINT32_READ(addr)          (*((const __packed uint32_t *)(addr)))
N#endif
N#ifndef   __ALIGNED
N  #define __ALIGNED(x)                           __attribute__((aligned(x)))
N#endif
N#ifndef   __RESTRICT
N  #define __RESTRICT                             __restrict
N#endif
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N/**
N  \brief   Enable IRQ Interrupts
N  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N/* intrinsic void __enable_irq();     */
N
N
N/**
N  \brief   Disable IRQ Interrupts
N  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N/* intrinsic void __disable_irq();    */
N
N/**
N  \brief   Get Control Register
N  \details Returns the content of the Control Register.
N  \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/**
N  \brief   Set Control Register
N  \details Writes the given value to the Control Register.
N  \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/**
N  \brief   Get IPSR Register
N  \details Returns the content of the IPSR Register.
N  \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/**
N  \brief   Get APSR Register
N  \details Returns the content of the APSR Register.
N  \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/**
N  \brief   Get xPSR Register
N  \details Returns the content of the xPSR Register.
N  \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/**
N  \brief   Get Process Stack Pointer
N  \details Returns the current value of the Process Stack Pointer (PSP).
N  \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/**
N  \brief   Set Process Stack Pointer
N  \details Assigns the given value to the Process Stack Pointer (PSP).
N  \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/**
N  \brief   Get Main Stack Pointer
N  \details Returns the current value of the Main Stack Pointer (MSP).
N  \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/**
N  \brief   Set Main Stack Pointer
N  \details Assigns the given value to the Main Stack Pointer (MSP).
N  \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/**
N  \brief   Get Priority Mask
N  \details Returns the current state of the priority mask bit from the Priority Mask Register.
N  \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/**
N  \brief   Set Priority Mask
N  \details Assigns the given value to the Priority Mask Register.
N  \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7M__  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
S
S/**
S  \brief   Enable FIQ
S  \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
S           Can only be executed in Privileged modes.
S */
S#define __enable_fault_irq                __enable_fiq
S
S
S/**
S  \brief   Disable FIQ
S  \details Disables FIQ interrupts by setting the F-bit in the CPSR.
S           Can only be executed in Privileged modes.
S */
S#define __disable_fault_irq               __disable_fiq
S
S
S/**
S  \brief   Get Base Priority
S  \details Returns the current value of the Base Priority register.
S  \return               Base Priority register value
S */
S__STATIC_INLINE uint32_t  __get_BASEPRI(void)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  return(__regBasePri);
S}
S
S
S/**
S  \brief   Set Base Priority
S  \details Assigns the given value to the Base Priority register.
S  \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  __regBasePri = (basePri & 0xFFU);
S}
S
S
S/**
S  \brief   Set Base Priority with condition
S  \details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
S           or the new value increases the BASEPRI priority level.
S  \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
S{
S  register uint32_t __regBasePriMax      __ASM("basepri_max");
S  __regBasePriMax = (basePri & 0xFFU);
S}
S
S
S/**
S  \brief   Get Fault Mask
S  \details Returns the current value of the Fault Mask register.
S  \return               Fault Mask register value
S */
S__STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  return(__regFaultMask);
S}
S
S
S/**
S  \brief   Set Fault Mask
S  \details Assigns the given value to the Fault Mask register.
S  \param [in]    faultMask  Fault Mask value to set
S */
S__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  __regFaultMask = (faultMask & (uint32_t)1U);
S}
S
N#endif /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#endif  
N
N
N#if ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7EM__ == 1))     )
S
S/**
S  \brief   Get FPSCR
S  \details Returns the current value of the Floating Point Status/Control register.
S  \return               Floating Point Status/Control register value
S */
S__STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
S     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
X#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) &&      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
S#else
S   return(0U);
S#endif
S}
S
S
S/**
S  \brief   Set FPSCR
S  \details Assigns the given value to the Floating Point Status/Control register.
S  \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
S     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
X#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) &&      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
S#else
S  (void)fpscr;
S#endif
S}
S
N#endif /* ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
N
N
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/**
N  \brief   No Operation
N  \details No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/**
N  \brief   Wait For Interrupt
N  \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/**
N  \brief   Wait For Event
N  \details Wait For Event is a hint instruction that permits the processor to enter
N           a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/**
N  \brief   Send Event
N  \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/**
N  \brief   Instruction Synchronization Barrier
N  \details Instruction Synchronization Barrier flushes the pipeline in the processor,
N           so that all instructions following the ISB are fetched from cache or memory,
N           after the instruction has been completed.
N */
N#define __ISB() do {\
N                   __schedule_barrier();\
N                   __isb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __ISB() do {                   __schedule_barrier();                   __isb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Synchronization Barrier
N  \details Acts as a special kind of Data Memory Barrier.
N           It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB() do {\
N                   __schedule_barrier();\
N                   __dsb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DSB() do {                   __schedule_barrier();                   __dsb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Memory Barrier
N  \details Ensures the apparent order of the explicit memory operations before
N           and after the instruction, without ensuring their completion.
N */
N#define __DMB() do {\
N                   __schedule_barrier();\
N                   __dmb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DMB() do {                   __schedule_barrier();                   __dmb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Reverse byte order (32 bit)
N  \details Reverses the byte order in integer value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order in two unsigned short values.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Reverse byte order in signed short value
N  \details Reverses the byte order in a signed short value with sign extension to integer.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Rotate Right in unsigned value (32 bit)
N  \details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N  \param [in]    op1  Value to rotate
N  \param [in]    op2  Number of Bits to rotate
N  \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/**
N  \brief   Breakpoint
N  \details Causes the processor to enter Debug state.
N           Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N  \param [in]    value  is ignored by the processor.
N                 If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N/**
N  \brief   Reverse bit order of value
N  \details Reverses the bit order of the given value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7M__  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
S  #define __RBIT                          __rbit
N#else
N__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
X__attribute__((always_inline)) static __inline uint32_t __RBIT(uint32_t value)
N{
N  uint32_t result;
N  int32_t s = (4 /*sizeof(v)*/ * 8) - 1; /* extra shift needed at end */
N
N  result = value;                      /* r will be reversed bits of v; first get LSB of v */
N  for (value >>= 1U; value; value >>= 1U)
N  {
N    result <<= 1U;
N    result |= value & 1U;
N    s--;
N  }
N  result <<= s;                        /* shift when v's highest bits are zero */
N  return(result);
N}
N#endif
N
N
N/**
N  \brief   Count leading zeros
N  \details Counts the number of leading zeros of a data value.
N  \param [in]  value  Value to count the leading zeros
N  \return             number of leading zeros in value
N */
N#define __CLZ                             __clz
N
N
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7M__  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
S
S/**
S  \brief   LDR Exclusive (8 bit)
S  \details Executes a exclusive LDR instruction for 8 bit value.
S  \param [in]    ptr  Pointer to data
S  \return             value of type uint8_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXB(ptr)                                                        ((uint8_t ) __ldrex(ptr))
S#else
S  #define __LDREXB(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint8_t ) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   LDR Exclusive (16 bit)
S  \details Executes a exclusive LDR instruction for 16 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint16_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXH(ptr)                                                        ((uint16_t) __ldrex(ptr))
S#else
S  #define __LDREXH(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint16_t) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   LDR Exclusive (32 bit)
S  \details Executes a exclusive LDR instruction for 32 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint32_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXW(ptr)                                                        ((uint32_t ) __ldrex(ptr))
S#else
S  #define __LDREXW(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint32_t ) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (8 bit)
S  \details Executes a exclusive STR instruction for 8 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXB(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXB(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (16 bit)
S  \details Executes a exclusive STR instruction for 16 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXH(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXH(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (32 bit)
S  \details Executes a exclusive STR instruction for 32 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXW(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXW(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   Remove the exclusive lock
S  \details Removes the exclusive lock which is created by LDREX.
S */
S#define __CLREX                           __clrex
S
S
S/**
S  \brief   Signed Saturate
S  \details Saturates a signed value.
S  \param [in]  value  Value to be saturated
S  \param [in]    sat  Bit position to saturate to (1..32)
S  \return             Saturated value
S */
S#define __SSAT                            __ssat
S
S
S/**
S  \brief   Unsigned Saturate
S  \details Saturates an unsigned value.
S  \param [in]  value  Value to be saturated
S  \param [in]    sat  Bit position to saturate to (0..31)
S  \return             Saturated value
S */
S#define __USAT                            __usat
S
S
S/**
S  \brief   Rotate Right with Extend (32 bit)
S  \details Moves each bit of a bitstring right by one bit.
S           The carry input is shifted in at the left end of the bitstring.
S  \param [in]    value  Value to rotate
S  \return               Rotated value
S */
S#ifndef __NO_EMBEDDED_ASM
S__attribute__((section(".rrx_text"))) __STATIC_INLINE __ASM uint32_t __RRX(uint32_t value)
S{
S  rrx r0, r0
S  bx lr
S}
S#endif
S
S
S/**
S  \brief   LDRT Unprivileged (8 bit)
S  \details Executes a Unprivileged LDRT instruction for 8 bit value.
S  \param [in]    ptr  Pointer to data
S  \return             value of type uint8_t at (*ptr)
S */
S#define __LDRBT(ptr)                      ((uint8_t )  __ldrt(ptr))
S
S
S/**
S  \brief   LDRT Unprivileged (16 bit)
S  \details Executes a Unprivileged LDRT instruction for 16 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint16_t at (*ptr)
S */
S#define __LDRHT(ptr)                      ((uint16_t)  __ldrt(ptr))
S
S
S/**
S  \brief   LDRT Unprivileged (32 bit)
S  \details Executes a Unprivileged LDRT instruction for 32 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint32_t at (*ptr)
S */
S#define __LDRT(ptr)                       ((uint32_t ) __ldrt(ptr))
S
S
S/**
S  \brief   STRT Unprivileged (8 bit)
S  \details Executes a Unprivileged STRT instruction for 8 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRBT(value, ptr)               __strt(value, ptr)
S
S
S/**
S  \brief   STRT Unprivileged (16 bit)
S  \details Executes a Unprivileged STRT instruction for 16 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRHT(value, ptr)               __strt(value, ptr)
S
S
S/**
S  \brief   STRT Unprivileged (32 bit)
S  \details Executes a Unprivileged STRT instruction for 32 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRT(value, ptr)                __strt(value, ptr)
S
N#endif /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#endif  
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N#if ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7EM__ == 1))     )
S
S#define __SADD8                           __sadd8
S#define __QADD8                           __qadd8
S#define __SHADD8                          __shadd8
S#define __UADD8                           __uadd8
S#define __UQADD8                          __uqadd8
S#define __UHADD8                          __uhadd8
S#define __SSUB8                           __ssub8
S#define __QSUB8                           __qsub8
S#define __SHSUB8                          __shsub8
S#define __USUB8                           __usub8
S#define __UQSUB8                          __uqsub8
S#define __UHSUB8                          __uhsub8
S#define __SADD16                          __sadd16
S#define __QADD16                          __qadd16
S#define __SHADD16                         __shadd16
S#define __UADD16                          __uadd16
S#define __UQADD16                         __uqadd16
S#define __UHADD16                         __uhadd16
S#define __SSUB16                          __ssub16
S#define __QSUB16                          __qsub16
S#define __SHSUB16                         __shsub16
S#define __USUB16                          __usub16
S#define __UQSUB16                         __uqsub16
S#define __UHSUB16                         __uhsub16
S#define __SASX                            __sasx
S#define __QASX                            __qasx
S#define __SHASX                           __shasx
S#define __UASX                            __uasx
S#define __UQASX                           __uqasx
S#define __UHASX                           __uhasx
S#define __SSAX                            __ssax
S#define __QSAX                            __qsax
S#define __SHSAX                           __shsax
S#define __USAX                            __usax
S#define __UQSAX                           __uqsax
S#define __UHSAX                           __uhsax
S#define __USAD8                           __usad8
S#define __USADA8                          __usada8
S#define __SSAT16                          __ssat16
S#define __USAT16                          __usat16
S#define __UXTB16                          __uxtb16
S#define __UXTAB16                         __uxtab16
S#define __SXTB16                          __sxtb16
S#define __SXTAB16                         __sxtab16
S#define __SMUAD                           __smuad
S#define __SMUADX                          __smuadx
S#define __SMLAD                           __smlad
S#define __SMLADX                          __smladx
S#define __SMLALD                          __smlald
S#define __SMLALDX                         __smlaldx
S#define __SMUSD                           __smusd
S#define __SMUSDX                          __smusdx
S#define __SMLSD                           __smlsd
S#define __SMLSDX                          __smlsdx
S#define __SMLSLD                          __smlsld
S#define __SMLSLDX                         __smlsldx
S#define __SEL                             __sel
S#define __QADD                            __qadd
S#define __QSUB                            __qsub
S
S#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
S                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
X#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |                                             ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
S
S#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
S                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
X#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |                                             ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
S
S#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) + \
S                                                      ((int64_t)(ARG3) << 32U)     ) >> 32U))
X#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) +                                                       ((int64_t)(ARG3) << 32U)     ) >> 32U))
S
N#endif /* ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#endif /* __CMSIS_ARMCC_H */
L 35 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include\cmsis_compiler.h" 2
N
N
N/*
N * ARM Compiler 6 (armclang)
N */
N#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #include "cmsis_armclang.h"
S
S
S/*
S * GNU Compiler
S */
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S
S/*
S * IAR Compiler
S */
S#elif defined ( __ICCARM__ )
S
S
S  #ifndef   __ASM
S    #define __ASM                                  __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S
S  #include <cmsis_iar.h>
S
S  /* CMSIS compiler control architecture macros */
S  #if (__CORE__ == __ARM6M__) || (__CORE__ == __ARM6SM__)
S    #ifndef __ARM_ARCH_6M__
S      #define __ARM_ARCH_6M__                      1
S    #endif
S  #elif (__CORE__ == __ARM7M__)
S    #ifndef __ARM_ARCH_7M__
S      #define __ARM_ARCH_7M__                      1
S    #endif
S  #elif (__CORE__ == __ARM7EM__)
S    #ifndef __ARM_ARCH_7EM__
S      #define __ARM_ARCH_7EM__                     1
S    #endif
S  #endif
S
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN                            __noreturn
S  #endif
S  #ifndef   __USED
S    #define __USED                                 __root
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __weak
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               __packed
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        __packed struct
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         __packed union
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    __packed struct T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #warning No compiler specific solution for __ALIGNED. __ALIGNED is ignored.
S    #define __ALIGNED(x)
S  #endif
S  #ifndef   __RESTRICT
S    #warning No compiler specific solution for __RESTRICT. __RESTRICT is ignored.
S    #define __RESTRICT
S  #endif
S
S  // Workaround for missing __CLZ intrinsic in
S  // various versions of the IAR compilers.
S  // __IAR_FEATURE_CLZ__ should be defined by
S  // the compiler that supports __CLZ internally.
S  #if (defined (__ARM_ARCH_6M__)) && (__ARM_ARCH_6M__ == 1) && (!defined (__IAR_FEATURE_CLZ__))
S    __STATIC_INLINE uint32_t __CLZ(uint32_t data)
S    {
S      if (data == 0u) { return 32u; }
S      
S      uint32_t count = 0;
S      uint32_t mask = 0x80000000;
S      
S      while ((data & mask) == 0)
S      {
S        count += 1u;
S        mask = mask >> 1u;
S      }
S      
S      return (count);
S    }
S  #endif
S
S
S/*
S * TI ARM Compiler
S */
S#elif defined ( __TI_ARM__ )
S  #include <cmsis_ccs.h>
S
S  #ifndef   __ASM
S    #define __ASM                                  __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN                            __attribute__((noreturn))
S  #endif
S  #ifndef   __USED
S    #define __USED                                 __attribute__((used))
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __attribute__((weak))
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               __attribute__((packed))
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        struct __attribute__((packed))
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         union __attribute__((packed))
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    struct __attribute__((packed)) T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void*)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #define __ALIGNED(x)                           __attribute__((aligned(x)))
S  #endif
S  #ifndef   __RESTRICT
S    #warning No compiler specific solution for __RESTRICT. __RESTRICT is ignored.
S    #define __RESTRICT
S  #endif
S
S
S/*
S * TASKING Compiler
S */
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S  #ifndef   __ASM
S    #define __ASM                                  __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN                            __attribute__((noreturn))
S  #endif
S  #ifndef   __USED
S    #define __USED                                 __attribute__((used))
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __attribute__((weak))
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               __packed__
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        struct __packed__
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         union __packed__
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    struct __packed__ T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #define __ALIGNED(x)              __align(x)
S  #endif
S  #ifndef   __RESTRICT
S    #warning No compiler specific solution for __RESTRICT. __RESTRICT is ignored.
S    #define __RESTRICT
S  #endif
S
S
S/*
S * COSMIC Compiler
S */
S#elif defined ( __CSMC__ )
S   #include <cmsis_csm.h>
S
S #ifndef   __ASM
S    #define __ASM                                  _asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __NO_RETURN
S    // NO RETURN is automatically detected hence no warning here
S    #define __NO_RETURN
S  #endif
S  #ifndef   __USED
S    #warning No compiler specific solution for __USED. __USED is ignored.
S    #define __USED
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __weak
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               @packed
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        @packed struct
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         @packed union
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    @packed struct T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #warning No compiler specific solution for __ALIGNED. __ALIGNED is ignored.
S    #define __ALIGNED(x)
S  #endif
S  #ifndef   __RESTRICT
S    #warning No compiler specific solution for __RESTRICT. __RESTRICT is ignored.
S    #define __RESTRICT
S  #endif
S
S
S#else
S  #error Unknown compiler.
N#endif
N
N
N#endif /* __CMSIS_COMPILER_H */
N
L 116 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include\core_cm0.h" 2
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM0_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM0_H_DEPENDANT
N#define __CORE_CM0_H_DEPENDANT
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM0_REV
S    #define __CM0_REV               0x0000U
S    #warning "__CM0_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          2U
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0U
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions */
N
N/* following defines should be used for structure members */
N#define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
N#define     __OM     volatile            /*! Defines 'write only' structure member permissions */
N#define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
N
N/*@} end of group Cortex_M0 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N ******************************************************************************/
N/**
N  \defgroup CMSIS_core_register Defines and Type Definitions
N  \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_CORE  Status and Control Registers
N  \brief      Core Register type definitions.
N  @{
N */
N
N/**
N  \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:28;              /*!< bit:  0..27  Reserved */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} APSR_Type;
N
N/* APSR Register Definitions */
N#define APSR_N_Pos                         31U                                            /*!< APSR: N Position */
N#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
N
N#define APSR_Z_Pos                         30U                                            /*!< APSR: Z Position */
N#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
N
N#define APSR_C_Pos                         29U                                            /*!< APSR: C Position */
N#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
N
N#define APSR_V_Pos                         28U                                            /*!< APSR: V Position */
N#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
N
N
N/**
N  \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} IPSR_Type;
N
N/* IPSR Register Definitions */
N#define IPSR_ISR_Pos                        0U                                            /*!< IPSR: ISR Position */
N#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved */
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
N    uint32_t _reserved1:3;               /*!< bit: 25..27  Reserved */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} xPSR_Type;
N
N/* xPSR Register Definitions */
N#define xPSR_N_Pos                         31U                                            /*!< xPSR: N Position */
N#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
N
N#define xPSR_Z_Pos                         30U                                            /*!< xPSR: Z Position */
N#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
N
N#define xPSR_C_Pos                         29U                                            /*!< xPSR: C Position */
N#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
N
N#define xPSR_V_Pos                         28U                                            /*!< xPSR: V Position */
N#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
N
N#define xPSR_T_Pos                         24U                                            /*!< xPSR: T Position */
N#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
N
N#define xPSR_ISR_Pos                        0U                                            /*!< xPSR: ISR Position */
N#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:1;               /*!< bit:      0  Reserved */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
N    uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} CONTROL_Type;
N
N/* CONTROL Register Definitions */
N#define CONTROL_SPSEL_Pos                   1U                                            /*!< CONTROL: SPSEL Position */
N#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
N
N/*@} end of group CMSIS_CORE */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N  \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IOM uint32_t ISER[1U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
X  volatile uint32_t ISER[1U];                
N        uint32_t RESERVED0[31U];
N  __IOM uint32_t ICER[1U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
X  volatile uint32_t ICER[1U];                
N        uint32_t RSERVED1[31U];
N  __IOM uint32_t ISPR[1U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
X  volatile uint32_t ISPR[1U];                
N        uint32_t RESERVED2[31U];
N  __IOM uint32_t ICPR[1U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
X  volatile uint32_t ICPR[1U];                
N        uint32_t RESERVED3[31U];
N        uint32_t RESERVED4[64U];
N  __IOM uint32_t IP[8U];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register */
X  volatile uint32_t IP[8U];                  
N}  NVIC_Type;
N
N/*@} end of group CMSIS_NVIC */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCB     System Control Block (SCB)
N  \brief    Type definitions for the System Control Block Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
X  volatile const  uint32_t CPUID;                   
N  __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
X  volatile uint32_t ICSR;                    
N        uint32_t RESERVED0;
N  __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
X  volatile uint32_t AIRCR;                   
N  __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
X  volatile uint32_t SCR;                     
N  __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register */
X  volatile uint32_t CCR;                     
N        uint32_t RESERVED1;
N  __IOM uint32_t SHP[2U];                /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED */
X  volatile uint32_t SHP[2U];                 
N  __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
X  volatile uint32_t SHCSR;                   
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N  \brief    Type definitions for the System Timer Registers.
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
X  volatile uint32_t LOAD;                    
N  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
X  volatile uint32_t VAL;                     
N  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
X  volatile const  uint32_t CALIB;                   
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N  \brief    Cortex-M0 Core Debug Registers (DCB registers, SHCSR, and DFSR) are only accessible over DAP and not via processor.
N            Therefore they are not covered by the Cortex-M0 header file.
N  @{
N */
N/*@} end of group CMSIS_CoreDebug */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_bitfield     Core register bit field macros
N  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
N  @{
N */
N
N/**
N  \brief   Mask and shift a bit field value for use in a register bit range.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
N  \return           Masked and shifted value.
N*/
N#define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)
N
N/**
N  \brief     Mask and shift a register value to extract a bit filed value.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
N  \return           Masked and shifted bit field value.
N*/
N#define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)
N
N/*@} end of group CMSIS_core_bitfield */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_base     Core Definitions
N  \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Core Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct */
N
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/**
N  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N  \brief    Functions that manage interrupts and exceptions via the NVIC.
N  @{
N */
N
N#ifdef CMSIS_NVIC_VIRTUAL
S  #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE
S    #define CMSIS_NVIC_VIRTUAL_HEADER_FILE "cmsis_nvic_virtual.h"
S  #endif
S  #include CMSIS_NVIC_VIRTUAL_HEADER_FILE
N#else
N/*#define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping   not available for Cortex-M0 */
N/*#define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping   not available for Cortex-M0 */
N  #define NVIC_EnableIRQ              __NVIC_EnableIRQ
N  #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ
N  #define NVIC_DisableIRQ             __NVIC_DisableIRQ
N  #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ
N  #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ
N  #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ
N/*#define NVIC_GetActive              __NVIC_GetActive             not available for Cortex-M0 */
N  #define NVIC_SetPriority            __NVIC_SetPriority
N  #define NVIC_GetPriority            __NVIC_GetPriority
N  #define NVIC_SystemReset            __NVIC_SystemReset
N#endif /* CMSIS_NVIC_VIRTUAL */
N
N#ifdef CMSIS_VECTAB_VIRTUAL
S  #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE
S    #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE "cmsis_vectab_virtual.h"
S  #endif
S  #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE
N#else
N  #define NVIC_SetVector              __NVIC_SetVector
N  #define NVIC_GetVector              __NVIC_GetVector
N#endif  /* (CMSIS_VECTAB_VIRTUAL) */
N
N#define NVIC_USER_IRQ_OFFSET          16
N
N
N/* Interrupt Priorities are WORD accessible only under ARMv6M                   */
N/* The following MACROS handle generation of the register offset and byte masks */
N#define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)
N#define _SHP_IDX(IRQn)           ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >>    2UL)      )
N#define _IP_IDX(IRQn)            (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )
N
N
N/**
N  \brief   Enable Interrupt
N  \details Enables a device specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Enable status
N  \details Returns a device specific interrupt enable status from the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt is not enabled.
N  \return             1  Interrupt is enabled.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->ISER[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Disable Interrupt
N  \details Disables a device specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N    __DSB();
X    do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);
N    __ISB();
X    do { __schedule_barrier(); __isb(0xF); __schedule_barrier(); } while (0U);
N  }
N}
N
N
N/**
N  \brief   Get Pending Interrupt
N  \details Reads the NVIC pending register and returns the pending bit for the specified device specific interrupt.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt status is not pending.
N  \return             1  Interrupt status is pending.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->ISPR[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Set Pending Interrupt
N  \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Clear Pending Interrupt
N  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Set Interrupt Priority
N  \details Sets the priority of a device specific interrupt or a processor exception.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]      IRQn  Interrupt number.
N  \param [in]  priority  Priority to set.
N  \note    The priority cannot be set for every processor exception.
N */
N__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )]  = ((uint32_t)(((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )]  & ~(0xFFUL << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL))) |
N       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
X       (((priority << (8U - 2)) & (uint32_t)0xFFUL) << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL)));
N  }
N  else
N  {
N    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] = ((uint32_t)(((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] & ~(0xFFUL << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL))) |
N       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
X       (((priority << (8U - 2)) & (uint32_t)0xFFUL) << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL)));
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Priority
N  \details Reads the priority of a device specific interrupt or a processor exception.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]   IRQn  Interrupt number.
N  \return             Interrupt Priority.
N                      Value is aligned automatically to the implemented priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[ ( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )] >> ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL) ) & (uint32_t)0xFFUL) >> (8U - 2)));
N  }
N  else
N  {
N    return((uint32_t)(((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));
X    return((uint32_t)(((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] >> ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL) ) & (uint32_t)0xFFUL) >> (8U - 2)));
N  }
N}
N
N
N/**
N  \brief   Set Interrupt Vector
N  \details Sets an interrupt vector in SRAM based interrupt vector table.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N           Address 0 must be mapped to SRAM.
N  \param [in]   IRQn      Interrupt number
N  \param [in]   vector    Address of interrupt handler function
N */
N__STATIC_INLINE void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
Xstatic __inline void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
N{
N  uint32_t *vectors = (uint32_t *)0x0U;
N  vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET] = vector;
X  vectors[(int32_t)IRQn + 16] = vector;
N}
N
N
N/**
N  \brief   Get Interrupt Vector
N  \details Reads an interrupt vector from interrupt vector table.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]   IRQn      Interrupt number.
N  \return                 Address of interrupt handler function
N */
N__STATIC_INLINE uint32_t __NVIC_GetVector(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetVector(IRQn_Type IRQn)
N{
N  uint32_t *vectors = (uint32_t *)0x0U;
N  return vectors[(int32_t)IRQn + NVIC_USER_IRQ_OFFSET];
X  return vectors[(int32_t)IRQn + 16];
N}
N
N
N/**
N  \brief   System Reset
N  \details Initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void __NVIC_SystemReset(void)
Xstatic __inline void __NVIC_SystemReset(void)
N{
N  __DSB();                                                          /* Ensure all outstanding memory accesses included
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                          
N                                                                       buffered write are completed before reset */
N  SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = ((0x5FAUL << 16U) |
N                 SCB_AIRCR_SYSRESETREQ_Msk);
X                 (1UL << 2U));
N  __DSB();                                                          /* Ensure completion of memory access */
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                           
N
N  for(;;)                                                           /* wait until reset */
N  {
N    __NOP();
X    __nop();
N  }
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N/* ##########################  FPU functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_FpuFunctions FPU Functions
N  \brief    Function that provides FPU type.
N  @{
N */
N
N/**
N  \brief   get FPU type
N  \details returns the FPU type
N  \returns
N   - \b  0: No FPU
N   - \b  1: Single precision FPU
N   - \b  2: Double + Single precision FPU
N */
N__STATIC_INLINE uint32_t SCB_GetFPUType(void)
Xstatic __inline uint32_t SCB_GetFPUType(void)
N{
N    return 0U;           /* No FPU */
N}
N
N
N/*@} end of CMSIS_Core_FpuFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N  \brief    Functions that configure the System.
N  @{
N */
N
N#if defined (__Vendor_SysTickConfig) && (__Vendor_SysTickConfig == 0U)
X#if 1L && (0 == 0U)
N
N/**
N  \brief   System Tick Configuration
N  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
N           Counter is in free running mode to generate periodic interrupts.
N  \param [in]  ticks  Number of ticks between two interrupts.
N  \return          0  Function succeeded.
N  \return          1  Function failed.
N  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N           must contain a vendor-specific implementation of this function.
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
X  if ((ticks - 1UL) > (0xFFFFFFUL ))
N  {
N    return (1UL);                                                   /* Reload value impossible */
N  }
N
N  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (uint32_t)(ticks - 1UL);                          
N  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
X  __NVIC_SetPriority (SysTick_IRQn, (1UL << 2) - 1UL);  
N  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0UL;                                              
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2U) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1U)   |
N                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL );                          
N  return (0UL);                                                     /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM0_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
L 131 "C:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.1.0\Device\Mini51\Include\Mini51Series.h" 2
N#include "system_Mini51Series.h"            /* Mini51 Series System include file                  */
L 1 "C:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.1.0\Device\Mini51\Include\system_Mini51Series.h" 1
N/**************************************************************************//**
N * @file     system_Mini51Series.h
N * @version  V1.00
N * $Revision: 4 $
N * $Date: 13/11/07 4:40p $
N * @brief    Mini51 series system clock definition file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N
N
N#ifndef __SYSTEM_MINI51SERIES_H__
N#define __SYSTEM_MINI51SERIES_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Macro Definition                                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/*----------------------------------------------------------------------------
N  Define SYSCLK
N *----------------------------------------------------------------------------*/
N
N#define __XTAL12M        (12000000UL)
N#define __XTAL32K        (32768UL)
N#define __IRC22M        (22118400UL)
N#define __IRC10K        (10000UL)
N#define __XTAL            __XTAL12M
N#define __HSI            (__IRC22M)      /* Factory Default is internal 22MHz */
N
N
Nextern uint32_t SystemCoreClock;        /*!< System Clock Frequency (Core Clock) */
Nextern uint32_t CyclesPerUs;            /*!< Cycles per micro second */
N
N/**
N * Update SystemCoreClock variable
N *
N * @param  None
N * @return None
N *
N * @brief  Updates the SystemCoreClock with current core Clock
N *         retrieved from CPU registers.
N */
N
Nextern void SystemCoreClockUpdate (void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif  //__SYSTEM_MINI51SERIES_H__
N
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 132 "C:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.1.0\Device\Mini51\Include\Mini51Series.h" 2
N#include <stdint.h>
N
N/******************************************************************************/
N/*                Device Specific Peripheral registers structures             */
N/******************************************************************************/
N/** @addtogroup MINI51_Peripherals MINI51 Peripherals
N  MINI51 Device Specific Peripheral registers structures
N  @{
N*/
N
N#if defined ( __CC_ARM  )
X#if 1L
N#pragma anon_unions
N#endif
N
N
N
N/*---------------------- Analog Comparator Controller -------------------------*/
N/**
N    @addtogroup ACMP Analog Comparator Controller(ACMP)
N    Memory Mapped Structure for ACMP Controller
N@{ */
N
N
Ntypedef struct {
N
N    /**
N     * @var ACMP_T::CMPCR
N     * Offset: 0x00  Analog Comparator 0 Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ACMPEN    |Analog Comparator Enable Control
N     * |        |          |0 = Analog Comparator Disabled.
N     * |        |          |1 = Analog Comparator Enabled.
N     * |        |          |Note: Analog comparator output needs to wait 2 us stable time after this bit is set.
N     * |[1]     |ACMPIE    |Analog Comparator 0 Interrupt Enable Control
N     * |        |          |0 = Interrupt function Disabled.
N     * |        |          |1 = Interrupt function Enabled.
N     * |[2]     |HYSEN     |Analog Comparator Hysteresis Enable Control
N     * |        |          |0 = Hysteresis function Disabled.
N     * |        |          |1 = Hysteresis function Enabled.
N     * |[4]     |NEGSEL    |Analog Comparator Negative Input Selection
N     * |        |          |0 = The source of the negative comparator input is from CPN pin.
N     * |        |          |1 = The source of the negative comparator input is from internal band-gap voltage or comparator reference voltage.
N     * |[8]     |RISING    |Analog Comparator Rising Edge Trigger Enable Control
N     * |        |          |0 = Analog comparator rising edge trigger Disabled.
N     * |        |          |1 = Analog comparator rising edge trigger PWM or Timer Enabled.
N     * |        |          |Note: The bit is only effective while analog comparator triggers PWM or Timer.
N     * |[9]     |FALLING   |Analog Comparator Falling Edge Trigger Enable Control
N     * |        |          |0 = Analog comparator falling edge trigger Disabled.
N     * |        |          |1 = Analog comparator falling edge trigger PWM or Timer Enabled.
N     * |        |          |Note: The bit is only effective while analog comparator triggers PWM or Timer.
N     * |[30:29] |CPPSEL    |Analog Comparator Positive Input Selection
N     * @var ACMP_T::CMPSR
N     * Offset: 0x08  Analog Comparator 0/1 Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ACMPF0    |Analog Comparator 0 Flag
N     * |        |          |This bit is set by hardware whenever the comparator 0 output changes state.
N     * |        |          |This will generate an interrupt if ACMPIE(ACMP_CR0[1]) = 1.
N     * |        |          |0 = Analog comparator 0 output does not change.
N     * |        |          |1 = Analog comparator 0 output changed.
N     * |        |          |Note: Software can write 1 to clear this bit to 0.
N     * |[1]     |ACMPF1    |Analog Comparator 1 Flag
N     * |        |          |This bit is set by hardware whenever the comparator 1 output changes state.
N     * |        |          |This will generate an interrupt if ACMPIE(ACMP_CR1[1]) = 1.
N     * |        |          |0 = Analog comparator 1 output does not change.
N     * |        |          |1 = Analog comparator 1 output changed.
N     * |        |          |Note: Software can write 1 to clear this bit to 0.
N     * |[2]     |ACMPO0    |Analog Comparator 0 Output
N     * |        |          |Synchronized to the APB clock to allow reading by software.
N     * |        |          |Cleared when the comparator 0 is disabled ACMPEN(ACMP_CR0[0]) = 0.
N     * |        |          |0 = Analog comparator 0 outputs 0.
N     * |        |          |1 = Analog comparator 0 outputs 1.
N     * |[3]     |ACMPO1    |Analog Comparator 1 Output
N     * |        |          |Synchronized to the APB clock to allow reading by software.
N     * |        |          |Cleared when the comparator 1 is disabled ACMPEN(ACMP_CR1[0]) = 0.
N     * |        |          |0 = Analog comparator 1 outputs 0.
N     * |        |          |1 = Analog comparator 1 outputs 1.
N     * @var ACMP_T::CMPRVCR
N     * Offset: 0x0C  Analog Comparator Reference Voltage Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |CRVS      |Comparator Reference Voltage Setting
N     * |        |          |Comparator reference voltage = AVDD * (1 / 6 + CRVS[3:0] / 24).
N     * |[7]     |OUT_SEL   |CRV Module Output Selection
N     * |        |          |0 = Band-gap voltage.
N     * |        |          |1 = Internal comparator reference voltage.
N     */
N
N    __IO uint32_t CMPCR[2];      /* Offset: 0x00 ~0x04 Analog Comparator 0 & 1Control Register                       */
X    volatile uint32_t CMPCR[2];       
N    __IO uint32_t CMPSR;         /* Offset: 0x08  Analog Comparator 0/1 Status Register                              */
X    volatile uint32_t CMPSR;          
N    __IO uint32_t CMPRVCR;       /* Offset: 0x0C  Analog Comparator Reference Voltage Control Register               */
X    volatile uint32_t CMPRVCR;        
N
N} ACMP_T;
N
N
N
N/**
N    @addtogroup ACMP_CONST ACMP Bit Field Definition
N    Constant Definitions for ACMP Controller
N@{ */
N
N#define ACMP_CMPCR_ACMPEN_Pos           (0)                                               /*!< ACMP_T::CMPCR: ACMPEN Position           */
N#define ACMP_CMPCR_ACMPEN_Msk           (0x1ul << ACMP_CMPCR_ACMPEN_Pos)                  /*!< ACMP_T::CMPCR: ACMPEN Mask               */
N
N#define ACMP_CMPCR_ACMPIE_Pos           (1)                                               /*!< ACMP_T::CMPCR: ACMPIE Position           */
N#define ACMP_CMPCR_ACMPIE_Msk           (0x1ul << ACMP_CMPCR_ACMPIE_Pos)                  /*!< ACMP_T::CMPCR: ACMPIE Mask               */
N
N#define ACMP_CMPCR_HYSEN_Pos            (2)                                               /*!< ACMP_T::CMPCR: HYSEN Position            */
N#define ACMP_CMPCR_HYSEN_Msk            (0x1ul << ACMP_CMPCR_HYSEN_Pos)                   /*!< ACMP_T::CMPCR: HYSEN Mask                */
N
N#define ACMP_CMPCR_NEGSEL_Pos           (4)                                               /*!< ACMP_T::CMPCR: NEGSEL Position           */
N#define ACMP_CMPCR_NEGSEL_Msk           (0x1ul << ACMP_CMPCR_NEGSEL_Pos)                  /*!< ACMP_T::CMPCR: NEGSEL Mask               */
N
N#define ACMP_CMPCR_RISING_Pos           (8)                                               /*!< ACMP_T::CMPCR: RISING Position           */
N#define ACMP_CMPCR_RISING_Msk           (0x1ul << ACMP_CMPCR_RISING_Pos)                  /*!< ACMP_T::CMPCR: RISING Mask               */
N
N#define ACMP_CMPCR_FALLING_Pos          (9)                                               /*!< ACMP_T::CMPCR: FALLING Position          */
N#define ACMP_CMPCR_FALLING_Msk          (0x1ul << ACMP_CMPCR_FALLING_Pos)                 /*!< ACMP_T::CMPCR: FALLING Mask              */
N
N#define ACMP_CMPCR_CPPSEL_Pos           (29)                                              /*!< ACMP_T::CMPCR: CPP0SEL Position          */
N#define ACMP_CMPCR_CPPSEL_Msk           (0x3ul << ACMP_CMPCR_CPPSEL_Pos)                  /*!< ACMP_T::CMPCR: CPP0SEL Mask              */
N
N#define ACMP_CMPSR_ACMPF0_Pos           (0)                                               /*!< ACMP_T::CMPSR: ACMPF0 Position            */
N#define ACMP_CMPSR_ACMPF0_Msk           (0x1ul << ACMP_CMPSR_ACMPF0_Pos)                  /*!< ACMP_T::CMPSR: ACMPF0 Mask                */
N
N#define ACMP_CMPSR_ACMPF1_Pos           (1)                                               /*!< ACMP_T::CMPSR: ACMPF1 Position            */
N#define ACMP_CMPSR_ACMPF1_Msk           (0x1ul << ACMP_CMPSR_ACMPF1_Pos)                  /*!< ACMP_T::CMPSR: ACMPF1 Mask                */
N
N#define ACMP_CMPSR_ACMPCO0_Pos          (2)                                               /*!< ACMP_T::CMPSR: ACMPO0 Position            */
N#define ACMP_CMPSR_ACMPCO0_Msk          (0x1ul << ACMP_CMPSR_ACMPCO0_Pos)                 /*!< ACMP_T::CMPSR: ACMPO0 Mask                */
N
N#define ACMP_CMPSR_ACMPCO1_Pos          (3)                                               /*!< ACMP_T::CMPSR: ACMPO1 Position            */
N#define ACMP_CMPSR_ACMPCO1_Msk          (0x1ul << ACMP_CMPSR_ACMPCO1_Pos)                 /*!< ACMP_T::CMPSR: ACMPO1 Mask                */
N
N#define ACMP_CMPRVCR_CRVS_Pos           (0)                                               /*!< ACMP_T::CMPRVCR: CRVS Position              */
N#define ACMP_CMPRVCR_CRVS_Msk           (0xful << ACMP_CMPRVCR_CRVS_Pos)                  /*!< ACMP_T::CMPRVCR: CRVS Mask                  */
N
N#define ACMP_CMPRVCR_OUT_SEL_Pos        (7)                                               /*!< ACMP_T::CMPRVCR: OUT_SEL Position           */
N#define ACMP_CMPRVCR_OUT_SEL_Msk        (0x1ul << ACMP_CMPRVCR_OUT_SEL_Pos)               /*!< ACMP_T::CMPRVCR: OUT_SEL Mask               */
N
N/**@}*/ /* ACMP_CONST */
N/**@}*/ /* end of ACMP register group */
N
N
N/*---------------------- Analog to Digital Converter -------------------------*/
N/**
N    @addtogroup ADC Analog to Digital Converter(ADC)
N    Memory Mapped Structure for ADC Controller
N@{ */
N
N
Ntypedef struct {
N    /**
N     * @var ADC_T::ADDR
N     * Offset: 0x00  ADC Data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[9:0]   |RSLT      |A/D Conversion Result
N     * |        |          |This field contains conversion result of ADC.
N     * |[16]    |OVERRUN   |Over Run Flag
N     * |        |          |0 = Data in RSLT (ADDR[9:0])is recent conversion result.
N     * |        |          |1 = Data in RSLT (ADDR[9:0])overwrote.
N     * |        |          |If converted data in RSLT[9:0] has not been read before the new conversion result is loaded to this register, OVERRUN is set to 1.
N     * |        |          |It is cleared by hardware after the ADDR register is read.
N     * |[17]    |VALID     |Valid Flag
N     * |        |          |0 = Data in RSLT (ADDR[9:0]) bits not valid.
N     * |        |          |1 = Data in RSLT (ADDR[9:0]) bits valid.
N     * |        |          |This bit is set to 1 when ADC conversion is completed and cleared by hardware after the ADDR register is read.
N     * @var ADC_T::ADCR
N     * Offset: 0x20  ADC Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ADEN      |A/D Converter Enable Control
N     * |        |          |0 = A/D Converter Disabled.
N     * |        |          |1 = A/D Converter Enabled.
N     * |        |          |Note: Before starting A/D conversion function, this bit should be set to 1.
N     * |        |          |Clear it to 0 to disable A/D converter analog circuit to save power consumption.
N     * |[1]     |ADIE      |A/D Interrupt Enable Control
N     * |        |          |A/D conversion end interrupt request is generated if ADIE bit is set to 1.
N     * |        |          |0 = A/D interrupt function Disabled.
N     * |        |          |1 = A/D interrupt function Enabled.
N     * |[5:4]   |TRGS      |Hardware Trigger Source
N     * |        |          |00 = A/D conversion is started by external STADC pin.
N     * |        |          |11 = A/D conversion is started by PWM trigger.
N     * |        |          |Others = Reserved.
N     * |        |          |Note: Software should disable TRGEN and ADST before change TRGS.
N     * |[6]     |TRGCOND   |External Trigger Condition
N     * |        |          |This bit decides whether the external pin STADC trigger event is falling or raising edge.
N     * |        |          |The signal must be kept at stable state at least 4 PCLKs at high and low state for edge trigger.
N     * |        |          |0 = Falling edge.
N     * |        |          |1 = Raising edge.
N     * |[8]     |TRGEN     |External Trigger Enable Control
N     * |        |          |Enable or disable triggering of A/D conversion by external STADC pin.
N     * |        |          |If external trigger is enabled, the ADST bit can be set to 1 by the selected hardware trigger source.
N     * |        |          |0= External trigger Disabled.
N     * |        |          |1= External trigger Enabled.
N     * |[11]    |ADST      |A/D Conversion Start
N     * |        |          |ADST bit can be set to 1 from three sources: software or PWM trigger and external pin STADC.
N     * |        |          |ADST will be cleared to 0 by hardware automatically after conversion complete.
N     * |        |          |0 = Conversion stopped and A/D converter entered idle state.
N     * |        |          |1 = Conversion start.
N     * @var ADC_T::ADCHER
N     * Offset: 0x24  ADC Channel Enable Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CHEN0     |Analog Input Channel 0 Enable Control
N     * |        |          |0 = Channel 0 Disabled.
N     * |        |          |1 = Channel 0 Enabled.
N     * |        |          |Note: If software enables more than one channel, the channel with the smallest number will be selected and the other enabled channels will be ignored.
N     * |[1]     |CHEN1     |Analog Input Channel 1 Enable Control
N     * |        |          |0 = Channel 1 Disabled.
N     * |        |          |1 = Channel 1 Enabled.
N     * |[2]     |CHEN2     |Analog Input Channel 2 Enable Control
N     * |        |          |0 = Channel 2 Disabled.
N     * |        |          |1 = Channel 2 Enabled.
N     * |[3]     |CHEN3     |Analog Input Channel 3 Enable Control
N     * |        |          |0 = Channel 3 Disabled.
N     * |        |          |1 = Channel 3 Enabled.
N     * |[4]     |CHEN4     |Analog Input Channel 4 Enable Control
N     * |        |          |0 = Channel 4 Disabled.
N     * |        |          |1 = Channel 4 Enabled.
N     * |[5]     |CHEN5     |Analog Input Channel 5 Enable Control
N     * |        |          |0 = Channel 5 Disabled.
N     * |        |          |1 = Channel 5 Enabled.
N     * |[6]     |CHEN6     |Analog Input Channel 6 Enable Control
N     * |        |          |0 = Channel 6 Disabled.
N     * |        |          |1 = Channel 6 Enabled.
N     * |[7]     |CHEN7     |Analog Input Channel 7 Enable Control
N     * |        |          |0 = Channel 7 Disabled.
N     * |        |          |1 = Channel 7 Enabled.
N     * |[8]     |PRESEL    |Analog Input Channel 7 Selection
N     * |        |          |0 = External analog input.
N     * |        |          |1 = Internal band-gap voltage (VBG).
N     * |        |          |Note: When software selects the band-gap voltage as the analog input source of ADC channel 7, the ADC clock rate needs to be limited to lower than 300 kHz.
N     * @var ADC_T::ADCMPR
N     * Offset: 0x28 ~ 0x2C ADC Compare Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CMPEN     |Compare Enable Control
N     * |        |          |Set 1 to this bit to enable comparing CMPD[9:0] with specified channel conversion results when converted data is loaded into the ADDR register.
N     * |        |          |0 = Compare function Disabled.
N     * |        |          |1 = Compare function Enabled.
N     * |[1]     |CMPIE     |Compare Interrupt Enable Control
N     * |        |          |If the compare function is enabled and the compare condition matches the setting of CMPCOND and CMPMATCNT, CMPFx bit will be asserted, in the meanwhile, if CMPIE is set to 1, a compare interrupt request is generated.
N     * |        |          |0 = Compare function interrupt Disabled.
N     * |        |          |1 = Compare function interrupt Enabled.
N     * |[2]     |CMPCOND   |Compare Condition
N     * |        |          |0 = Set the compare condition as that when a 10-bit A/D conversion result is less than the 10-bit CMPD (ADCMPRx[25:16]), the internal match counter will increase one.
N     * |        |          |1 = Set the compare condition as that when a 10-bit A/D conversion result is greater or equal to the 10-bit CMPD (ADCMPRx[25:16]), the internal match counter will increase one.
N     * |        |          |Note: When the internal counter reaches the value to (CMPMATCNT +1), the CMPFx bit will be set.
N     * |[5:3]   |CMPCH     |Compare Channel Selection
N     * |        |          |000 = Channel 0 conversion result is selected to be compared.
N     * |        |          |001 = Channel 1 conversion result is selected to be compared.
N     * |        |          |010 = Channel 2 conversion result is selected to be compared.
N     * |        |          |011 = Channel 3 conversion result is selected to be compared.
N     * |        |          |100 = Channel 4 conversion result is selected to be compared.
N     * |        |          |101 = Channel 5 conversion result is selected to be compared.
N     * |        |          |110 = Channel 6 conversion result is selected to be compared.
N     * |        |          |111 = Channel 7 conversion result is selected to be compared.
N     * |[11:8]  |CMPMATCNT |Compare Match Count
N     * |        |          |When the specified A/D channel analog conversion result matches the compare condition defined by CMPCOND, the internal match counter will increase 1.
N     * |        |          |When the internal counter reaches the value to (CMPMATCNT +1), the CMPFx bit will be set.
N     * |[25:16] |CMPD      |Comparison Data
N     * |        |          |The 10-bit data is used to compare with conversion result of specified channel.
N     * @var ADC_T::ADSR
N     * Offset: 0x30  ADC Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ADF       |A/D Conversion End Flag
N     * |        |          |A status flag that indicates the end of A/D conversion. ADF is set to 1 When A/D conversion ends.
N     * |        |          |Software can write 1 to clear this bit to 0.
N     * |[1]     |CMPF0     |Compare Flag 0
N     * |        |          |When the selected channel A/D conversion result meets the setting condition in ADCMPR0, this bit is set to 1.
N     * |        |          |Software can write 1 to clear this bit to 0.
N     * |        |          |0 = Conversion result in ADDR does not meet the ADCMPR0 setting.
N     * |        |          |1 = Conversion result in ADDR meets the ADCMPR0 setting.
N     * |[2]     |CMPF1     |Compare Flag 1
N     * |        |          |When the selected channel A/D conversion result meets the setting condition in ADCMPR1, this bit is set to 1.
N     * |        |          |Software can write 1 to clear this bit to 0.
N     * |        |          |0 = Conversion result in ADDR does not meet the ADCMPR1 setting.
N     * |        |          |1 = Conversion result in ADDR meets the ADCMPR1 setting.
N     * |[3]     |BUSY      |BUSY/IDLE (Read Only)
N     * |        |          |This bit is mirror of as ADST bit in ADCR
N     * |        |          |0 = A/D converter is in idle state.
N     * |        |          |1 = A/D converter is busy at conversion.
N     * |[6:4]   |CHANNEL   |Current Conversion Channel (Read Only)
N     * |        |          |This filed reflects the current conversion channel when BUSY=1.
N     * |        |          |When BUSY=0, it shows the number of the next converted channel.
N     * |[8]     |VALID     |Data Valid Flag (Read Only)
N     * |        |          |It is a mirror of VALID (ADDR[17]) bit in ADDR register.
N     * |[16]    |OVERRUN   |Overrun Flag (Read Only)
N     * |        |          |It is a mirror to OVERRUN (ADSR[16]) bit in ADDR register.
N     * @var ADC_T::ADTDCR
N     * Offset: 0x44  ADC Trigger Delay Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |PTDT      |PWM Trigger Delay Timer
N     * |        |          |Set this field will delay ADC start conversion time after PWM trigger.
N     * |        |          |PWM trigger delay time is (4 * PTDT) * system clock.
N     * @var ADC_T::ADSAMP
N     * Offset: 0x48  ADC Sampling Time Counter Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |ADSAMPCNT |ADC Sampling Counter
N     * |        |          |If the ADC input is unstable, user can set this register to increase the sampling time to get a stable ADC input signal.
N     * |        |          |The default sampling time is 1 ADC clock.
N     * |        |          |The additional clock number will be inserted to lengthen the sampling clock.
N     * |        |          |0000 = 0 additional ADC sample clock.
N     * |        |          |0001 = 1 additional ADC sample clock.
N     * |        |          |0010 = 2 additional ADC sample clock.
N     * |        |          |0011 = 4 additional ADC sample clock.
N     * |        |          |0100 = 8 additional ADC sample clock.
N     * |        |          |0101 = 16 additional ADC sample clock.
N     * |        |          |0110 = 32 additional ADC sample clock.
N     * |        |          |0111 = 64 additional ADC sample clock.
N     * |        |          |1000 = 128 additional ADC sample clock.
N     * |        |          |1001 = 256 additional ADC sample clock.
N     * |        |          |1010 = 512 additional ADC sample clock.
N     * |        |          |1011 = 1024 additional ADC sample clock.
N     * |        |          |1100 = 1024 additional ADC sample clock.
N     * |        |          |1101 = 1024 additional ADC sample clock.
N     * |        |          |1110 = 1024 additional ADC sample clock.
N     * |        |          |1111 = 1024 additional ADC sample clock.
N     */
N
N    __I  uint32_t ADDR;          /* Offset: 0x00  ADC Data Register                                                  */
X    volatile const  uint32_t ADDR;           
N    /// @cond HIDDEN_SYMBOLS
N    __I  uint32_t RESERVE0[7];
X    volatile const  uint32_t RESERVE0[7];
N    /// @endcond //HIDDEN_SYMBOLS
N    __IO uint32_t ADCR;          /* Offset: 0x20  ADC Control Register                                               */
X    volatile uint32_t ADCR;           
N    __IO uint32_t ADCHER;        /* Offset: 0x24  ADC Channel Enable Control Register                                */
X    volatile uint32_t ADCHER;         
N    __IO uint32_t ADCMPR[2];     /* Offset: 0x28, 0x2C  A/D Compare Register 0 & 1                                   */
X    volatile uint32_t ADCMPR[2];      
N    __IO uint32_t ADSR;          /* Offset: 0x30  ADC Status Register                                                */
X    volatile uint32_t ADSR;           
N    /// @cond HIDDEN_SYMBOLS
N    __I  uint32_t RESERVE1[4];
X    volatile const  uint32_t RESERVE1[4];
N    /// @endcond //HIDDEN_SYMBOLS
N    __IO uint32_t ADTDCR;        /* Offset: 0x44  ADC Trigger Delay Control Register                                 */
X    volatile uint32_t ADTDCR;         
N    __IO uint32_t ADSAMP;        /* Offset: 0x48  ADC Sampling Time Counter Register                                 */
X    volatile uint32_t ADSAMP;         
N
N} ADC_T;
N
N
N
N/**
N    @addtogroup ADC_CONST ADC Bit Field Definition
N    Constant Definitions for ADC Controller
N@{ */
N
N#define ADC_ADDR_RSLT_Pos                (0)                                               /*!< ADC_T::ADDR: RSLT Position                */
N#define ADC_ADDR_RSLT_Msk                (0x3fful << ADC_ADDR_RSLT_Pos)                    /*!< ADC_T::ADDR: RSLT Mask                    */
N
N#define ADC_ADDR_OVERRUN_Pos             (16)                                              /*!< ADC_T::ADDR: OVERRUN Position             */
N#define ADC_ADDR_OVERRUN_Msk             (0x1ul << ADC_ADDR_OVERRUN_Pos)                   /*!< ADC_T::ADDR: OVERRUN Mask                 */
N
N#define ADC_ADDR_VALID_Pos               (17)                                              /*!< ADC_T::ADDR: VALID Position               */
N#define ADC_ADDR_VALID_Msk               (0x1ul << ADC_ADDR_VALID_Pos)                     /*!< ADC_T::ADDR: VALID Mask                   */
N
N#define ADC_ADCR_ADEN_Pos                (0)                                               /*!< ADC_T::ADCR: ADEN Position                */
N#define ADC_ADCR_ADEN_Msk                (0x1ul << ADC_ADCR_ADEN_Pos)                      /*!< ADC_T::ADCR: ADEN Mask                    */
N
N#define ADC_ADCR_ADIE_Pos                (1)                                               /*!< ADC_T::ADCR: ADIE Position                */
N#define ADC_ADCR_ADIE_Msk                (0x1ul << ADC_ADCR_ADIE_Pos)                      /*!< ADC_T::ADCR: ADIE Mask                    */
N
N#define ADC_ADCR_TRGS_Pos                (4)                                               /*!< ADC_T::ADCR: TRGS Position                */
N#define ADC_ADCR_TRGS_Msk                (0x3ul << ADC_ADCR_TRGS_Pos)                      /*!< ADC_T::ADCR: TRGS Mask                    */
N
N#define ADC_ADCR_TRGCOND_Pos             (6)                                               /*!< ADC_T::ADCR: TRGCOND Position             */
N#define ADC_ADCR_TRGCOND_Msk             (0x1ul << ADC_ADCR_TRGCOND_Pos)                   /*!< ADC_T::ADCR: TRGCOND Mask                 */
N
N#define ADC_ADCR_TRGEN_Pos               (8)                                               /*!< ADC_T::ADCR: TRGEN Position               */
N#define ADC_ADCR_TRGEN_Msk               (0x1ul << ADC_ADCR_TRGEN_Pos)                     /*!< ADC_T::ADCR: TRGEN Mask                   */
N
N#define ADC_ADCR_ADST_Pos                (11)                                              /*!< ADC_T::ADCR: ADST Position                */
N#define ADC_ADCR_ADST_Msk                (0x1ul << ADC_ADCR_ADST_Pos)                      /*!< ADC_T::ADCR: ADST Mask                    */
N
N#define ADC_ADCHER_CHEN_Pos              (0)                                               /*!< ADC_T::ADCHER: CHEN Position              */
N#define ADC_ADCHER_CHEN_Msk              (0xfful << ADC_ADCHER_CHEN_Pos)                   /*!< ADC_T::ADCHER: CHEN Mask                  */
N
N#define ADC_ADCHER_CHEN0_Pos             (0)                                               /*!< ADC_T::ADCHER: CHEN0 Position             */
N#define ADC_ADCHER_CHEN0_Msk             (0x1ul << ADC_ADCHER_CHEN0_Pos)                   /*!< ADC_T::ADCHER: CHEN0 Mask                 */
N
N#define ADC_ADCHER_CHEN1_Pos             (1)                                               /*!< ADC_T::ADCHER: CHEN1 Position             */
N#define ADC_ADCHER_CHEN1_Msk             (0x1ul << ADC_ADCHER_CHEN1_Pos)                   /*!< ADC_T::ADCHER: CHEN1 Mask                 */
N
N#define ADC_ADCHER_CHEN2_Pos             (2)                                               /*!< ADC_T::ADCHER: CHEN2 Position             */
N#define ADC_ADCHER_CHEN2_Msk             (0x1ul << ADC_ADCHER_CHEN2_Pos)                   /*!< ADC_T::ADCHER: CHEN2 Mask                 */
N
N#define ADC_ADCHER_CHEN3_Pos             (3)                                               /*!< ADC_T::ADCHER: CHEN3 Position             */
N#define ADC_ADCHER_CHEN3_Msk             (0x1ul << ADC_ADCHER_CHEN3_Pos)                   /*!< ADC_T::ADCHER: CHEN3 Mask                 */
N
N#define ADC_ADCHER_CHEN4_Pos             (4)                                               /*!< ADC_T::ADCHER: CHEN4 Position             */
N#define ADC_ADCHER_CHEN4_Msk             (0x1ul << ADC_ADCHER_CHEN4_Pos)                   /*!< ADC_T::ADCHER: CHEN4 Mask                 */
N
N#define ADC_ADCHER_CHEN5_Pos             (5)                                               /*!< ADC_T::ADCHER: CHEN5 Position             */
N#define ADC_ADCHER_CHEN5_Msk             (0x1ul << ADC_ADCHER_CHEN5_Pos)                   /*!< ADC_T::ADCHER: CHEN5 Mask                 */
N
N#define ADC_ADCHER_CHEN6_Pos             (6)                                               /*!< ADC_T::ADCHER: CHEN6 Position             */
N#define ADC_ADCHER_CHEN6_Msk             (0x1ul << ADC_ADCHER_CHEN6_Pos)                   /*!< ADC_T::ADCHER: CHEN6 Mask                 */
N
N#define ADC_ADCHER_CHEN7_Pos             (7)                                               /*!< ADC_T::ADCHER: CHEN7 Position             */
N#define ADC_ADCHER_CHEN7_Msk             (0x1ul << ADC_ADCHER_CHEN7_Pos)                   /*!< ADC_T::ADCHER: CHEN7 Mask                 */
N
N#define ADC_ADCHER_PRESEL_Pos            (8)                                               /*!< ADC_T::ADCHER: PRESEL Position            */
N#define ADC_ADCHER_PRESEL_Msk            (0x1ul << ADC_ADCHER_PRESEL_Pos)                  /*!< ADC_T::ADCHER: PRESEL Mask                */
N
N#define ADC_ADCMPR_CMPEN_Pos             (0)                                               /*!< ADC_T::ADCMPR: CMPEN Position             */
N#define ADC_ADCMPR_CMPEN_Msk             (0x1ul << ADC_ADCMPR_CMPEN_Pos)                   /*!< ADC_T::ADCMPR: CMPEN Mask                 */
N
N#define ADC_ADCMPR_CMPIE_Pos             (1)                                               /*!< ADC_T::ADCMPR: CMPIE Position             */
N#define ADC_ADCMPR_CMPIE_Msk             (0x1ul << ADC_ADCMPR_CMPIE_Pos)                   /*!< ADC_T::ADCMPR: CMPIE Mask                 */
N
N#define ADC_ADCMPR_CMPCOND_Pos           (2)                                               /*!< ADC_T::ADCMPR: CMPCOND Position           */
N#define ADC_ADCMPR_CMPCOND_Msk           (0x1ul << ADC_ADCMPR_CMPCOND_Pos)                 /*!< ADC_T::ADCMPR: CMPCOND Mask               */
N
N#define ADC_ADCMPR_CMPCH_Pos             (3)                                               /*!< ADC_T::ADCMPR: CMPCH Position             */
N#define ADC_ADCMPR_CMPCH_Msk             (0x7ul << ADC_ADCMPR_CMPCH_Pos)                   /*!< ADC_T::ADCMPR: CMPCH Mask                 */
N
N#define ADC_ADCMPR_CMPMATCNT_Pos         (8)                                               /*!< ADC_T::ADCMPR: CMPMATCNT Position         */
N#define ADC_ADCMPR_CMPMATCNT_Msk         (0xful << ADC_ADCMPR_CMPMATCNT_Pos)               /*!< ADC_T::ADCMPR: CMPMATCNT Mask             */
N
N#define ADC_ADCMPR_CMPD_Pos              (16)                                              /*!< ADC_T::ADCMPR: CMPD Position              */
N#define ADC_ADCMPR_CMPD_Msk              (0x3fful << ADC_ADCMPR_CMPD_Pos)                  /*!< ADC_T::ADCMPR: CMPD Mask                  */
N
N#define ADC_ADSR_ADF_Pos                 (0)                                               /*!< ADC_T::ADSR: ADF Position                 */
N#define ADC_ADSR_ADF_Msk                 (0x1ul << ADC_ADSR_ADF_Pos)                       /*!< ADC_T::ADSR: ADF Mask                     */
N
N#define ADC_ADSR_CMPF0_Pos               (1)                                               /*!< ADC_T::ADSR: CMPF0 Position               */
N#define ADC_ADSR_CMPF0_Msk               (0x1ul << ADC_ADSR_CMPF0_Pos)                     /*!< ADC_T::ADSR: CMPF0 Mask                   */
N
N#define ADC_ADSR_CMPF1_Pos               (2)                                               /*!< ADC_T::ADSR: CMPF1 Position               */
N#define ADC_ADSR_CMPF1_Msk               (0x1ul << ADC_ADSR_CMPF1_Pos)                     /*!< ADC_T::ADSR: CMPF1 Mask                   */
N
N#define ADC_ADSR_BUSY_Pos                (3)                                               /*!< ADC_T::ADSR: BUSY Position                */
N#define ADC_ADSR_BUSY_Msk                (0x1ul << ADC_ADSR_BUSY_Pos)                      /*!< ADC_T::ADSR: BUSY Mask                    */
N
N#define ADC_ADSR_CHANNEL_Pos             (4)                                               /*!< ADC_T::ADSR: CHANNEL Position             */
N#define ADC_ADSR_CHANNEL_Msk             (0x7ul << ADC_ADSR_CHANNEL_Pos)                   /*!< ADC_T::ADSR: CHANNEL Mask                 */
N
N#define ADC_ADSR_VALID_Pos               (8)                                               /*!< ADC_T::ADSR: VALID Position               */
N#define ADC_ADSR_VALID_Msk               (0x1ul << ADC_ADSR_VALID_Pos)                     /*!< ADC_T::ADSR: VALID Mask                   */
N
N#define ADC_ADSR_OVERRUN_Pos             (16)                                              /*!< ADC_T::ADSR: OVERRUN Position             */
N#define ADC_ADSR_OVERRUN_Msk             (0x1ul << ADC_ADSR_OVERRUN_Pos)                   /*!< ADC_T::ADSR: OVERRUN Mask                 */
N
N#define ADC_ADTDCR_PTDT_Pos              (0)                                               /*!< ADC_T::ADTDCR: PTDT Position              */
N#define ADC_ADTDCR_PTDT_Msk              (0xfful << ADC_ADTDCR_PTDT_Pos)                   /*!< ADC_T::ADTDCR: PTDT Mask                  */
N
N#define ADC_ADSAMP_SAMPCNT_Pos           (0)                                               /*!< ADC_T::ADSAMP: ADSAMPCNT Position         */
N#define ADC_ADSAMP_SAMPCNT_Msk           (0xful << ADC_ADSAMP_SAMPCNT_Pos)                 /*!< ADC_T::ADSAMP: ADSAMPCNT Mask             */
N
N/**@}*/ /* ADC_CONST */
N/**@}*/ /* end of ADC register group */
N
N
N/*---------------------- System Clock Controller -------------------------*/
N/**
N    @addtogroup CLK System Clock Controller(CLK)
N    Memory Mapped Structure for CLK Controller
N@{ */
N
N
Ntypedef struct {
N
N    /**
N     * @var CLK_T::PWRCON
N     * Offset: 0x00  System Power-down Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |XTLCLK_EN |External Crystal HXT Or LXT Enable Control (Write Protect)
N     * |        |          |The default clock source is from HIRC.
N     * |        |          |These two bits are default set to "00" and the XTAL1 and XTAL2 pins are GPIO.
N     * |        |          |00 = XTAL1 and XTAL2 are GPIO, disable both LXT & HXT (default).
N     * |        |          |01 = HXT Enabled.
N     * |        |          |10 = LXT Enabled.
N     * |        |          |11 = XTAL1 is external clock input pin, XTAL2 is GPIO.
N     * |        |          |Note: To enable the external XTAL function, the P5_ALT[1:0] and P5_MFP[1:0] bits must also be set in P5_MFP.
N     * |[2]     |OSC22M_EN |22.1184 MHz Internal High Speed RC Oscillator (HIRC) Enable Control (Write Protect)
N     * |        |          |0 = 22.1184 MHz internal high speed RC oscillator (HIRC) Disabled.
N     * |        |          |1 = 22.1184 MHz internal high speed RC oscillator (HIRC) Enabled.
N     * |        |          |Note: The default of OSC22M_EN bit is 1.
N     * |[3]     |OSC10K_EN |10 KHz Internal Low Speed RC Oscillator (LIRC) Enable Control (Write Protect)
N     * |        |          |0 = 10 kHz internal low speed RC oscillator (LIRC) Disabled.
N     * |        |          |1 = 10 kHz internal low speed RC oscillator (LIRC) Enabled.
N     * |[4]     |PD_WU_DLY |Wake-up Delay Counter Enable Control (Write Protect)
N     * |        |          |When the chip wakes up from Power-down mode, the clock control will delay certain clock cycles to wait system clock stable.
N     * |        |          |The delayed clock cycle is 4096 clock cycles when chip work at 4~24 MHz external high speed crystal (HXT), 4096 clock cycles for 32.768 kHz external low speed crystal (LXT), and 16 clock cycles when chip works at 22.1184 MHz internal high speed RC oscillator (HIRC).
N     * |        |          |0 = Clock cycles delay Disabled.
N     * |        |          |1 = Clock cycles delay Enabled.
N     * |[5]     |PD_WU_INT_EN|Power-down Mode Wake-up Interrupt Enable Control (Write Protect)
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: The interrupt will occur when both PD_WU_STS and PD_WU_INT_EN are high.
N     * |[6]     |PD_WU_STS |Power-down Mode Wake-up Interrupt Status
N     * |        |          |Set by "Power-down wake-up event", which indicates that resume from Power-down mode.
N     * |        |          |The flag is set if the GPIO, UART, WDT, I2C, ACMP, Timer or BOD wake-up occurred.
N     * |        |          |Note: This bit works only if PD_WU_INT_EN (PWRCON[5]) set to 1. Write 1 to clear the bit to 0.
N     * |[7]     |PWR_DOWN_EN|System Power-down Enable Bit (Write Protect)
N     * |        |          |When chip wakes up from Power-down mode, this bit is cleared by hardware.
N     * |        |          |User needs to set this bit again for next Power-down.
N     * |        |          |In Power-down mode, 4~24 MHz external high speed crystal oscillator (HXT), 32.768 kHz external low speed crystal oscillator (LXT), and the 22.1184 MHz internal high speed oscillator (HIRC) will be disabled in this mode, and 10 kHz internal low speed RC oscillator (LIRC) are not controlled by Power-down mode.
N     * |        |          |In Power-down mode, the system clock is disabled, and ignored the clock source selection.
N     * |        |          |The clocks of peripheral are not controlled by Power-down mode, if the peripheral clock source is from 10 kHz internal low speed oscillator.
N     * |        |          |0 = Chip operating normally or chip in Idle mode because of WFI command.
N     * |        |          |1 = Chip enters Power-down mode instantly or waits CPU sleep command WFI.
N     * |[9]     |PD_32K    |Enable LXT In Power-down Mode
N     * |        |          |This bit controls the crystal oscillator active or not in Power-down mode.
N     * |        |          |0 = No effect to Power-down mode.
N     * |        |          |1 = If XTLCLK_EN[1:0] = 10, LXT is still active in Power-down mode.
N     * @var CLK_T::AHBCLK
N     * Offset: 0x04  AHB Devices Clock Enable Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2]     |ISP_EN    |Flash ISP Controller Clock Enable Control
N     * |        |          |0 = Flash ISP peripheral clock Disabled.
N     * |        |          |1 = Flash ISP peripheral clock Enabled.
N     * @var CLK_T::APBCLK
N     * Offset: 0x08  APB Devices Clock Enable Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |WDT_EN    |Watchdog Timer Clock Enable Control (Write Protect)
N     * |        |          |0 = Watchdog Timer clock Disabled.
N     * |        |          |1 = Watchdog Timer clock Enabled.
N     * |        |          |Note: This bit is the protected bit, and programming it needs to write 0x59, 0x16, and 0x88 to address 0x5000_0100 to disable register protection.
N     * |        |          |Refer to the register REGWRPROT at address GCR_BA + 0x100.
N     * |[2]     |TMR0_EN   |Timer0 Clock Enable Control
N     * |        |          |0 = Timer0 clock Disabled.
N     * |        |          |1 = Timer0 clock Enabled.
N     * |[3]     |TMR1_EN   |Timer1 Clock Enable Control
N     * |        |          |0 = Timer1 clock Disabled.
N     * |        |          |1 = Timer1 clock Enabled.
N     * |[6]     |FDIV_EN   |Frequency Divider Output Clock Enable Control
N     * |        |          |0 = FDIV clock Disabled.
N     * |        |          |1 = FDIV clock Enabled.
N     * |[8]     |I2C_EN    |I2C Clock Enable Control
N     * |        |          |0 = I2C clock Disabled.
N     * |        |          |1 = I2C clock Enabled.
N     * |[12]    |SPI_EN    |SPI Peripheral Clock Enable Control
N     * |        |          |0 = SPI peripheral clock Disabled.
N     * |        |          |1 = SPI peripheral clock Enabled.
N     * |[16]    |UART_EN   |UART Clock Enable Control
N     * |        |          |0 = UART clock Disabled.
N     * |        |          |1 = UART clock Enabled.
N     * |[20]    |PWM01_EN  |PWM_01 Clock Enable Control
N     * |        |          |0 = PWM01 clock Disabled.
N     * |        |          |1 = PWM01 clock Enabled.
N     * |[21]    |PWM23_EN  |PWM_23 Clock Enable Control
N     * |        |          |0 = PWM23 clock Disabled.
N     * |        |          |1 = PWM23 clock Enabled.
N     * |[22]    |PWM45_EN  |PWM_45 Clock Enable Control
N     * |        |          |0 = PWM45 clock Disabled.
N     * |        |          |1 = PWM45 clock Enabled.
N     * |[28]    |ADC_EN    |Analog-digital-converter (ADC) Clock Enable Control
N     * |        |          |0 = ADC peripheral clock Disabled.
N     * |        |          |1 = ADC peripheral clock Enabled.
N     * |[30]    |ACMP_EN   |Analog Comparator Clock Enable Control
N     * |        |          |0 = Analog Comparator clock Disabled.
N     * |        |          |1 = Analog Comparator clock Enabled.
N     * @var CLK_T::CLKSTATUS
N     * Offset: 0x0C  Clock Status Monitor Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |XTL_STB   |HXT Or LXT Clock Source Stable Flag
N     * |        |          |0 = HXT or LXT clock is not stable or disabled.
N     * |        |          |1 = HXT or LXT clock is stable.
N     * |[3]     |OSC10K_STB|LIRC Clock Source Stable Flag (Read Only)
N     * |        |          |0 = LIRC clock is not stable or disabled.
N     * |        |          |1 = LIRC clock is stable.
N     * |[4]     |OSC22M_STB|HIRC Clock Source Stable Flag (Read Only)
N     * |        |          |0 = HIRC clock is not stable or disabled.
N     * |        |          |1 = HIRC clock is stable.
N     * |[7]     |CLK_SW_FAIL|Clock Switch Fail Flag
N     * |        |          |0 = Clock switching success.
N     * |        |          |1 = Clock switching failed.
N     * |        |          |Note1: This bit is updated when software switches system clock source.
N     * |        |          |If switch target clock is stable, this bit will be set to 0.
N     * |        |          |If switch target clock is not stable, this bit will be set to 1.
N     * |        |          |Note2: This bit is read only.
N     * |        |          |After selected clock source is stable, hardware will switch system clock to selected clock automatically, and CLK_SE_FAIL will be cleared automatically by hardware.
N     * @var CLK_T::CLKSEL0
N     * Offset: 0x10  Clock Source Select Control Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |HCLK_S    |HCLK Clock Source Selection (Write Protect)
N     * |        |          |000 = Clock source is from HXT or LXT.
N     * |        |          |001 = Reserved.
N     * |        |          |010 = Reserved.
N     * |        |          |011 = Clock source is from LIRC.
N     * |        |          |111 = Clock source is from HIRC.
N     * |        |          |Others = Reserved.
N     * |        |          |Note1: Before clock switching, the related clock sources (both pre-select and new-select) must be turn-on and stable.
N     * |        |          |Note2: These bits are protected bit, and programming them needs to write 0x59, 0x16, and 0x88 to address 0x5000_0100 to disable register protection.
N     * |        |          |Refer to the register REGWRPROT at address GCR_BA + 0x100.
N     * |        |          |Note3: To set PWRCON[1:0], select HXT or LXT crystal clock.
N     * |[5:3]   |STCLK_S   |Cortex-M0 SysTick Clock Source Selection From Reference Clock (Write Protect)
N     * |        |          |If SYST_CSR[2] = 1, SysTick clock source is from HCLK.
N     * |        |          |If SYST_CSR[2] = 0, SysTick clock source is defined by below settings.
N     * |        |          |000 = Clock source is from HXT or LXT.
N     * |        |          |001 = Reserved.
N     * |        |          |010 = Clock source is from HXT/2 or LXT/2.
N     * |        |          |011 = Clock source is from HCLK/2.
N     * |        |          |111 = Clock source is from HIRC /2.
N     * |        |          |Others = Reserved.
N     * |        |          |Note1: These bits are protected bit, and programming them needs to write 0x59, 0x16, and 0x88 to address 0x5000_0100 to disable register protection.
N     * |        |          |Refer to the register REGWRPROT at address GCR_BA + 0x100.
N     * |        |          |Note2: If the SysTick clock source is not from HCLK (i.e. SYST_CSR[2] = 0), SysTick clock source must less than or equal to HCLK/2.
N     * |        |          |Note3: To set PWRCON[1:0], select HXT or LXT crystal clock.
N     * @var CLK_T::CLKSEL1
N     * Offset: 0x14  Clock Source Select Control Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |WDT_S     |WDT CLK Clock Source Selection (Write Protect)
N     * |        |          |00 = Clock source is from HXT or LXT.
N     * |        |          |01 = Reserved.
N     * |        |          |10 = Clock source is from HCLK/2048 clock.
N     * |        |          |11 = Clock source is from LIRC.
N     * |        |          |Note1: These bits are the protected bit, and programming them needs to write 0x59, 0x16, and 0x88 to address 0x5000_0100 to disable register protection.
N     * |        |          |Refer to the register REGWRPROT at address GCR_BA + 0x100.
N     * |        |          |Note2: To set PWRCON[1:0], select HXT or LXT crystal clock.
N     * |[3:2]   |ADC_S     |ADC Peripheral Clock Source Selection
N     * |        |          |00 = Clock source is from HXT or LXT.
N     * |        |          |01 = Reserved.
N     * |        |          |10 = Clock source is from HCLK.
N     * |        |          |11 = Clock source is from HIRC.
N     * |        |          |Note: To set PWRCON[1:0], select HXT or LXT crystal clock.
N     * |[4]     |SPI_S     |SPI Clock Source Selection
N     * |        |          |0 = Clock source is from HXT or LXT.
N     * |        |          |1 = Clock source is from HCLK.
N     * |        |          |Note: To set PWRCON[1:0], select HXT or LXT crystal clock.
N     * |[10:8]  |TMR0_S    |TIMER0 Clock Source Selection
N     * |        |          |000 = Clock source is from HXT or LXT.
N     * |        |          |001 = Clock source is from LIRC.
N     * |        |          |010 = Clock source is from HCLK.
N     * |        |          |011 = Clock source is from external trigger.
N     * |        |          |111 = Clock source is from HIRC.
N     * |        |          |Others = Reserved.
N     * |        |          |Note: To set PWRCON[1:0], select HXT or LXT crystal clock.
N     * |[14:12] |TMR1_S    |TIMER1 Clock Source Selection
N     * |        |          |000 = Clock source is from HXT or LXT.
N     * |        |          |001 = Clock source is from LIRC.
N     * |        |          |010 = Clock source is from HCLK.
N     * |        |          |011 = Clock source is from external trigger.
N     * |        |          |111 = Clock source is from HIRC.
N     * |        |          |Others = Reserved.
N     * |        |          |Note: To set PWRCON[1:0], select HXT or LXT crystal clock.
N     * |[25:24] |UART_S    |UART Clock Source Selection
N     * |        |          |00 = Clock source is from HXT or LXT.
N     * |        |          |01 = Reserved.
N     * |        |          |10 = Clock source is from HIRC.
N     * |        |          |11 = Clock source is from HIRC .
N     * |        |          |Note: To set PWRCON[1:0], select HXT or LXT crystal clock.
N     * @var CLK_T::CLKDIV
N     * Offset: 0x18  Clock Divider Number Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |HCLK_N    |HCLK Clock Divide Number From HCLK Clock Source
N     * |        |          |HCLK clock frequency = (HCLK clock source frequency) / (HCLK_N + 1).
N     * |[11:8]  |UART_N    |UART Clock Divide Number From UART Clock Source
N     * |        |          |UART clock frequency = (UART clock source frequency) / (UART_N + 1).
N     * |[23:16] |ADC_N     |ADC Peripheral Clock Divide Number From ADC Peripheral Clock Source
N     * |        |          |ADC peripheral clock frequency = (ADC peripheral clock source frequency) / (ADC_N + 1).
N     * @var CLK_T::CLKSEL2
N     * Offset: 0x1C  Clock Source Select Control Register 2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:2]   |FRQDIV_S  |Clock Divider Clock Source Selection
N     * |        |          |00 = Clock source is from HXT or LXT.
N     * |        |          |01 = Reserved.
N     * |        |          |10 = Clock source is from HCLK.
N     * |        |          |11 = Clock source is from HIRC.
N     * |        |          |Note: To set PWRCON[1:0], select HXT or LXT crystal clock.
N     * @var CLK_T::FRQDIV
N     * Offset: 0x24  Frequency Divider Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |FSEL      |Divider Output Frequency Selection
N     * |        |          |The formula of output frequency is
N     * |        |          |Fout = Fin/2(N+1),.
N     * |        |          |Fin is the input clock frequency.
N     * |        |          |Fout is the frequency of divider output clock.
N     * |        |          |N is the 4-bit value of FSEL[3:0].
N     * |[4]     |DIVIDER_EN|Frequency Divider Enable Control
N     * |        |          |0 = Frequency Divider Disabled.
N     * |        |          |1 = Frequency Divider Enabled.
N     * |[5]     |DIVIDER1  |Frequency Divider 1 Enable Control
N     * |        |          |0 = Divider output frequency is depended on FSEL value.
N     * |        |          |1 = Divider output frequency is the same as input clock frequency.
N     */
N
N    __IO uint32_t PWRCON;        /* Offset: 0x00  System Power-down Control Register                                 */
X    volatile uint32_t PWRCON;         
N    __IO uint32_t AHBCLK;        /* Offset: 0x04  AHB Devices Clock Enable Control Register                          */
X    volatile uint32_t AHBCLK;         
N    __IO uint32_t APBCLK;        /* Offset: 0x08  APB Devices Clock Enable Control Register                          */
X    volatile uint32_t APBCLK;         
N    __IO uint32_t CLKSTATUS;     /* Offset: 0x0C  Clock Status Monitor Register                                      */
X    volatile uint32_t CLKSTATUS;      
N    __IO uint32_t CLKSEL0;       /* Offset: 0x10  Clock Source Select Control Register 0                             */
X    volatile uint32_t CLKSEL0;        
N    __IO uint32_t CLKSEL1;       /* Offset: 0x14  Clock Source Select Control Register 1                             */
X    volatile uint32_t CLKSEL1;        
N    __IO uint32_t CLKDIV;        /* Offset: 0x18  Clock Divider Number Register                                      */
X    volatile uint32_t CLKDIV;         
N    __IO uint32_t CLKSEL2;       /* Offset: 0x1C  Clock Source Select Control Register 2                             */
X    volatile uint32_t CLKSEL2;        
N    /// @cond HIDDEN_SYMBOLS
N    __I  uint32_t RESERVE0[1];
X    volatile const  uint32_t RESERVE0[1];
N    /// @endcond //HIDDEN_SYMBOLS
N    __IO uint32_t FRQDIV;        /* Offset: 0x24  Frequency Divider Control Register                                 */
X    volatile uint32_t FRQDIV;         
N
N} CLK_T;
N
N
N
N/**
N    @addtogroup CLK_CONST CLK Bit Field Definition
N    Constant Definitions for CLK Controller
N@{ */
N
N#define CLK_PWRCON_XTLCLK_EN_Pos         (0)                                               /*!< CLK_T::PWRCON: XTLCLK_EN Position         */
N#define CLK_PWRCON_XTLCLK_EN_Msk         (0x3ul << CLK_PWRCON_XTLCLK_EN_Pos)               /*!< CLK_T::PWRCON: XTLCLK_EN Mask             */
N
N#define CLK_PWRCON_OSC22M_EN_Pos         (2)                                               /*!< CLK_T::PWRCON: OSC22M_EN Position         */
N#define CLK_PWRCON_OSC22M_EN_Msk         (0x1ul << CLK_PWRCON_OSC22M_EN_Pos)               /*!< CLK_T::PWRCON: OSC22M_EN Mask             */
N#define CLK_PWRCON_IRC22M_EN_Pos         (2)                                               /*!< CLK_T::PWRCON: OSC22M_EN Position         */
N#define CLK_PWRCON_IRC22M_EN_Msk         (0x1ul << CLK_PWRCON_IRC22M_EN_Pos)               /*!< CLK_T::PWRCON: OSC22M_EN Mask             */
N#define CLK_PWRCON_HIRC_EN_Pos           (2)                                               /*!< CLK_T::PWRCON: OSC22M_EN Position         */
N#define CLK_PWRCON_HIRC_EN_Msk           (0x1ul << CLK_PWRCON_HIRC_EN_Pos)                 /*!< CLK_T::PWRCON: OSC22M_EN Mask             */
N
N#define CLK_PWRCON_OSC10K_EN_Pos         (3)                                               /*!< CLK_T::PWRCON: OSC10K_EN Position         */
N#define CLK_PWRCON_OSC10K_EN_Msk         (0x1ul << CLK_PWRCON_OSC10K_EN_Pos)               /*!< CLK_T::PWRCON: OSC10K_EN Mask             */
N#define CLK_PWRCON_IRC10K_EN_Pos         (3)                                               /*!< CLK_T::PWRCON: OSC10K_EN Position         */
N#define CLK_PWRCON_IRC10K_EN_Msk         (0x1ul << CLK_PWRCON_IRC10K_EN_Pos)               /*!< CLK_T::PWRCON: OSC10K_EN Mask             */
N#define CLK_PWRCON_LIRC_EN_Pos           (3)                                               /*!< CLK_T::PWRCON: OSC10K_EN Position         */
N#define CLK_PWRCON_LIRC_EN_Msk           (0x1ul << CLK_PWRCON_LIRC_EN_Pos)                 /*!< CLK_T::PWRCON: OSC10K_EN Mask             */
N
N#define CLK_PWRCON_WU_DLY_Pos            (4)                                               /*!< CLK_T::PWRCON: PD_WU_DLY Position         */
N#define CLK_PWRCON_WU_DLY_Msk            (0x1ul << CLK_PWRCON_WU_DLY_Pos)                  /*!< CLK_T::PWRCON: PD_WU_DLY Mask             */
N
N#define CLK_PWRCON_WINT_EN_Pos           (5)                                               /*!< CLK_T::PWRCON: PD_WU_INT_EN Position      */
N#define CLK_PWRCON_WINT_EN_Msk           (0x1ul << CLK_PWRCON_WINT_EN_Pos)                 /*!< CLK_T::PWRCON: PD_WU_INT_EN Mask          */
N
N#define CLK_PWRCON_PD_WU_STS_Pos         (6)                                               /*!< CLK_T::PWRCON: PD_WU_STS Position         */
N#define CLK_PWRCON_PD_WU_STS_Msk         (0x1ul << CLK_PWRCON_PD_WU_STS_Pos)               /*!< CLK_T::PWRCON: PD_WU_STS Mask             */
N
N#define CLK_PWRCON_PWR_DOWN_EN_Pos       (7)                                               /*!< CLK_T::PWRCON: PWR_DOWN_EN Position       */
N#define CLK_PWRCON_PWR_DOWN_EN_Msk       (0x1ul << CLK_PWRCON_PWR_DOWN_EN_Pos)             /*!< CLK_T::PWRCON: PWR_DOWN_EN Mask           */
N
N#define CLK_PWRCON_PD_32K_Pos            (9)                                               /*!< CLK_T::PWRCON: PD_32K Position            */
N#define CLK_PWRCON_PD_32K_Msk            (0x1ul << CLK_PWRCON_PD_32K_Pos)                  /*!< CLK_T::PWRCON: PD_32K Mask                */
N
N#define CLK_AHBCLK_ISP_EN_Pos            (2)                                               /*!< CLK_T::AHBCLK: ISP_EN Position            */
N#define CLK_AHBCLK_ISP_EN_Msk            (0x1ul << CLK_AHBCLK_ISP_EN_Pos)                  /*!< CLK_T::AHBCLK: ISP_EN Mask                */
N
N#define CLK_APBCLK_WDT_EN_Pos            (0)                                               /*!< CLK_T::APBCLK: WDT_EN Position            */
N#define CLK_APBCLK_WDT_EN_Msk            (0x1ul << CLK_APBCLK_WDT_EN_Pos)                  /*!< CLK_T::APBCLK: WDT_EN Mask                */
N
N#define CLK_APBCLK_TMR0_EN_Pos           (2)                                               /*!< CLK_T::APBCLK: TMR0_EN Position           */
N#define CLK_APBCLK_TMR0_EN_Msk           (0x1ul << CLK_APBCLK_TMR0_EN_Pos)                 /*!< CLK_T::APBCLK: TMR0_EN Mask               */
N
N#define CLK_APBCLK_TMR1_EN_Pos           (3)                                               /*!< CLK_T::APBCLK: TMR1_EN Position           */
N#define CLK_APBCLK_TMR1_EN_Msk           (0x1ul << CLK_APBCLK_TMR1_EN_Pos)                 /*!< CLK_T::APBCLK: TMR1_EN Mask               */
N
N#define CLK_APBCLK_FDIV_EN_Pos           (6)                                               /*!< CLK_T::APBCLK: FDIV_EN Position           */
N#define CLK_APBCLK_FDIV_EN_Msk           (0x1ul << CLK_APBCLK_FDIV_EN_Pos)                 /*!< CLK_T::APBCLK: FDIV_EN Mask               */
N
N#define CLK_APBCLK_I2C_EN_Pos            (8)                                               /*!< CLK_T::APBCLK: I2C_EN Position            */
N#define CLK_APBCLK_I2C_EN_Msk            (0x1ul << CLK_APBCLK_I2C_EN_Pos)                  /*!< CLK_T::APBCLK: I2C_EN Mask                */
N
N#define CLK_APBCLK_SPI_EN_Pos            (12)                                              /*!< CLK_T::APBCLK: SPI_EN Position            */
N#define CLK_APBCLK_SPI_EN_Msk            (0x1ul << CLK_APBCLK_SPI_EN_Pos)                  /*!< CLK_T::APBCLK: SPI_EN Mask                */
N
N#define CLK_APBCLK_UART_EN_Pos           (16)                                              /*!< CLK_T::APBCLK: UART_EN Position           */
N#define CLK_APBCLK_UART_EN_Msk           (0x1ul << CLK_APBCLK_UART_EN_Pos)                 /*!< CLK_T::APBCLK: UART_EN Mask               */
N
N#define CLK_APBCLK_PWM01_EN_Pos          (20)                                              /*!< CLK_T::APBCLK: PWM01_EN Position          */
N#define CLK_APBCLK_PWM01_EN_Msk          (0x1ul << CLK_APBCLK_PWM01_EN_Pos)                /*!< CLK_T::APBCLK: PWM01_EN Mask              */
N
N#define CLK_APBCLK_PWM23_EN_Pos          (21)                                              /*!< CLK_T::APBCLK: PWM23_EN Position          */
N#define CLK_APBCLK_PWM23_EN_Msk          (0x1ul << CLK_APBCLK_PWM23_EN_Pos)                /*!< CLK_T::APBCLK: PWM23_EN Mask              */
N
N#define CLK_APBCLK_PWM45_EN_Pos          (22)                                              /*!< CLK_T::APBCLK: PWM45_EN Position          */
N#define CLK_APBCLK_PWM45_EN_Msk          (0x1ul << CLK_APBCLK_PWM45_EN_Pos)                /*!< CLK_T::APBCLK: PWM45_EN Mask              */
N
N#define CLK_APBCLK_ADC_EN_Pos            (28)                                              /*!< CLK_T::APBCLK: ADC_EN Position            */
N#define CLK_APBCLK_ADC_EN_Msk            (0x1ul << CLK_APBCLK_ADC_EN_Pos)                  /*!< CLK_T::APBCLK: ADC_EN Mask                */
N
N#define CLK_APBCLK_CMP_EN_Pos            (30)                                              /*!< CLK_T::APBCLK: ACMP_EN Position           */
N#define CLK_APBCLK_CMP_EN_Msk            (0x1ul << CLK_APBCLK_CMP_EN_Pos)                  /*!< CLK_T::APBCLK: ACMP_EN Mask               */
N
N#define CLK_CLKSTATUS_XTL_STB_Pos        (0)                                               /*!< CLK_T::CLKSTATUS: XTL_STB Position        */
N#define CLK_CLKSTATUS_XTL_STB_Msk        (0x1ul << CLK_CLKSTATUS_XTL_STB_Pos)              /*!< CLK_T::CLKSTATUS: XTL_STB Mask            */
N#define CLK_CLKSTATUS_HXT_STB_Pos        (0)                                               /*!< CLK_T::CLKSTATUS: XTL_STB Position        */
N#define CLK_CLKSTATUS_HXT_STB_Msk        (0x1ul << CLK_CLKSTATUS_HXT_STB_Pos)              /*!< CLK_T::CLKSTATUS: XTL_STB Mask            */
N#define CLK_CLKSTATUS_LXT_STB_Pos        (0)                                               /*!< CLK_T::CLKSTATUS: XTL_STB Position        */
N#define CLK_CLKSTATUS_LXT_STB_Msk        (0x1ul << CLK_CLKSTATUS_LXT_STB_Pos)              /*!< CLK_T::CLKSTATUS: XTL_STB Mask            */
N
N#define CLK_CLKSTATUS_OSC10K_STB_Pos     (3)                                               /*!< CLK_T::CLKSTATUS: OSC10K_STB Position     */
N#define CLK_CLKSTATUS_OSC10K_STB_Msk     (0x1ul << CLK_CLKSTATUS_OSC10K_STB_Pos)           /*!< CLK_T::CLKSTATUS: OSC10K_STB Mask         */
N#define CLK_CLKSTATUS_IRC10K_STB_Pos     (3)                                               /*!< CLK_T::CLKSTATUS: OSC10K_STB Position     */
N#define CLK_CLKSTATUS_IRC10K_STB_Msk     (0x1ul << CLK_CLKSTATUS_OSC10K_STB_Pos)           /*!< CLK_T::CLKSTATUS: OSC10K_STB Mask         */
N#define CLK_CLKSTATUS_LIRC_STB_Pos       (3)                                               /*!< CLK_T::CLKSTATUS: OSC10K_STB Position     */
N#define CLK_CLKSTATUS_LIRC_STB_Msk       (0x1ul << CLK_CLKSTATUS_LIRC_STB_Pos)             /*!< CLK_T::CLKSTATUS: OSC10K_STB Mask         */
N
N#define CLK_CLKSTATUS_OSC22M_STB_Pos     (4)                                               /*!< CLK_T::CLKSTATUS: OSC22M_STB Position     */
N#define CLK_CLKSTATUS_OSC22M_STB_Msk     (0x1ul << CLK_CLKSTATUS_OSC22M_STB_Pos)           /*!< CLK_T::CLKSTATUS: OSC22M_STB Mask         */
N#define CLK_CLKSTATUS_IRC22M_STB_Pos     (4)                                               /*!< CLK_T::CLKSTATUS: OSC22M_STB Position     */
N#define CLK_CLKSTATUS_IRC22M_STB_Msk     (0x1ul << CLK_CLKSTATUS_OSC22M_STB_Pos)           /*!< CLK_T::CLKSTATUS: OSC22M_STB Mask         */
N#define CLK_CLKSTATUS_HIRC_STB_Pos       (4)                                               /*!< CLK_T::CLKSTATUS: OSC22M_STB Position     */
N#define CLK_CLKSTATUS_HIRC_STB_Msk       (0x1ul << CLK_CLKSTATUS_HIRC_STB_Pos)             /*!< CLK_T::CLKSTATUS: OSC22M_STB Mask         */
N
N#define CLK_CLKSTATUS_CLK_SW_FAIL_Pos    (7)                                               /*!< CLK_T::CLKSTATUS: CLK_SW_FAIL Position    */
N#define CLK_CLKSTATUS_CLK_SW_FAIL_Msk    (0x1ul << CLK_CLKSTATUS_CLK_SW_FAIL_Pos)          /*!< CLK_T::CLKSTATUS: CLK_SW_FAIL Mask        */
N
N#define CLK_CLKSEL0_HCLK_S_Pos           (0)                                               /*!< CLK_T::CLKSEL0: HCLK_S Position           */
N#define CLK_CLKSEL0_HCLK_S_Msk           (0x7ul << CLK_CLKSEL0_HCLK_S_Pos)                 /*!< CLK_T::CLKSEL0: HCLK_S Mask               */
N
N#define CLK_CLKSEL0_STCLK_S_Pos          (3)                                               /*!< CLK_T::CLKSEL0: STCLK_S Position          */
N#define CLK_CLKSEL0_STCLK_S_Msk          (0x7ul << CLK_CLKSEL0_STCLK_S_Pos)                /*!< CLK_T::CLKSEL0: STCLK_S Mask              */
N
N#define CLK_CLKSEL1_WDT_S_Pos            (0)                                               /*!< CLK_T::CLKSEL1: WDT_S Position            */
N#define CLK_CLKSEL1_WDT_S_Msk            (0x3ul << CLK_CLKSEL1_WDT_S_Pos)                  /*!< CLK_T::CLKSEL1: WDT_S Mask                */
N
N#define CLK_CLKSEL1_ADC_S_Pos            (2)                                               /*!< CLK_T::CLKSEL1: ADC_S Position            */
N#define CLK_CLKSEL1_ADC_S_Msk            (0x3ul << CLK_CLKSEL1_ADC_S_Pos)                  /*!< CLK_T::CLKSEL1: ADC_S Mask                */
N
N#define CLK_CLKSEL1_SPI_S_Pos            (4)                                               /*!< CLK_T::CLKSEL1: SPI_S Position            */
N#define CLK_CLKSEL1_SPI_S_Msk            (0x1ul << CLK_CLKSEL1_SPI_S_Pos)                  /*!< CLK_T::CLKSEL1: SPI_S Mask                */
N
N#define CLK_CLKSEL1_TMR0_S_Pos           (8)                                               /*!< CLK_T::CLKSEL1: TMR0_S Position           */
N#define CLK_CLKSEL1_TMR0_S_Msk           (0x7ul << CLK_CLKSEL1_TMR0_S_Pos)                 /*!< CLK_T::CLKSEL1: TMR0_S Mask               */
N
N#define CLK_CLKSEL1_TMR1_S_Pos           (12)                                              /*!< CLK_T::CLKSEL1: TMR1_S Position           */
N#define CLK_CLKSEL1_TMR1_S_Msk           (0x7ul << CLK_CLKSEL1_TMR1_S_Pos)                 /*!< CLK_T::CLKSEL1: TMR1_S Mask               */
N
N#define CLK_CLKSEL1_UART_S_Pos           (24)                                              /*!< CLK_T::CLKSEL1: UART_S Position           */
N#define CLK_CLKSEL1_UART_S_Msk           (0x3ul << CLK_CLKSEL1_UART_S_Pos)                 /*!< CLK_T::CLKSEL1: UART_S Mask               */
N
N#define CLK_CLKDIV_HCLK_N_Pos            (0)                                               /*!< CLK_T::CLKDIV: HCLK_N Position            */
N#define CLK_CLKDIV_HCLK_N_Msk            (0xful << CLK_CLKDIV_HCLK_N_Pos)                  /*!< CLK_T::CLKDIV: HCLK_N Mask                */
N
N#define CLK_CLKDIV_UART_N_Pos            (8)                                               /*!< CLK_T::CLKDIV: UART_N Position            */
N#define CLK_CLKDIV_UART_N_Msk            (0xful << CLK_CLKDIV_UART_N_Pos)                  /*!< CLK_T::CLKDIV: UART_N Mask                */
N
N#define CLK_CLKDIV_ADC_N_Pos             (16)                                              /*!< CLK_T::CLKDIV: ADC_N Position             */
N#define CLK_CLKDIV_ADC_N_Msk             (0xfful << CLK_CLKDIV_ADC_N_Pos)                  /*!< CLK_T::CLKDIV: ADC_N Mask                 */
N
N#define CLK_CLKSEL2_FRQDIV_S_Pos         (2)                                               /*!< CLK_T::CLKSEL2: FRQDIV_S Position         */
N#define CLK_CLKSEL2_FRQDIV_S_Msk         (0x3ul << CLK_CLKSEL2_FRQDIV_S_Pos)               /*!< CLK_T::CLKSEL2: FRQDIV_S Mask             */
N
N#define CLK_FRQDIV_FSEL_Pos              (0)                                               /*!< CLK_T::FRQDIV: FSEL Position              */
N#define CLK_FRQDIV_FSEL_Msk              (0xful << CLK_FRQDIV_FSEL_Pos)                    /*!< CLK_T::FRQDIV: FSEL Mask                  */
N
N#define CLK_FRQDIV_DIVIDER_EN_Pos        (4)                                               /*!< CLK_T::FRQDIV: DIVIDER_EN Position        */
N#define CLK_FRQDIV_DIVIDER_EN_Msk        (0x1ul << CLK_FRQDIV_DIVIDER_EN_Pos)              /*!< CLK_T::FRQDIV: DIVIDER_EN Mask            */
N
N#define CLK_FRQDIV_DIVIDER1_Pos          (5)                                               /*!< CLK_T::FRQDIV: DIVIDER1 Position          */
N#define CLK_FRQDIV_DIVIDER1_Msk          (0x1ul << CLK_FRQDIV_DIVIDER1_Pos)                /*!< CLK_T::FRQDIV: DIVIDER1 Mask              */
N
N/**@}*/ /* CLK_CONST */
N/**@}*/ /* end of CLK register group */
N
N
N/*---------------------- Flash Memory Controller -------------------------*/
N/**
N    @addtogroup FMC Flash Memory Controller(FMC)
N    Memory Mapped Structure for FMC Controller
N@{ */
N
N
Ntypedef struct {
N
N    /**
N     * @var FMC_T::ISPCON
N     * Offset: 0x00  ISP Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ISPEN     |ISP Enable Control (Write Protect)
N     * |        |          |Set this bit to enable ISP function.
N     * |        |          |0 = ISP function Disabled.
N     * |        |          |1 = ISP function Enabled.
N     * |[1]     |BS        |Boot Select (Write Protect)
N     * |        |          |Set/clear this bit to select next booting from LDROM/APROM, respectively.
N     * |        |          |This bit also functions as chip booting status flag, which can be used to check where chip booted from.
N     * |        |          |This bit is initiated with the inversed value of CBS in CONFIG0 after any reset is happened except CPU reset (RSTS_CPU is 1) or system reset (RSTS_SYS) is happened.
N     * |        |          |0 = Boot from APROM.
N     * |        |          |1 = Boot from LDROM.
N     * |[3]     |APUEN     |APROM Update Enable Control (Write Protect)
N     * |        |          |0 = APROM cannot be updated when chip runs in APROM.
N     * |        |          |1 = APROM can be updated when chip runs in APROM.
N     * |[4]     |CFGUEN    |CONFIG Update Enable Control (Write Protect)
N     * |        |          |Writing this bit to 1 enables software to update CONFIG value by ISP register control procedure regardless of program code is running in APROM or LDROM.
N     * |        |          |0 = ISP update User Configuration Disabled.
N     * |        |          |1 = ISP update User Configuration Enabled.
N     * |[5]     |LDUEN     |LDROM Update Enable Control (Write Protect)
N     * |        |          |0 = LDROM cannot be updated.
N     * |        |          |1 = LDROM can be updated when the MCU runs in APROM.
N     * |[6]     |ISPFF     |ISP Fail Flag (Write Protect)
N     * |        |          |This bit is set by hardware when a triggered ISP meets any of the following conditions:
N     * |        |          |(1) APROM writes to itself if APUEN is set to 0 or CBS[0]=1.
N     * |        |          |(2) LDROM writes to itself if LDUEN is set to 0 or CBS[0]=1.
N     * |        |          |(3) User Configuration is erased/programmed when CFGUEN is 0.
N     * |        |          |(4) Destination address is illegal, such as over an available range.
N     * |        |          |Note: Write 1 to clear this bit to 0.
N     * @var FMC_T::ISPADR
N     * Offset: 0x04  ISP Address Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |ISPADR    |ISP Address
N     * |        |          |The NuMicro Mini51TM series supports word program only. ISPADR[1:0] must be kept 00 for ISP operation.
N     * @var FMC_T::ISPDAT
N     * Offset: 0x08  ISP Data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |ISPDAT    |ISP Data
N     * |        |          |Write data to this register before ISP program operation.
N     * |        |          |Read data from this register after ISP read operation.
N     * @var FMC_T::ISPCMD
N     * Offset: 0x0C  ISP Command Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |ISPCMD    |ISP Command
N     * |        |          |ISP commands are shown below:
N     * |        |          |0x00 = Read.
N     * |        |          |0x04 = Read Unique ID.
N     * |        |          |0x0B = Read Company ID (0xDA).
N     * |        |          |0x21 = Program.
N     * |        |          |0x22 = Page Erase.
N     * |        |          |0x2E = Set Vector Page Re-Map.
N     * @var FMC_T::ISPTRG
N     * Offset: 0x10  ISP Trigger Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ISPGO     |ISP Start Trigger (Write Protect)
N     * |        |          |Write 1 to start ISP operation and this bit will be cleared to 0 by hardware automatically when ISP operation is finished.
N     * |        |          |0 = ISP operation is finished.
N     * |        |          |1 = ISP operation is progressed.
N     * @var FMC_T::DFBADR
N     * Offset: 0x14  Data Flash Start Address
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |DFBA      |Data Flash Base Address
N     * |        |          |This register indicates Data Flash start address. It is a read only register.
N     * |        |          |The Data Flash start address is defined by user.
N     * |        |          |Since on chip flash erase unit is 512 bytes, it is mandatory to keep bit 8-0 as 0.
N     * @var FMC_T::ISPSTA
N     * Offset: 0x40  ISP Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ISPGO     |ISP Start Trigger (Read Only)
N     * |        |          |Write 1 to start ISP operation and this bit will be cleared to 0 by hardware automatically when ISP operation is finished.
N     * |        |          |0 = ISP operation is finished.
N     * |        |          |1 = ISP operation is progressed.
N     * |        |          |Note: This bit is the same with ISPTRG bit 0.
N     * |[2:1]   |CBS       |Config Boot Selection (Read Only)
N     * |        |          |This is a mirror of CBS in CONFIG0.
N     * |[6]     |ISPFF     |ISP Fail Flag (Write Protect)
N     * |        |          |This bit is set by hardware when a triggered ISP meets any of the following conditions:
N     * |        |          |(1) APROM writes to itself if APUEN is set to 0 or CBS[0]=1.
N     * |        |          |(2) LDROM writes to itself if LDUEN is set to 0 or CBS[0]=1.
N     * |        |          |(3) User Configuration is erased/programmed when CFGUEN is 0.
N     * |        |          |(4) Destination address is illegal, such as over an available range.
N     * |        |          |Write 1 to clear.
N     * |        |          |Note: This bit functions the same as ISPCON bit 6.
N     * |[20:9]  |VECMAP    |Vector Page Mapping Address (Read Only)
N     * |        |          |The current flash address space 0x0000_0000~0x0000_01FF is mapping to address {VECMAP[11:0], 9'h000} ~ {VECMAP[11:0], 9'h1FF}.
N     */
N
N    __IO uint32_t ISPCON;        /* Offset: 0x00  ISP Control Register                                               */
X    volatile uint32_t ISPCON;         
N    __IO uint32_t ISPADR;        /* Offset: 0x04  ISP Address Register                                               */
X    volatile uint32_t ISPADR;         
N    __IO uint32_t ISPDAT;        /* Offset: 0x08  ISP Data Register                                                  */
X    volatile uint32_t ISPDAT;         
N    __IO uint32_t ISPCMD;        /* Offset: 0x0C  ISP Command Register                                               */
X    volatile uint32_t ISPCMD;         
N    __IO uint32_t ISPTRG;        /* Offset: 0x10  ISP Trigger Register                                               */
X    volatile uint32_t ISPTRG;         
N    __I  uint32_t DFBADR;        /* Offset: 0x14  Data Flash Start Address                                           */
X    volatile const  uint32_t DFBADR;         
N    /// @cond HIDDEN_SYMBOLS
N    __I  uint32_t RESERVE0[10];
X    volatile const  uint32_t RESERVE0[10];
N    /// @endcond //HIDDEN_SYMBOLS
N    __I  uint32_t ISPSTA;        /* Offset: 0x40  ISP Status Register                                                */
X    volatile const  uint32_t ISPSTA;         
N
N} FMC_T;
N
N
N
N/**
N    @addtogroup FMC_CONST FMC Bit Field Definition
N    Constant Definitions for FMC Controller
N@{ */
N
N#define FMC_ISPCON_ISPEN_Pos             (0)                                               /*!< FMC_T::ISPCON: ISPEN Position             */
N#define FMC_ISPCON_ISPEN_Msk             (0x1ul << FMC_ISPCON_ISPEN_Pos)                   /*!< FMC_T::ISPCON: ISPEN Mask                 */
N
N#define FMC_ISPCON_BS_Pos                (1)                                               /*!< FMC_T::ISPCON: BS Position                */
N#define FMC_ISPCON_BS_Msk                (0x1ul << FMC_ISPCON_BS_Pos)                      /*!< FMC_T::ISPCON: BS Mask                    */
N
N#define FMC_ISPCON_APUEN_Pos             (3)                                               /*!< FMC_T::ISPCON: APUEN Position             */
N#define FMC_ISPCON_APUEN_Msk             (0x1ul << FMC_ISPCON_APUEN_Pos)                   /*!< FMC_T::ISPCON: APUEN Mask                 */
N
N#define FMC_ISPCON_CFGUEN_Pos            (4)                                               /*!< FMC_T::ISPCON: CFGUEN Position            */
N#define FMC_ISPCON_CFGUEN_Msk            (0x1ul << FMC_ISPCON_CFGUEN_Pos)                  /*!< FMC_T::ISPCON: CFGUEN Mask                */
N
N#define FMC_ISPCON_LDUEN_Pos             (5)                                               /*!< FMC_T::ISPCON: LDUEN Position             */
N#define FMC_ISPCON_LDUEN_Msk             (0x1ul << FMC_ISPCON_LDUEN_Pos)                   /*!< FMC_T::ISPCON: LDUEN Mask                 */
N
N#define FMC_ISPCON_ISPFF_Pos             (6)                                               /*!< FMC_T::ISPCON: ISPFF Position             */
N#define FMC_ISPCON_ISPFF_Msk             (0x1ul << FMC_ISPCON_ISPFF_Pos)                   /*!< FMC_T::ISPCON: ISPFF Mask                 */
N
N#define FMC_ISPADR_ISPADR_Pos            (0)                                               /*!< FMC_T::ISPADR: ISPADR Position            */
N#define FMC_ISPADR_ISPADR_Msk            (0xfffffffful << FMC_ISPADR_ISPADR_Pos)           /*!< FMC_T::ISPADR: ISPADR Mask                */
N
N#define FMC_ISPDAT_ISPDAT_Pos            (0)                                               /*!< FMC_T::ISPDAT: ISPDAT Position            */
N#define FMC_ISPDAT_ISPDAT_Msk            (0xfffffffful << FMC_ISPDAT_ISPDAT_Pos)           /*!< FMC_T::ISPDAT: ISPDAT Mask                */
N
N#define FMC_ISPCMD_ISPCMD_Pos            (0)                                               /*!< FMC_T::ISPCMD: ISPCMD Position            */
N#define FMC_ISPCMD_ISPCMD_Msk            (0x3ful << FMC_ISPCMD_ISPCMD_Pos)                 /*!< FMC_T::ISPCMD: ISPCMD Mask                */
N
N#define FMC_ISPTRG_ISPGO_Pos             (0)                                               /*!< FMC_T::ISPTRG: ISPGO Position             */
N#define FMC_ISPTRG_ISPGO_Msk             (0x1ul << FMC_ISPTRG_ISPGO_Pos)                   /*!< FMC_T::ISPTRG: ISPGO Mask                 */
N
N#define FMC_DFBADR_DFBA_Pos                (0)                                               /*!< FMC_T::DFBADR: DFBA Position                */
N#define FMC_DFBADR_DFBA_Msk                (0xfffffffful << FMC_DFBA_DFBA_Pos)               /*!< FMC_T::DFBADR: DFBA Mask                    */
N
N#define FMC_ISPSTA_ISPGO_Pos             (0)                                               /*!< FMC_T::ISPSTA: ISPGO Position             */
N#define FMC_ISPSTA_ISPGO_Msk             (0x1ul << FMC_ISPSTA_ISPGO_Pos)                   /*!< FMC_T::ISPSTA: ISPGO Mask                 */
N
N#define FMC_ISPSTA_CBS_Pos               (1)                                               /*!< FMC_T::ISPSTA: CBS Position               */
N#define FMC_ISPSTA_CBS_Msk               (0x3ul << FMC_ISPSTA_CBS_Pos)                     /*!< FMC_T::ISPSTA: CBS Mask                   */
N
N#define FMC_ISPSTA_ISPFF_Pos             (6)                                               /*!< FMC_T::ISPSTA: ISPFF Position             */
N#define FMC_ISPSTA_ISPFF_Msk             (0x1ul << FMC_ISPSTA_ISPFF_Pos)                   /*!< FMC_T::ISPSTA: ISPFF Mask                 */
N
N#define FMC_ISPSTA_VECMAP_Pos            (9)                                               /*!< FMC_T::ISPSTA: VECMAP Position            */
N#define FMC_ISPSTA_VECMAP_Msk            (0xffful << FMC_ISPSTA_VECMAP_Pos)                /*!< FMC_T::ISPSTA: VECMAP Mask                */
N
N/**@}*/ /* FMC_CONST */
N/**@}*/ /* end of FMC register group */
N
N
N/*---------------------- System Global Control Registers -------------------------*/
N/**
N    @addtogroup GCR System Global Control Registers(GCR)
N    Memory Mapped Structure for GCR Controller
N@{ */
N
N
Ntypedef struct {
N
N    /**
N     * @var GCR_T::PDID
N     * Offset: 0x00  Part Device Identification Number Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |PDID      |Product Device Identification Number
N     * |        |          |This register reflects the device part number code.
N     * |        |          |Software can read this register to identify which device is used.
N     * |        |          |For example, the MINI51LDE PDID code is "0x20205100".
N     * @var GCR_T::RSTSRC
N     * Offset: 0x04  System Reset Source Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RSTS_POR  |Power-on Reset Flag
N     * |        |          |The RSTS_POR flag is set by the "reset signal", which is from the Power-On Reset (POR) controller or bit CHIP_RST (IPRSTC1[0]), to indicate the previous reset source.
N     * |        |          |0 = No reset from POR or CHIP_RST.
N     * |        |          |1 = Power-on-Reset (POR) or CHIP_RST had issued the reset signal to reset the system.
N     * |        |          |Note: Software can write 1 to clear this bit to 0.
N     * |[1]     |RSTS_RESET|Reset Pin Reset Flag
N     * |        |          |The RSTS_RESET flag is set by the "reset signal" from the /RESET pin to indicate the previous reset source.
N     * |        |          |0 = No reset from pin /RESET pin.
N     * |        |          |1 = The /RESET pin had issued the reset signal to reset the system.
N     * |        |          |Note: Software can write 1 to clear this bit to 0.
N     * |[2]     |RSTS_WDT  |Watchdog Reset Flag
N     * |        |          |The RSTS_WDT flag is set by the "reset signal" from the Watchdog timer to indicate the previous reset source.
N     * |        |          |0 = No reset from Watchdog timer.
N     * |        |          |1 = The Watchdog timer had issued the reset signal to reset the system.
N     * |        |          |Note: Software can write 1 to clear this bit to 0.
N     * |[4]     |RSTS_BOD  |Brown-out Detector Reset Flag
N     * |        |          |The RSTS_BOD flag is set by the "reset signal" from the Brown-out Detector to indicate the previous reset source.
N     * |        |          |0 = No reset from BOD.
N     * |        |          |1 = The BOD had issued the reset signal to reset the system.
N     * |        |          |Note: Software can write 1 to clear this bit to 0.
N     * |[5]     |RSTS_MCU  |MCU Reset Flag
N     * |        |          |The RSTS_MCU flag is set by the "reset signal" from the Cortex-M0 core to indicate the previous reset source.
N     * |        |          |0 = No reset from Cortex-M0.
N     * |        |          |1 = The Cortex-M0 had issued the reset signal to reset the system by writing 1 to bit SYSRESETREQ (AIRCR[2]), Application Interrupt and Reset Control Register, address = 0xE000ED0C in system control registers of Cortex-M0 core.
N     * |        |          |Note: Software can write 1 to clear this bit to 0.
N     * |[7]     |RSTS_CPU  |CPU Reset Flag
N     * |        |          |The RSTS_CPU flag is set by hardware if software writes CPU_RST (IPRSTC1[1]) 1 to reset Cortex-M0 core and Flash memory controller (FMC).
N     * |        |          |0 = No reset from CPU.
N     * |        |          |1 = Cortex-M0 core and FMC are reset by software setting CPU_RST to 1.
N     * |        |          |Note: Software can write 1 to clear this bit to 0.
N     * @var GCR_T::IPRSTC1
N     * Offset: 0x08  Peripheral Reset Control Resister 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CHIP_RST  |CHIP One-shot Reset (Write Protect)
N     * |        |          |Setting this bit will reset the CHIP, including CPU kernel and all peripherals, and this bit will automatically return to 0 after the 2 clock cycles.
N     * |        |          |The CHIP_RST is the same as the POR reset, and all the chip module is reset and the chip settings from flash are also reloaded.
N     * |        |          |0 = Chip normal operation.
N     * |        |          |1 = CHIP one-shot reset.
N     * |        |          |Note: This bit is the protected bit, and programming it needs to write 0x59, 0x16, and 0x88 to address 0x5000_0100 to disable register protection.
N     * |        |          |Refer to the register REGWRPROT at address GCR_BA + 0x100.
N     * |[1]     |CPU_RST   |CPU Kernel Reset
N     * |        |          |Setting this bit will reset the CPU kernel, and this bit will automatically return to 0 after the 2 clock cycles.
N     * |        |          |0 = CPU normal operation.
N     * |        |          |1 = Reset CPU Kernel.
N     * |        |          |Note: This bit is the protected bit, and programming it needs to write 0x59, 0x16, and 0x88 to address 0x5000_0100 to disable register protection.
N     * |        |          |Refer to the register REGWRPROT at address GCR_BA + 0x100.
N     * @var GCR_T::IPRSTC2
N     * Offset: 0x0C  Peripheral Reset Control Resister 2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |GPIO_RST  |GPIO (P0~P5) Controller Reset
N     * |        |          |0 = GPIO module normal operation.
N     * |        |          |1 = GPIO module reset.
N     * |[2]     |TMR0_RST  |Timer0 Controller Reset
N     * |        |          |0 = Timer0 module normal operation.
N     * |        |          |1 = Timer0 module reset.
N     * |[3]     |TMR1_RST  |Timer1 Controller Reset
N     * |        |          |0 = Timer1 module normal operation.
N     * |        |          |1 = Timer1 module reset.
N     * |[8]     |I2C_RST   |I2C Controller Reset
N     * |        |          |0 = I2C module normal operation.
N     * |        |          |1 = I2C module reset.
N     * |[12]    |SPI_RST   |SPI Controller Reset
N     * |        |          |0 = SPI module normal operation.
N     * |        |          |1 = SPI module reset.
N     * |[16]    |UART_RST  |UART Controller Reset
N     * |        |          |0 = UART module normal operation.
N     * |        |          |1 = UART module reset.
N     * |[20]    |PWM_RST   |PWM Controller Reset
N     * |        |          |0 = PWM module normal operation.
N     * |        |          |1 = PWM module reset.
N     * |[22]    |ACMP_RST  |ACMP Controller Reset
N     * |        |          |0 = ACMP module normal operation.
N     * |        |          |1 = ACMP module reset.
N     * |[28]    |ADC_RST   |ADC Controller Reset
N     * |        |          |0 = ADC module normal operation.
N     * |        |          |1 = ADC module reset.
N     * @var GCR_T::BODCTL
N     * Offset: 0x18  Brown-out Detector Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |BOD_VL_EXT|Brown-out Detector Selection Extension (Initiated & Write-protected Bit)
N     * |        |          |The default value is set by flash controller user configuration CBOVEXT bit (config0 [23]).
N     * |        |          |If config0 bit[23] is set to 1, default value of BOD_VL_EXT is 0.
N     * |        |          |If config0 bit[23] is set to 0, default value of BOD_VL_EXT is 1.
N     * |        |          |0 = Brown-out detector threshold voltage is selected by the table defined in BOD_VL.
N     * |        |          |1 = Brown-out detector threshold voltage is selected by the table defined below.
N     * |        |          |11 = 4.4V
N     * |        |          |10 = 3.7V
N     * |        |          |01 = 2.7V
N     * |        |          |00 = 2.2V
N     * |[2:1]   |BOD_VL    |Brown-out Detector Threshold Voltage Selection (Initiated & Write-protected Bit)
N     * |        |          |The default value is set by flash controller user configuration CBOV bit (config0 [22:21]).
N     * |        |          |BOD_VL[1]
N     * |        |          |BOD_VL[0]
N     * |        |          |Brown-out   voltage
N     * |        |          |11 = Disable
N     * |        |          |10 = 3.7V
N     * |        |          |01 = 2.7V
N     * |        |          |00 = Reserved
N     * |[3]     |BOD_RSTEN |Brown-out Reset Enable Control (Initiated And Write-protected Bit)
N     * |        |          |0 = Brown-out "INTERRUPT" function Enabled; when the Brown-out Detector function is enable and the detected voltage is lower than the threshold, then assert a signal to interrupt the Cortex-M0 CPU.
N     * |        |          |1 = Brown-out "RESET" function Enabled; when the Brown-out Detector function is enable and the detected voltage is lower than the threshold then assert a signal to reset the chip.
N     * |        |          |The default value is set by flash controller user configuration register config0 bit[20].
N     * |        |          |When the BOD_EN is enabled and the interrupt is asserted, the interrupt will be kept till the BOD_EN is set to 0.
N     * |        |          |The interrupt for CPU can be blocked by disabling the NVIC in CPU for BOD interrupt or disable the interrupt source by disabling the BOD_EN and then re-enabling the BOD_EN function if the BOD function is required.
N     * |[4]     |BOD_INTF  |Brown-out Detector Interrupt Flag
N     * |        |          |0 = Brown-out Detector does not detect any voltage dropped at AVDD down through or up through the voltage of BOD_VL setting.
N     * |        |          |1 = When Brown-out Detector detects the AVDD is dropped through the voltage of BOD_VL setting or the AVDD is raised up through the voltage of BOD_VL setting, this bit is set to 1 and the Brown-out interrupt is requested if Brown-out interrupt is enabled.
N     * |[5]     |BOD_LPM   |Brown-out Detector Low Power Mode (Write Protect)
N     * |        |          |0 = BOD operate in normal mode (default).
N     * |        |          |1 = Enable the BOD low power mode.
N     * |        |          |The BOD consumes about 100uA in normal mode, the low power mode can reduce the current to about 1uA but slow the BOD response.
N     * |[6]     |BOD_OUT   |Brown-out Detector Output State
N     * |        |          |0 = Brown-out Detector status output is 0, the detected voltage is higher than BOD_VL setting.
N     * |        |          |1 = Brown-out Detector status output is 1, the detected voltage is lower than BOD_VL setting.
N     * @var GCR_T::P0_MFP
N     * Offset: 0x30  P0 Multiple Function and Input Type Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |P0_MFP    |P0 Multiple Function Selection
N     * |[8]     |P0_ALT0   |P0.0 Alternate Function Selection
N     * |[9]     |P0_ALT1   |P0.1 Alternate Function Selection
N     * |[12]    |P0_ALT4   |P0.4 Alternate Function Selection
N     * |[13]    |P0_ALT5   |P0.5 Alternate Function Selection
N     * |[14]    |P0_ALT6   |P0.6 Alternate Function Selection
N     * |[15]    |P0_ALT7   |P0.7 Alternate Function Selection
N     * |[23:16] |P0_TYPE   |P0[7:0] TTL Or Schmitt Trigger Function Enable Control
N     * |        |          |0 = P0[7:0]Select I/O input as TTL function.
N     * |        |          |1 = P0[7:0] Select I/O input as Schmitt Trigger function .
N     * @var GCR_T::P1_MFP
N     * Offset: 0x34  P1 Multiple Function and Input Type Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |P1_MFP    |P1 Multiple Function Selection
N     * |[8]     |P1_ALT0   |P1.0 Alternate Function Selection
N     * |[10]    |P1_ALT2   |P1.2 Alternate Function Selection
N     * |[11]    |P1_ALT3   |P1.3 Alternate Function Selection
N     * |[12]    |P1_ALT4   |P1.4 Alternate Function Selection
N     * |[13]    |P1_ALT5   |P1.5 Alternate Function Selection
N     * |[23:16] |P1_TYPE   |P1[7:0] TTL Or Schmitt Trigger Function Enable Control
N     * |        |          |0 = P1[7:0]Select I/O input as TTL function.
N     * |        |          |1 = P1[7:0] Select I/O input as Schmitt Trigger function .
N     * @var GCR_T::P2_MFP
N     * Offset: 0x38  P2 Multiple Function and Input Type Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |P2_MFP    |P2 Multiple Function Selection
N     * |[10]    |P2_ALT2   |P2.2 Alternate Function Selection
N     * |[11]    |P2_ALT3   |P2.3 Alternate Function Selection
N     * |[12]    |P2_ALT4   |P2.4 Alternate Function Selection
N     * |[13]    |P2_ALT5   |P2.5 Alternate Function Selection
N     * |[14]    |P2_ALT6   |P2.6 Alternate Function Selection
N     * |[23:16] |P2_TYPE   |P2[7:0] TTL Or Schmitt Trigger Function Enable Control
N     * |        |          |0 = P2[7:0]Select I/O input as TTL function.
N     * |        |          |1 = P2[7:0] Select I/O input as Schmitt Trigger function .
N     * @var GCR_T::P3_MFP
N     * Offset: 0x3C  P3 Multiple Function and Input Type Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |P3_MFP    |P3 Multiple Function Selection
N     * |[8]     |P3_ALT0   |P3.0 Alternate Function Selection
N     * |[9]     |P3_ALT1   |P3.1 Alternate Function Selection
N     * |[10]    |P3_ALT2   |P3.2 Alternate Function Selection
N     * |[12]    |P3_ALT4   |P3.4 Alternate Function Selection
N     * |[13]    |P3_ALT5   |P3.5 Alternate Function Selection
N     * |[14]    |P3_ALT6   |P3.6 Alternate Function Selection
N     * |[23:16] |P3_TYPE   |P3[7:0] TTL Or Schmitt Trigger Function Enable Control
N     * |        |          |0 = P3[7:0]Select I/O input as TTL function.
N     * |        |          |1 = P3[7:0] Select I/O input as Schmitt Trigger function .
N     * |[24]    |P32CPP1   |P3.2 Alternate Function Selection Extension
N     * @var GCR_T::P4_MFP
N     * Offset: 0x40  P4 Multiple Function and Input Type Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |P4_MFP    |P4 Multiple Function Selection
N     * |[14]    |P4_ALT6   |P4.6 Alternate Function Selection
N     * |[15]    |P4_ALT7   |P4.7 Alternate Function Selection
N     * |[23:16] |P4_TYPE   |P4[7:0] TTL Or Schmitt Trigger Function Enable Control
N     * |        |          |0 = P4[7:0]Select I/O input as TTL function.
N     * |        |          |1 = P4[7:0] Select I/O input as Schmitt Trigger function .
N     * @var GCR_T::P5_MFP
N     * Offset: 0x44  P5 Multiple Function and Input Type Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |P5_MFP    |P5 Multiple Function Selection
N     * |[8]     |P5_ALT0   |P5.0 Alternate Function Selection
N     * |[9]     |P5_ALT1   |P5.1 Alternate Function Selection
N     * |[10]    |P5_ALT2   |P5.2 Alternate Function Selection
N     * |[11]    |P5_ALT3   |P5.3 Alternate Function Selection
N     * |[12]    |P5_ALT4   |P5.4 Alternate Function Selection
N     * |[13]    |P5_ALT5   |P5.5 Alternate Function Selection
N     * |[23:16] |P5_TYPE   |P5[7:0] TTL Or Schmitt Trigger Function Enable Control
N     * |        |          |0 = P5[7:0]Select I/O input as TTL function.
N     * |        |          |1 = P5[7:0] Select I/O input as Schmitt Trigger function .
N     * @var GCR_T::IRCTRIMCTL
N     * Offset: 0x80  HIRC Trim Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TRIM_SEL  |Trim Frequency Selection
N     * |        |          |This bit is to enable the HIRC auto trim.
N     * |        |          |When setting this bit to 1, the HIRC auto trim function will trim HIRC to 22.1184 MHz automatically based on the LXT reference clock.
N     * |        |          |During auto trim operation, if LXT clock error is detected or trim retry limitation count reached, this field will be cleared to 0 automatically.
N     * |        |          |0 = HIRC auto trim function Disabled.
N     * |        |          |1 = HIRC auto trim function Enabled and HIRC trimmed to 22.1184 MHz.
N     * |[5:4]   |TRIM_LOOP |Trim Calculation Loop
N     * |        |          |This field defines that trim value calculation is based on how many LXT clocks in.
N     * |        |          |For example, if TRIM_LOOP is set as 00, auto trim circuit will calculate trim value based on the average frequency difference in 4 LXT clock.
N     * |        |          |00 = Trim value calculation is based on average difference in 4 LXT clocks.
N     * |        |          |01 = Trim value calculation is based on average difference in 8 LXT clocks.
N     * |        |          |10 = Trim value calculation is based on average difference in 16 LXT clocks.
N     * |        |          |11 = Trim value calculation is based on average difference in 32 LXT clocks.
N     * @var GCR_T::IRCTRIMIER
N     * Offset: 0x84  HIRC Trim Interrupt Enable Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |TRIM_FAIL_IEN|Trim Failure Interrupt Enable Control
N     * |        |          |This bit controls if an interrupt will be triggered while HIRC trim value update limitation count is reached and HIRC frequency is still not locked on target frequency set by TRIM_SEL.
N     * |        |          |If this bit is high and TRIM_FAIL_INT is set during auto trim operation, an interrupt will be triggered to notify that HIRC trim value update limitation count is reached.
N     * |        |          |0 = TRIM_FAIL_INT status Disabled to trigger an interrupt to CPU.
N     * |        |          |1 = TRIM_FAIL_INT status Enabled to trigger an interrupt to CPU.
N     * |[2]     |32K_ERR_IEN|LXT Clock Error Interrupt Enable Control
N     * |        |          |This bit controls if CPU could get an interrupt while LXT clock is inaccurate during auto trim operation.
N     * |        |          |If this bit is high, and 32K_ERR_INT is set during auto trim operation, an interrupt will be triggered to notify the LXT clock frequency is inaccurate.
N     * |        |          |0 = 32K_ERR_INT status Disabled to trigger an interrupt to CPU.
N     * |        |          |1 = 32K_ERR_INT status Enabled to trigger an interrupt to CPU.
N     * @var GCR_T::IRCTRIMISR
N     * Offset: 0x88  HIRC Trim Interrupt Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |FREQ_LOCK |HIRC Frequency Lock Status
N     * |        |          |This bit indicates the HIRC frequency locked in 22.1184 MHz.
N     * |        |          |This is a read only status bit and doesn't trigger any interrupt.
N     * |[1]     |TRIM_FAIL_INT|Trim Failure Interrupt Status
N     * |        |          |This bit indicates that HIRC trim value update limitation count reached and HIRC clock frequency still doesn't lock.
N     * |        |          |Once this bit is set, the auto trim operation stopped and TRIM_SEL will be cleared to 0 by hardware automatically.
N     * |        |          |If this bit is set and TRIM_FAIL_IEN is high, an interrupt will be triggered to notify that HIRC trim value update limitation count was reached.
N     * |        |          |Software can write 1 to clear this bit to 0.
N     * |        |          |0 = Trim value update limitation count is not reached.
N     * |        |          |1 = Trim value update limitation count is reached and HIRC frequency is still not locked.
N     * |[2]     |32K_ERR_INT|LXT Clock Error Interrupt Status
N     * |        |          |This bit indicates that LXT clock frequency is inaccuracy.
N     * |        |          |Once this bit is set, the auto trim operation stopped and TRIM_SEL will be cleared to 0 by hardware automatically.
N     * |        |          |If this bit is set and 32K_ERR_IEN is high, an interrupt will be triggered to notify the LXT clock frequency is inaccuracy.
N     * |        |          |Software can write 1 to clear this bit to 0.
N     * |        |          |0 = LXT clock frequency is accuracy.
N     * |        |          |1 = LXT clock frequency is inaccuracy.
N     * @var GCR_T::RegLockAddr
N     * Offset: 0x100  Register Write-Protection Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RegUnLock |Register Write-protection Disable Index (Read Only)
N     * |        |          |0 = Write-protection Enabled for writing protected registers.
N     * |        |          |Any write to the protected register is ignored.
N     * |        |          |1 = Write-protection Disabled for writing protected registers.
N     * |        |          |The Protected registers are:
N     * |        |          |IPRSTC1 (0x5000_0008)
N     * |        |          |BODCTL (0x5000_0018)
N     * |        |          |PWRCON (0x5000_0200), bit[6] is not protected for power wake-up interrupt clear
N     * |        |          |APBCLK (0x5000_0208), bit[0] watchdog clock enable only
N     * |        |          |CLKSEL0 (0x5000_0210)
N     * |        |          |CLKSEL1 (0x5000_0214), bit[1:0] Watchdog clock source select only
N     * |        |          |NMI_SEL (0x5000_0380), bit[8] NMI interrupt enable only
N     * |        |          |ISPCON (0x5000_C000)
N     * |        |          |ISPTRG (0x5000_C010)
N     * |        |          |WTCR (0x4000_4000)
N     * |        |          |Note: The bits which are write-protected will be noted as" (Write Protect)" beside the description.
N     * |[7:0]   |REGWRPROT |Register Write-protection Code (Write Only)
N     * |        |          |Some registers have write-protection function.
N     * |        |          |Writing these registers have to disable the protected function by writing the sequence value 0x59, 0x16, 0x88 to this field.
N     * |        |          |After this sequence is completed, the REGPROTDIS bit will be set to 1 and write-protection registers can be normal write.
N     */
N
N    __I  uint32_t PDID;          /* Offset: 0x00  Part Device Identification Number Register                         */
X    volatile const  uint32_t PDID;           
N    __IO uint32_t RSTSRC;        /* Offset: 0x04  System Reset Source Register                                       */
X    volatile uint32_t RSTSRC;         
N    __IO uint32_t IPRSTC1;       /* Offset: 0x08  Peripheral Reset Control Resister 1                                */
X    volatile uint32_t IPRSTC1;        
N    __IO uint32_t IPRSTC2;       /* Offset: 0x0C  Peripheral Reset Control Resister 2                                */
X    volatile uint32_t IPRSTC2;        
N    /// @cond HIDDEN_SYMBOLS
N    __I  uint32_t RESERVE0[2];
X    volatile const  uint32_t RESERVE0[2];
N    /// @endcond //HIDDEN_SYMBOLS
N    __IO uint32_t BODCTL;         /* Offset: 0x18  Brown-out Detector Control Register                                */
X    volatile uint32_t BODCTL;          
N    /// @cond HIDDEN_SYMBOLS
N    __I  uint32_t RESERVE1[5];
X    volatile const  uint32_t RESERVE1[5];
N    /// @endcond //HIDDEN_SYMBOLS
N    __IO uint32_t P0_MFP;        /* Offset: 0x30  P0 Multiple Function and Input Type Control Register               */
X    volatile uint32_t P0_MFP;         
N    __IO uint32_t P1_MFP;        /* Offset: 0x34  P1 Multiple Function and Input Type Control Register               */
X    volatile uint32_t P1_MFP;         
N    __IO uint32_t P2_MFP;        /* Offset: 0x38  P2 Multiple Function and Input Type Control Register               */
X    volatile uint32_t P2_MFP;         
N    __IO uint32_t P3_MFP;        /* Offset: 0x3C  P3 Multiple Function and Input Type Control Register               */
X    volatile uint32_t P3_MFP;         
N    __IO uint32_t P4_MFP;        /* Offset: 0x40  P4 Multiple Function and Input Type Control Register               */
X    volatile uint32_t P4_MFP;         
N    __IO uint32_t P5_MFP;        /* Offset: 0x44  P5 Multiple Function and Input Type Control Register               */
X    volatile uint32_t P5_MFP;         
N    /// @cond HIDDEN_SYMBOLS
N    __I  uint32_t RESERVE2[14];
X    volatile const  uint32_t RESERVE2[14];
N    /// @endcond //HIDDEN_SYMBOLS
N    __IO uint32_t IRCTRIMCTL;    /* Offset: 0x80  HIRC Trim Control Register                                         */
X    volatile uint32_t IRCTRIMCTL;     
N    __IO uint32_t IRCTRIMIER;    /* Offset: 0x84  HIRC Trim Interrupt Enable Control Register                        */
X    volatile uint32_t IRCTRIMIER;     
N    __IO uint32_t IRCTRIMISR;    /* Offset: 0x88  HIRC Trim Interrupt Status Register                                */
X    volatile uint32_t IRCTRIMISR;     
N    /// @cond HIDDEN_SYMBOLS
N    __IO uint32_t RESERVE3[29];
X    volatile uint32_t RESERVE3[29];
N    /// @endcond //HIDDEN_SYMBOLS
N    __IO uint32_t RegLockAddr;   /* Offset: 0x100  Register Write-Protection Control Register                        */
X    volatile uint32_t RegLockAddr;    
N
N} GCR_T;
N
N
N
N/**
N    @addtogroup GCR_CONST GCR Bit Field Definition
N    Constant Definitions for GCR Controller
N@{ */
N
N#define SYS_PDID_PDID_Pos                (0)                                               /*!< GCR_T::PDID: PDID Position                */
N#define SYS_PDID_PDID_Msk                (0xfffffffful << SYS_PDID_PDID_Pos)               /*!< GCR_T::PDID: PDID Mask                    */
N
N#define SYS_RSTSRC_RSTS_POR_Pos          (0)                                               /*!< GCR_T::RSTSRC: RSTS_POR Position          */
N#define SYS_RSTSRC_RSTS_POR_Msk          (0x1ul << SYS_RSTSRC_RSTS_POR_Pos)                /*!< GCR_T::RSTSRC: RSTS_POR Mask              */
N
N#define SYS_RSTSRC_RSTS_RESET_Pos        (1)                                               /*!< GCR_T::RSTSRC: RSTS_RESET Position        */
N#define SYS_RSTSRC_RSTS_RESET_Msk        (0x1ul << SYS_RSTSRC_RSTS_RESET_Pos)              /*!< GCR_T::RSTSRC: RSTS_RESET Mask            */
N
N#define SYS_RSTSRC_RSTS_WDT_Pos          (2)                                               /*!< GCR_T::RSTSRC: RSTS_WDT Position          */
N#define SYS_RSTSRC_RSTS_WDT_Msk          (0x1ul << SYS_RSTSRC_RSTS_WDT_Pos)                /*!< GCR_T::RSTSRC: RSTS_WDT Mask              */
N
N#define SYS_RSTSRC_RSTS_BOD_Pos          (4)                                               /*!< GCR_T::RSTSRC: RSTS_BOD Position          */
N#define SYS_RSTSRC_RSTS_BOD_Msk          (0x1ul << SYS_RSTSRC_RSTS_BOD_Pos)                /*!< GCR_T::RSTSRC: RSTS_BOD Mask              */
N
N#define SYS_RSTSRC_RSTS_MCU_Pos          (5)                                               /*!< GCR_T::RSTSRC: RSTS_MCU Position          */
N#define SYS_RSTSRC_RSTS_MCU_Msk          (0x1ul << SYS_RSTSRC_RSTS_MCU_Pos)                /*!< GCR_T::RSTSRC: RSTS_MCU Mask              */
N
N#define SYS_RSTSRC_RSTS_CPU_Pos          (7)                                               /*!< GCR_T::RSTSRC: RSTS_CPU Position          */
N#define SYS_RSTSRC_RSTS_CPU_Msk          (0x1ul << SYS_RSTSRC_RSTS_CPU_Pos)                /*!< GCR_T::RSTSRC: RSTS_CPU Mask              */
N
N#define SYS_IPRSTC1_CHIP_RST_Pos         (0)                                               /*!< GCR_T::IPRSTC1: CHIP_RST Position         */
N#define SYS_IPRSTC1_CHIP_RST_Msk         (0x1ul << SYS_IPRSTC1_CHIP_RST_Pos)               /*!< GCR_T::IPRSTC1: CHIP_RST Mask             */
N
N#define SYS_IPRSTC1_CPU_RST_Pos          (1)                                               /*!< GCR_T::IPRSTC1: CPU_RST Position          */
N#define SYS_IPRSTC1_CPU_RST_Msk          (0x1ul << SYS_IPRSTC1_CPU_RST_Pos)                /*!< GCR_T::IPRSTC1: CPU_RST Mask              */
N
N#define SYS_IPRSTC2_GPIO_RST_Pos         (1)                                               /*!< GCR_T::IPRSTC2: GPIO_RST Position         */
N#define SYS_IPRSTC2_GPIO_RST_Msk         (0x1ul << SYS_IPRSTC2_GPIO_RST_Pos)               /*!< GCR_T::IPRSTC2: GPIO_RST Mask             */
N
N#define SYS_IPRSTC2_TMR0_RST_Pos         (2)                                               /*!< GCR_T::IPRSTC2: TMR0_RST Position         */
N#define SYS_IPRSTC2_TMR0_RST_Msk         (0x1ul << SYS_IPRSTC2_TMR0_RST_Pos)               /*!< GCR_T::IPRSTC2: TMR0_RST Mask             */
N
N#define SYS_IPRSTC2_TMR1_RST_Pos         (3)                                               /*!< GCR_T::IPRSTC2: TMR1_RST Position         */
N#define SYS_IPRSTC2_TMR1_RST_Msk         (0x1ul << SYS_IPRSTC2_TMR1_RST_Pos)               /*!< GCR_T::IPRSTC2: TMR1_RST Mask             */
N
N#define SYS_IPRSTC2_I2C_RST_Pos          (8)                                               /*!< GCR_T::IPRSTC2: I2C_RST Position          */
N#define SYS_IPRSTC2_I2C_RST_Msk          (0x1ul << SYS_IPRSTC2_I2C_RST_Pos)                /*!< GCR_T::IPRSTC2: I2C_RST Mask              */
N
N#define SYS_IPRSTC2_SPI_RST_Pos          (12)                                              /*!< GCR_T::IPRSTC2: SPI_RST Position          */
N#define SYS_IPRSTC2_SPI_RST_Msk          (0x1ul << SYS_IPRSTC2_SPI_RST_Pos)                /*!< GCR_T::IPRSTC2: SPI_RST Mask              */
N
N#define SYS_IPRSTC2_UART_RST_Pos         (16)                                              /*!< GCR_T::IPRSTC2: UART_RST Position         */
N#define SYS_IPRSTC2_UART_RST_Msk         (0x1ul << SYS_IPRSTC2_UART_RST_Pos)               /*!< GCR_T::IPRSTC2: UART_RST Mask             */
N
N#define SYS_IPRSTC2_PWM_RST_Pos          (20)                                              /*!< GCR_T::IPRSTC2: PWM_RST Position          */
N#define SYS_IPRSTC2_PWM_RST_Msk          (0x1ul << SYS_IPRSTC2_PWM_RST_Pos)                /*!< GCR_T::IPRSTC2: PWM_RST Mask              */
N
N#define SYS_IPRSTC2_ACMP_RST_Pos         (22)                                              /*!< GCR_T::IPRSTC2: ACMP_RST Position         */
N#define SYS_IPRSTC2_ACMP_RST_Msk         (0x1ul << SYS_IPRSTC2_ACMP_RST_Pos)               /*!< GCR_T::IPRSTC2: ACMP_RST Mask             */
N
N#define SYS_IPRSTC2_ADC_RST_Pos          (28)                                              /*!< GCR_T::IPRSTC2: ADC_RST Position          */
N#define SYS_IPRSTC2_ADC_RST_Msk          (0x1ul << SYS_IPRSTC2_ADC_RST_Pos)                /*!< GCR_T::IPRSTC2: ADC_RST Mask              */
N
N#define SYS_BODCR_BOD_VL_EXT_Pos         (0)                                               /*!< GCR_T::BODCTL: BOD_VL_EXT Position         */
N#define SYS_BODCR_BOD_VL_EXT_Msk         (0x1ul << SYS_BODCR_BOD_VL_EXT_Pos)               /*!< GCR_T::BODCTL: BOD_VL_EXT Mask             */
N
N#define SYS_BODCR_BOD_VL_Pos             (1)                                               /*!< GCR_T::BODCTL: BOD_VL Position             */
N#define SYS_BODCR_BOD_VL_Msk             (0x3ul << SYS_BODCR_BOD_VL_Pos)                   /*!< GCR_T::BODCTL: BOD_VL Mask                 */
N
N#define SYS_BODCR_BOD_RSTEN_Pos          (3)                                               /*!< GCR_T::BODCTL: BOD_RSTEN Position          */
N#define SYS_BODCR_BOD_RSTEN_Msk          (0x1ul << SYS_BODCR_BOD_RSTEN_Pos)                /*!< GCR_T::BODCTL: BOD_RSTEN Mask              */
N
N#define SYS_BODCR_BOD_INTF_Pos           (4)                                               /*!< GCR_T::BODCTL: BOD_INTF Position           */
N#define SYS_BODCR_BOD_INTF_Msk           (0x1ul << SYS_BODCR_BOD_INTF_Pos)                 /*!< GCR_T::BODCTL: BOD_INTF Mask               */
N
N#define SYS_BODCR_BOD_LPM_Pos            (5)                                               /*!< GCR_T::BODCTL: BOD_LPM Position            */
N#define SYS_BODCR_BOD_LPM_Msk            (0x1ul << SYS_BODCR_BOD_LPM_Pos)                  /*!< GCR_T::BODCTL: BOD_LPM Mask                */
N
N#define SYS_BODCR_BOD_OUT_Pos            (6)                                               /*!< GCR_T::BODCTL: BOD_OUT Position            */
N#define SYS_BODCR_BOD_OUT_Msk            (0x1ul << SYS_BODCR_BOD_OUT_Pos)                  /*!< GCR_T::BODCTL: BOD_OUT Mask                */
N
N#define SYS_P0_MFP_P0_MFP_Pos            (0)                                               /*!< GCR_T::P0_MFP: P0_MFP Position            */
N#define SYS_P0_MFP_P0_MFP_Msk            (0xfful << SYS_P0_MFP_P0_MFP_Pos)                 /*!< GCR_T::P0_MFP: P0_MFP Mask                */
N
N#define SYS_P0_MFP_P0_ALT_Pos            (8)                                               /*!< GCR_T::P0_MFP: P0_ALT Position            */
N#define SYS_P0_MFP_P0_ALT_Msk            (0xfful << SYS_P0_MFP_P0_ALT_Pos)                 /*!< GCR_T::P0_MFP: P0_ALT Mask                */
N
N#define SYS_P0_MFP_P0_ALT0_Pos           (8)                                               /*!< GCR_T::P0_MFP: P0_ALT0 Position           */
N#define SYS_P0_MFP_P0_ALT0_Msk           (0x1ul << SYS_P0_MFP_P0_ALT0_Pos)                 /*!< GCR_T::P0_MFP: P0_ALT0 Mask               */
N
N#define SYS_P0_MFP_P0_ALT1_Pos           (9)                                               /*!< GCR_T::P0_MFP: P0_ALT1 Position           */
N#define SYS_P0_MFP_P0_ALT1_Msk           (0x1ul << SYS_P0_MFP_P0_ALT1_Pos)                 /*!< GCR_T::P0_MFP: P0_ALT1 Mask               */
N
N#define SYS_P0_MFP_P0_ALT4_Pos           (12)                                              /*!< GCR_T::P0_MFP: P0_ALT4 Position           */
N#define SYS_P0_MFP_P0_ALT4_Msk           (0x1ul << SYS_P0_MFP_P0_ALT4_Pos)                 /*!< GCR_T::P0_MFP: P0_ALT4 Mask               */
N
N#define SYS_P0_MFP_P0_ALT5_Pos           (13)                                              /*!< GCR_T::P0_MFP: P0_ALT5 Position           */
N#define SYS_P0_MFP_P0_ALT5_Msk           (0x1ul << SYS_P0_MFP_P0_ALT5_Pos)                 /*!< GCR_T::P0_MFP: P0_ALT5 Mask               */
N
N#define SYS_P0_MFP_P0_ALT6_Pos           (14)                                              /*!< GCR_T::P0_MFP: P0_ALT6 Position           */
N#define SYS_P0_MFP_P0_ALT6_Msk           (0x1ul << SYS_P0_MFP_P0_ALT6_Pos)                 /*!< GCR_T::P0_MFP: P0_ALT6 Mask               */
N
N#define SYS_P0_MFP_P0_ALT7_Pos           (15)                                              /*!< GCR_T::P0_MFP: P0_ALT7 Position           */
N#define SYS_P0_MFP_P0_ALT7_Msk           (0x1ul << SYS_P0_MFP_P0_ALT7_Pos)                 /*!< GCR_T::P0_MFP: P0_ALT7 Mask               */
N
N#define SYS_P0_MFP_P0_TYPE_Pos           (16)                                              /*!< GCR_T::P0_MFP: P0_TYPE Position           */
N#define SYS_P0_MFP_P0_TYPE_Msk           (0xfful << SYS_P0_MFP_P0_TYPE_Pos)                /*!< GCR_T::P0_MFP: P0_TYPE Mask               */
N
N#define SYS_P1_MFP_P1_MFP_Pos            (0)                                               /*!< GCR_T::P1_MFP: P1_MFP Position            */
N#define SYS_P1_MFP_P1_MFP_Msk            (0xfful << SYS_P1_MFP_P1_MFP_Pos)                 /*!< GCR_T::P1_MFP: P1_MFP Mask                */
N
N#define SYS_P1_MFP_P1_ALT_Pos            (8)                                               /*!< GCR_T::P1_MFP: P1_ALT Position            */
N#define SYS_P1_MFP_P1_ALT_Msk            (0xfful << SYS_P1_MFP_P1_ALT_Pos)                 /*!< GCR_T::P1_MFP: P1_ALT Mask                */
N
N#define SYS_P1_MFP_P1_ALT0_Pos           (8)                                               /*!< GCR_T::P1_MFP: P1_ALT0 Position           */
N#define SYS_P1_MFP_P1_ALT0_Msk           (0x1ul << SYS_P1_MFP_P1_ALT0_Pos)                 /*!< GCR_T::P1_MFP: P1_ALT0 Mask               */
N
N#define SYS_P1_MFP_P1_ALT2_Pos           (10)                                              /*!< GCR_T::P1_MFP: P1_ALT2 Position           */
N#define SYS_P1_MFP_P1_ALT2_Msk           (0x1ul << SYS_P1_MFP_P1_ALT2_Pos)                 /*!< GCR_T::P1_MFP: P1_ALT2 Mask               */
N
N#define SYS_P1_MFP_P1_ALT3_Pos           (11)                                              /*!< GCR_T::P1_MFP: P1_ALT3 Position           */
N#define SYS_P1_MFP_P1_ALT3_Msk           (0x1ul << SYS_P1_MFP_P1_ALT3_Pos)                 /*!< GCR_T::P1_MFP: P1_ALT3 Mask               */
N
N#define SYS_P1_MFP_P1_ALT4_Pos           (12)                                              /*!< GCR_T::P1_MFP: P1_ALT4 Position           */
N#define SYS_P1_MFP_P1_ALT4_Msk           (0x1ul << SYS_P1_MFP_P1_ALT4_Pos)                 /*!< GCR_T::P1_MFP: P1_ALT4 Mask               */
N
N#define SYS_P1_MFP_P1_ALT5_Pos           (13)                                              /*!< GCR_T::P1_MFP: P1_ALT5 Position           */
N#define SYS_P1_MFP_P1_ALT5_Msk           (0x1ul << SYS_P1_MFP_P1_ALT5_Pos)                 /*!< GCR_T::P1_MFP: P1_ALT5 Mask               */
N
N#define SYS_P1_MFP_P1_TYPE_Pos           (16)                                              /*!< GCR_T::P1_MFP: P1_TYPE Position           */
N#define SYS_P1_MFP_P1_TYPE_Msk           (0xfful << SYS_P1_MFP_P1_TYPE_Pos)                /*!< GCR_T::P1_MFP: P1_TYPE Mask               */
N
N#define SYS_P2_MFP_P2_MFP_Pos            (0)                                               /*!< GCR_T::P2_MFP: P2_MFP Position            */
N#define SYS_P2_MFP_P2_MFP_Msk            (0xfful << SYS_P2_MFP_P2_MFP_Pos)                 /*!< GCR_T::P2_MFP: P2_MFP Mask                */
N
N#define SYS_P2_MFP_P2_ALT_Pos            (8)                                               /*!< GCR_T::P2_MFP: P2_ALT Position            */
N#define SYS_P2_MFP_P2_ALT_Msk            (0xfful << SYS_P2_MFP_P2_ALT_Pos)                 /*!< GCR_T::P2_MFP: P2_ALT Mask                */
N
N#define SYS_P2_MFP_P2_ALT2_Pos           (10)                                              /*!< GCR_T::P2_MFP: P2_ALT2 Position           */
N#define SYS_P2_MFP_P2_ALT2_Msk           (0x1ul << SYS_P2_MFP_P2_ALT2_Pos)                 /*!< GCR_T::P2_MFP: P2_ALT2 Mask               */
N
N#define SYS_P2_MFP_P2_ALT3_Pos           (11)                                              /*!< GCR_T::P2_MFP: P2_ALT3 Position           */
N#define SYS_P2_MFP_P2_ALT3_Msk           (0x1ul << SYS_P2_MFP_P2_ALT3_Pos)                 /*!< GCR_T::P2_MFP: P2_ALT3 Mask               */
N
N#define SYS_P2_MFP_P2_ALT4_Pos           (12)                                              /*!< GCR_T::P2_MFP: P2_ALT4 Position           */
N#define SYS_P2_MFP_P2_ALT4_Msk           (0x1ul << SYS_P2_MFP_P2_ALT4_Pos)                 /*!< GCR_T::P2_MFP: P2_ALT4 Mask               */
N
N#define SYS_P2_MFP_P2_ALT5_Pos           (13)                                              /*!< GCR_T::P2_MFP: P2_ALT5 Position           */
N#define SYS_P2_MFP_P2_ALT5_Msk           (0x1ul << SYS_P2_MFP_P2_ALT5_Pos)                 /*!< GCR_T::P2_MFP: P2_ALT5 Mask               */
N
N#define SYS_P2_MFP_P2_ALT6_Pos           (14)                                              /*!< GCR_T::P2_MFP: P2_ALT6 Position           */
N#define SYS_P2_MFP_P2_ALT6_Msk           (0x1ul << SYS_P2_MFP_P2_ALT6_Pos)                 /*!< GCR_T::P2_MFP: P2_ALT6 Mask               */
N
N#define SYS_P2_MFP_P2_TYPE_Pos           (16)                                              /*!< GCR_T::P2_MFP: P2_TYPE Position           */
N#define SYS_P2_MFP_P2_TYPE_Msk           (0xfful << SYS_P2_MFP_P2_TYPE_Pos)                /*!< GCR_T::P2_MFP: P2_TYPE Mask               */
N
N#define SYS_P3_MFP_P3_MFP_Pos            (0)                                               /*!< GCR_T::P3_MFP: P3_MFP Position            */
N#define SYS_P3_MFP_P3_MFP_Msk            (0xfful << SYS_P3_MFP_P3_MFP_Pos)                 /*!< GCR_T::P3_MFP: P3_MFP Mask                */
N
N#define SYS_P3_MFP_P3_ALT_Pos            (8)                                               /*!< GCR_T::P3_MFP: P3_ALT Position            */
N#define SYS_P3_MFP_P3_ALT_Msk            (0xfful << SYS_P3_MFP_P3_ALT_Pos)                 /*!< GCR_T::P3_MFP: P3_ALT Mask                */
N
N#define SYS_P3_MFP_P3_ALT0_Pos           (8)                                               /*!< GCR_T::P3_MFP: P3_ALT0 Position           */
N#define SYS_P3_MFP_P3_ALT0_Msk           (0x1ul << SYS_P3_MFP_P3_ALT0_Pos)                 /*!< GCR_T::P3_MFP: P3_ALT0 Mask               */
N
N#define SYS_P3_MFP_P3_ALT1_Pos           (9)                                               /*!< GCR_T::P3_MFP: P3_ALT1 Position           */
N#define SYS_P3_MFP_P3_ALT1_Msk           (0x1ul << SYS_P3_MFP_P3_ALT1_Pos)                 /*!< GCR_T::P3_MFP: P3_ALT1 Mask               */
N
N#define SYS_P3_MFP_P3_ALT2_Pos           (10)                                              /*!< GCR_T::P3_MFP: P3_ALT2 Position           */
N#define SYS_P3_MFP_P3_ALT2_Msk           (0x1ul << SYS_P3_MFP_P3_ALT2_Pos)                 /*!< GCR_T::P3_MFP: P3_ALT2 Mask               */
N
N#define SYS_P3_MFP_P3_ALT4_Pos           (12)                                              /*!< GCR_T::P3_MFP: P3_ALT4 Position           */
N#define SYS_P3_MFP_P3_ALT4_Msk           (0x1ul << SYS_P3_MFP_P3_ALT4_Pos)                 /*!< GCR_T::P3_MFP: P3_ALT4 Mask               */
N
N#define SYS_P3_MFP_P3_ALT5_Pos           (13)                                              /*!< GCR_T::P3_MFP: P3_ALT5 Position           */
N#define SYS_P3_MFP_P3_ALT5_Msk           (0x1ul << SYS_P3_MFP_P3_ALT5_Pos)                 /*!< GCR_T::P3_MFP: P3_ALT5 Mask               */
N
N#define SYS_P3_MFP_P3_ALT6_Pos           (14)                                              /*!< GCR_T::P3_MFP: P3_ALT6 Position           */
N#define SYS_P3_MFP_P3_ALT6_Msk           (0x1ul << SYS_P3_MFP_P3_ALT6_Pos)                 /*!< GCR_T::P3_MFP: P3_ALT6 Mask               */
N
N#define SYS_P3_MFP_P3_TYPE_Pos           (16)                                              /*!< GCR_T::P3_MFP: P3_TYPE Position           */
N#define SYS_P3_MFP_P3_TYPE_Msk           (0xfful << SYS_P3_MFP_P3_TYPE_Pos)                /*!< GCR_T::P3_MFP: P3_TYPE Mask               */
N
N#define SYS_P3_MFP_P32CPP1_Pos           (24)                                              /*!< GCR_T::P3_MFP: P32CPP1 Position           */
N#define SYS_P3_MFP_P32CPP1_Msk           (0x1ul << SYS_P3_MFP_P32CPP1_Pos)                 /*!< GCR_T::P3_MFP: P32CPP1 Mask               */
N
N#define SYS_P4_MFP_P4_MFP_Pos            (0)                                               /*!< GCR_T::P4_MFP: P4_MFP Position            */
N#define SYS_P4_MFP_P4_MFP_Msk            (0xfful << SYS_P4_MFP_P4_MFP_Pos)                 /*!< GCR_T::P4_MFP: P4_MFP Mask                */
N
N#define SYS_P4_MFP_P4_ALT_Pos            (8)                                               /*!< GCR_T::P4_MFP: P4_ALT Position           */
N#define SYS_P4_MFP_P4_ALT_Msk            (0xfful << SYS_P4_MFP_P4_ALT_Pos)                 /*!< GCR_T::P4_MFP: P4_ALT Mask               */
N
N#define SYS_P4_MFP_P4_ALT6_Pos           (14)                                              /*!< GCR_T::P4_MFP: P4_ALT6 Position           */
N#define SYS_P4_MFP_P4_ALT6_Msk           (0x1ul << SYS_P4_MFP_P4_ALT6_Pos)                 /*!< GCR_T::P4_MFP: P4_ALT6 Mask               */
N
N#define SYS_P4_MFP_P4_ALT7_Pos           (15)                                              /*!< GCR_T::P4_MFP: P4_ALT7 Position           */
N#define SYS_P4_MFP_P4_ALT7_Msk           (0x1ul << SYS_P4_MFP_P4_ALT7_Pos)                 /*!< GCR_T::P4_MFP: P4_ALT7 Mask               */
N
N#define SYS_P4_MFP_P4_TYPE_Pos           (16)                                              /*!< GCR_T::P4_MFP: P4_TYPE Position           */
N#define SYS_P4_MFP_P4_TYPE_Msk           (0xfful << SYS_P4_MFP_P4_TYPE_Pos)                /*!< GCR_T::P4_MFP: P4_TYPE Mask               */
N
N#define SYS_P5_MFP_P5_MFP_Pos            (0)                                               /*!< GCR_T::P5_MFP: P5_MFP Position            */
N#define SYS_P5_MFP_P5_MFP_Msk            (0xfful << SYS_P5_MFP_P5_MFP_Pos)                 /*!< GCR_T::P5_MFP: P5_MFP Mask                */
N
N#define SYS_P5_MFP_P5_ALT_Pos            (8)                                               /*!< GCR_T::P5_MFP: P5_ALT Position            */
N#define SYS_P5_MFP_P5_ALT_Msk            (0xFFul << SYS_P5_MFP_P5_ALT_Pos)                 /*!< GCR_T::P5_MFP: P5_ALT Mask                */
N
N#define SYS_P5_MFP_P5_ALT0_Pos           (8)                                               /*!< GCR_T::P5_MFP: P5_ALT0 Position           */
N#define SYS_P5_MFP_P5_ALT0_Msk           (0x1ul << SYS_P5_MFP_P5_ALT0_Pos)                 /*!< GCR_T::P5_MFP: P5_ALT0 Mask               */
N
N#define SYS_P5_MFP_P5_ALT1_Pos           (9)                                               /*!< GCR_T::P5_MFP: P5_ALT1 Position           */
N#define SYS_P5_MFP_P5_ALT1_Msk           (0x1ul << SYS_P5_MFP_P5_ALT1_Pos)                 /*!< GCR_T::P5_MFP: P5_ALT1 Mask               */
N
N#define SYS_P5_MFP_P5_ALT2_Pos           (10)                                              /*!< GCR_T::P5_MFP: P5_ALT2 Position           */
N#define SYS_P5_MFP_P5_ALT2_Msk           (0x1ul << SYS_P5_MFP_P5_ALT2_Pos)                 /*!< GCR_T::P5_MFP: P5_ALT2 Mask               */
N
N#define SYS_P5_MFP_P5_ALT3_Pos           (11)                                              /*!< GCR_T::P5_MFP: P5_ALT3 Position           */
N#define SYS_P5_MFP_P5_ALT3_Msk           (0x1ul << SYS_P5_MFP_P5_ALT3_Pos)                 /*!< GCR_T::P5_MFP: P5_ALT3 Mask               */
N
N#define SYS_P5_MFP_P5_ALT4_Pos           (12)                                              /*!< GCR_T::P5_MFP: P5_ALT4 Position           */
N#define SYS_P5_MFP_P5_ALT4_Msk           (0x1ul << SYS_P5_MFP_P5_ALT4_Pos)                 /*!< GCR_T::P5_MFP: P5_ALT4 Mask               */
N
N#define SYS_P5_MFP_P5_ALT5_Pos           (13)                                              /*!< GCR_T::P5_MFP: P5_ALT5 Position           */
N#define SYS_P5_MFP_P5_ALT5_Msk           (0x1ul << SYS_P5_MFP_P5_ALT5_Pos)                 /*!< GCR_T::P5_MFP: P5_ALT5 Mask               */
N
N#define SYS_P5_MFP_P5_TYPE_Pos           (16)                                              /*!< GCR_T::P5_MFP: P5_TYPE Position           */
N#define SYS_P5_MFP_P5_TYPE_Msk           (0xfful << SYS_P5_MFP_P5_TYPE_Pos)                /*!< GCR_T::P5_MFP: P5_TYPE Mask               */
N
N#define SYS_IRCTRIMCTL_TRIM_SEL_Pos      (0)                                               /*!< GCR_T::IRCTRIMCTL: TRIM_SEL Position      */
N#define SYS_IRCTRIMCTL_TRIM_SEL_Msk      (0x1ul << SYS_IRCTRIMCTL_TRIM_SEL_Pos)            /*!< GCR_T::IRCTRIMCTL: TRIM_SEL Mask          */
N
N#define SYS_IRCTRIMCTL_TRIM_LOOP_Pos     (4)                                               /*!< GCR_T::IRCTRIMCTL: TRIM_LOOP Position     */
N#define SYS_IRCTRIMCTL_TRIM_LOOP_Msk     (0x3ul << SYS_IRCTRIMCTL_TRIM_LOOP_Pos)           /*!< GCR_T::IRCTRIMCTL: TRIM_LOOP Mask         */
N
N#define SYS_IRCTRIMIEN_TRIM_FAIL_IEN_Pos (1)                                               /*!< GCR_T::IRCTRIMIER: TRIM_FAIL_IEN Position */
N#define SYS_IRCTRIMIEN_TRIM_FAIL_IEN_Msk (0x1ul << SYS_IRCTRIMIEN_TRIM_FAIL_IEN_Pos)       /*!< GCR_T::IRCTRIMIER: TRIM_FAIL_IEN Mask     */
N
N#define SYS_IRCTRIMIEN_32K_ERR_IEN_Pos   (2)                                               /*!< GCR_T::IRCTRIMIER: 32K_ERR_IEN Position   */
N#define SYS_IRCTRIMIEN_32K_ERR_IEN_Msk   (0x1ul << SYS_IRCTRIMIEN_32K_ERR_IEN_Pos)         /*!< GCR_T::IRCTRIMIER: 32K_ERR_IEN Mask       */
N
N#define SYS_IRCTRIMINT_FREQ_LOCK_Pos     (0)                                               /*!< GCR_T::IRCTRIMISR: FREQ_LOCK Position     */
N#define SYS_IRCTRIMINT_FREQ_LOCK_Msk     (0x1ul << SYS_IRCTRIMINT_FREQ_LOCK_Pos)           /*!< GCR_T::IRCTRIMISR: FREQ_LOCK Mask         */
N
N#define SYS_IRCTRIMINT_TRIM_FAIL_INT_Pos (1)                                               /*!< GCR_T::IRCTRIMISR: TRIM_FAIL_INT Position */
N#define SYS_IRCTRIMINT_TRIM_FAIL_INT_Msk (0x1ul << SYS_IRCTRIMINT_TRIM_FAIL_INT_Pos)       /*!< GCR_T::IRCTRIMISR: TRIM_FAIL_INT Mask     */
N
N#define SYS_IRCTRIMINT_32K_ERR_INT_Pos   (2)                                               /*!< GCR_T::IRCTRIMISR: 32K_ERR_INT Position   */
N#define SYS_IRCTRIMINT_32K_ERR_INT_Msk   (0x1ul << SYS_IRCTRIMINT_32K_ERR_INT_Pos)         /*!< GCR_T::IRCTRIMISR: 32K_ERR_INT Mask       */
N
N#define SYS_RegLockAddr_RegUnLock_Pos    0                                                 /*!< GCR_T::RegLockAddr: RegUnLock Position    */
N#define SYS_RegLockAddr_RegUnLock_Msk    (0x1ul << SYS_RegLockAddr_RegUnLock_Pos)          /*!< GCR_T::RegLockAddr: RegUnLock Mask        */
N
N/**@}*/ /* GCR_CONST */
N/**@}*/ /* end of GCR register group */
N
N
N/*---------------------- General Purpose Input/Output Controller -------------------------*/
N/**
N    @addtogroup GP General Purpose Input/Output Controller(GP)
N    Memory Mapped Structure for GP Controller
N@{ */
N
N
Ntypedef struct {
N
N    /**
N     * @var GPIO_T::PMD
N     * Offset: 0x00  Px I/O Mode Control
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |PMD0      |Port 0-5 I/O Pin [N] Mode Control
N     * |        |          |Determine each I/O mode of Px.n pin. Default mode is controlled by CIOINI (CONFIG0[10]).
N     * |        |          |00 = Px.n is in Input mode.
N     * |        |          |01 = Px.n is in Push-pull Output mode.
N     * |        |          |10 = Px.n is in Open-drain Output mode.
N     * |        |          |11 = Px.n is in Quasi-bidirectional mode.
N     * |        |          |Note1: x = 0~4, n = 0~7.
N     * |        |          |Note2:
N     * |        |          |P0_PMD[7:4] are reserved.
N     * |        |          |P1_PMD[15:12], [3:2] are reserved.
N     * |        |          |P2_PMD[15:14], [3:0] are reserved.
N     * |        |          |P3_PMD[15:14], [7:6] are reserved.
N     * |        |          |P4_PMD[11:0] are reserved.
N     * |        |          |P5_PMD[15:12] are reserved.
N     * |[3:2]   |PMD1      |Port 0-5 I/O Pin [N] Mode Control
N     * |        |          |Determine each I/O mode of Px.n pin. Default mode is controlled by CIOINI (CONFIG0[10]).
N     * |        |          |00 = Px.n is in Input mode.
N     * |        |          |01 = Px.n is in Push-pull Output mode.
N     * |        |          |10 = Px.n is in Open-drain Output mode.
N     * |        |          |11 = Px.n is in Quasi-bidirectional mode.
N     * |        |          |Note1: x = 0~4, n = 0~7.
N     * |        |          |Note2:
N     * |        |          |P0_PMD[7:4] are reserved.
N     * |        |          |P1_PMD[15:12], [3:2] are reserved.
N     * |        |          |P2_PMD[15:14], [3:0] are reserved.
N     * |        |          |P3_PMD[15:14], [7:6] are reserved.
N     * |        |          |P4_PMD[11:0] are reserved.
N     * |        |          |P5_PMD[15:12] are reserved.
N     * |[5:4]   |PMD2      |Port 0-5 I/O Pin [N] Mode Control
N     * |        |          |Determine each I/O mode of Px.n pin. Default mode is controlled by CIOINI (CONFIG0[10]).
N     * |        |          |00 = Px.n is in Input mode.
N     * |        |          |01 = Px.n is in Push-pull Output mode.
N     * |        |          |10 = Px.n is in Open-drain Output mode.
N     * |        |          |11 = Px.n is in Quasi-bidirectional mode.
N     * |        |          |Note1: x = 0~4, n = 0~7.
N     * |        |          |Note2:
N     * |        |          |P0_PMD[7:4] are reserved.
N     * |        |          |P1_PMD[15:12], [3:2] are reserved.
N     * |        |          |P2_PMD[15:14], [3:0] are reserved.
N     * |        |          |P3_PMD[15:14], [7:6] are reserved.
N     * |        |          |P4_PMD[11:0] are reserved.
N     * |        |          |P5_PMD[15:12] are reserved.
N     * |[7:6]   |PMD3      |Port 0-5 I/O Pin [N] Mode Control
N     * |        |          |Determine each I/O mode of Px.n pin. Default mode is controlled by CIOINI (CONFIG0[10]).
N     * |        |          |00 = Px.n is in Input mode.
N     * |        |          |01 = Px.n is in Push-pull Output mode.
N     * |        |          |10 = Px.n is in Open-drain Output mode.
N     * |        |          |11 = Px.n is in Quasi-bidirectional mode.
N     * |        |          |Note1: x = 0~4, n = 0~7.
N     * |        |          |Note2:
N     * |        |          |P0_PMD[7:4] are reserved.
N     * |        |          |P1_PMD[15:12], [3:2] are reserved.
N     * |        |          |P2_PMD[15:14], [3:0] are reserved.
N     * |        |          |P3_PMD[15:14], [7:6] are reserved.
N     * |        |          |P4_PMD[11:0] are reserved.
N     * |        |          |P5_PMD[15:12] are reserved.
N     * |[9:8]   |PMD4      |Port 0-5 I/O Pin [N] Mode Control
N     * |        |          |Determine each I/O mode of Px.n pin. Default mode is controlled by CIOINI (CONFIG0[10]).
N     * |        |          |00 = Px.n is in Input mode.
N     * |        |          |01 = Px.n is in Push-pull Output mode.
N     * |        |          |10 = Px.n is in Open-drain Output mode.
N     * |        |          |11 = Px.n is in Quasi-bidirectional mode.
N     * |        |          |Note1: x = 0~4, n = 0~7.
N     * |        |          |Note2:
N     * |        |          |P0_PMD[7:4] are reserved.
N     * |        |          |P1_PMD[15:12], [3:2] are reserved.
N     * |        |          |P2_PMD[15:14], [3:0] are reserved.
N     * |        |          |P3_PMD[15:14], [7:6] are reserved.
N     * |        |          |P4_PMD[11:0] are reserved.
N     * |        |          |P5_PMD[15:12] are reserved.
N     * |[11:10] |PMD5      |Port 0-5 I/O Pin [N] Mode Control
N     * |        |          |Determine each I/O mode of Px.n pin. Default mode is controlled by CIOINI (CONFIG0[10]).
N     * |        |          |00 = Px.n is in Input mode.
N     * |        |          |01 = Px.n is in Push-pull Output mode.
N     * |        |          |10 = Px.n is in Open-drain Output mode.
N     * |        |          |11 = Px.n is in Quasi-bidirectional mode.
N     * |        |          |Note1: x = 0~4, n = 0~7.
N     * |        |          |Note2:
N     * |        |          |P0_PMD[7:4] are reserved.
N     * |        |          |P1_PMD[15:12], [3:2] are reserved.
N     * |        |          |P2_PMD[15:14], [3:0] are reserved.
N     * |        |          |P3_PMD[15:14], [7:6] are reserved.
N     * |        |          |P4_PMD[11:0] are reserved.
N     * |        |          |P5_PMD[15:12] are reserved.
N     * |[13:12] |PMD6      |Port 0-5 I/O Pin [N] Mode Control
N     * |        |          |Determine each I/O mode of Px.n pin. Default mode is controlled by CIOINI (CONFIG0[10]).
N     * |        |          |00 = Px.n is in Input mode.
N     * |        |          |01 = Px.n is in Push-pull Output mode.
N     * |        |          |10 = Px.n is in Open-drain Output mode.
N     * |        |          |11 = Px.n is in Quasi-bidirectional mode.
N     * |        |          |Note1: x = 0~4, n = 0~7.
N     * |        |          |Note2:
N     * |        |          |P0_PMD[7:4] are reserved.
N     * |        |          |P1_PMD[15:12], [3:2] are reserved.
N     * |        |          |P2_PMD[15:14], [3:0] are reserved.
N     * |        |          |P3_PMD[15:14], [7:6] are reserved.
N     * |        |          |P4_PMD[11:0] are reserved.
N     * |        |          |P5_PMD[15:12] are reserved.
N     * |[15:14] |PMD7      |Port 0-5 I/O Pin [N] Mode Control
N     * |        |          |Determine each I/O mode of Px.n pin. Default mode is controlled by CIOINI (CONFIG0[10]).
N     * |        |          |00 = Px.n is in Input mode.
N     * |        |          |01 = Px.n is in Push-pull Output mode.
N     * |        |          |10 = Px.n is in Open-drain Output mode.
N     * |        |          |11 = Px.n is in Quasi-bidirectional mode.
N     * |        |          |Note1: x = 0~4, n = 0~7.
N     * |        |          |Note2:
N     * |        |          |P0_PMD[7:4] are reserved.
N     * |        |          |P1_PMD[15:12], [3:2] are reserved.
N     * |        |          |P2_PMD[15:14], [3:0] are reserved.
N     * |        |          |P3_PMD[15:14], [7:6] are reserved.
N     * |        |          |P4_PMD[11:0] are reserved.
N     * |        |          |P5_PMD[15:12] are reserved.
N     * @var GPIO_T::OFFD
N     * Offset: 0x04  Px Digital Input Path Disable Control
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[23:16] |OFFD      |Port 0-5 Pin [N] Digital Input Path Disable Control
N     * |        |          |0 = Px.n digital input path Enabled.
N     * |        |          |1 = Px.n digital input path Disabled (digital input tied to low).
N     * |        |          |Note: x = 0~5, n = 0~7.
N     * @var GPIO_T::DOUT
N     * Offset: 0x08  Px Data Output Value
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |DOUT      |Port 0-5 Pin [N] Output Value
N     * |        |          |Each of these bits controls the status of a Px.n pin when the Px.n is configured as Push-pull output, Open-drain output and Quasi-bidirectional mode.
N     * |        |          |0 = Px.n will drive Low if the Px.n pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
N     * |        |          |1 = Px.n will drive High if the Px.n pin is configured as Push-pull output or Quasi-bidirectional mode.
N     * |        |          |Note1: x = 0~5, n = 0~7.
N     * |        |          |Note2:
N     * |        |          |P0_DOUT[3:2] are reserved.
N     * |        |          |P1_DOUT[7:6], [1] are reserved.
N     * |        |          |P2_DOUT[7], [1:0] are reserved.
N     * |        |          |P3_DOUT[7], [3] are reserved.
N     * |        |          |P4_DOUT[5:0] are reserved.
N     * |        |          |P5_DOUT[7:6] are reserved.
N     * @var GPIO_T::DMASK
N     * Offset: 0x0C  Px Data Output Write Mask
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |DMASK     |Port 0-5 Pin [N] Data Output Write Mask
N     * |        |          |These bits are used to protect the corresponding Px_DOUT[n] bit.
N     * |        |          |When the DMASK[n] bit is set to 1, the corresponding Px_DOUT[n] bit is protected.
N     * |        |          |If the write signal is masked, writing data to the protect bit is ignored.
N     * |        |          |0 = Corresponding Px_DOUT[n] bit can be updated.
N     * |        |          |1 = Corresponding Px_DOUT[n] bit is protected.
N     * |        |          |Note1: x = 0~5, n = 0~7.
N     * |        |          |Note2: This function only protects the corresponding Px_DOUT[n] bit, and will not protect the corresponding Pxn_PDIO bit.
N     * |        |          |Note3:
N     * |        |          |P0_DMASK[3:2] are reserved.
N     * |        |          |P1_DMASK[7:6], [1] are reserved.
N     * |        |          |P2_DMASK[7], [1:0] are reserved.
N     * |        |          |P3_DMASK[7], [3] are reserved.
N     * |        |          |P4_DMASK[5:0] are reserved.
N     * |        |          |P5_DMASK[7:6] are reserved.
N     * @var GPIO_T::PIN
N     * Offset: 0x10  Px Pin Value
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |PIN       |Port 0-5 Pin [N] Pin Value
N     * |        |          |Each bit of the register reflects the actual status of the respective Px.n pin.
N     * |        |          |If the bit is 1, it indicates the corresponding pin status is high; else the pin status is low.
N     * |        |          |Note1: x = 0~5, n = 0~7.
N     * |        |          |Note2:
N     * |        |          |P0_PIN[3:2] are reserved.
N     * |        |          |P1_PIN[7:6], [1] are reserved.
N     * |        |          |P2_PIN[7], [1:0] are reserved.
N     * |        |          |P3_PIN[7], [3] are reserved.
N     * |        |          |P4_PIN[5:0] are reserved.
N     * |        |          |P5_PIN[7:6] are reserved.
N     * @var GPIO_T::DBEN
N     * Offset: 0x14  Px De-bounce Enable Control
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |DBEN      |Port 0-5 Pin [N] Input Signal De-bounce Enable Control
N     * |        |          |DBEN[n] bit is used to enable the de-bounce function for each corresponding bit.
N     * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt.
N     * |        |          |The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0].
N     * |        |          |0 = Px.n de-bounce function Disabled.
N     * |        |          |1 = Px.n de-bounce function Enabled.
N     * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N     * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N     * |        |          |Note1: x = 0~5, n = 0~7.
N     * |        |          |Note2: If Px.n pin is chosen as Power-down wake-up source, user should be disable the de-bounce function before entering Power-down mode to avoid the second interrupt event occurred after system woken up caused by the Px.n de-bounce function.
N     * |        |          |Note3:
N     * |        |          |P0_DBEN[3:2] are reserved.
N     * |        |          |P1_DBEN[7:6], [1] are reserved.
N     * |        |          |P2_DBEN[7], [1:0] are reserved.
N     * |        |          |P3_DBEN[7], [3] are reserved.
N     * |        |          |P4_DBEN[5:0] are reserved.
N     * |        |          |P5_DBEN[7:6] are reserved.
N     * @var GPIO_T::IMD
N     * Offset: 0x18  Px Interrupt Mode Control
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |IMD       |Port 0-5 Pin [N] Edge Or Level Detection Interrupt Mode Control
N     * |        |          |IMD[n] bit is used to control the triggered interrupt is by level trigger or by edge trigger.
N     * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
N     * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrupt.
N     * |        |          |0 = Edge trigger interrupt.
N     * |        |          |1 = Level trigger interrupt.
N     * |        |          |If pin is set as the level trigger interrupt, only one level can be set on the registers Px_IEN.
N     * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
N     * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N     * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N     * |        |          |Note1: x = 0~5, n = 0~7.
N     * |        |          |Note2:
N     * |        |          |P0_IMD[3:2] are reserved.
N     * |        |          |P1_IMD[7:6], [1] are reserved.
N     * |        |          |P2_IMD[7], [1:0] are reserved.
N     * |        |          |P3_IMD[7], [3] are reserved.
N     * |        |          |P4_IMD[5:0] are reserved.
N     * |        |          |P5_IMD[7:6] are reserved.
N     * @var GPIO_T::IEN
N     * Offset: 0x1C  Px Interrupt Enable Control
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |IF_EN     |Port 0-5 Pin [N] Interrupt Enabled By Input Falling Edge Or Input Level Low
N     * |        |          |IF_EN[n] is used to enable the interrupt for each of the corresponding input Px.n pin.
N     * |        |          |Set bit to 1 also enable the pin wake-up function.
N     * |        |          |When setting the IF_EB[n] bit to 1:
N     * |        |          |If the interrupt is level trigger (IMD[n] is 1), the input Px.n pin will generate the interrupt while this pin state is at low level.
N     * |        |          |If the interrupt is edge mode trigger (IMD[n] is 0), the input Px.n pin will generate the interrupt while this pin state changed from high to low.
N     * |        |          |0 = Px.n low level or high to low interrupt Disabled.
N     * |        |          |1 = Px.n low level or high to low interrupt Enabled.
N     * |        |          |Note1: x = 0~5, n = 0~7.
N     * |        |          |Note2:
N     * |        |          |P0_IEN[19:18], [3:2] are reserved.
N     * |        |          |P1_IEN[23:22], [17], [7:6], [1] are reserved.
N     * |        |          |P2_IEN[23], [17:16], [7], [1:0] are reserved.
N     * |        |          |P3_IEN[23], [19], [7], [3] are reserved.
N     * |        |          |P4_IEN[21:16], [5:0] are reserved.
N     * |        |          |P5_IEN[23:22], [7:6] are reserved.
N     * |[23:16] |IR_EN     |Port 0-5 Pin [N] Interrupt Enabled By Input Rising Edge Or Input Level High
N     * |        |          |IR_EN[n] bit is used to enable the interrupt for each of the corresponding input Px.n pin.
N     * |        |          |Set bit to 1 also enable the pin wake-up function.
N     * |        |          |When setting the IR_EN[n] bit to 1:
N     * |        |          |If the interrupt is level trigger (IMD[n] is 1), the input Px.n pin will generate the interrupt while this pin state is at high level.
N     * |        |          |If the interrupt is edge trigger (IMD[n] is 0), the input Px.n pin will generate the interrupt while this pin state changed from low to high.
N     * |        |          |0 = Px.n level high or low to high interrupt Disabled.
N     * |        |          |1 = Px.n level high or low to high interrupt Enabled.
N     * |        |          |Note: x = 0~5, n = 0~7.
N     * @var GPIO_T::ISRC
N     * Offset: 0x20  Px Interrupt Source Flag
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |ISRC      |Port 0-5 Pin [N] Interrupt Source Flag
N     * |        |          |Write :
N     * |        |          |0 = No action.
N     * |        |          |1 = Clear the corresponding pending interrupt.
N     * |        |          |Read :
N     * |        |          |0 = No interrupt at Px.n.
N     * |        |          |1 = Px.n generates an interrupt.
N     * |        |          |Note1: x = 0~5, n = 0~7.
N     * |        |          |Note2:
N     * |        |          |P0_ISRC[3:2] are reserved.
N     * |        |          |P1_ISRC[7:6], [1] are reserved.
N     * |        |          |P2_ISRC[7], [1:0] are reserved.
N     * |        |          |P3_ISRC[7], [3] are reserved.
N     * |        |          |P4_ISRC[5:0] are reserved.
N     * |        |          |P5_ISRC[7:6] are reserved.
N     */
N    __IO uint32_t PMD;           /* Offset: 0x00  Px I/O Mode Control                                                */
X    volatile uint32_t PMD;            
N    __IO uint32_t OFFD;          /* Offset: 0x04  Px Digital Input Path Disable Control                              */
X    volatile uint32_t OFFD;           
N    __IO uint32_t DOUT;          /* Offset: 0x08  Px Data Output Value                                               */
X    volatile uint32_t DOUT;           
N    __IO uint32_t DMASK;         /* Offset: 0x0C  Px Data Output Write Mask                                          */
X    volatile uint32_t DMASK;          
N    __I  uint32_t PIN;           /* Offset: 0x10  Px Pin Value                                                       */
X    volatile const  uint32_t PIN;            
N    __IO uint32_t DBEN;          /* Offset: 0x14  Px De-bounce Enable Control                                        */
X    volatile uint32_t DBEN;           
N    __IO uint32_t IMD;           /* Offset: 0x18  Px Interrupt Mode Control                                          */
X    volatile uint32_t IMD;            
N    __IO uint32_t IEN;           /* Offset: 0x1C  Px Interrupt Enable Control                                        */
X    volatile uint32_t IEN;            
N    __IO uint32_t ISRC;          /* Offset: 0x20  Px Interrupt Source Flag                                           */
X    volatile uint32_t ISRC;           
N} GPIO_T;
N
N/**
N  * @brief GPIO debounce register map
N  */
Ntypedef struct {
N    /**
N     * @var GPIO_DBNCECON_T::DBNCECON
N     * Offset: 0x180  Interrupt De-bounce Control
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |DBCLKSEL  |De-bounce Sampling Cycle Selection
N     * |        |          |0000 = Sample interrupt input once per 1 clock.
N     * |        |          |0001 = Sample interrupt input once per 2 clocks.
N     * |        |          |0010 = Sample interrupt input once per 4 clocks.
N     * |        |          |0011 = Sample interrupt input once per 8 clocks.
N     * |        |          |0100 = Sample interrupt input once per 16 clocks.
N     * |        |          |0101 = Sample interrupt input once per 32 clocks.
N     * |        |          |0110 = Sample interrupt input once per 64 clocks.
N     * |        |          |0111 = Sample interrupt input once per 128 clocks.
N     * |        |          |1000 = Sample interrupt input once per 256 clocks.
N     * |        |          |1001 = Sample interrupt input once per 2*256 clocks.
N     * |        |          |1010 = Sample interrupt input once per 4*256 clocks.
N     * |        |          |1011 = Sample interrupt input once per 8*256 clocks.
N     * |        |          |1100 = Sample interrupt input once per 16*256 clocks.
N     * |        |          |1101 = Sample interrupt input once per 32*256 clocks.
N     * |        |          |1110 = Sample interrupt input once per 64*256 clocks.
N     * |        |          |1111 = Sample interrupt input once per 128*256 clocks.
N     * |[4]     |DBCLKSRC  |De-bounce Counter Clock Source Selection
N     * |        |          |0 = De-bounce counter clock source is the HCLK.
N     * |        |          |1 = De-bounce counter clock source is the 10 kHz internal low speed oscillator.
N     * |[5]     |ICLK_ON   |Interrupt Clock On Mode
N     * |        |          |0 = Edge detection circuit is active only if I/O pin corresponding Px_IEN bit is set to 1.
N     * |        |          |1 = All I/O pins edge detection circuit is always active after reset.
N     * |        |          |Note: It is recommended to turn off this bit to save system power if no special application concern.
N     */
N    __IO uint32_t DBNCECON;      /* Offset: 0x00  Interrupt De-bounce Control                                       */
X    volatile uint32_t DBNCECON;       
N} GPIO_DBNCECON_T;
N
N
N
N/**
N    @addtogroup GP_CONST GP Bit Field Definition
N    Constant Definitions for GP Controller
N@{ */
N
N#define GPIO_PMD_PMD0_Pos                (0)                                               /*!< GPIO_T::PMD: PMD0 Position                  */
N#define GPIO_PMD_PMD0_Msk                (0x3ul << GPIO_PMD_PMD0_Pos)                      /*!< GPIO_T::PMD: PMD0 Mask                      */
N
N#define GPIO_PMD_PMD1_Pos                (2)                                               /*!< GPIO_T::PMD: PMD1 Position                  */
N#define GPIO_PMD_PMD1_Msk                (0x3ul << GPIO_PMD_PMD1_Pos)                      /*!< GPIO_T::PMD: PMD1 Mask                      */
N
N#define GPIO_PMD_PMD2_Pos                (4)                                               /*!< GPIO_T::PMD: PMD2 Position                  */
N#define GPIO_PMD_PMD2_Msk                (0x3ul << GPIO_PMD_PMD2_Pos)                      /*!< GPIO_T::PMD: PMD2 Mask                      */
N
N#define GPIO_PMD_PMD3_Pos                (6)                                               /*!< GPIO_T::PMD: PMD3 Position                  */
N#define GPIO_PMD_PMD3_Msk                (0x3ul << GPIO_PMD_PMD3_Pos)                      /*!< GPIO_T::PMD: PMD3 Mask                      */
N
N#define GPIO_PMD_PMD4_Pos                (8)                                               /*!< GPIO_T::PMD: PMD4 Position                  */
N#define GPIO_PMD_PMD4_Msk                (0x3ul << GPIO_PMD_PMD4_Pos)                      /*!< GPIO_T::PMD: PMD4 Mask                      */
N
N#define GPIO_PMD_PMD5_Pos                (10)                                              /*!< GPIO_T::PMD: PMD5 Position                  */
N#define GPIO_PMD_PMD5_Msk                (0x3ul << GPIO_PMD_PMD5_Pos)                      /*!< GPIO_T::PMD: PMD5 Mask                      */
N
N#define GPIO_PMD_PMD6_Pos                (12)                                              /*!< GPIO_T::PMD: PMD6 Position                  */
N#define GPIO_PMD_PMD6_Msk                (0x3ul << GPIO_PMD_PMD6_Pos)                      /*!< GPIO_T::PMD: PMD6 Mask                      */
N
N#define GPIO_PMD_PMD7_Pos                (14)                                              /*!< GPIO_T::PMD: PMD7 Position                  */
N#define GPIO_PMD_PMD7_Msk                (0x3ul << GPIO_PMD_PMD7_Pos)                      /*!< GPIO_T::PMD: PMD7 Mask                      */
N
N#define GPIO_OFFD_OFFD_Pos               (16)                                              /*!< GPIO_T::OFFD: OFFD Position                 */
N#define GPIO_OFFD_OFFD_Msk               (0xfful << GPIO_OFFD_OFFD_Pos)                    /*!< GPIO_T::OFFD: OFFD Mask                     */
N
N#define GPIO_DOUT_DOUT_Pos               (0)                                               /*!< GPIO_T::DOUT: DOUT Position                 */
N#define GPIO_DOUT_DOUT_Msk               (0xfful << GPIO_DOUT_DOUT_Pos)                    /*!< GPIO_T::DOUT: DOUT Mask                     */
N
N#define GPIO_DMASK_DMASK_Pos             (0)                                               /*!< GPIO_T::DMASK: DMASK Position               */
N#define GPIO_DMASK_DMASK_Msk             (0xfful << GPIO_DMASK_DMASK_Pos)                  /*!< GPIO_T::DMASK: DMASK Mask                   */
N
N#define GPIO_PIN_PIN_Pos                 (0)                                               /*!< GPIO_T::PIN: PIN Position                   */
N#define GPIO_PIN_PIN_Msk                 (0xfful << GPIO_PIN_PIN_Pos)                      /*!< GPIO_T::PIN: PIN Mask                       */
N
N#define GPIO_DBEN_DBEN_Pos               (0)                                               /*!< GPIO_T::DBEN: DBEN Position                 */
N#define GPIO_DBEN_DBEN_Msk               (0xfful << GPIO_DBEN_DBEN_Pos)                    /*!< GPIO_T::DBEN: DBEN Mask                     */
N
N#define GPIO_IMD_IMD_Pos                 (0)                                               /*!< GPIO_T::IMD: IMD Position                   */
N#define GPIO_IMD_IMD_Msk                 (0xfful << GPIO_IMD_IMD_Pos)                      /*!< GPIO_T::IMD: IMD Mask                       */
N
N#define GPIO_IEN_IF_EN_Pos               (0)                                               /*!< GPIO_T::IEN: IF_EN Position                 */
N#define GPIO_IEN_IF_EN_Msk               (0x1ul << GPIO_IEN_IF_EN_Pos)                     /*!< GPIO_T::IEN: IF_EN Mask                     */
N
N#define GPIO_IEN_IR_EN_Pos               (16)                                              /*!< GPIO_T::IEN: IR_EN Position                 */
N#define GPIO_IEN_IR_EN_Msk               (0xfful << GPIO_IEN_IR_EN_Pos)                    /*!< GPIO_T::IEN: IR_EN Mask                     */
N
N#define GPIO_ISRC_ISRC_Pos               (0)                                               /*!< GPIO_T::ISRC: ISRC Position                 */
N#define GPIO_ISRC_ISRC_Msk               (0xfful << GPIO_ISRC_ISRC_Pos)                    /*!< GPIO_T::ISRC: ISRC Mask                     */
N
N#define GPIO_DBNCECON_DBCLKSEL_Pos       (0)                                               /*!< GPIO_DBNCECON_T::DBNCECON: DBCLKSEL Position         */
N#define GPIO_DBNCECON_DBCLKSEL_Msk       (0xful << GPIO_DBNCECON_DBCLKSEL_Pos)             /*!< GPIO_DBNCECON_T::DBNCECON: DBCLKSEL Mask             */
N
N#define GPIO_DBNCECON_DBCLKSRC_Pos       (4)                                               /*!< GPIO_DBNCECON_T::DBNCECON: DBCLKSRC Position         */
N#define GPIO_DBNCECON_DBCLKSRC_Msk       (0x1ul << GPIO_DBNCECON_DBCLKSRC_Pos)             /*!< GPIO_DBNCECON_T::DBNCECON: DBCLKSRC Mask             */
N
N#define GPIO_DBNCECON_ICLK_ON_Pos        (5)                                               /*!< GPIO_DBNCECON_T::DBNCECON: ICLK_ON Position          */
N#define GPIO_DBNCECON_ICLK_ON_Msk        (0x1ul << GPIO_DBNCECON_ICLK_ON_Pos)              /*!< GPIO_DBNCECON_T::DBNCECON: ICLK_ON Mask              */
N
N/**@}*/ /* GP_CONST */
N/**@}*/ /* end of GP register group */
N
N
N/*---------------------- Inter-IC Bus Controller -------------------------*/
N/**
N    @addtogroup I2C Inter-IC Bus Controller(I2C)
N    Memory Mapped Structure for I2C Controller
N@{ */
N
N
Ntypedef struct {
N
N    /**
N     * @var I2C_T::I2CON
N     * Offset: 0x00  I2C Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2]     |AA        |Assert Acknowledge Control Bit
N     * |        |          |When AA=1 is prior to address or data received, an acknowledged (low level to SDA) will be returned during the acknowledge clock pulse on the SCL line when 1.) A slave is acknowledging the address sent from master, 2.) The receiver devices are acknowledging the data sent by transmitter.
N     * |        |          |When AA=0 prior to address or data received, a Not acknowledged (high level to SDA) will be returned during the acknowledge clock pulse on the SCL line.
N     * |[3]     |SI        |I2C Interrupt Flag
N     * |        |          |When a new I2C state is present in the I2CSTATUS register, the SI flag is set by hardware, and if bit EI (I2CON[7]) is set, the I2C interrupt is requested.
N     * |        |          |SI must be cleared by software.
N     * |        |          |Software can write 1 to clear this bit.
N     * |[4]     |STO       |I2C STOP Control Bit
N     * |        |          |In Master mode, setting STO to transmit a STOP condition to bus then I2C hardware will check the bus condition if a STOP condition is detected this bit will be cleared by hardware automatically.
N     * |        |          |In Slave mode, setting STO resets I2C hardware to the defined "not addressed" Slave mode.
N     * |        |          |This means it is NO LONGER in the Slave receiver mode to receive data from the master transmit device.
N     * |[5]     |STA       |I2C START Control Bit
N     * |        |          |Setting STA to logic 1 to enter Master mode.
N     * |        |          |I2C hardware sends a START or repeats the START condition to bus when the bus is free.
N     * |[6]     |ENS1      |I2C Controller Enable Control
N     * |        |          |0 = I2C Controller Disabled.
N     * |        |          |1 = I2C Controller Enabled.
N     * |        |          |Set to enable I2C serial function controller.
N     * |        |          |When ENS1=1 the I2C serial function enables.
N     * |        |          |The function of multi-function pin must be set to I2C first.
N     * |[7]     |EI        |Interrupt Enable Control
N     * |        |          |0 = I2C interrupt Disabled.
N     * |        |          |1 = I2C interrupt Enabled.
N     * @var I2C_T::I2CADDR0
N     * Offset: 0x04  I2C Slave Address Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |GC        |General Call Function
N     * |        |          |0 = General Call Function Disabled.
N     * |        |          |1 = General Call Function Enabled.
N     * |[7:1]   |I2CADDR   |I2C Address Bits
N     * |        |          |The content of this register is irrelevant when I2C is in Master mode.
N     * |        |          |In Slave mode, the seven most significant bits must be loaded with the MCU's own address.
N     * |        |          |The I2C hardware will react if either of the address is matched.
N     * @var I2C_T::I2CDAT
N     * Offset: 0x08  I2C DATA Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |I2CDAT    |I2C Data Bits
N     * |        |          |Bit [7:0] is located with the 8-bit transferred data of the I2C serial port.
N     * @var I2C_T::I2CSTATUS
N     * Offset: 0x0C  I2C Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |I2CSTATUS |I2C Status Bits
N     * |        |          |The three least significant bits are always 0.
N     * |        |          |The five most significant bits contain the status code.
N     * |        |          |There are 26 possible status codes.
N     * |        |          |When I2CSTATUS contains F8H, no serial interrupt is requested.
N     * |        |          |All the other I2CSTATUS values correspond to defined I2C states.
N     * |        |          |When each of these states is entered, a status interrupt is requested (SI = 1).
N     * |        |          |A valid status code is present in I2CSTATUS one cycle after SI is set by hardware and is still present one cycle after SI has been reset by software.
N     * |        |          |In addition, the states 00H stands for a Bus Error.
N     * |        |          |A Bus Error occurs when a START or STOP condition is present at an illegal position in the formation frame.
N     * |        |          |Examples of illegal position are during the serial transfer of an address byte, a data byte or an acknowledge bit.
N     * @var I2C_T::I2CLK
N     * Offset: 0x10  I2C Clock Divided Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |I2CLK     |I2C Clock Divided Bits
N     * |        |          |The I2C clock rate bits: Data Baud Rate of I2C = (system clock) / (4x (I2CLK+1)).
N     * |        |          |Note: The minimum value of I2CLK is 4.
N     * @var I2C_T::I2CTOC
N     * Offset: 0x14  I2C Time-Out Counter Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TIF       |Time-out Flag
N     * |        |          |This bit is set by hardware when I2C time-out happened and it can interrupt CPU if I2C interrupt enable bit (EI) is set to 1.
N     * |        |          |Note: Software can write 1 to clear this bit.
N     * |[1]     |DIV4      |Time-out Counter Input Clock Divided By 4
N     * |        |          |0 = Time-out counter input clock divided by 4 Disabled.
N     * |        |          |1 = Time-out counter input clock divided by 4 Enabled.
N     * |        |          |Note: When enabled, the time-out period is extended 4 times.
N     * |[2]     |ENTI      |Time-out Counter Enable Control
N     * |        |          |0 = Time-out counter Disabled.
N     * |        |          |1 = Time-out counter Enabled.
N     * |        |          |Note: When the 14-bit time-out counter is enabled, it will start counting when SI is clear.
N     * |        |          |Setting 1to the SI flag will reset counter and re-start up counting after SI is cleared.
N     * @var I2C_T::I2CADDR1
N     * Offset: 0x18  I2C Slave Address Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |GC        |General Call Function
N     * |        |          |0 = General Call Function Disabled.
N     * |        |          |1 = General Call Function Enabled.
N     * |[7:1]   |I2CADDR   |I2C Address Bits
N     * |        |          |The content of this register is irrelevant when I2C is in Master mode.
N     * |        |          |In Slave mode, the seven most significant bits must be loaded with the MCU's own address.
N     * |        |          |The I2C hardware will react if either of the address is matched.
N     * @var I2C_T::I2CADDR2
N     * Offset: 0x1C  I2C Slave Address Register 2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |GC        |General Call Function
N     * |        |          |0 = General Call Function Disabled.
N     * |        |          |1 = General Call Function Enabled.
N     * |[7:1]   |I2CADDR   |I2C Address Bits
N     * |        |          |The content of this register is irrelevant when I2C is in Master mode.
N     * |        |          |In Slave mode, the seven most significant bits must be loaded with the MCU's own address.
N     * |        |          |The I2C hardware will react if either of the address is matched.
N     * @var I2C_T::I2CADDR3
N     * Offset: 0x20  I2C Slave Address Register 3
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |GC        |General Call Function
N     * |        |          |0 = General Call Function Disabled.
N     * |        |          |1 = General Call Function Enabled.
N     * |[7:1]   |I2CADDR   |I2C Address Bits
N     * |        |          |The content of this register is irrelevant when I2C is in Master mode.
N     * |        |          |In Slave mode, the seven most significant bits must be loaded with the MCU's own address.
N     * |        |          |The I2C hardware will react if either of the address is matched.
N     * @var I2C_T::I2CADM0
N     * Offset: 0x24  I2C Slave Address Mask Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:1]   |I2CADM    |I2C Address Mask Bits
N     * |        |          |0 = I2C address mask Disabled (the received corresponding register bit should be exactly the same as address register).
N     * |        |          |1 = I2C address mask Enabled (the received corresponding address bit is "Don't care").
N     * @var I2C_T::I2CADM1
N     * Offset: 0x28  I2C Slave Address Mask Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:1]   |I2CADM    |I2C Address Mask Bits
N     * |        |          |0 = I2C address mask Disabled (the received corresponding register bit should be exactly the same as address register).
N     * |        |          |1 = I2C address mask Enabled (the received corresponding address bit is "Don't care").
N     * @var I2C_T::I2CADM2
N     * Offset: 0x2C  I2C Slave Address Mask Register 2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:1]   |I2CADM    |I2C Address Mask Bits
N     * |        |          |0 = I2C address mask Disabled (the received corresponding register bit should be exactly the same as address register).
N     * |        |          |1 = I2C address mask Enabled (the received corresponding address bit is "Don't care").
N     * @var I2C_T::I2CADM3
N     * Offset: 0x30  I2C Slave Address Mask Register 3
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:1]   |I2CADM    |I2C Address Mask Bits
N     * |        |          |0 = I2C address mask Disabled (the received corresponding register bit should be exactly the same as address register).
N     * |        |          |1 = I2C address mask Enabled (the received corresponding address bit is "Don't care").
N     * @var I2C_T::I2CON2
N     * Offset: 0x3C  I2C Control Register 2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |WAKEUPEN  |Wake-up Enable Control
N     * |        |          |0 = I2C wake-up function Disabled.
N     * |        |          |1 = I2C wake-up function Enabled.
N     * |        |          |The system can be wake-up by I2C bus when the system is set into power mode and the received data matched one of the addresses in Address Register.
N     * |[1]     |TWOFF_EN  |TWO LEVEL FIFO Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Set to enable the two-level FIFO for I2C transmitted or received buffer.
N     * |        |          |It is used to improve the performance of the I2C bus.
N     * |        |          |If this bit is set = 1, the control bit of STA for repeat start or STO bit should be set after the current SI is clear.
N     * |        |          |For example: if there are 4 data shall be transmitted and then stop it.
N     * |        |          |The STO bit shall be set after the 3rd data's SI event being clear.
N     * |        |          |In this time, the 4th data can be transmitted and the I2C stop after the 4th data transmission done.
N     * |[2]     |NOSTRETCH |NO STRETCH The I2C BUS
N     * |        |          |0 = The I2C SCL bus is stretched by hardware if the SI is not cleared in master mode.
N     * |        |          |1 = The I2C SCL bus is not stretched by hardware if the SI is not cleared in master mode.
N     * |[3]     |OVER_INTEN|I2C OVER RUN Interrupt Control Bit
N     * |        |          |Setting OVER_INTEN to enable will send a interrupt to system when the TWOFF bit is enabled and there is over run event in received FIFO.
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[4]     |UNDER_INTEN|I2C UNDER RUN Interrupt Control Bit
N     * |        |          |Setting UNDER_INTEN to enable will send a interrupt to system when the TWOFF bit is enabled and there is under run event happened in transmitted FIFO.
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * @var I2C_T::I2CSTATUS2
N     * Offset: 0x40  I2C Status Register 2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |WAKEUP    |I2C Wake-up Interrupt Flag
N     * |        |          |When chip is woken up from Power-Down mode by I2C, this bit is set to 1.
N     * |        |          |Software can write 1 to clear this bit.
N     * |[1]     |FULL      |I2C TWO LEVEL FIFO FULL
N     * |        |          |This bit indicates TX FIFO full or not when the TWOFF_EN = 1.
N     * |[2]     |EMPTY     |I2C TWO LEVEL FIFO EMPTY
N     * |        |          |This bit indicates RX FIFO empty or not when the TWOFF_EN = 1.
N     * |[3]     |OVERUN    |I2C OVER RUN Status Bit
N     * |        |          |This bit indicates the received FIFO is over run when the TWOFF_EN = 1.
N     * |[4]     |UNDERUN   |I2C UNDER RUN Status Bit
N     * |        |          |This bit indicates the transmitted FIFO is under run when the TWOFF_EN = 1.
N     */
N
N    __IO uint32_t I2CON;         /* Offset: 0x00  I2C Control Register                                               */
X    volatile uint32_t I2CON;          
N    __IO uint32_t I2CADDR0;      /* Offset: 0x04  I2C Slave Address Register 0                                       */
X    volatile uint32_t I2CADDR0;       
N    __IO uint32_t I2CDAT;        /* Offset: 0x08  I2C DATA Register                                                  */
X    volatile uint32_t I2CDAT;         
N    __I  uint32_t I2CSTATUS;     /* Offset: 0x0C  I2C Status Register                                                */
X    volatile const  uint32_t I2CSTATUS;      
N    __IO uint32_t I2CLK;         /* Offset: 0x10  I2C Clock Divided Register                                         */
X    volatile uint32_t I2CLK;          
N    __IO uint32_t I2CTOC;        /* Offset: 0x14  I2C Time-Out Counter Register                                      */
X    volatile uint32_t I2CTOC;         
N    __IO uint32_t I2CADDR1;      /* Offset: 0x18  I2C Slave Address Register 1                                       */
X    volatile uint32_t I2CADDR1;       
N    __IO uint32_t I2CADDR2;      /* Offset: 0x1C  I2C Slave Address Register 2                                       */
X    volatile uint32_t I2CADDR2;       
N    __IO uint32_t I2CADDR3;      /* Offset: 0x20  I2C Slave Address Register 3                                       */
X    volatile uint32_t I2CADDR3;       
N    __IO uint32_t I2CADM0;       /* Offset: 0x24  I2C Slave Address Mask Register 0                                  */
X    volatile uint32_t I2CADM0;        
N    __IO uint32_t I2CADM1;       /* Offset: 0x28  I2C Slave Address Mask Register 1                                  */
X    volatile uint32_t I2CADM1;        
N    __IO uint32_t I2CADM2;       /* Offset: 0x2C  I2C Slave Address Mask Register 2                                  */
X    volatile uint32_t I2CADM2;        
N    __IO uint32_t I2CADM3;       /* Offset: 0x30  I2C Slave Address Mask Register 3                                  */
X    volatile uint32_t I2CADM3;        
N    /// @cond HIDDEN_SYMBOLS
N    __I  uint32_t RESERVE0[2];
X    volatile const  uint32_t RESERVE0[2];
N    /// @endcond //HIDDEN_SYMBOLS
N    __IO uint32_t I2CON2;        /* Offset: 0x3C  I2C Control Register 2                                             */
X    volatile uint32_t I2CON2;         
N    __IO uint32_t I2CSTATUS2;    /* Offset: 0x40  I2C Status Register 2                                              */
X    volatile uint32_t I2CSTATUS2;     
N
N} I2C_T;
N
N
N
N/**
N    @addtogroup I2C_CONST I2C Bit Field Definition
N    Constant Definitions for I2C Controller
N@{ */
N
N#define I2C_I2CON_AA_Pos                 (2)                                               /*!< I2C_T::I2CON: AA Position                 */
N#define I2C_I2CON_AA_Msk                 (0x1ul << I2C_I2CON_AA_Pos)                       /*!< I2C_T::I2CON: AA Mask                     */
N
N#define I2C_I2CON_SI_Pos                 (3)                                               /*!< I2C_T::I2CON: SI Position                 */
N#define I2C_I2CON_SI_Msk                 (0x1ul << I2C_I2CON_SI_Pos)                       /*!< I2C_T::I2CON: SI Mask                     */
N
N#define I2C_I2CON_STO_Pos                (4)                                               /*!< I2C_T::I2CON: STO Position                */
N#define I2C_I2CON_STO_Msk                (0x1ul << I2C_I2CON_STO_Pos)                      /*!< I2C_T::I2CON: STO Mask                    */
N
N#define I2C_I2CON_STA_Pos                (5)                                               /*!< I2C_T::I2CON: STA Position                */
N#define I2C_I2CON_STA_Msk                (0x1ul << I2C_I2CON_STA_Pos)                      /*!< I2C_T::I2CON: STA Mask                    */
N
N#define I2C_I2CON_ENSI_Pos               (6)                                               /*!< I2C_T::I2CON: ENSI Position               */
N#define I2C_I2CON_ENSI_Msk               (0x1ul << I2C_I2CON_ENSI_Pos)                     /*!< I2C_T::I2CON: ENSI Mask                   */
N
N#define I2C_I2CON_EI_Pos                 (7)                                               /*!< I2C_T::I2CON: EI Position                 */
N#define I2C_I2CON_EI_Msk                 (0x1ul << I2C_I2CON_EI_Pos)                       /*!< I2C_T::I2CON: EI Mask                     */
N
N#define I2C_I2CADDR_GC_Pos               (0)                                               /*!< I2C_T::I2CADDR0: GC Position               */
N#define I2C_I2CADDR_GC_Msk               (0x1ul << I2C_I2CADDR_GC_Pos)                     /*!< I2C_T::I2CADDR0: GC Mask                   */
N
N#define I2C_I2CADDR_I2CADDR_Pos          (1)                                               /*!< I2C_T::I2CADDR0: I2CADDR Position          */
N#define I2C_I2CADDR_I2CADDR_Msk          (0x7ful << I2C_I2CADDR_I2CADDR_Pos)               /*!< I2C_T::I2CADDR0: I2CADDR Mask              */
N
N#define I2C_I2CDAT_I2CDAT_Pos            (0)                                               /*!< I2C_T::I2CDAT: I2CDAT Position            */
N#define I2C_I2CDAT_I2CDAT_Msk            (0xfful << I2C_I2CDAT_I2CDAT_Pos)                 /*!< I2C_T::I2CDAT: I2CDAT Mask                */
N
N#define I2C_I2CSTATUS_I2CSTATUS_Pos      (0)                                               /*!< I2C_T::I2CSTATUS: I2CSTATUS Position      */
N#define I2C_I2CSTATUS_I2CSTATUS_Msk      (0xfful << I2C_I2CSTATUS_I2CSTATUS_Pos)           /*!< I2C_T::I2CSTATUS: I2CSTATUS Mask          */
N
N#define I2C_I2CLK_I2CLK_Pos              (0)                                               /*!< I2C_T::I2CLK: I2CLK Position              */
N#define I2C_I2CLK_I2CLK_Msk              (0xfful << I2C_I2CLK_I2CLK_Pos)                   /*!< I2C_T::I2CLK: I2CLK Mask                  */
N
N#define I2C_I2CTOC_TIF_Pos               (0)                                               /*!< I2C_T::I2CTOC: TIF Position               */
N#define I2C_I2CTOC_TIF_Msk               (0x1ul << I2C_I2CTOC_TIF_Pos)                     /*!< I2C_T::I2CTOC: TIF Mask                   */
N
N#define I2C_I2CTOC_DIV4_Pos              (1)                                               /*!< I2C_T::I2CTOC: DIV4 Position              */
N#define I2C_I2CTOC_DIV4_Msk              (0x1ul << I2C_I2CTOC_DIV4_Pos)                    /*!< I2C_T::I2CTOC: DIV4 Mask                  */
N
N#define I2C_I2CTOC_ENTI_Pos              (2)                                               /*!< I2C_T::I2CTOC: ENTI Position              */
N#define I2C_I2CTOC_ENTI_Msk              (0x1ul << I2C_I2CTOC_ENTI_Pos)                    /*!< I2C_T::I2CTOC: ENTI Mask                  */
N
N#define I2C_I2CADM_I2CADM_Pos            (1)                                               /*!< I2C_T::I2CADM0: I2CADM Position            */
N#define I2C_I2CADM_I2CADM_Msk            (0x7ful << I2C_I2CADM_I2CADM_Pos)                 /*!< I2C_T::I2CADM0: I2CADM Mask                */
N
N#define I2C_I2CON2_WKUPEN_Pos            (0)                                               /*!< I2C_T::I2CON2: WKUPEN Position            */
N#define I2C_I2CON2_WKUPEN_Msk            (0x1ul << I2C_I2CON2_WKUPEN_Pos)                  /*!< I2C_T::I2CON2: WKUPEN Mask                */
N
N#define I2C_I2CON2_TWOFF_EN_Pos          (1)                                               /*!< I2C_T::I2CON2: TWOFF_EN Position          */
N#define I2C_I2CON2_TWOFF_EN_Msk          (0x1ul << I2C_I2CON2_TWOFF_EN_Pos)                /*!< I2C_T::I2CON2: TWOFF_EN Mask              */
N
N#define I2C_I2CON2_NOSTRETCH_Pos         (2)                                               /*!< I2C_T::I2CON2: NOSTRETCH Position         */
N#define I2C_I2CON2_NOSTRETCH_Msk         (0x1ul << I2C_I2CON2_NOSTRETCH_Pos)               /*!< I2C_T::I2CON2: NOSTRETCH Mask             */
N
N#define I2C_I2CON2_OVER_INTEN_Pos        (3)                                               /*!< I2C_T::I2CON2: OVER_INTEN Position        */
N#define I2C_I2CON2_OVER_INTEN_Msk        (0x1ul << I2C_I2CON2_OVER_INTEN_Pos)              /*!< I2C_T::I2CON2: OVER_INTEN Mask            */
N
N#define I2C_I2CON2_UNDER_INTEN_Pos       (4)                                               /*!< I2C_T::I2CON2: UNDER_INTEN Position       */
N#define I2C_I2CON2_UNDER_INTEN_Msk       (0x1ul << I2C_I2CON2_UNDER_INTEN_Pos)             /*!< I2C_T::I2CON2: UNDER_INTEN Mask           */
N
N#define I2C_I2CSTATUS2_WAKEUP_Pos        (0)                                               /*!< I2C_T::I2CSTATUS2: WAKEUP Position        */
N#define I2C_I2CSTATUS2_WAKEUP_Msk        (0x1ul << I2C_I2CSTATUS2_WAKEUP_Pos)              /*!< I2C_T::I2CSTATUS2: WAKEUP Mask            */
N
N#define I2C_I2CSTATUS2_FULL_Pos          (1)                                               /*!< I2C_T::I2CSTATUS2: FULL Position          */
N#define I2C_I2CSTATUS2_FULL_Msk          (0x1ul << I2C_I2CSTATUS2_FULL_Pos)                /*!< I2C_T::I2CSTATUS2: FULL Mask              */
N
N#define I2C_I2CSTATUS2_EMPTY_Pos         (2)                                               /*!< I2C_T::I2CSTATUS2: EMPTY Position         */
N#define I2C_I2CSTATUS2_EMPTY_Msk         (0x1ul << I2C_I2CSTATUS2_EMPTY_Pos)               /*!< I2C_T::I2CSTATUS2: EMPTY Mask             */
N
N#define I2C_I2CSTATUS2_OVERUN_Pos        (3)                                               /*!< I2C_T::I2CSTATUS2: OVERUN Position        */
N#define I2C_I2CSTATUS2_OVERUN_Msk        (0x1ul << I2C_I2CSTATUS2_OVERUN_Pos)              /*!< I2C_T::I2CSTATUS2: OVERUN Mask            */
N
N#define I2C_I2CSTATUS2_UNDERUN_Pos       (4)                                               /*!< I2C_T::I2CSTATUS2: UNDERUN Position       */
N#define I2C_I2CSTATUS2_UNDERUN_Msk       (0x1ul << I2C_I2CSTATUS2_UNDERUN_Pos)             /*!< I2C_T::I2CSTATUS2: UNDERUN Mask           */
N
N/**@}*/ /* I2C_CONST */
N/**@}*/ /* end of I2C register group */
N
N
N/*---------------------- INT Controller -------------------------*/
N/**
N    @addtogroup INT Interrupt Controller (INT)
N    Memory Mapped Structure for INT Controller
N@{ */
N
N
N
Ntypedef struct {
N
N    /**
N     * @var INT_T::SRC0
N     * Offset: 0x00  IRQ0 (BOD) Interrupt Source Identity
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |INT_SRC   |Interrupt Source
N     * |        |          |Define the interrupt sources for interrupt event.
N     * @var INT_T::SRC1
N     * Offset: 0x04  IRQ1 (WDT) Interrupt Source Identity
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |INT_SRC   |Interrupt Source
N     * |        |          |Define the interrupt sources for interrupt event.
N     * @var INT_T::SRC2
N     * Offset: 0x08  IRQ2 (EINT0) Interrupt Source Identity
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |INT_SRC   |Interrupt Source
N     * |        |          |Define the interrupt sources for interrupt event.
N     * @var INT_T::SRC3
N     * Offset: 0x0C  IRQ3 (EINT1) Interrupt Source Identity
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |INT_SRC   |Interrupt Source
N     * |        |          |Define the interrupt sources for interrupt event.
N     * @var INT_T::SRC4
N     * Offset: 0x10  IRQ4 (GP0/1) Interrupt Source Identity
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |INT_SRC   |Interrupt Source
N     * |        |          |Define the interrupt sources for interrupt event.
N     * @var INT_T::SRC5
N     * Offset: 0x14  IRQ5 (GP2/3/4) Interrupt Source Identity
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |INT_SRC   |Interrupt Source
N     * |        |          |Define the interrupt sources for interrupt event.
N     * @var INT_T::SRC6
N     * Offset: 0x18  IRQ6 (PWM) Interrupt Source Identity
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |INT_SRC   |Interrupt Source
N     * |        |          |Define the interrupt sources for interrupt event.
N     * @var INT_T::SRC7
N     * Offset: 0x1C  IRQ7 (BRAKE) Interrupt Source Identity
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |INT_SRC   |Interrupt Source
N     * |        |          |Define the interrupt sources for interrupt event.
N     * @var INT_T::SRC8
N     * Offset: 0x20  IRQ8 (TMR0) Interrupt Source Identity
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |INT_SRC   |Interrupt Source
N     * |        |          |Define the interrupt sources for interrupt event.
N     * @var INT_T::SRC9
N     * Offset: 0x24  IRQ9 (TMR1) Interrupt Source Identity
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |INT_SRC   |Interrupt Source
N     * |        |          |Define the interrupt sources for interrupt event.
N     * @var INT_T::SRC12
N     * Offset: 0x30  IRQ12 (UART) Interrupt Source Identity
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |INT_SRC   |Interrupt Source
N     * |        |          |Define the interrupt sources for interrupt event.
N     * @var INT_T::SRC14
N     * Offset: 0x38  IRQ14 (SPI) Interrupt Source Identity
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |INT_SRC   |Interrupt Source
N     * |        |          |Define the interrupt sources for interrupt event.
N     * @var INT_T::SRC16
N     * Offset: 0x40  IRQ16 (GP5) Interrupt Source Identity
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |INT_SRC   |Interrupt Source
N     * |        |          |Define the interrupt sources for interrupt event.
N     * @var INT_T::SRC17
N     * Offset: 0x44  IRQ17 (HIRC trim) Interrupt Source Identity
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |INT_SRC   |Interrupt Source
N     * |        |          |Define the interrupt sources for interrupt event.
N     * @var INT_T::SRC18
N     * Offset: 0x48  IRQ18 (I2C) Interrupt Source Identity
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |INT_SRC   |Interrupt Source
N     * |        |          |Define the interrupt sources for interrupt event.
N     * @var INT_T::SRC25
N     * Offset: 0x64  IRQ25 (ACMP) Interrupt Source Identity
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |INT_SRC   |Interrupt Source
N     * |        |          |Define the interrupt sources for interrupt event.
N     * @var INT_T::SRC28
N     * Offset: 0x70  IRQ28 (PWRWU) Interrupt Source Identity
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |INT_SRC   |Interrupt Source
N     * |        |          |Define the interrupt sources for interrupt event.
N     * @var INT_T::SRC29
N     * Offset: 0x74  IRQ29 (ADC) Interrupt Source Identity
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |INT_SRC   |Interrupt Source
N     * |        |          |Define the interrupt sources for interrupt event.
N     * @var INT_T::NMICON
N     * Offset: 0x80  NMI Source Interrupt Select Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[4:0]   |NMI_SEL   |NMI Interrupt Source Selection
N     * |        |          |The NMI interrupt to Cortex-M0 can be selected from one of the peripheral interrupt by setting NMI_SEL.
N     * |[8]     |NMI_SEL_EN|NMI Interrupt Enable Control (Write Protect)
N     * |        |          |0 = NMI interrupt Disabled.
N     * |        |          |1 = NMI interrupt Enabled.
N     * |        |          |Note: This bit is the protected bit, and programming it needs to write 0x59, 0x16, and 0x88 to address 0x5000_0100 to disable register protection.
N     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
N     * @var INT_T::MCUIRQ
N     * Offset: 0x84  MCU IRQ Number Identity Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |MCU_IRQ   |MCU IRQ Source
N     * |        |          |The MCU_IRQ collects all the interrupts from the peripherals and generates the synchronous interrupt to Cortex-M0 core.
N     * |        |          |This modes to generate interrupt to Cortex-M0 - the normal mode.
N     * |        |          |The MCU_IRQ collects all interrupts from each peripheral and synchronizes them then interrupts the Cortex-M0.
N     * |        |          |When the MCU_IRQ[n] is 0, setting MCU_IRQ[n] to 1 will generate an interrupt to Cortex-M0 NVIC[n].
N     * |        |          |When the MCU_IRQ[n] is 1 (mean an interrupt is assert), setting 1 to the MCU_bit[n] will clear the interrupt and setting MCU_IRQ[n] 0 has no effect.
N     */
N
N
N    __I  uint32_t SRC0;           /* Offset: 0x00  IRQ0 (BOD) Interrupt Source Identity                               */
X    volatile const  uint32_t SRC0;            
N    __I  uint32_t SRC1;           /* Offset: 0x04  IRQ1 (WDT) Interrupt Source Identity                               */
X    volatile const  uint32_t SRC1;            
N    __I  uint32_t SRC2;           /* Offset: 0x08  IRQ2 (EINT0) Interrupt Source Identity                             */
X    volatile const  uint32_t SRC2;            
N    __I  uint32_t SRC3;           /* Offset: 0x0C  IRQ3 (EINT1) Interrupt Source Identity                             */
X    volatile const  uint32_t SRC3;            
N    __I  uint32_t SRC4;           /* Offset: 0x10  IRQ4 (GP0/1) Interrupt Source Identity                             */
X    volatile const  uint32_t SRC4;            
N    __I  uint32_t SRC5;           /* Offset: 0x14  IRQ5 (GP2/3/4) Interrupt Source Identity                           */
X    volatile const  uint32_t SRC5;            
N    __I  uint32_t SRC6;           /* Offset: 0x18  IRQ6 (PWM) Interrupt Source Identity                               */
X    volatile const  uint32_t SRC6;            
N    __I  uint32_t SRC7;           /* Offset: 0x1C  IRQ7 (BRAKE) Interrupt Source Identity                             */
X    volatile const  uint32_t SRC7;            
N    __I  uint32_t SRC8;           /* Offset: 0x20  IRQ8 (TMR0) Interrupt Source Identity                              */
X    volatile const  uint32_t SRC8;            
N    __I  uint32_t SRC9;           /* Offset: 0x24  IRQ9 (TMR1) Interrupt Source Identity                              */
X    volatile const  uint32_t SRC9;            
N    /// @cond HIDDEN_SYMBOLS
N    __I  uint32_t RESERVED0[2];
X    volatile const  uint32_t RESERVED0[2];
N    /// @endcond //HIDDEN_SYMBOLS
N    __I  uint32_t SRC12;           /* Offset: 0x30  IRQ12 (UART) Interrupt Source Identity                            */
X    volatile const  uint32_t SRC12;            
N    /// @cond HIDDEN_SYMBOLS
N    __I  uint32_t RESERVED1;
X    volatile const  uint32_t RESERVED1;
N    /// @endcond //HIDDEN_SYMBOLS
N    __I  uint32_t SRC14;           /* Offset: 0x38  IRQ14 (SPI) Interrupt Source Identity                             */
X    volatile const  uint32_t SRC14;            
N    /// @cond HIDDEN_SYMBOLS
N    __I  uint32_t RESERVED2;
X    volatile const  uint32_t RESERVED2;
N    /// @endcond //HIDDEN_SYMBOLS
N    __I  uint32_t SRC16;           /* Offset: 0x40  IRQ16 (GP5) Interrupt Source Identity                             */
X    volatile const  uint32_t SRC16;            
N    __I  uint32_t SRC17;           /* Offset: 0x44  IRQ17 (HIRC trim) Interrupt Source Identity                       */
X    volatile const  uint32_t SRC17;            
N    __I  uint32_t SRC18;           /* Offset: 0x48  IRQ18 (I2C) Interrupt Source Identity                             */
X    volatile const  uint32_t SRC18;            
N    /// @cond HIDDEN_SYMBOLS
N    __I  uint32_t RESERVED3[6];
X    volatile const  uint32_t RESERVED3[6];
N    /// @endcond //HIDDEN_SYMBOLS
N    __I  uint32_t SRC25;           /* Offset: 0x64  IRQ25 (ACMP) Interrupt Source Identity                            */
X    volatile const  uint32_t SRC25;            
N    /// @cond HIDDEN_SYMBOLS
N    __I  uint32_t RESERVED4[2];
X    volatile const  uint32_t RESERVED4[2];
N    /// @endcond //HIDDEN_SYMBOLS
N    __I  uint32_t SRC28;           /* Offset: 0x70  IRQ28 (PWRWU) Interrupt Source Identity                           */
X    volatile const  uint32_t SRC28;            
N    __I  uint32_t SRC29;           /* Offset: 0x74  IRQ29 (ADC) Interrupt Source Identity                             */
X    volatile const  uint32_t SRC29;            
N    /// @cond HIDDEN_SYMBOLS
N    __I  uint32_t RESERVED5[2];
X    volatile const  uint32_t RESERVED5[2];
N    /// @endcond //HIDDEN_SYMBOLS
N    __IO uint32_t NMICON;          /* Offset: 0x80  NMI Source Interrupt Select Control Register                      */
X    volatile uint32_t NMICON;           
N    __IO uint32_t MCUIRQ;          /* Offset: 0x84  MCU IRQ Number Identity Register                                  */
X    volatile uint32_t MCUIRQ;           
N
N} INT_T;
N
N
N
N/**
N    @addtogroup INT_CONST INT Bit Field Definition
N    Constant Definitions for INT Controller
N@{ */
N
N#define INT_SRC_INT_SRC_Pos              (0)                                               /*!< INT_T::SRC0: INT_SRC Position              */
N#define INT_SRC_INT_SRC_Msk              (0x7ul << INT_SRC_INT_SRC_Pos)                    /*!< INT_T::SRC0: INT_SRC Mask                  */
N
N#define INT_CON_NMI_SEL_Pos              (0)                                               /*!< INT_T::NMICON: NMI_SEL Position              */
N#define INT_CON_NMI_SEL_Msk              (0x1ful << INT_CON_NMI_SEL_Pos)                   /*!< INT_T::NMICON: NMI_SEL Mask                  */
N
N#define INT_CON_NMI_SEL_EN_Pos           (8)                                               /*!< INT_T::NMICON: NMI_SEL_EN Position           */
N#define INT_CON_NMI_SEL_EN_Msk           (0x1ul << INT_CON_NMI_SEL_EN_Pos)                 /*!< INT_T::NMICON: NMI_SEL_EN Mask               */
N
N#define INT_IRQ_MCU_IRQ_Pos              (0)                                               /*!< INT_T::MCUIRQ: MCU_IRQ Position              */
N#define INT_IRQ_MCU_IRQ_Msk              (0xfffffffful << INT_IRQ_MCU_IRQ_Pos)             /*!< INT_T::MCUIRQ: MCU_IRQ Mask                  */
N
N/**@}*/ /* INT_CONST */
N/**@}*/ /* end of INT register group */
N
N
N/*---------------------- Pulse Width Modulation Controller -------------------------*/
N/**
N    @addtogroup PWM Pulse Width Modulation Controller(PWM)
N    Memory Mapped Structure for PWM Controller
N@{ */
N
N
Ntypedef struct {
N
N    /**
N     * @var PWM_T::PPR
N     * Offset: 0x00  PWM Pre-scale Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |CP01      |Clock Prescaler 0 For PWM Counter 0 And 1
N     * |        |          |Clock input is divided by (CP01 + 1) before it is fed to the corresponding PWM counter.
N     * |        |          |If CP01 = 0, the clock prescaler 0 output clock will be stopped.
N     * |        |          |So the corresponding PWM counter will also be stopped.
N     * |[15:8]  |CP23      |Clock Prescaler 2 For PWM Counter 2 And 3
N     * |        |          |Clock input is divided by (CP23 + 1) before it is fed to the corresponding PWM counter.
N     * |        |          |If CP23 = 0, the clock prescaler 2 output clock will be stopped.
N     * |        |          |So the corresponding PWM counter will also be stopped.
N     * |[23:16] |CP45      |Clock Prescaler 4 For PWM Counter 4 And 5
N     * |        |          |Clock input is divided by (CP45 + 1) before it is fed to the corresponding PWM counter.
N     * |        |          |If CP45 = 0, the clock prescaler 4 output clock will be stopped.
N     * |        |          |So the corresponding PWM counter will also be stopped.
N     * @var PWM_T::CSR
N     * Offset: 0x04  PWM Clock Select Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |CSR0      |Timer 0 Clock Source Selection
N     * |        |          |Select clock input for PWM timer.
N     * |        |          |(Table is the same as CSR5.)
N     * |[6:4]   |CSR1      |Timer 1 Clock Source Selection
N     * |        |          |Select clock input for PWM timer.
N     * |        |          |(Table is the same as CSR5.)
N     * |[10:8]  |CSR2      |Timer 2 Clock Source Selection
N     * |        |          |Select clock input for PWM timer.
N     * |        |          |(Table is the same as CSR5.)
N     * |[14:12] |CSR3      |Timer 3 Clock Source Selection
N     * |        |          |Select clock input for PWM timer.
N     * |        |          |(Table is the same as CSR5.)
N     * |[18:16] |CSR4      |Timer 4 Clock Source Selection
N     * |        |          |Select clock input for PWM timer.
N     * |        |          |(Table is the same as CSR5.)
N     * |[22:20] |CSR5      |Timer 5 Clock Source Selection
N     * |        |          |Select clock input for PWM timer.
N     * |        |          |000 = Input Clock Divided by 2.
N     * |        |          |001 = Input Clock Divided by 4.
N     * |        |          |010 = Input Clock Divided by 8.
N     * |        |          |011 = Input Clock Divided by 16.
N     * |        |          |100 = Input Clock Divided by 1.
N     * @var PWM_T::PCR
N     * Offset: 0x08  PWM Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CH0EN     |PWM-timer 0 Enable/Disable Start Run
N     * |        |          |0 = Corresponding PWM-timer running Stopped.
N     * |        |          |1 = Corresponding PWM-timer start run Enabled.
N     * |[1]     |DB_MODE   |PWM Debug Mode Configuration Bit (Available In DEBUG Mode Only)
N     * |        |          |0 = Safe mode: The timer is frozen and PWM outputs are shut down Safe state for the inverter.
N     * |        |          |The timer can still be re-started from where it stops.
N     * |        |          |1 = Normal mode: The timer continues to operate normally May be dangerous in some cases since a constant duty cycle is applied to the inverter (no more interrupts serviced).
N     * |[2]     |CH0INV    |PWM-timer 0 Output Inverter Enable Control
N     * |        |          |0 = Inverter Disabled.
N     * |        |          |1 = Inverter Enabled.
N     * |[3]     |CH0MOD    |PWM-timer 0 Auto-reload/One-shot Mode
N     * |        |          |0 = One-shot mode.
N     * |        |          |1 = Auto-reload mode.
N     * |        |          |Note: If there is a rising transition at this bit, it will cause CNR0 and CMR0 cleared.
N     * |[4]     |CH1EN     |PWM-timer 1 Enable/Disable Start Run
N     * |        |          |0 = Corresponding PWM-timer running Stopped.
N     * |        |          |1 = Corresponding PWM-timer start run Enabled.
N     * |[6]     |CH1INV    |PWM-timer 1 Output Inverter ON/OFF
N     * |        |          |0 = Inverter OFF.
N     * |        |          |1 = Inverter ON.
N     * |[7]     |CH1MOD    |PWM-timer 1 Auto-reload/One-shot Mode
N     * |        |          |0 = One-shot mode.
N     * |        |          |1 = Auto-reload mode.
N     * |        |          |Note: If there is a rising transition at this bit, it will cause CNR1 and CMR1 cleared.
N     * |[8]     |CH2EN     |PWM-timer 2 Enable/Disable Start Run
N     * |        |          |0 = Corresponding PWM-timer running Stopped.
N     * |        |          |1 = Corresponding PWM-timer start run Enabled.
N     * |[10]    |CH2INV    |PWM-timer 2 Output Inverter Enable Control
N     * |        |          |0 = Inverter Disabled.
N     * |        |          |1 = Inverter Enabled.
N     * |[11]    |CH2MOD    |PWM-timer 2 Auto-reload/One-shot Mode
N     * |        |          |0 = One-shot mode.
N     * |        |          |1 = Auto-reload mode.
N     * |        |          |Note: If there is a rising transition at this bit, it will cause CNR2 and CMR2 cleared.
N     * |[12]    |CH3EN     |PWM-timer 3 Enable/Disable Start Run
N     * |        |          |0 = Corresponding PWM-timer running Stopped.
N     * |        |          |1 = Corresponding PWM-timer start run Enabled.
N     * |[14]    |CH3INV    |PWM-timer 3 Output Inverter Enable Control
N     * |        |          |0 = Inverter Disabled.
N     * |        |          |1 = Inverter Enabled.
N     * |[15]    |CH3MOD    |PWM-timer 3 Auto-reload/One-shot Mode
N     * |        |          |0 = One-shot mode.
N     * |        |          |1 = Auto-reload mode.
N     * |        |          |Note: If there is a rising transition at this bit, it will cause CNR3 and CMR3 cleared.
N     * |[16]    |CH4EN     |PWM-timer 4 Enable/Disable Start Run
N     * |        |          |0 = Corresponding PWM-timer running Stopped.
N     * |        |          |1 = Corresponding PWM-timer start run Enabled.
N     * |[18]    |CH4INV    |PWM-timer 4 Output Inverter Enable Control
N     * |        |          |0 = Inverter Disabled.
N     * |        |          |1 = Inverter Enabled.
N     * |[19]    |CH4MOD    |PWM-timer 4 Auto-reload/One-shot Mode
N     * |        |          |0 = One-shot mode.
N     * |        |          |1 = Auto-reload mode.
N     * |        |          |Note: If there is a rising transition at this bit, it will cause CNR4 and CMR4 cleared.
N     * |[20]    |CH5EN     |PWM-timer 5 Enable/Disable Start Run
N     * |        |          |0 = Corresponding PWM-timer running Stopped.
N     * |        |          |1 = Corresponding PWM-timer start run Enabled.
N     * |[22]    |CH5INV    |PWM-timer 5 Output Inverter Enable Control
N     * |        |          |0 = Inverter Disabled.
N     * |        |          |1 = Inverter Enabled.
N     * |[23]    |CH5MOD    |PWM-timer 5 Auto-reload/One-shot Mode
N     * |        |          |0 = One-shot mode.
N     * |        |          |1 = Auto-reload mode.
N     * |        |          |Note: If there is a rising transition at this bit, it will cause CNR5 and CMR5 cleared.
N     * |[24]    |DZEN01    |Dead-zone 0 Generator Enable Control (PWM0 And PWM1 Pair For PWM Group)
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: When the dead-zone generator is enabled, the pair of PWM0 and PWM1 becomes a complementary pair for PWM group.
N     * |[25]    |DZEN23    |Dead-zone 2 Generator Enable Control (PWM2 And PWM3 Pair For PWM Group)
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: When the dead-zone generator is enabled, the pair of PWM2 and PWM3 becomes a complementary pair for PWM group.
N     * |[26]    |DZEN45    |Dead-zone 4 Generator Enable Control (PWM4 And PWM5 Pair For PWM Group)
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: When the dead-zone generator is enabled, the pair of PWM4 and PWM5 becomes a complementary pair for PWM group.
N     * |[27]    |CLRPWM    |Clear PWM Counter Control Bit
N     * |        |          |0 = Do not clear PWM counter.
N     * |        |          |1 = All 16-bit PWM counters cleared to 0x0000.
N     * |        |          |Note: It is automatically cleared by hardware.
N     * |[29:28] |PWMMOD    |PWM Operating Mode Selection
N     * |        |          |00 = Independent mode.
N     * |        |          |01 = Complementary mode.
N     * |        |          |10 = Synchronized mode.
N     * |        |          |11 = Reserved.
N     * |[30]    |GRP       |Group Bit
N     * |        |          |0 = The signals timing of all PWM channels are independent.
N     * |        |          |1 = Unify the signals timing of PWM0, PWM2 and PWM4 in the same phase which is controlled by PWM0 and also unify the signals timing of PWM1, PWM3 and PWM5 in the same phase which is controlled by PWM1.
N     * |[31]    |PWMTYPE   |PWM Aligned Type Selection Bit
N     * |        |          |0 = Edge-aligned type.
N     * |        |          |1 = Center-aligned type.
N     * @var PWM_T::CNR
N     * Offset: 0x0C ~ 0x20 PWM Counter Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CNRn      |PWM Counter/Timer Loaded Value
N     * |        |          |CNRn determines the PWM period. n = 0, 1..5.
N     * |        |          |Edge-aligned mode:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/(CNRn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMRn+1)/(CNRn+1).
N     * |        |          |CMRn >= CNRn: PWM output is always high.
N     * |        |          |CMRn < CNRn: PWM low width = (CNRn-CMRn) unit; PWM high width = (CMR+1) unit.
N     * |        |          |CMRn = 0: PWM low width = (CNRn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned mode:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/ (2*CNRn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CNRn - CMRn)/(CNRn+1).
N     * |        |          |CMRn >= CNRn: PWM output is always low.
N     * |        |          |CMRn < CNRn: PWM low width = (CMRn + 1) * 2 unit; PWM high width = (CNRn - CMRn) * 2 unit.
N     * |        |          |CMRn = 0: PWM low width = 2 unit; PWM high width = (CNRn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to CNRn will take effect in next PWM cycle.
N     * @var PWM_T::CMR
N     * Offset: 0x24 ~ 0x38 PWM Comparator Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CMRn      |PWM Comparator Bits
N     * |        |          |CMR determines the PWM duty. n = 0, 1..5.
N     * |        |          |Edge-aligned mode:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider))/(CNRn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CMRn+1)/(CNRn+1).
N     * |        |          |CMRn >= CNRn: PWM output is always high.
N     * |        |          |CMRn < CNRn: PWM low width = (CNRn-CMRn) unit; PWM high width = (CMR+1) unit.
N     * |        |          |CMRn = 0: PWM low width = (CNRn) unit; PWM high width = 1 unit.
N     * |        |          |Center-aligned mode:
N     * |        |          |PWM frequency = HCLK/((prescale+1)*(clock divider)) /(2*CNRn+1); where xy, could be 01, 23, 45 depending on the selected PWM channel.
N     * |        |          |Duty ratio = (CNRn - CMRn)/(CNRn+1).
N     * |        |          |CMRn >= CNRn: PWM output is always low.
N     * |        |          |CMRn < CNRn: PWM low width = (CMRn + 1) * 2 unit; PWM high width = (CNRn - CMRn) * 2 unit.
N     * |        |          |CMRn = 0: PWM low width = 2 unit; PWM high width = (CNRn) * 2 unit.
N     * |        |          |(Unit = One PWM clock cycle).
N     * |        |          |Note: Any write to CMRn will take effect in next PWM cycle.
N     * @var PWM_T::PIER
N     * Offset: 0x54  PWM Interrupt Enable Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |PWMPIE0   |PWM Channel 0 Period Interrupt Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[1]     |PWMPIE1   |PWM Channel 1 Period Interrupt Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[2]     |PWMPIE2   |PWM Channel 2 Period Interrupt Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[3]     |PWMPIE3   |PWM Channel 3 Period Interrupt Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[4]     |PWMPIE4   |PWM Channel 4 Period Interrupt Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[5]     |PWMPIE5   |PWM Channel 5 Period Interrupt Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[8]     |PWMDIE0   |PWM Channel 0 Duty Interrupt Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[9]     |PWMDIE1   |PWM Channel 1 Duty Interrupt Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[10]    |PWMDIE2   |PWM Channel 2 Duty Interrupt Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[11]    |PWMDIE3   |PWM Channel 3 Duty Interrupt Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[12]    |PWMDIE4   |PWM Channel 4 Duty Interrupt Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[13]    |PWMDIE5   |PWM Channel 5 Duty Interrupt Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[16]    |BRKIE     |Fault Brake0 And 1 Interrupt Enable Control
N     * |        |          |0 = Disabling flags BKF0 and BKF1 to trigger PWM interrupt.
N     * |        |          |1 = Enabling flags BKF0 and BKF1 can trigger PWM interrupt.
N     * |[17]    |INT_TYPE  |PWM Interrupt Type Selection Bit
N     * |        |          |0 = PWMPIFn will be set if PWM counter underflows.
N     * |        |          |1 = PWMPIFn will be set if PWM counter matches CNRn register.
N     * |        |          |Note: This bit is effective when PWM in central align mode only.
N     * @var PWM_T::PIIR
N     * Offset: 0x58  PWM Interrupt Indication Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |PWMPIF0   |PWM Channel 0 Period Interrupt Flag
N     * |        |          |Flag is set by hardware when PWM0 down counter reaches zero.
N     * |        |          |Note: Software can write 1 to clear this bit.
N     * |[1]     |PWMPIF1   |PWM Channel 1 Period Interrupt Flag
N     * |        |          |Flag is set by hardware when PWM1 down counter reaches zero.
N     * |        |          |Note: Software can write 1 to clear this bit.
N     * |[2]     |PWMPIF2   |PWM Channel 2 Period Interrupt Flag
N     * |        |          |Flag is set by hardware when PWM2 down counter reaches zero.
N     * |        |          |Note: Software can write 1 to clear this bit.
N     * |[3]     |PWMPIF3   |PWM Channel 3 Period Interrupt Flag
N     * |        |          |Flag is set by hardware when PWM3 down counter reaches zero.
N     * |        |          |Note: Software can write 1 to clear this bit.
N     * |[4]     |PWMPIF4   |PWM Channel 4 Period Interrupt Flag
N     * |        |          |Flag is set by hardware when PWM4 down counter reaches zero.
N     * |        |          |Note: Software can write 1 to clear this bit.
N     * |[5]     |PWMPIF5   |PWM Channel 5 Period Interrupt Flag
N     * |        |          |Flag is set by hardware when PWM5 down counter reaches zero.
N     * |        |          |Note: Software can write 1 to clear this bit.
N     * |[8]     |PWMDIF0   |PWM Channel 0 Duty Interrupt Flag
N     * |        |          |Flag is set by hardware when a channel 0 PWM counter reaches CMR0 in down-count direction.
N     * |        |          |Note: Software can write 1 to clear this bit.
N     * |[9]     |PWMDIF1   |PWM Channel 1 Duty Interrupt Flag
N     * |        |          |Flag is set by hardware when a channel 1 PWM counter reaches CMR1 in down-count direction.
N     * |        |          |Note: Software can write 1 to clear this bit.
N     * |[10]    |PWMDIF2   |PWM Channel 2 Duty Interrupt Flag
N     * |        |          |Flag is set by hardware when a channel 2 PWM counter reaches CMR2 in down-count direction.
N     * |        |          |Note: Software can write 1 to clear this bit.
N     * |[11]    |PWMDIF3   |PWM Channel 3 Duty Interrupt Flag
N     * |        |          |Flag is set by hardware when a channel 3 PWM counter reaches CMR3 in down-count direction.
N     * |        |          |Note: Software can write 1 to clear this bit.
N     * |[12]    |PWMDIF4   |PWM Channel 4 Duty Interrupt Flag
N     * |        |          |Flag is set by hardware when a channel 4 PWM counter reaches CMR4 in down-count direction.
N     * |        |          |Note: Software can write 1 to clear this bit.
N     * |[13]    |PWMDIF5   |PWM Channel 5 Duty Interrupt Flag
N     * |        |          |Flag is set by hardware when a channel 5 PWM counter reaches CMR5 in down-count direction.
N     * |        |          |Note: Software can write 1 to clear this bit.
N     * |[16]    |BKF0      |PWM Brake0 Flag
N     * |        |          |0 = PWM Brake does not recognize a falling signal at BKP0.
N     * |        |          |1 = When PWM Brake detects a falling signal at pin BKP0, this flag will be set to high.
N     * |        |          |Note: Software can write 1 to clear this bit.
N     * |[17]    |BKF1      |PWM Brake1 Flag
N     * |        |          |0 = PWM Brake does not recognize a falling signal at BKP1.
N     * |        |          |1 = When PWM Brake detects a falling signal at pin BKP1, this flag will be set to high.
N     * |        |          |Note: Software can write 1 to clear this bit.
N     * @var PWM_T::POE
N     * Offset: 0x5C  PWM Output Enable for Channel 0~5
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |PWM0      |PWM Channel 0 Output Enable Control
N     * |        |          |0 = PWM channel 0 output to pin Disabled.
N     * |        |          |1 = PWM channel 0 output to pin Enabled.
N     * |        |          |Note: The corresponding GPIO pin must be switched to PWM function.
N     * |[1]     |PWM1      |PWM Channel 1 Output Enable Control
N     * |        |          |0 = PWM channel 1 output to pin Disabled.
N     * |        |          |1 = PWM channel 1 output to pin Enabled.
N     * |        |          |Note: The corresponding GPIO pin must be switched to PWM function.
N     * |[2]     |PWM2      |PWM Channel 2 Output Enable Control
N     * |        |          |0 = PWM channel 2 output to pin Disabled.
N     * |        |          |1 = PWM channel 2 output to pin Enabled.
N     * |        |          |Note: The corresponding GPIO pin must be switched to PWM function.
N     * |[3]     |PWM3      |PWM Channel 3 Output Enable Control
N     * |        |          |0 = PWM channel 3 output to pin Disabled.
N     * |        |          |1 = PWM channel 3 output to pin Enabled.
N     * |        |          |Note: The corresponding GPIO pin must be switched to PWM function.
N     * |[4]     |PWM4      |PWM Channel 4 Output Enable Control
N     * |        |          |0 = PWM channel 4 output to pin Disabled.
N     * |        |          |1 = PWM channel 4 output to pin Enabled.
N     * |        |          |Note: The corresponding GPIO pin must be switched to PWM function.
N     * |[5]     |PWM5      |PWM Channel 5 Output Enable Control
N     * |        |          |0 = PWM channel 5 output to pin Disabled.
N     * |        |          |1 = PWM channel 5 output to pin Enabled.
N     * |        |          |Note: The corresponding GPIO pin must be switched to PWM function.
N     * @var PWM_T::PFBCON
N     * Offset: 0x60  PWM Fault Brake Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |BKEN0     |Enable BKP0 Pin Trigger Fault Brake Function 0
N     * |        |          |0 = Disabling BKP0 pin can trigger brake function 0 (EINT0 or CPO1).
N     * |        |          |1 = Enabling a falling at BKP0 pin can trigger brake function 0.
N     * |[1]     |BKEN1     |Enable BKP1 Pin Trigger Fault Brake Function 1
N     * |        |          |0 = Disabling BKP1 pin can trigger brake function 1 (EINT1 or CPO0).
N     * |        |          |1 = Enabling a falling at BKP1 pin can trigger brake function 1.
N     * |[2]     |CPO0BKEN  |BKP1 Fault Brake Function Source Selection
N     * |        |          |0 = EINT1 as one brake source in BKP1.
N     * |        |          |1 = CPO0 as one brake source in BKP1.
N     * |[3]     |CPO1BKEN  |BKP0 Fault Brake Function Source Selection
N     * |        |          |0 = EINT0 as one brake source in BKP0.
N     * |        |          |1 = CPO1 as one brake source in BKP0.
N     * |[7]     |BKF       |PWM Fault Brake Event Flag (Write 1 Clear)
N     * |        |          |0 = PWM output initial state when fault brake conditions asserted.
N     * |        |          |1 = PWM output fault brake state when fault brake conditions asserted.
N     * |        |          |Software can write 1 to clear this bit and must clear this bit before restart PWM counter.
N     * |[24]    |PWMBKO0   |PWM Channel 0 Brake Output Select Bit
N     * |        |          |0 = PWM output low when fault brake conditions asserted.
N     * |        |          |1 = PWM output high when fault brake conditions asserted.
N     * |[25]    |PWMBKO1   |PWM Channel 1 Brake Output Select Bit
N     * |        |          |0 = PWM output low when fault brake conditions asserted.
N     * |        |          |1 = PWM output high when fault brake conditions asserted.
N     * |[26]    |PWMBKO2   |PWM Channel 2 Brake Output Select Bit
N     * |        |          |0 = PWM output low when fault brake conditions asserted.
N     * |        |          |1 = PWM output high when fault brake conditions asserted.
N     * |[27]    |PWMBKO3   |PWM Channel 3 Brake Output Select Bit
N     * |        |          |0 = PWM output low when fault brake conditions asserted.
N     * |        |          |1 = PWM output high when fault brake conditions asserted.
N     * |[28]    |PWMBKO4   |PWM Channel 4 Brake Output Select Bit
N     * |        |          |0 = PWM output low when fault brake conditions asserted.
N     * |        |          |1 = PWM output high when fault brake conditions asserted.
N     * |[29]    |PWMBKO5   |PWM Channel 5 Brake Output Select Bit
N     * |        |          |0 = PWM output low when fault brake conditions asserted.
N     * |        |          |1 = PWM output high when fault brake conditions asserted.
N     * |[30]    |D6BKO6    |D6 Brake Output Select Bit
N     * |        |          |0 = D6 output low when fault brake conditions asserted.
N     * |        |          |1 = D6 output high when fault brake conditions asserted.
N     * |[31]    |D7BKO7    |D7 Brake Output Select Bit
N     * |        |          |0 = D7 output low when fault brake conditions asserted.
N     * |        |          |1 = D7 output high when fault brake conditions asserted.
N     * @var PWM_T::PDZIR
N     * Offset: 0x64  PWM Dead-zone Interval Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |DZI01     |Dead-zone Interval Register For Pair Of Channel0 And Channel1 (PWM0 And PWM1 Pair)
N     * |        |          |These 8 bits determine dead-zone length.
N     * |        |          |The unit time of dead-zone length is received from corresponding CSR bits.
N     * |[15:8]  |DZI23     |Dead-zone Interval Register For Pair Of Channel2 And Channel3 (PWM2 And PWM3 Pair)
N     * |        |          |These 8 bits determine dead-zone length.
N     * |        |          |The unit time of dead-zone length is received from corresponding CSR bits.
N     * |[23:16] |DZI45     |Dead-zone Interval Register For Pair Of Channel4 And Channel5 (PWM4 And PWM5 Pair)
N     * |        |          |These 8 bits determine dead-zone length.
N     * |        |          |The unit time of dead-zone length is received from corresponding CSR bits.
N     * @var PWM_T::TRGCON0
N     * Offset: 0x68  PWM Trigger Control Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CM0TRGREN |Enable PWM Trigger ADC Function While Channel0's Counter Matching CMR0 In Up-count Direction
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: This bit is only valid for PWM in center aligned mode.
N     * |        |          |When PWM is in edged aligned mode, setting this bit is meaningless and will not take any effect.
N     * |[1]     |CNT0TRGEN |Enable PWM Trigger ADC Function While Channel0's Counter Matching CNR0
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: This bit is only valid for PWM in center aligned mode.
N     * |        |          |When PWM is in edged aligned mode, setting this bit is meaningless and will not take any effect.
N     * |[2]     |CM0TRGFEN |Enable PWM Trigger ADC Function While Channel0's Counter Matching CMR0 In Down-count Direction
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: This bit is valid for both center aligned mode and edged aligned mode.
N     * |[3]     |P0TRGEN   |Enable PWM Trigger ADC Function While Channel0's Counter Matching 0
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: This bit is valid for both center aligned mode and edged aligned mode.
N     * |[8]     |CM1TRGREN |Enable PWM Trigger ADC Function While Channel1's Counter Matching CMR1 In Up-count Direction
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: This bit is only valid for PWM in center aligned mode.
N     * |        |          |When PWM is in edged aligned mode, setting this bit is meaningless and will not take any effect.
N     * |[9]     |CNT1TRGEN |Enable PWM Trigger ADC Function While Channel1's Counter Matching CNR1
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: This bit is only valid for PWM in center aligned mode.
N     * |        |          |When PWM is in edged aligned mode, setting this bit is meaningless and will not take any effect.
N     * |[10]    |CM1TRGFEN |Enable PWM Trigger ADC Function While Channel1's Counter Matching CMR1 In Down-count Direction
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: This bit is valid for both center aligned mode and edged aligned mode.
N     * |[11]    |P1TRGEN   |Enable PWM Trigger ADC Function While Channel1's Counter Matching 0
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: This bit is valid for both center aligned mode and edged aligned mode.
N     * |[16]    |CM2TRGREN |Enable PWM Trigger ADC Function While Channel2's Counter Matching CMR2 In Up-count Direction
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: This bit is only valid for PWM in center aligned mode.
N     * |        |          |When PWM is in edged aligned mode, setting this bit is meaningless and will not take any effect.
N     * |[17]    |CNT2TRGEN |Enable PWM Trigger ADC Function While Channel2's Counter Matching CNR2
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: This bit is only valid for PWM in center aligned mode.
N     * |        |          |When PWM is in edged aligned mode, setting this bit is meaningless and will not take any effect.
N     * |[18]    |CM2TRGFEN |Enable PWM Trigger ADC Function While Channel2's Counter Matching CMR2 In Down-count Direction
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: This bit is valid for both center aligned mode and edged aligned mode.
N     * |[19]    |P2TRGEN   |Enable PWM Trigger ADC Function While Channel2's Counter Matching 0
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: This bit is valid for both center aligned mode and edged aligned mode.
N     * |[24]    |CM3TRGREN |Enable PWM Trigger ADC Function While Channel3's Counter Matching CMR3 In Up-count Direction
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: This bit is only valid for PWM in center aligned mode.
N     * |        |          |When PWM is in edged aligned mode, setting this bit is meaningless and will not take any effect.
N     * |[25]    |CNT3TRGEN |Enable PWM Trigger ADC Function While Channel3's Counter Matching CNR3
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: This bit is only valid for PWM in center aligned mode.
N     * |        |          |When PWM is in edged aligned mode, setting this bit is meaningless and will not take any effect.
N     * |[26]    |CM3TRGFEN |Enable PWM Trigger ADC Function While Channel3's Counter Matching CMR3 In Down-count Direction
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: This bit is valid for both center aligned mode and edged aligned mode.
N     * |[27]    |P3TRGEN   |Enable PWM Trigger ADC Function While Channel3's Counter Matching 0
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: This bit is valid for both center aligned mode and edged aligned mode.
N     * @var PWM_T::TRGCON1
N     * Offset: 0x6C  PWM Trigger Control Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CM4TRGREN |Enable PWM Trigger ADC Function While Channel4's Counter Matching CMR4 In Up-count Direction
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: This bit is only valid for PWM in center aligned mode.
N     * |        |          |When PWM is in edged aligned mode, setting this bit is meaningless and will not take any effect.
N     * |[1]     |CNT4TRGEN |Enable PWM Trigger ADC Function While Channel4's Counter Matching CNR4
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: This bit is only valid for PWM in center aligned mode.
N     * |        |          |When PWM is in edged aligned mode, setting this bit is meaningless and will not take any effect.
N     * |[2]     |CM4TRGFEN |Enable PWM Trigger ADC Function While Channel4's Counter Matching CMR4 In Down-count Direction
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: This bit is valid for both center aligned mode and edged aligned mode.
N     * |[3]     |P4TRGEN   |Enable PWM Trigger ADC Function While Channel4's Counter Matching 0
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: This bit is valid for both center aligned mode and edged aligned mode.
N     * |[8]     |CM5TRGREN |Enable PWM Trigger ADC Function While Channel5's Counter Matching CMR5 In Up-count Direction
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: This bit is only valid for PWM in center aligned mode.
N     * |        |          |When PWM is in edged aligned mode, setting this bit is meaningless and will not take any effect.
N     * |[9]     |CNT5TRGEN |Enable PWM Trigger ADC Function While Channel5's Counter Matching CNR5
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: This bit is only valid for PWM in center aligned mode.
N     * |        |          |When PWM is in edged aligned mode, setting this bit is meaningless and will not take any effect.
N     * |[10]    |CM5TRGFEN |Enable PWM Trigger ADC Function While Channel5's Counter Matching CMR5 In Down-count Direction
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: This bit is valid for both center aligned mode and edged aligned mode.
N     * |[11]    |P5TRGEN   |Enable PWM Trigger ADC Function While Channel5's Counter Matching 0
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: This bit is valid for both center aligned mode and edged aligned mode.
N     * @var PWM_T::TRGSTS0
N     * Offset: 0x70  PWM Trigger Status Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CMR0FLAG_R|ADC Trigger Flag By Counting Up To CMR
N     * |        |          |Note: Software can write 1 to clear this bit.
N     * |[1]     |CNT0FLAG  |ADC Trigger Flag By Counting To CNR
N     * |        |          |Note: Software can write 1 to clear this bit.
N     * |[2]     |CMR0FLAG_F|ADC Trigger Flag By Counting Down To CMR
N     * |        |          |Note: Software can write 1 to clear this bit.
N     * |[3]     |PERID0FLAG|ADC Trigger Flag By Period
N     * |        |          |Note: Software can write 1 to clear this bit.
N     * |[8]     |CMR1FLAG_R|ADC Trigger Flag By Counting Up To CMR
N     * |        |          |Note: Software can write 1 to clear this bit.
N     * |[9]     |CNT1FLAG  |ADC Trigger Flag By Counting To CNR
N     * |        |          |Note: Software can write 1 to clear this bit.
N     * |[10]    |CMR1FLAG_F|ADC Trigger Flag By Counting Down To CMR
N     * |        |          |Note: Software can write 1 to clear this bit.
N     * |[11]    |PERID1FLAG|ADC Trigger Flag By Period
N     * |        |          |Note: Software can write 1 to clear this bit.
N     * |[16]    |CMR2FLAG_R|ADC Trigger Flag By Counting Up To CMR
N     * |        |          |Note: Software can write 1 to clear this bit.
N     * |[17]    |CNT2FLAG  |ADC Trigger Flag By Counting To CNR
N     * |        |          |Note: Software can write 1 to clear this bit.
N     * |[18]    |CMR2FLAG_F|ADC Trigger Flag By Counting Down To CMR
N     * |        |          |Note: Software can write 1 to clear this bit.
N     * |[19]    |PERID2FLAG|ADC Trigger Flag By Period
N     * |        |          |Note: Software can write 1 to clear this bit.
N     * |[24]    |CMR3FLAG_R|When Counter Counting Up To CMR, This Bit Will Be Set For Trigger ADC
N     * |        |          |Note: Software can write 1 to clear this bit.
N     * |[25]    |CNT3FLAG  |When Counter Counting To CNR, This Bit Will Be Set For Trigger ADC
N     * |        |          |Note: Software can write 1 to clear this bit.
N     * |[26]    |CMR3FLAG_F|When Counter Counting Down To CMR, This Bit Will Be Set For Trigger ADC
N     * |        |          |Note: Software can write 1 to clear this bit.
N     * |[27]    |PERID3FLAG|When Counter Counting To Period, This Bit Will Be Set For Trigger ADC
N     * |        |          |Note: Software can write 1 to clear this bit.
N     * @var PWM_T::TRGSTS1
N     * Offset: 0x74  PWM Trigger Status Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CMR4FLAG_R|ADC Trigger Flag By Counting Up To CMR
N     * |        |          |Note: Software can write 1 to clear this bit.
N     * |[1]     |CNT4FLAG  |ADC Trigger Flag By Counting To CNR
N     * |        |          |Note: Software can write 1 to clear this bit.
N     * |[2]     |CMR4FLAG_F|ADC Trigger Flag By Counting Down To CMR
N     * |        |          |Note: Software can write 1 to clear this bit.
N     * |[3]     |PERID4FLAG|ADC Trigger Flag By Period
N     * |        |          |Note: Software can write 1 to clear this bit.
N     * |[8]     |CMR5FLAG_R|ADC Trigger Flag By Counting Up To CMR
N     * |        |          |Note: Software can write 1 to clear this bit.
N     * |[9]     |CNT5FLAG  |ADC Trigger Flag By Counting To CNR
N     * |        |          |Note: Software can write 1 to clear this bit.
N     * |[10]    |CMR5FLAG_F|ADC Trigger Flag By Counting Down To CMR
N     * |        |          |Note: Software can write 1 to clear this bit.
N     * |[11]    |PERID5FLAG|ADC Trigger Flag By Period
N     * |        |          |Note: Software can write 1 to clear this bit.
N     * @var PWM_T::PHCHG
N     * Offset: 0x78  Phase Change Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |D0        |D0: When PWM0 Is Zero, Channel 0's Output Waveform Is D0
N     * |        |          |0 = Output low.
N     * |        |          |1 = Output high.
N     * |[1]     |D1        |D1: When PWM1 Is Zero, Channel 1's Output Waveform Is D1
N     * |        |          |0 = Output low.
N     * |        |          |1 = Output high.
N     * |[2]     |D2        |D2: When PWM2 Is Zero, Channel 2's Output Waveform Is D2
N     * |        |          |0 = Output low.
N     * |        |          |1 = Output high.
N     * |[3]     |D3        |D3: When PWM3 Is Zero, Channel 3's Output Waveform Is D3
N     * |        |          |0 = Output low.
N     * |        |          |1 = Output high.
N     * |[4]     |D4        |D4: When PWM4 Is Zero, Channel 4's Output Waveform Is D4
N     * |        |          |0 = Output low.
N     * |        |          |1 = Output high.
N     * |[5]     |D5        |D5: When PWM5 Is Zero, Channel 5's Output Waveform Is D5
N     * |        |          |0 = Output low.
N     * |        |          |1 = Output high.
N     * |[6]     |D6        |D6: When MASK6 Is 1, Channel 6's Output Waveform Is D6
N     * |        |          |0 = Output low.
N     * |        |          |1 = Output high.
N     * |[7]     |D7        |D7: When MASK7 Is 1, Channel 7's Output Waveform Is D7
N     * |        |          |0 = Output low.
N     * |        |          |1 = Output high.
N     * |[8]     |PWM0      |PWM Channel 0 Output Enable Control
N     * |        |          |0 = Output D0 specified in bit 0 of PHCHG register.
N     * |        |          |1 = Output the original channel 0 waveform.
N     * |[9]     |PWM1      |PWM Channel 1 Output Enable Control
N     * |        |          |0 = Output D1 specified in bit 1 of PHCHG register.
N     * |        |          |1 = Output the original channel 1 waveform.
N     * |[10]    |PWM2      |PWM Channel 2 Output Enable Control
N     * |        |          |0 = Output D2 specified in bit 2 of PHCHG register.
N     * |        |          |1 = Output the original channel 2 waveform.
N     * |[11]    |PWM3      |PWM Channel 3 Output Enable Control
N     * |        |          |0 = Output D3 specified in bit 3 of PHCHG register.
N     * |        |          |1 = Output the original channel 3 waveform.
N     * |[12]    |PWM4      |PWM Channel 4 Output Enable Control
N     * |        |          |0 = Output D4 specified in bit 4 of PHCHG register.
N     * |        |          |1 = Output the original channel 4 waveform.
N     * |[13]    |PWM5      |PWM Channel 5 Output Enable Control
N     * |        |          |0 = Output D5 specified in bit 5 of PHCHG register.
N     * |        |          |1 = Output the original channel 5 waveform.
N     * |[14]    |ACCNT0    |Hardware Auto Clear CE0 When ACMP0 Trigger It
N     * |        |          |0 = Enabled.
N     * |        |          |1 = Disabled.
N     * |[15]    |ACCNT1    |Hardware Auto Clear CE1 When ACMP1 Trigger It
N     * |        |          |0 = Enabled.
N     * |        |          |1 = Disabled.
N     * |[16]    |CH01TOFF1 |Setting This Bit Will Force PWM0 To Output Low Lasting For At Most One Period Cycle As Long As ACMP1 Trigger It; This Feature Is Usually In Step Motor Application
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: only for PWM0,PWM1,PWM2,PWM3.
N     * |[17]    |CH11TOFF1 |Setting This Bit Will Force PWM1 To Output Low Lasting For At Most One Period Cycle As Long As ACMP1 Trigger It; This Feature Is Usually In Step Motor Application
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: Only for PWM0, PWM1, PWM2, PWM3.
N     * |[18]    |CH21TOFF1 |Setting This Bit Will Force PWM2 To Output Low Lasting For At Most One Period Cycle As Long As ACMP1 Trigger It; This Feature Is Usually In Step Motor Application
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: Only for PWM0, PWM1, PWM2, PWM3.
N     * |[19]    |CH31TOFF1 |Setting This Bit Will Force PWM3 To Output Low Lasting For At Most One Period Cycle As Long As ACMP1 Trigger It; This Feature Is Usually In Step Motor Application
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: Only for PWM0, PWM1, PWM2, PWM3.
N     * |[21:20] |CMP1SEL   |CMP1SEL
N     * |        |          |Select the positive input source of ACMP1.
N     * |        |          |00 = Select P3.1 as the input of ACMP1.
N     * |        |          |01 = Select P3.2 as the input of ACMP1.
N     * |        |          |10 = Select P3.3 as the input of ACMP1.
N     * |        |          |11 = Select P3.4 as the input of ACMP1.
N     * |[22]    |T1        |Timer1 Trigger PWM Function Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |When this bit is set, timer1 time-out event will update PHCHG with PHCHG_NXT register.
N     * |[23]    |CE1       |ACMP1 Trigger Function Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: This bit will be auto cleared when ACMP1 trigger PWM if ACCNT1 is set.
N     * |[24]    |CH01TOFF0 |Setting This Bit Will Force PWM0 To Output Low Lasting For At Most One Period Cycle As Long As ACMP0 Trigger It; This Feature Is Usually In Step Motor Application
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: Only for PWM0, PWM1, PWM2, PWM3.
N     * |[25]    |CH11TOFF0 |Setting This Bit Will Force PWM1 To Output Low Lasting For At Most One Period Cycle As Long As ACMP0 Trigger It; This Feature Is Usually In Step Motor Application
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: Only for PWM0, PWM1, PWM2, PWM3.
N     * |[26]    |CH21TOFF0 |Setting This Bit Will Force PWM2 To Output Low Lasting For At Most One Period Cycle As Long As ACMP0 Trigger It; This Feature Is Usually In Step Motor Application
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: Only for PWM0, PWM1, PWM2, PWM3.
N     * |[27]    |CH31TOFF0 |Setting This Bit Will Force PWM3 To Output Low Lasting For At Most One Period Cycle As Long As ACMP0 Trigger It; This Feature Is Usually In Step Motor Application
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: Only for PWM0, PWM1, PWM2, PWM3.
N     * |[29:28] |CMP0SEL   |CMP0SEL
N     * |        |          |Select the positive input source of ACMP0.
N     * |        |          |00 = Select P1.5 as the input of ACMP0.
N     * |        |          |01 = Select P1.0 as the input of ACMP0.
N     * |        |          |10 = Select P1.2 as the input of ACMP0.
N     * |        |          |11 = Select P1.3 as the input of ACMP0.
N     * |[30]    |T0        |Timer0 Trigger PWM Function Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |When this bit is set, timer0 time-out event will update PHCHG with PHCHG_NXT register.
N     * |[31]    |CE0       |ACMP0 Trigger Function Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: This bit will be auto cleared when ACMP0 trigger PWM if ACCNT0 is set.
N     * @var PWM_T::PHCHGNXT
N     * Offset: 0x7C  Next Phase Change Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |D0        |D0: When PWM0 Is Zero, Channel 0's Output Waveform Is D0
N     * |        |          |0 = Output low.
N     * |        |          |1 = Output high.
N     * |[1]     |D1        |D1: When PWM1 Is Zero, Channel 1's Output Waveform Is D1
N     * |        |          |0 = Output low.
N     * |        |          |1 = Output high.
N     * |[2]     |D2        |D2: When PWM2 Is Zero, Channel 2's Output Waveform Is D2
N     * |        |          |0 = Output low.
N     * |        |          |1 = Output high.
N     * |[3]     |D3        |D3: When PWM3 Is Zero, Channel 3's Output Waveform Is D3
N     * |        |          |0 = Output low.
N     * |        |          |1 = Output high.
N     * |[4]     |D4        |D4: When PWM4 Is Zero, Channel 4's Output Waveform Is D4
N     * |        |          |0 = Output low.
N     * |        |          |1 = Output high.
N     * |[5]     |D5        |D5: When PWM5 Is Zero, Channel 5's Output Waveform Is D5
N     * |        |          |0 = Output low.
N     * |        |          |1 = Output high.
N     * |[6]     |D6        |D6: When MASK6 Is 1, Channel 6's Output Waveform Is D6
N     * |        |          |0 = Output low.
N     * |        |          |1 = Output high.
N     * |[7]     |D7        |D7: When MASK7 Is 1, Channel 7's Output Waveform Is D7
N     * |        |          |0 = Output low.
N     * |        |          |1 = Output high.
N     * |[8]     |PWM0      |PWM Channel 0 Output Enable Control
N     * |        |          |0 = Output D0 specified in bit 0 of PHCHG register.
N     * |        |          |1 = Output the original channel 0 waveform.
N     * |[9]     |PWM1      |PWM Channel 1 Output Enable Control
N     * |        |          |0 = Output D1 specified in bit 1 of PHCHG register.
N     * |        |          |1 = Output the original channel 1 waveform.
N     * |[10]    |PWM2      |PWM Channel 2 Output Enable Control
N     * |        |          |0 = Output D2 specified in bit 2 of PHCHG register.
N     * |        |          |1 = Output the original channel 2 waveform.
N     * |[11]    |PWM3      |PWM Channel 3 Output Enable Control
N     * |        |          |0 = Output D3 specified in bit 3 of PHCHG register.
N     * |        |          |1 = Output the original channel 3 waveform.
N     * |[12]    |PWM4      |PWM Channel 4 Output Enable Control
N     * |        |          |0 = Output D4 specified in bit 4 of PHCHG register.
N     * |        |          |1 = Output the original channel 4 waveform.
N     * |[13]    |PWM5      |PWM Channel 5 Output Enable Control
N     * |        |          |0 = Output D5 specified in bit 5 of PHCHG register.
N     * |        |          |1 = Output the original channel 5 waveform.
N     * |[14]    |ACCNT0    |Hardware Auto Clear CE0 When ACMP0 Trigger It
N     * |        |          |0 = Enabled.
N     * |        |          |1 = Disabled.
N     * |[15]    |ACCNT1    |Hardware Auto Clear CE1 When ACMP1 Trigger It
N     * |        |          |0 = Enabled.
N     * |        |          |1 = Disabled.
N     * |[16]    |CH01TOFF1 |Setting This Bit Will Force PWM0 To Output Low Lasting For At Most One Period Cycle As Long As ACMP1 Trigger It; This Feature Is Usually In Step Motor Application
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: only for PWM0,PWM1,PWM2,PWM3.
N     * |[17]    |CH11TOFF1 |Setting This Bit Will Force PWM1 To Output Low Lasting For At Most One Period Cycle As Long As ACMP1 Trigger It; This Feature Is Usually In Step Motor Application
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: Only for PWM0, PWM1, PWM2, PWM3.
N     * |[18]    |CH21TOFF1 |Setting This Bit Will Force PWM2 To Output Low Lasting For At Most One Period Cycle As Long As ACMP1 Trigger It; This Feature Is Usually In Step Motor Application
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: Only for PWM0, PWM1, PWM2, PWM3.
N     * |[19]    |CH31TOFF1 |Setting This Bit Will Force PWM3 To Output Low Lasting For At Most One Period Cycle As Long As ACMP1 Trigger It; This Feature Is Usually In Step Motor Application
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: Only for PWM0, PWM1, PWM2, PWM3.
N     * |[21:20] |CMP1SEL   |CMP1SEL
N     * |        |          |Select the positive input source of ACMP1.
N     * |        |          |00 = Select P3.1 as the input of ACMP1.
N     * |        |          |01 = Select P3.2 as the input of ACMP1.
N     * |        |          |10 = Select P3.3 as the input of ACMP1.
N     * |        |          |11 = Select P3.4 as the input of ACMP1.
N     * |[22]    |T1        |Timer1 Trigger PWM Function Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |When this bit is set, timer1 time-out event will update PHCHG with PHCHG_NXT register.
N     * |[23]    |CE1       |ACMP1 Trigger Function Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: This bit will be auto cleared when ACMP1 trigger PWM if ACCNT1 is set.
N     * |[24]    |CH01TOFF0 |Setting This Bit Will Force PWM0 To Output Low Lasting For At Most One Period Cycle As Long As ACMP0 Trigger It; This Feature Is Usually In Step Motor Application
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: Only for PWM0, PWM1, PWM2, PWM3.
N     * |[25]    |CH11TOFF0 |Setting This Bit Will Force PWM1 To Output Low Lasting For At Most One Period Cycle As Long As ACMP0 Trigger It; This Feature Is Usually In Step Motor Application
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: Only for PWM0, PWM1, PWM2, PWM3.
N     * |[26]    |CH21TOFF0 |Setting This Bit Will Force PWM2 To Output Low Lasting For At Most One Period Cycle As Long As ACMP0 Trigger It; This Feature Is Usually In Step Motor Application
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: Only for PWM0, PWM1, PWM2, PWM3.
N     * |[27]    |CH31TOFF0 |Setting This Bit Will Force PWM3 To Output Low Lasting For At Most One Period Cycle As Long As ACMP0 Trigger It; This Feature Is Usually In Step Motor Application
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: Only for PWM0, PWM1, PWM2, PWM3.
N     * |[29:28] |CMP0SEL   |CMP0SEL
N     * |        |          |Select the positive input source of ACMP0.
N     * |        |          |00 = Select P1.5 as the input of ACMP0.
N     * |        |          |01 = Select P1.0 as the input of ACMP0.
N     * |        |          |10 = Select P1.2 as the input of ACMP0.
N     * |        |          |11 = Select P1.3 as the input of ACMP0.
N     * |[30]    |T0        |Timer0 Trigger PWM Function Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |When this bit is set, timer0 time-out event will update PHCHG with PHCHG_NXT register.
N     * |[31]    |CE0       |ACMP0 Trigger Function Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note: This bit will be auto cleared when ACMP0 trigger PWM if ACCNT0 is set.
N     * @var PWM_T::PHCHGMASK
N     * Offset: 0x80  Phase Change MASK Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[6]     |MASK6     |MASK For D6
N     * |        |          |0 = Original GPIO P0.1.
N     * |        |          |1 = D6.
N     * |[7]     |MASK7     |MASK For D7
N     * |        |          |0 = Original GPIO P0.0.
N     * |        |          |1 = D7.
N     * |[8]     |CMPMASK0  |MASK For ACMP0
N     * |        |          |0 = The input of ACMP is controlled by CMP0CR.
N     * |        |          |1 = The input of ACMP is controlled by CMP0SEL of PHCHG register.
N     * |        |          |Note: Register CMP0CR is describe in Comparator Controller chapter
N     * |[9]     |CMPMASK1  |MASK For ACMP1
N     * |        |          |0 = The input of ACMP is controlled by CMP1CR.
N     * |        |          |1 = The input of ACMP is controlled by CMP1SEL of PHCHG register.
N     * |        |          |Note: Register CMP1CR is describe in Comparator Controller chapter
N     * @var PWM_T::INTACCUCTL
N     * Offset: 0x84  Period Interrupt Accumulation Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |INTACCUEN0|Interrupt Accumulation Function Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[7:4]   |PERIODCNT |Interrupt Accumulation Bits
N     * |        |          |When INTACCUEN0 is set, PERIODCNT will decrease when every PWMPIF0 flag is set and when PERIODCNT reach to zero, the PWM0 interrupt will occurred and PERIODCNT will reload itself.
N     */
N
N    __IO uint32_t PPR;           /* Offset: 0x00  PWM Pre-scale Register                                             */
X    volatile uint32_t PPR;            
N    __IO uint32_t CSR;           /* Offset: 0x04  PWM Clock Select Register                                          */
X    volatile uint32_t CSR;            
N    __IO uint32_t PCR;           /* Offset: 0x08  PWM Control Register                                               */
X    volatile uint32_t PCR;            
N    __IO uint32_t CNR[6];        /* Offset: 0x000C ~ 0x0020 PWM Counter Register 0 ~ 5                               */
X    volatile uint32_t CNR[6];         
N    __IO uint32_t CMR[6];        /* Offset: 0x0024 ~ 0x0038 PWM Comparator Register 0 ~ 5                            */
X    volatile uint32_t CMR[6];         
N    /// @cond HIDDEN_SYMBOLS
N    __I  uint32_t RESERVE0[6];
X    volatile const  uint32_t RESERVE0[6];
N    /// @endcond //HIDDEN_SYMBOLS
N    __IO uint32_t PIER;          /* Offset: 0x54  PWM Interrupt Enable Control Register                              */
X    volatile uint32_t PIER;           
N    __IO uint32_t PIIR;          /* Offset: 0x58  PWM Interrupt Indication Register                                  */
X    volatile uint32_t PIIR;           
N    __IO uint32_t POE;           /* Offset: 0x5C  PWM Output Enable for Channel 0~5                                  */
X    volatile uint32_t POE;            
N    __IO uint32_t PFBCON;        /* Offset: 0x60  PWM Fault Brake Control Register                                   */
X    volatile uint32_t PFBCON;         
N    __IO uint32_t PDZIR;         /* Offset: 0x64  PWM Dead-zone Interval Register                                    */
X    volatile uint32_t PDZIR;          
N    __IO uint32_t TRGCON0;       /* Offset: 0x68  PWM Trigger Control Register 0                                     */
X    volatile uint32_t TRGCON0;        
N    __IO uint32_t TRGCON1;       /* Offset: 0x6C  PWM Trigger Control Register 1                                     */
X    volatile uint32_t TRGCON1;        
N    __IO uint32_t TRGSTS0;       /* Offset: 0x70  PWM Trigger Status Register 0                                      */
X    volatile uint32_t TRGSTS0;        
N    __IO uint32_t TRGSTS1;       /* Offset: 0x74  PWM Trigger Status Register 1                                      */
X    volatile uint32_t TRGSTS1;        
N    __IO uint32_t PHCHG;         /* Offset: 0x78  Phase Change Register                                              */
X    volatile uint32_t PHCHG;          
N    __IO uint32_t PHCHGNXT;      /* Offset: 0x7C  Next Phase Change Register                                         */
X    volatile uint32_t PHCHGNXT;       
N    __IO uint32_t PHCHGMASK;     /* Offset: 0x80  Phase Change MASK Register                                         */
X    volatile uint32_t PHCHGMASK;      
N    __IO uint32_t INTACCUCTL;    /* Offset: 0x84  Period Interrupt Accumulation Control Register                     */
X    volatile uint32_t INTACCUCTL;     
N
N} PWM_T;
N
N
N
N/**
N    @addtogroup PWM_CONST PWM Bit Field Definition
N    Constant Definitions for PWM Controller
N@{ */
N
N#define PWM_PPR_CP01_Pos                 (0)                                               /*!< PWM_T::PPR: CP01 Position                 */
N#define PWM_PPR_CP01_Msk                 (0xfful << PWM_PPR_CP01_Pos)                      /*!< PWM_T::PPR: CP01 Mask                     */
N
N#define PWM_PPR_CP23_Pos                 (8)                                               /*!< PWM_T::PPR: CP23 Position                 */
N#define PWM_PPR_CP23_Msk                 (0xfful << PWM_PPR_CP23_Pos)                      /*!< PWM_T::PPR: CP23 Mask                     */
N
N#define PWM_PPR_CP45_Pos                 (16)                                              /*!< PWM_T::PPR: CP45 Position                 */
N#define PWM_PPR_CP45_Msk                 (0xfful << PWM_PPR_CP45_Pos)                      /*!< PWM_T::PPR: CP45 Mask                     */
N
N#define PWM_CSR_CSR0_Pos                 (0)                                               /*!< PWM_T::CSR: CSR0 Position                 */
N#define PWM_CSR_CSR0_Msk                 (0x7ul << PWM_CSR_CSR0_Pos)                       /*!< PWM_T::CSR: CSR0 Mask                     */
N
N#define PWM_CSR_CSR1_Pos                 (4)                                               /*!< PWM_T::CSR: CSR1 Position                 */
N#define PWM_CSR_CSR1_Msk                 (0x7ul << PWM_CSR_CSR1_Pos)                       /*!< PWM_T::CSR: CSR1 Mask                     */
N
N#define PWM_CSR_CSR2_Pos                 (8)                                               /*!< PWM_T::CSR: CSR2 Position                 */
N#define PWM_CSR_CSR2_Msk                 (0x7ul << PWM_CSR_CSR2_Pos)                       /*!< PWM_T::CSR: CSR2 Mask                     */
N
N#define PWM_CSR_CSR3_Pos                 (12)                                              /*!< PWM_T::CSR: CSR3 Position                 */
N#define PWM_CSR_CSR3_Msk                 (0x7ul << PWM_CSR_CSR3_Pos)                       /*!< PWM_T::CSR: CSR3 Mask                     */
N
N#define PWM_CSR_CSR4_Pos                 (16)                                              /*!< PWM_T::CSR: CSR4 Position                 */
N#define PWM_CSR_CSR4_Msk                 (0x7ul << PWM_CSR_CSR4_Pos)                       /*!< PWM_T::CSR: CSR4 Mask                     */
N
N#define PWM_CSR_CSR5_Pos                 (20)                                              /*!< PWM_T::CSR: CSR5 Position                 */
N#define PWM_CSR_CSR5_Msk                 (0x7ul << PWM_CSR_CSR5_Pos)                       /*!< PWM_T::CSR: CSR5 Mask                     */
N
N#define PWM_PCR_CH0EN_Pos                (0)                                               /*!< PWM_T::PCR: CH0EN Position                */
N#define PWM_PCR_CH0EN_Msk                (0x1ul << PWM_PCR_CH0EN_Pos)                      /*!< PWM_T::PCR: CH0EN Mask                    */
N
N#define PWM_PCR_DB_MOD_Pos               (1)                                               /*!< PWM_T::PCR: DB_MODE Position              */
N#define PWM_PCR_DB_MOD_Msk               (0x1ul << PWM_PCR_DB_MOD_Pos)                     /*!< PWM_T::PCR: DB_MODE Mask                  */
N
N#define PWM_PCR_CH0INV_Pos               (2)                                               /*!< PWM_T::PCR: CH0INV Position               */
N#define PWM_PCR_CH0INV_Msk               (0x1ul << PWM_PCR_CH0INV_Pos)                     /*!< PWM_T::PCR: CH0INV Mask                   */
N
N#define PWM_PCR_CH0MOD_Pos               (3)                                               /*!< PWM_T::PCR: CH0MOD Position               */
N#define PWM_PCR_CH0MOD_Msk               (0x1ul << PWM_PCR_CH0MOD_Pos)                     /*!< PWM_T::PCR: CH0MOD Mask                   */
N
N#define PWM_PCR_CH1EN_Pos                (4)                                               /*!< PWM_T::PCR: CH1EN Position                */
N#define PWM_PCR_CH1EN_Msk                (0x1ul << PWM_PCR_CH1EN_Pos)                      /*!< PWM_T::PCR: CH1EN Mask                    */
N
N#define PWM_PCR_CH1INV_Pos               (6)                                               /*!< PWM_T::PCR: CH1INV Position               */
N#define PWM_PCR_CH1INV_Msk               (0x1ul << PWM_PCR_CH1INV_Pos)                     /*!< PWM_T::PCR: CH1INV Mask                   */
N
N#define PWM_PCR_CH1MOD_Pos               (7)                                               /*!< PWM_T::PCR: CH1MOD Position               */
N#define PWM_PCR_CH1MOD_Msk               (0x1ul << PWM_PCR_CH1MOD_Pos)                     /*!< PWM_T::PCR: CH1MOD Mask                   */
N
N#define PWM_PCR_CH2EN_Pos                (8)                                               /*!< PWM_T::PCR: CH2EN Position                */
N#define PWM_PCR_CH2EN_Msk                (0x1ul << PWM_PCR_CH2EN_Pos)                      /*!< PWM_T::PCR: CH2EN Mask                    */
N
N#define PWM_PCR_CH2INV_Pos               (10)                                              /*!< PWM_T::PCR: CH2INV Position               */
N#define PWM_PCR_CH2INV_Msk               (0x1ul << PWM_PCR_CH2INV_Pos)                     /*!< PWM_T::PCR: CH2INV Mask                   */
N
N#define PWM_PCR_CH2MOD_Pos               (11)                                              /*!< PWM_T::PCR: CH2MOD Position               */
N#define PWM_PCR_CH2MOD_Msk               (0x1ul << PWM_PCR_CH2MOD_Pos)                     /*!< PWM_T::PCR: CH2MOD Mask                   */
N
N#define PWM_PCR_CH3EN_Pos                (12)                                              /*!< PWM_T::PCR: CH3EN Position                */
N#define PWM_PCR_CH3EN_Msk                (0x1ul << PWM_PCR_CH3EN_Pos)                      /*!< PWM_T::PCR: CH3EN Mask                    */
N
N#define PWM_PCR_CH3INV_Pos               (14)                                              /*!< PWM_T::PCR: CH3INV Position               */
N#define PWM_PCR_CH3INV_Msk               (0x1ul << PWM_PCR_CH3INV_Pos)                     /*!< PWM_T::PCR: CH3INV Mask                   */
N
N#define PWM_PCR_CH3MOD_Pos               (15)                                              /*!< PWM_T::PCR: CH3MOD Position               */
N#define PWM_PCR_CH3MOD_Msk               (0x1ul << PWM_PCR_CH3MOD_Pos)                     /*!< PWM_T::PCR: CH3MOD Mask                   */
N
N#define PWM_PCR_CH4EN_Pos                (16)                                              /*!< PWM_T::PCR: CH4EN Position                */
N#define PWM_PCR_CH4EN_Msk                (0x1ul << PWM_PCR_CH4EN_Pos)                      /*!< PWM_T::PCR: CH4EN Mask                    */
N
N#define PWM_PCR_CH4INV_Pos               (18)                                              /*!< PWM_T::PCR: CH4INV Position               */
N#define PWM_PCR_CH4INV_Msk               (0x1ul << PWM_PCR_CH4INV_Pos)                     /*!< PWM_T::PCR: CH4INV Mask                   */
N
N#define PWM_PCR_CH4MOD_Pos               (19)                                              /*!< PWM_T::PCR: CH4MOD Position               */
N#define PWM_PCR_CH4MOD_Msk               (0x1ul << PWM_PCR_CH4MOD_Pos)                     /*!< PWM_T::PCR: CH4MOD Mask                   */
N
N#define PWM_PCR_CH5EN_Pos                (20)                                              /*!< PWM_T::PCR: CH5EN Position                */
N#define PWM_PCR_CH5EN_Msk                (0x1ul << PWM_PCR_CH5EN_Pos)                      /*!< PWM_T::PCR: CH5EN Mask                    */
N
N#define PWM_PCR_CH5INV_Pos               (22)                                              /*!< PWM_T::PCR: CH5INV Position               */
N#define PWM_PCR_CH5INV_Msk               (0x1ul << PWM_PCR_CH5INV_Pos)                     /*!< PWM_T::PCR: CH5INV Mask                   */
N
N#define PWM_PCR_CH5MOD_Pos               (23)                                              /*!< PWM_T::PCR: CH5MOD Position               */
N#define PWM_PCR_CH5MOD_Msk               (0x1ul << PWM_PCR_CH5MOD_Pos)                     /*!< PWM_T::PCR: CH5MOD Mask                   */
N
N#define PWM_PCR_DZEN01_Pos               (24)                                              /*!< PWM_T::PCR: DZEN01 Position               */
N#define PWM_PCR_DZEN01_Msk               (0x1ul << PWM_PCR_DZEN01_Pos)                     /*!< PWM_T::PCR: DZEN01 Mask                   */
N
N#define PWM_PCR_DZEN23_Pos               (25)                                              /*!< PWM_T::PCR: DZEN23 Position               */
N#define PWM_PCR_DZEN23_Msk               (0x1ul << PWM_PCR_DZEN23_Pos)                     /*!< PWM_T::PCR: DZEN23 Mask                   */
N
N#define PWM_PCR_DZEN45_Pos               (26)                                              /*!< PWM_T::PCR: DZEN45 Position               */
N#define PWM_PCR_DZEN45_Msk               (0x1ul << PWM_PCR_DZEN45_Pos)                     /*!< PWM_T::PCR: DZEN45 Mask                   */
N
N#define PWM_PCR_CLRPWM_Pos               (27)                                              /*!< PWM_T::PCR: CLRPWM Position               */
N#define PWM_PCR_CLRPWM_Msk               (0x1ul << PWM_PCR_CLRPWM_Pos)                     /*!< PWM_T::PCR: CLRPWM Mask                   */
N
N#define PWM_PCR_PWMMOD_Pos               (28)                                              /*!< PWM_T::PCR: PWMMOD Position               */
N#define PWM_PCR_PWMMOD_Msk               (0x3ul << PWM_PCR_PWMMOD_Pos)                     /*!< PWM_T::PCR: PWMMOD Mask                   */
N
N#define PWM_PCR_GRP_Pos                  (30)                                              /*!< PWM_T::PCR: GRP Position                  */
N#define PWM_PCR_GRP_Msk                  (0x1ul << PWM_PCR_GRP_Pos)                        /*!< PWM_T::PCR: GRP Mask                      */
N
N#define PWM_PCR_PWMTYPE_Pos              (31)                                              /*!< PWM_T::PCR: PWMTYPE Position              */
N#define PWM_PCR_PWMTYPE_Msk              (0x1ul << PWM_PCR_PWMTYPE_Pos)                    /*!< PWM_T::PCR: PWMTYPE Mask                  */
N
N#define PWM_CNR_CNR_Pos                  0                                                 /*!< PWM CNR::CNR Position                     */
N#define PWM_CNR_CNR_Msk                  (0xfffful << PWM_CNR_CNR_Pos)                     /*!< PWM CNR::CNR Mask                         */
N
N#define PWM_CMR_CMR_Pos                  0                                                 /*!< PWM CMR::CMR Position                     */
N#define PWM_CMR_CMR_Msk                  (0xfffful << PWM_CMR_CMR_Pos)                     /*!< PWM CMR::CMR Mask                         */
N
N#define PWM_PIER_PWMPIE0_Pos             (0)                                               /*!< PWM_T::PIER: PWMPIE0 Position             */
N#define PWM_PIER_PWMPIE0_Msk             (0x1ul << PWM_PIER_PWMPIE0_Pos)                   /*!< PWM_T::PIER: PWMPIE0 Mask                 */
N
N#define PWM_PIER_PWMPIE1_Pos             (1)                                               /*!< PWM_T::PIER: PWMPIE1 Position             */
N#define PWM_PIER_PWMPIE1_Msk             (0x1ul << PWM_PIER_PWMPIE1_Pos)                   /*!< PWM_T::PIER: PWMPIE1 Mask                 */
N
N#define PWM_PIER_PWMPIE2_Pos             (2)                                               /*!< PWM_T::PIER: PWMPIE2 Position             */
N#define PWM_PIER_PWMPIE2_Msk             (0x1ul << PWM_PIER_PWMPIE2_Pos)                   /*!< PWM_T::PIER: PWMPIE2 Mask                 */
N
N#define PWM_PIER_PWMPIE3_Pos             (3)                                               /*!< PWM_T::PIER: PWMPIE3 Position             */
N#define PWM_PIER_PWMPIE3_Msk             (0x1ul << PWM_PIER_PWMPIE3_Pos)                   /*!< PWM_T::PIER: PWMPIE3 Mask                 */
N
N#define PWM_PIER_PWMPIE4_Pos             (4)                                               /*!< PWM_T::PIER: PWMPIE4 Position             */
N#define PWM_PIER_PWMPIE4_Msk             (0x1ul << PWM_PIER_PWMPIE4_Pos)                   /*!< PWM_T::PIER: PWMPIE4 Mask                 */
N
N#define PWM_PIER_PWMPIE5_Pos             (5)                                               /*!< PWM_T::PIER: PWMPIE5 Position             */
N#define PWM_PIER_PWMPIE5_Msk             (0x1ul << PWM_PIER_PWMPIE5_Pos)                   /*!< PWM_T::PIER: PWMPIE5 Mask                 */
N
N#define PWM_PIER_PWMDIE0_Pos             (8)                                               /*!< PWM_T::PIER: PWMDIE0 Position             */
N#define PWM_PIER_PWMDIE0_Msk             (0x1ul << PWM_PIER_PWMDIE0_Pos)                   /*!< PWM_T::PIER: PWMDIE0 Mask                 */
N
N#define PWM_PIER_PWMDIE1_Pos             (9)                                               /*!< PWM_T::PIER: PWMDIE1 Position             */
N#define PWM_PIER_PWMDIE1_Msk             (0x1ul << PWM_PIER_PWMDIE1_Pos)                   /*!< PWM_T::PIER: PWMDIE1 Mask                 */
N
N#define PWM_PIER_PWMDIE2_Pos             (10)                                              /*!< PWM_T::PIER: PWMDIE2 Position             */
N#define PWM_PIER_PWMDIE2_Msk             (0x1ul << PWM_PIER_PWMDIE2_Pos)                   /*!< PWM_T::PIER: PWMDIE2 Mask                 */
N
N#define PWM_PIER_PWMDIE3_Pos             (11)                                              /*!< PWM_T::PIER: PWMDIE3 Position             */
N#define PWM_PIER_PWMDIE3_Msk             (0x1ul << PWM_PIER_PWMDIE3_Pos)                   /*!< PWM_T::PIER: PWMDIE3 Mask                 */
N
N#define PWM_PIER_PWMDIE4_Pos             (12)                                              /*!< PWM_T::PIER: PWMDIE4 Position             */
N#define PWM_PIER_PWMDIE4_Msk             (0x1ul << PWM_PIER_PWMDIE4_Pos)                   /*!< PWM_T::PIER: PWMDIE4 Mask                 */
N
N#define PWM_PIER_PWMDIE5_Pos             (13)                                              /*!< PWM_T::PIER: PWMDIE5 Position             */
N#define PWM_PIER_PWMDIE5_Msk             (0x1ul << PWM_PIER_PWMDIE5_Pos)                   /*!< PWM_T::PIER: PWMDIE5 Mask                 */
N
N#define PWM_PIER_BRKIE_Pos               (16)                                              /*!< PWM_T::PIER: BRKIE Position               */
N#define PWM_PIER_BRKIE_Msk               (0x1ul << PWM_PIER_BRKIE_Pos)                     /*!< PWM_T::PIER: BRKIE Mask                   */
N
N#define PWM_PIER_INT_TYPE_Pos            (17)                                              /*!< PWM_T::PIER: INT_TYPE Position            */
N#define PWM_PIER_INT_TYPE_Msk            (0x1ul << PWM_PIER_INT_TYPE_Pos)                  /*!< PWM_T::PIER: INT_TYPE Mask                */
N
N#define PWM_PIIR_PWMPIF0_Pos             (0)                                               /*!< PWM_T::PIIR: PWMPIF0 Position             */
N#define PWM_PIIR_PWMPIF0_Msk             (0x1ul << PWM_PIIR_PWMPIF0_Pos)                   /*!< PWM_T::PIIR: PWMPIF0 Mask                 */
N
N#define PWM_PIIR_PWMPIF1_Pos             (1)                                               /*!< PWM_T::PIIR: PWMPIF1 Position             */
N#define PWM_PIIR_PWMPIF1_Msk             (0x1ul << PWM_PIIR_PWMPIF1_Pos)                   /*!< PWM_T::PIIR: PWMPIF1 Mask                 */
N
N#define PWM_PIIR_PWMPIF2_Pos             (2)                                               /*!< PWM_T::PIIR: PWMPIF2 Position             */
N#define PWM_PIIR_PWMPIF2_Msk             (0x1ul << PWM_PIIR_PWMPIF2_Pos)                   /*!< PWM_T::PIIR: PWMPIF2 Mask                 */
N
N#define PWM_PIIR_PWMPIF3_Pos             (3)                                               /*!< PWM_T::PIIR: PWMPIF3 Position             */
N#define PWM_PIIR_PWMPIF3_Msk             (0x1ul << PWM_PIIR_PWMPIF3_Pos)                   /*!< PWM_T::PIIR: PWMPIF3 Mask                 */
N
N#define PWM_PIIR_PWMPIF4_Pos             (4)                                               /*!< PWM_T::PIIR: PWMPIF4 Position             */
N#define PWM_PIIR_PWMPIF4_Msk             (0x1ul << PWM_PIIR_PWMPIF4_Pos)                   /*!< PWM_T::PIIR: PWMPIF4 Mask                 */
N
N#define PWM_PIIR_PWMPIF5_Pos             (5)                                               /*!< PWM_T::PIIR: PWMPIF5 Position             */
N#define PWM_PIIR_PWMPIF5_Msk             (0x1ul << PWM_PIIR_PWMPIF5_Pos)                   /*!< PWM_T::PIIR: PWMPIF5 Mask                 */
N
N#define PWM_PIIR_PWMDIF0_Pos             (8)                                               /*!< PWM_T::PIIR: PWMDIF0 Position             */
N#define PWM_PIIR_PWMDIF0_Msk             (0x1ul << PWM_PIIR_PWMDIF0_Pos)                   /*!< PWM_T::PIIR: PWMDIF0 Mask                 */
N
N#define PWM_PIIR_PWMDIF1_Pos             (9)                                               /*!< PWM_T::PIIR: PWMDIF1 Position             */
N#define PWM_PIIR_PWMDIF1_Msk             (0x1ul << PWM_PIIR_PWMDIF1_Pos)                   /*!< PWM_T::PIIR: PWMDIF1 Mask                 */
N
N#define PWM_PIIR_PWMDIF2_Pos             (10)                                              /*!< PWM_T::PIIR: PWMDIF2 Position             */
N#define PWM_PIIR_PWMDIF2_Msk             (0x1ul << PWM_PIIR_PWMDIF2_Pos)                   /*!< PWM_T::PIIR: PWMDIF2 Mask                 */
N
N#define PWM_PIIR_PWMDIF3_Pos             (11)                                              /*!< PWM_T::PIIR: PWMDIF3 Position             */
N#define PWM_PIIR_PWMDIF3_Msk             (0x1ul << PWM_PIIR_PWMDIF3_Pos)                   /*!< PWM_T::PIIR: PWMDIF3 Mask                 */
N
N#define PWM_PIIR_PWMDIF4_Pos             (12)                                              /*!< PWM_T::PIIR: PWMDIF4 Position             */
N#define PWM_PIIR_PWMDIF4_Msk             (0x1ul << PWM_PIIR_PWMDIF4_Pos)                   /*!< PWM_T::PIIR: PWMDIF4 Mask                 */
N
N#define PWM_PIIR_PWMDIF5_Pos             (13)                                              /*!< PWM_T::PIIR: PWMDIF5 Position             */
N#define PWM_PIIR_PWMDIF5_Msk             (0x1ul << PWM_PIIR_PWMDIF5_Pos)                   /*!< PWM_T::PIIR: PWMDIF5 Mask                 */
N
N#define PWM_PIIR_BKF0_Pos                (16)                                              /*!< PWM_T::PIIR: BKF0 Position                */
N#define PWM_PIIR_BKF0_Msk                (0x1ul << PWM_PIIR_BKF0_Pos)                      /*!< PWM_T::PIIR: BKF0 Mask                    */
N
N#define PWM_PIIR_BKF1_Pos                (17)                                              /*!< PWM_T::PIIR: BKF1 Position                */
N#define PWM_PIIR_BKF1_Msk                (0x1ul << PWM_PIIR_BKF1_Pos)                      /*!< PWM_T::PIIR: BKF1 Mask                    */
N
N#define PWM_POE_PWM0_Pos                 (0)                                               /*!< PWM_T::POE: PWM0 Position                 */
N#define PWM_POE_PWM0_Msk                 (0x1ul << PWM_POE_PWM0_Pos)                       /*!< PWM_T::POE: PWM0 Mask                     */
N
N#define PWM_POE_PWM1_Pos                 (1)                                               /*!< PWM_T::POE: PWM1 Position                 */
N#define PWM_POE_PWM1_Msk                 (0x1ul << PWM_POE_PWM1_Pos)                       /*!< PWM_T::POE: PWM1 Mask                     */
N
N#define PWM_POE_PWM2_Pos                 (2)                                               /*!< PWM_T::POE: PWM2 Position                 */
N#define PWM_POE_PWM2_Msk                 (0x1ul << PWM_POE_PWM2_Pos)                       /*!< PWM_T::POE: PWM2 Mask                     */
N
N#define PWM_POE_PWM3_Pos                 (3)                                               /*!< PWM_T::POE: PWM3 Position                 */
N#define PWM_POE_PWM3_Msk                 (0x1ul << PWM_POE_PWM3_Pos)                       /*!< PWM_T::POE: PWM3 Mask                     */
N
N#define PWM_POE_PWM4_Pos                 (4)                                               /*!< PWM_T::POE: PWM4 Position                 */
N#define PWM_POE_PWM4_Msk                 (0x1ul << PWM_POE_PWM4_Pos)                       /*!< PWM_T::POE: PWM4 Mask                     */
N
N#define PWM_POE_PWM5_Pos                 (5)                                               /*!< PWM_T::POE: PWM5 Position                 */
N#define PWM_POE_PWM5_Msk                 (0x1ul << PWM_POE_PWM5_Pos)                       /*!< PWM_T::POE: PWM5 Mask                     */
N
N#define PWM_PFBCON_BKEN0_Pos             (0)                                               /*!< PWM_T::PFBCON: BKEN0 Position             */
N#define PWM_PFBCON_BKEN0_Msk             (0x1ul << PWM_PFBCON_BKEN0_Pos)                   /*!< PWM_T::PFBCON: BKEN0 Mask                 */
N
N#define PWM_PFBCON_BKEN1_Pos             (1)                                               /*!< PWM_T::PFBCON: BKEN1 Position             */
N#define PWM_PFBCON_BKEN1_Msk             (0x1ul << PWM_PFBCON_BKEN1_Pos)                   /*!< PWM_T::PFBCON: BKEN1 Mask                 */
N
N#define PWM_PFBCON_CPO0BKEN_Pos          (2)                                               /*!< PWM_T::PFBCON: CPO0BKEN Position          */
N#define PWM_PFBCON_CPO0BKEN_Msk          (0x1ul << PWM_PFBCON_CPO0BKEN_Pos)                /*!< PWM_T::PFBCON: CPO0BKEN Mask              */
N
N#define PWM_PFBCON_CPO1BKEN_Pos          (3)                                               /*!< PWM_T::PFBCON: CPO1BKEN Position          */
N#define PWM_PFBCON_CPO1BKEN_Msk          (0x1ul << PWM_PFBCON_CPO1BKEN_Pos)                /*!< PWM_T::PFBCON: CPO1BKEN Mask              */
N
N#define PWM_PFBCON_BKF_Pos               (7)                                               /*!< PWM_T::PFBCON: BKF Position               */
N#define PWM_PFBCON_BKF_Msk               (0x1ul << PWM_PFBCON_BKF_Pos)                     /*!< PWM_T::PFBCON: BKF Mask                   */
N
N#define PWM_PFBCON_PWMBKO0_Pos           (24)                                              /*!< PWM_T::PFBCON: PWMBKO0 Position           */
N#define PWM_PFBCON_PWMBKO0_Msk           (0x1ul << PWM_PFBCON_PWMBKO0_Pos)                 /*!< PWM_T::PFBCON: PWMBKO0 Mask               */
N
N#define PWM_PFBCON_PWMBKO1_Pos           (25)                                              /*!< PWM_T::PFBCON: PWMBKO1 Position           */
N#define PWM_PFBCON_PWMBKO1_Msk           (0x1ul << PWM_PFBCON_PWMBKO1_Pos)                 /*!< PWM_T::PFBCON: PWMBKO1 Mask               */
N
N#define PWM_PFBCON_PWMBKO2_Pos           (26)                                              /*!< PWM_T::PFBCON: PWMBKO2 Position           */
N#define PWM_PFBCON_PWMBKO2_Msk           (0x1ul << PWM_PFBCON_PWMBKO2_Pos)                 /*!< PWM_T::PFBCON: PWMBKO2 Mask               */
N
N#define PWM_PFBCON_PWMBKO3_Pos           (27)                                              /*!< PWM_T::PFBCON: PWMBKO3 Position           */
N#define PWM_PFBCON_PWMBKO3_Msk           (0x1ul << PWM_PFBCON_PWMBKO3_Pos)                 /*!< PWM_T::PFBCON: PWMBKO3 Mask               */
N
N#define PWM_PFBCON_PWMBKO4_Pos           (28)                                              /*!< PWM_T::PFBCON: PWMBKO4 Position           */
N#define PWM_PFBCON_PWMBKO4_Msk           (0x1ul << PWM_PFBCON_PWMBKO4_Pos)                 /*!< PWM_T::PFBCON: PWMBKO4 Mask               */
N
N#define PWM_PFBCON_PWMBKO5_Pos           (29)                                              /*!< PWM_T::PFBCON: PWMBKO5 Position           */
N#define PWM_PFBCON_PWMBKO5_Msk           (0x1ul << PWM_PFBCON_PWMBKO5_Pos)                 /*!< PWM_T::PFBCON: PWMBKO5 Mask               */
N
N#define PWM_PFBCON_D6BKO6_Pos            (30)                                              /*!< PWM_T::PFBCON: D6BKO6 Position            */
N#define PWM_PFBCON_D6BKO6_Msk            (0x1ul << PWM_PFBCON_D6BKO6_Pos)                  /*!< PWM_T::PFBCON: D6BKO6 Mask                */
N
N#define PWM_PFBCON_D7BKO7_Pos            (31)                                              /*!< PWM_T::PFBCON: D7BKO7 Position            */
N#define PWM_PFBCON_D7BKO7_Msk            (0x1ul << PWM_PFBCON_D7BKO7_Pos)                  /*!< PWM_T::PFBCON: D7BKO7 Mask                */
N
N#define PWM_DZIR_DZI01_Pos               (0)                                               /*!< PWM_T::PDZIR: DZI01 Position              */
N#define PWM_DZIR_DZI01_Msk               (0xfful << PWM_DZIR_DZI01_Pos)                    /*!< PWM_T::PDZIR: DZI01 Mask                  */
N
N#define PWM_DZIR_DZI23_Pos               (8)                                               /*!< PWM_T::PDZIR: DZI23 Position              */
N#define PWM_DZIR_DZI23_Msk               (0xfful << PWM_DZIR_DZI23_Pos)                    /*!< PWM_T::PDZIR: DZI23 Mask                  */
N
N#define PWM_DZIR_DZI45_Pos               (16)                                              /*!< PWM_T::PDZIR: DZI45 Position              */
N#define PWM_DZIR_DZI45_Msk               (0xfful << PWM_DZIR_DZI45_Pos)                    /*!< PWM_T::PDZIR: DZI45 Mask                  */
N
N#define PWM_TRGCON0_CM0TRGREN_Pos        (0)                                               /*!< PWM_T::TRGCON0: CM0TRGREN Position        */
N#define PWM_TRGCON0_CM0TRGREN_Msk        (0x1ul << PWM_TRGCON0_CM0TRGREN_Pos)              /*!< PWM_T::TRGCON0: CM0TRGREN Mask            */
N
N#define PWM_TRGCON0_CNT0TRGEN_Pos        (1)                                               /*!< PWM_T::TRGCON0: CNT0TRGEN Position        */
N#define PWM_TRGCON0_CNT0TRGEN_Msk        (0x1ul << PWM_TRGCON0_CNT0TRGEN_Pos)              /*!< PWM_T::TRGCON0: CNT0TRGEN Mask            */
N
N#define PWM_TRGCON0_CM0TRGFEN_Pos        (2)                                               /*!< PWM_T::TRGCON0: CM0TRGFEN Position        */
N#define PWM_TRGCON0_CM0TRGFEN_Msk        (0x1ul << PWM_TRGCON0_CM0TRGFEN_Pos)              /*!< PWM_T::TRGCON0: CM0TRGFEN Mask            */
N
N#define PWM_TRGCON0_P0TRGEN_Pos          (3)                                               /*!< PWM_T::TRGCON0: P0TRGEN Position          */
N#define PWM_TRGCON0_P0TRGEN_Msk          (0x1ul << PWM_TRGCON0_P0TRGEN_Pos)                /*!< PWM_T::TRGCON0: P0TRGEN Mask              */
N
N#define PWM_TRGCON0_CM1TRGREN_Pos        (8)                                               /*!< PWM_T::TRGCON0: CM1TRGREN Position        */
N#define PWM_TRGCON0_CM1TRGREN_Msk        (0x1ul << PWM_TRGCON0_CM1TRGREN_Pos)              /*!< PWM_T::TRGCON0: CM1TRGREN Mask            */
N
N#define PWM_TRGCON0_CNT1TRGEN_Pos        (9)                                               /*!< PWM_T::TRGCON0: CNT1TRGEN Position        */
N#define PWM_TRGCON0_CNT1TRGEN_Msk        (0x1ul << PWM_TRGCON0_CNT1TRGEN_Pos)              /*!< PWM_T::TRGCON0: CNT1TRGEN Mask            */
N
N#define PWM_TRGCON0_CM1TRGFEN_Pos        (10)                                              /*!< PWM_T::TRGCON0: CM1TRGFEN Position        */
N#define PWM_TRGCON0_CM1TRGFEN_Msk        (0x1ul << PWM_TRGCON0_CM1TRGFEN_Pos)              /*!< PWM_T::TRGCON0: CM1TRGFEN Mask            */
N
N#define PWM_TRGCON0_P1TRGEN_Pos          (11)                                              /*!< PWM_T::TRGCON0: P1TRGEN Position          */
N#define PWM_TRGCON0_P1TRGEN_Msk          (0x1ul << PWM_TRGCON0_P1TRGEN_Pos)                /*!< PWM_T::TRGCON0: P1TRGEN Mask              */
N
N#define PWM_TRGCON0_CM2TRGREN_Pos        (16)                                              /*!< PWM_T::TRGCON0: CM2TRGREN Position        */
N#define PWM_TRGCON0_CM2TRGREN_Msk        (0x1ul << PWM_TRGCON0_CM2TRGREN_Pos)              /*!< PWM_T::TRGCON0: CM2TRGREN Mask            */
N
N#define PWM_TRGCON0_CNT2TRGEN_Pos        (17)                                              /*!< PWM_T::TRGCON0: CNT2TRGEN Position        */
N#define PWM_TRGCON0_CNT2TRGEN_Msk        (0x1ul << PWM_TRGCON0_CNT2TRGEN_Pos)              /*!< PWM_T::TRGCON0: CNT2TRGEN Mask            */
N
N#define PWM_TRGCON0_CM2TRGFEN_Pos        (18)                                              /*!< PWM_T::TRGCON0: CM2TRGFEN Position        */
N#define PWM_TRGCON0_CM2TRGFEN_Msk        (0x1ul << PWM_TRGCON0_CM2TRGFEN_Pos)              /*!< PWM_T::TRGCON0: CM2TRGFEN Mask            */
N
N#define PWM_TRGCON0_P2TRGEN_Pos          (19)                                              /*!< PWM_T::TRGCON0: P2TRGEN Position          */
N#define PWM_TRGCON0_P2TRGEN_Msk          (0x1ul << PWM_TRGCON0_P2TRGEN_Pos)                /*!< PWM_T::TRGCON0: P2TRGEN Mask              */
N
N#define PWM_TRGCON0_CM3TRGREN_Pos        (24)                                              /*!< PWM_T::TRGCON0: CM3TRGREN Position        */
N#define PWM_TRGCON0_CM3TRGREN_Msk        (0x1ul << PWM_TRGCON0_CM3TRGREN_Pos)              /*!< PWM_T::TRGCON0: CM3TRGREN Mask            */
N
N#define PWM_TRGCON0_CNT3TRGEN_Pos        (25)                                              /*!< PWM_T::TRGCON0: CNT3TRGEN Position        */
N#define PWM_TRGCON0_CNT3TRGEN_Msk        (0x1ul << PWM_TRGCON0_CNT3TRGEN_Pos)              /*!< PWM_T::TRGCON0: CNT3TRGEN Mask            */
N
N#define PWM_TRGCON0_CM3TRGFEN_Pos        (26)                                              /*!< PWM_T::TRGCON0: CM3TRGFEN Position        */
N#define PWM_TRGCON0_CM3TRGFEN_Msk        (0x1ul << PWM_TRGCON0_CM3TRGFEN_Pos)              /*!< PWM_T::TRGCON0: CM3TRGFEN Mask            */
N
N#define PWM_TRGCON0_P3TRGEN_Pos          (27)                                              /*!< PWM_T::TRGCON0: P3TRGEN Position          */
N#define PWM_TRGCON0_P3TRGEN_Msk          (0x1ul << PWM_TRGCON0_P3TRGEN_Pos)                /*!< PWM_T::TRGCON0: P3TRGEN Mask              */
N
N#define PWM_TRGCON1_CM4TRGREN_Pos        (0)                                               /*!< PWM_T::TRGCON1: CM4TRGREN Position        */
N#define PWM_TRGCON1_CM4TRGREN_Msk        (0x1ul << PWM_TRGCON1_CM4TRGREN_Pos)              /*!< PWM_T::TRGCON1: CM4TRGREN Mask            */
N
N#define PWM_TRGCON1_CNT4TRGEN_Pos        (1)                                               /*!< PWM_T::TRGCON1: CNT4TRGEN Position        */
N#define PWM_TRGCON1_CNT4TRGEN_Msk        (0x1ul << PWM_TRGCON1_CNT4TRGEN_Pos)              /*!< PWM_T::TRGCON1: CNT4TRGEN Mask            */
N
N#define PWM_TRGCON1_CM4TRGFEN_Pos        (2)                                               /*!< PWM_T::TRGCON1: CM4TRGFEN Position        */
N#define PWM_TRGCON1_CM4TRGFEN_Msk        (0x1ul << PWM_TRGCON1_CM4TRGFEN_Pos)              /*!< PWM_T::TRGCON1: CM4TRGFEN Mask            */
N
N#define PWM_TRGCON1_P4TRGEN_Pos          (3)                                               /*!< PWM_T::TRGCON1: P4TRGEN Position          */
N#define PWM_TRGCON1_P4TRGEN_Msk          (0x1ul << PWM_TRGCON1_P4TRGEN_Pos)                /*!< PWM_T::TRGCON1: P4TRGEN Mask              */
N
N#define PWM_TRGCON1_CM5TRGREN_Pos        (8)                                               /*!< PWM_T::TRGCON1: CM5TRGREN Position        */
N#define PWM_TRGCON1_CM5TRGREN_Msk        (0x1ul << PWM_TRGCON1_CM5TRGREN_Pos)              /*!< PWM_T::TRGCON1: CM5TRGREN Mask            */
N
N#define PWM_TRGCON1_CNT5TRGEN_Pos        (9)                                               /*!< PWM_T::TRGCON1: CNT5TRGEN Position        */
N#define PWM_TRGCON1_CNT5TRGEN_Msk        (0x1ul << PWM_TRGCON1_CNT5TRGEN_Pos)              /*!< PWM_T::TRGCON1: CNT5TRGEN Mask            */
N
N#define PWM_TRGCON1_CM5TRGFEN_Pos        (10)                                              /*!< PWM_T::TRGCON1: CM5TRGFEN Position        */
N#define PWM_TRGCON1_CM5TRGFEN_Msk        (0x1ul << PWM_TRGCON1_CM5TRGFEN_Pos)              /*!< PWM_T::TRGCON1: CM5TRGFEN Mask            */
N
N#define PWM_TRGCON1_P5TRGEN_Pos          (11)                                              /*!< PWM_T::TRGCON1: P5TRGEN Position          */
N#define PWM_TRGCON1_P5TRGEN_Msk          (0x1ul << PWM_TRGCON1_P5TRGEN_Pos)                /*!< PWM_T::TRGCON1: P5TRGEN Mask              */
N
N#define PWM_TRGSTS0_CMR0FLAG_R_Pos       (0)                                               /*!< PWM_T::TRGSTS0: CMR0FLAG_R Position       */
N#define PWM_TRGSTS0_CMR0FLAG_R_Msk       (0x1ul << PWM_TRGSTS0_CMR0FLAG_R_Pos)             /*!< PWM_T::TRGSTS0: CMR0FLAG_R Mask           */
N
N#define PWM_TRGSTS0_CNT0FLAG_Pos         (1)                                               /*!< PWM_T::TRGSTS0: CNT0FLAG Position         */
N#define PWM_TRGSTS0_CNT0FLAG_Msk         (0x1ul << PWM_TRGSTS0_CNT0FLAG_Pos)               /*!< PWM_T::TRGSTS0: CNT0FLAG Mask             */
N
N#define PWM_TRGSTS0_CMR0FLAG_F_Pos       (2)                                               /*!< PWM_T::TRGSTS0: CMR0FLAG_F Position       */
N#define PWM_TRGSTS0_CMR0FLAG_F_Msk       (0x1ul << PWM_TRGSTS0_CMR0FLAG_F_Pos)             /*!< PWM_T::TRGSTS0: CMR0FLAG_F Mask           */
N
N#define PWM_TRGSTS0_PERID0FLAG_Pos       (3)                                               /*!< PWM_T::TRGSTS0: PERID0FLAG Position       */
N#define PWM_TRGSTS0_PERID0FLAG_Msk       (0x1ul << PWM_TRGSTS0_PERID0FLAG_Pos)             /*!< PWM_T::TRGSTS0: PERID0FLAG Mask           */
N
N#define PWM_TRGSTS0_CMR1FLAG_R_Pos       (8)                                               /*!< PWM_T::TRGSTS0: CMR1FLAG_R Position       */
N#define PWM_TRGSTS0_CMR1FLAG_R_Msk       (0x1ul << PWM_TRGSTS0_CMR1FLAG_R_Pos)             /*!< PWM_T::TRGSTS0: CMR1FLAG_R Mask           */
N
N#define PWM_TRGSTS0_CNT1FLAG_Pos         (9)                                               /*!< PWM_T::TRGSTS0: CNT1FLAG Position         */
N#define PWM_TRGSTS0_CNT1FLAG_Msk         (0x1ul << PWM_TRGSTS0_CNT1FLAG_Pos)               /*!< PWM_T::TRGSTS0: CNT1FLAG Mask             */
N
N#define PWM_TRGSTS0_CMR1FLAG_F_Pos       (10)                                              /*!< PWM_T::TRGSTS0: CMR1FLAG_F Position       */
N#define PWM_TRGSTS0_CMR1FLAG_F_Msk       (0x1ul << PWM_TRGSTS0_CMR1FLAG_F_Pos)             /*!< PWM_T::TRGSTS0: CMR1FLAG_F Mask           */
N
N#define PWM_TRGSTS0_PERID1FLAG_Pos       (11)                                              /*!< PWM_T::TRGSTS0: PERID1FLAG Position       */
N#define PWM_TRGSTS0_PERID1FLAG_Msk       (0x1ul << PWM_TRGSTS0_PERID1FLAG_Pos)             /*!< PWM_T::TRGSTS0: PERID1FLAG Mask           */
N
N#define PWM_TRGSTS0_CMR2FLAG_R_Pos       (16)                                              /*!< PWM_T::TRGSTS0: CMR2FLAG_R Position       */
N#define PWM_TRGSTS0_CMR2FLAG_R_Msk       (0x1ul << PWM_TRGSTS0_CMR2FLAG_R_Pos)             /*!< PWM_T::TRGSTS0: CMR2FLAG_R Mask           */
N
N#define PWM_TRGSTS0_CNT2FLAG_Pos         (17)                                              /*!< PWM_T::TRGSTS0: CNT2FLAG Position         */
N#define PWM_TRGSTS0_CNT2FLAG_Msk         (0x1ul << PWM_TRGSTS0_CNT2FLAG_Pos)               /*!< PWM_T::TRGSTS0: CNT2FLAG Mask             */
N
N#define PWM_TRGSTS0_CMR2FLAG_F_Pos       (18)                                              /*!< PWM_T::TRGSTS0: CMR2FLAG_F Position       */
N#define PWM_TRGSTS0_CMR2FLAG_F_Msk       (0x1ul << PWM_TRGSTS0_CMR2FLAG_F_Pos)             /*!< PWM_T::TRGSTS0: CMR2FLAG_F Mask           */
N
N#define PWM_TRGSTS0_PERID2FLAG_Pos       (19)                                              /*!< PWM_T::TRGSTS0: PERID2FLAG Position       */
N#define PWM_TRGSTS0_PERID2FLAG_Msk       (0x1ul << PWM_TRGSTS0_PERID2FLAG_Pos)             /*!< PWM_T::TRGSTS0: PERID2FLAG Mask           */
N
N#define PWM_TRGSTS0_CMR3FLAG_R_Pos       (24)                                              /*!< PWM_T::TRGSTS0: CMR3FLAG_R Position       */
N#define PWM_TRGSTS0_CMR3FLAG_R_Msk       (0x1ul << PWM_TRGSTS0_CMR3FLAG_R_Pos)             /*!< PWM_T::TRGSTS0: CMR3FLAG_R Mask           */
N
N#define PWM_TRGSTS0_CNT3FLAG_Pos         (25)                                              /*!< PWM_T::TRGSTS0: CNT3FLAG Position         */
N#define PWM_TRGSTS0_CNT3FLAG_Msk         (0x1ul << PWM_TRGSTS0_CNT3FLAG_Pos)               /*!< PWM_T::TRGSTS0: CNT3FLAG Mask             */
N
N#define PWM_TRGSTS0_CMR3FLAG_F_Pos       (26)                                              /*!< PWM_T::TRGSTS0: CMR3FLAG_F Position       */
N#define PWM_TRGSTS0_CMR3FLAG_F_Msk       (0x1ul << PWM_TRGSTS0_CMR3FLAG_F_Pos)             /*!< PWM_T::TRGSTS0: CMR3FLAG_F Mask           */
N
N#define PWM_TRGSTS0_PERID3FLAG_Pos       (27)                                              /*!< PWM_T::TRGSTS0: PERID3FLAG Position       */
N#define PWM_TRGSTS0_PERID3FLAG_Msk       (0x1ul << PWM_TRGSTS0_PERID3FLAG_Pos)             /*!< PWM_T::TRGSTS0: PERID3FLAG Mask           */
N
N#define PWM_TRGSTS1_CMR4FLAG_R_Pos       (0)                                               /*!< PWM_T::TRGSTS1: CMR4FLAG_R Position       */
N#define PWM_TRGSTS1_CMR4FLAG_R_Msk       (0x1ul << PWM_TRGSTS1_CMR4FLAG_R_Pos)             /*!< PWM_T::TRGSTS1: CMR4FLAG_R Mask           */
N
N#define PWM_TRGSTS1_CNT4FLAG_Pos         (1)                                               /*!< PWM_T::TRGSTS1: CNT4FLAG Position         */
N#define PWM_TRGSTS1_CNT4FLAG_Msk         (0x1ul << PWM_TRGSTS1_CNT4FLAG_Pos)               /*!< PWM_T::TRGSTS1: CNT4FLAG Mask             */
N
N#define PWM_TRGSTS1_CMR4FLAG_F_Pos       (2)                                               /*!< PWM_T::TRGSTS1: CMR4FLAG_F Position       */
N#define PWM_TRGSTS1_CMR4FLAG_F_Msk       (0x1ul << PWM_TRGSTS1_CMR4FLAG_F_Pos)             /*!< PWM_T::TRGSTS1: CMR4FLAG_F Mask           */
N
N#define PWM_TRGSTS1_PERID4FLAG_Pos       (3)                                               /*!< PWM_T::TRGSTS1: PERID4FLAG Position       */
N#define PWM_TRGSTS1_PERID4FLAG_Msk       (0x1ul << PWM_TRGSTS1_PERID4FLAG_Pos)             /*!< PWM_T::TRGSTS1: PERID4FLAG Mask           */
N
N#define PWM_TRGSTS1_CMR5FLAG_R_Pos       (8)                                               /*!< PWM_T::TRGSTS1: CMR5FLAG_R Position       */
N#define PWM_TRGSTS1_CMR5FLAG_R_Msk       (0x1ul << PWM_TRGSTS1_CMR5FLAG_R_Pos)             /*!< PWM_T::TRGSTS1: CMR5FLAG_R Mask           */
N
N#define PWM_TRGSTS1_CNT5FLAG_Pos         (9)                                               /*!< PWM_T::TRGSTS1: CNT5FLAG Position         */
N#define PWM_TRGSTS1_CNT5FLAG_Msk         (0x1ul << PWM_TRGSTS1_CNT5FLAG_Pos)               /*!< PWM_T::TRGSTS1: CNT5FLAG Mask             */
N
N#define PWM_TRGSTS1_CMR5FLAG_F_Pos       (10)                                              /*!< PWM_T::TRGSTS1: CMR5FLAG_F Position       */
N#define PWM_TRGSTS1_CMR5FLAG_F_Msk       (0x1ul << PWM_TRGSTS1_CMR5FLAG_F_Pos)             /*!< PWM_T::TRGSTS1: CMR5FLAG_F Mask           */
N
N#define PWM_TRGSTS1_PERID5FLAG_Pos       (11)                                              /*!< PWM_T::TRGSTS1: PERID5FLAG Position       */
N#define PWM_TRGSTS1_PERID5FLAG_Msk       (0x1ul << PWM_TRGSTS1_PERID5FLAG_Pos)             /*!< PWM_T::TRGSTS1: PERID5FLAG Mask           */
N
N#define PWM_PHCHG_D0_Pos                 (0)                                               /*!< PWM_T::PHCHG: D0 Position                 */
N#define PWM_PHCHG_D0_Msk                 (0x1ul << PWM_PHCHG_D0_Pos)                       /*!< PWM_T::PHCHG: D0 Mask                     */
N
N#define PWM_PHCHG_D1_Pos                 (1)                                               /*!< PWM_T::PHCHG: D1 Position                 */
N#define PWM_PHCHG_D1_Msk                 (0x1ul << PWM_PHCHG_D1_Pos)                       /*!< PWM_T::PHCHG: D1 Mask                     */
N
N#define PWM_PHCHG_D2_Pos                 (2)                                               /*!< PWM_T::PHCHG: D2 Position                 */
N#define PWM_PHCHG_D2_Msk                 (0x1ul << PWM_PHCHG_D2_Pos)                       /*!< PWM_T::PHCHG: D2 Mask                     */
N
N#define PWM_PHCHG_D3_Pos                 (3)                                               /*!< PWM_T::PHCHG: D3 Position                 */
N#define PWM_PHCHG_D3_Msk                 (0x1ul << PWM_PHCHG_D3_Pos)                       /*!< PWM_T::PHCHG: D3 Mask                     */
N
N#define PWM_PHCHG_D4_Pos                 (4)                                               /*!< PWM_T::PHCHG: D4 Position                 */
N#define PWM_PHCHG_D4_Msk                 (0x1ul << PWM_PHCHG_D4_Pos)                       /*!< PWM_T::PHCHG: D4 Mask                     */
N
N#define PWM_PHCHG_D5_Pos                 (5)                                               /*!< PWM_T::PHCHG: D5 Position                 */
N#define PWM_PHCHG_D5_Msk                 (0x1ul << PWM_PHCHG_D5_Pos)                       /*!< PWM_T::PHCHG: D5 Mask                     */
N
N#define PWM_PHCHG_D6_Pos                 (6)                                               /*!< PWM_T::PHCHG: D6 Position                 */
N#define PWM_PHCHG_D6_Msk                 (0x1ul << PWM_PHCHG_D6_Pos)                       /*!< PWM_T::PHCHG: D6 Mask                     */
N
N#define PWM_PHCHG_D7_Pos                 (7)                                               /*!< PWM_T::PHCHG: D7 Position                 */
N#define PWM_PHCHG_D7_Msk                 (0x1ul << PWM_PHCHG_D7_Pos)                       /*!< PWM_T::PHCHG: D7 Mask                     */
N
N#define PWM_PHCHG_PWM0_Pos               (8)                                               /*!< PWM_T::PHCHG: PWM0 Position               */
N#define PWM_PHCHG_PWM0_Msk               (0x1ul << PWM_PHCHG_PWM0_Pos)                     /*!< PWM_T::PHCHG: PWM0 Mask                   */
N
N#define PWM_PHCHG_PWM1_Pos               (9)                                               /*!< PWM_T::PHCHG: PWM1 Position               */
N#define PWM_PHCHG_PWM1_Msk               (0x1ul << PWM_PHCHG_PWM1_Pos)                     /*!< PWM_T::PHCHG: PWM1 Mask                   */
N
N#define PWM_PHCHG_PWM2_Pos               (10)                                              /*!< PWM_T::PHCHG: PWM2 Position               */
N#define PWM_PHCHG_PWM2_Msk               (0x1ul << PWM_PHCHG_PWM2_Pos)                     /*!< PWM_T::PHCHG: PWM2 Mask                   */
N
N#define PWM_PHCHG_PWM3_Pos               (11)                                              /*!< PWM_T::PHCHG: PWM3 Position               */
N#define PWM_PHCHG_PWM3_Msk               (0x1ul << PWM_PHCHG_PWM3_Pos)                     /*!< PWM_T::PHCHG: PWM3 Mask                   */
N
N#define PWM_PHCHG_PWM4_Pos               (12)                                              /*!< PWM_T::PHCHG: PWM4 Position               */
N#define PWM_PHCHG_PWM4_Msk               (0x1ul << PWM_PHCHG_PWM4_Pos)                     /*!< PWM_T::PHCHG: PWM4 Mask                   */
N
N#define PWM_PHCHG_PWM5_Pos               (13)                                              /*!< PWM_T::PHCHG: PWM5 Position               */
N#define PWM_PHCHG_PWM5_Msk               (0x1ul << PWM_PHCHG_PWM5_Pos)                     /*!< PWM_T::PHCHG: PWM5 Mask                   */
N
N#define PWM_PHCHG_ACCNT0_Pos             (14)                                              /*!< PWM_T::PHCHG: ACCNT0 Position             */
N#define PWM_PHCHG_ACCNT0_Msk             (0x1ul << PWM_PHCHG_ACCNT0_Pos)                   /*!< PWM_T::PHCHG: ACCNT0 Mask                 */
N
N#define PWM_PHCHG_ACCNT1_Pos             (15)                                              /*!< PWM_T::PHCHG: ACCNT1 Position             */
N#define PWM_PHCHG_ACCNT1_Msk             (0x1ul << PWM_PHCHG_ACCNT1_Pos)                   /*!< PWM_T::PHCHG: ACCNT1 Mask                 */
N
N#define PWM_PHCHG_CH01TOFF1_Pos          (16)                                              /*!< PWM_T::PHCHG: CH01TOFF1 Position          */
N#define PWM_PHCHG_CH01TOFF1_Msk          (0x1ul << PWM_PHCHG_CH01TOFF1_Pos)                /*!< PWM_T::PHCHG: CH01TOFF1 Mask              */
N
N#define PWM_PHCHG_CH11TOFF1_Pos          (17)                                              /*!< PWM_T::PHCHG: CH11TOFF1 Position          */
N#define PWM_PHCHG_CH11TOFF1_Msk          (0x1ul << PWM_PHCHG_CH11TOFF1_Pos)                /*!< PWM_T::PHCHG: CH11TOFF1 Mask              */
N
N#define PWM_PHCHG_CH21TOFF1_Pos          (18)                                              /*!< PWM_T::PHCHG: CH21TOFF1 Position          */
N#define PWM_PHCHG_CH21TOFF1_Msk          (0x1ul << PWM_PHCHG_CH21TOFF1_Pos)                /*!< PWM_T::PHCHG: CH21TOFF1 Mask              */
N
N#define PWM_PHCHG_CH31TOFF1_Pos          (19)                                              /*!< PWM_T::PHCHG: CH31TOFF1 Position          */
N#define PWM_PHCHG_CH31TOFF1_Msk          (0x1ul << PWM_PHCHG_CH31TOFF1_Pos)                /*!< PWM_T::PHCHG: CH31TOFF1 Mask              */
N
N#define PWM_PHCHG_CMP1SEL_Pos            (20)                                              /*!< PWM_T::PHCHG: CMP1SEL Position            */
N#define PWM_PHCHG_CMP1SEL_Msk            (0x3ul << PWM_PHCHG_CMP1SEL_Pos)                  /*!< PWM_T::PHCHG: CMP1SEL Mask                */
N
N#define PWM_PHCHG_T1_Pos                 (22)                                              /*!< PWM_T::PHCHG: T1 Position                 */
N#define PWM_PHCHG_T1_Msk                 (0x1ul << PWM_PHCHG_T1_Pos)                       /*!< PWM_T::PHCHG: T1 Mask                     */
N
N#define PWM_PHCHG_CE1_Pos                (23)                                              /*!< PWM_T::PHCHG: CE1 Position                */
N#define PWM_PHCHG_CE1_Msk                (0x1ul << PWM_PHCHG_CE1_Pos)                      /*!< PWM_T::PHCHG: CE1 Mask                    */
N
N#define PWM_PHCHG_CH01TOFF0_Pos          (24)                                              /*!< PWM_T::PHCHG: CH01TOFF0 Position          */
N#define PWM_PHCHG_CH01TOFF0_Msk          (0x1ul << PWM_PHCHG_CH01TOFF0_Pos)                /*!< PWM_T::PHCHG: CH01TOFF0 Mask              */
N
N#define PWM_PHCHG_CH11TOFF0_Pos          (25)                                              /*!< PWM_T::PHCHG: CH11TOFF0 Position          */
N#define PWM_PHCHG_CH11TOFF0_Msk          (0x1ul << PWM_PHCHG_CH11TOFF0_Pos)                /*!< PWM_T::PHCHG: CH11TOFF0 Mask              */
N
N#define PWM_PHCHG_CH21TOFF0_Pos          (26)                                              /*!< PWM_T::PHCHG: CH21TOFF0 Position          */
N#define PWM_PHCHG_CH21TOFF0_Msk          (0x1ul << PWM_PHCHG_CH21TOFF0_Pos)                /*!< PWM_T::PHCHG: CH21TOFF0 Mask              */
N
N#define PWM_PHCHG_CH31TOFF0_Pos          (27)                                              /*!< PWM_T::PHCHG: CH31TOFF0 Position          */
N#define PWM_PHCHG_CH31TOFF0_Msk          (0x1ul << PWM_PHCHG_CH31TOFF0_Pos)                /*!< PWM_T::PHCHG: CH31TOFF0 Mask              */
N
N#define PWM_PHCHG_CMP0SEL_Pos            (28)                                              /*!< PWM_T::PHCHG: CMP0SEL Position            */
N#define PWM_PHCHG_CMP0SEL_Msk            (0x3ul << PWM_PHCHG_CMP0SEL_Pos)                  /*!< PWM_T::PHCHG: CMP0SEL Mask                */
N
N#define PWM_PHCHG_T0_Pos                 (30)                                              /*!< PWM_T::PHCHG: T0 Position                 */
N#define PWM_PHCHG_T0_Msk                 (0x1ul << PWM_PHCHG_T0_Pos)                       /*!< PWM_T::PHCHG: T0 Mask                     */
N
N#define PWM_PHCHG_CE0_Pos                (31)                                              /*!< PWM_T::PHCHG: CE0 Position                */
N#define PWM_PHCHG_CE0_Msk                (0x1ul << PWM_PHCHG_CE0_Pos)                      /*!< PWM_T::PHCHG: CE0 Mask                    */
N
N#define PWM_PHCHGNXT_D0_Pos              (0)                                               /*!< PWM_T::PHCHGNXT: D0 Position              */
N#define PWM_PHCHGNXT_D0_Msk              (0x1ul << PWM_PHCHGNXT_D0_Pos)                    /*!< PWM_T::PHCHGNXT: D0 Mask                  */
N
N#define PWM_PHCHGNXT_D1_Pos              (1)                                               /*!< PWM_T::PHCHGNXT: D1 Position              */
N#define PWM_PHCHGNXT_D1_Msk              (0x1ul << PWM_PHCHGNXT_D1_Pos)                    /*!< PWM_T::PHCHGNXT: D1 Mask                  */
N
N#define PWM_PHCHGNXT_D2_Pos              (2)                                               /*!< PWM_T::PHCHGNXT: D2 Position              */
N#define PWM_PHCHGNXT_D2_Msk              (0x1ul << PWM_PHCHGNXT_D2_Pos)                    /*!< PWM_T::PHCHGNXT: D2 Mask                  */
N
N#define PWM_PHCHGNXT_D3_Pos              (3)                                               /*!< PWM_T::PHCHGNXT: D3 Position              */
N#define PWM_PHCHGNXT_D3_Msk              (0x1ul << PWM_PHCHGNXT_D3_Pos)                    /*!< PWM_T::PHCHGNXT: D3 Mask                  */
N
N#define PWM_PHCHGNXT_D4_Pos              (4)                                               /*!< PWM_T::PHCHGNXT: D4 Position              */
N#define PWM_PHCHGNXT_D4_Msk              (0x1ul << PWM_PHCHGNXT_D4_Pos)                    /*!< PWM_T::PHCHGNXT: D4 Mask                  */
N
N#define PWM_PHCHGNXT_D5_Pos              (5)                                               /*!< PWM_T::PHCHGNXT: D5 Position              */
N#define PWM_PHCHGNXT_D5_Msk              (0x1ul << PWM_PHCHGNXT_D5_Pos)                    /*!< PWM_T::PHCHGNXT: D5 Mask                  */
N
N#define PWM_PHCHGNXT_D6_Pos              (6)                                               /*!< PWM_T::PHCHGNXT: D6 Position              */
N#define PWM_PHCHGNXT_D6_Msk              (0x1ul << PWM_PHCHGNXT_D6_Pos)                    /*!< PWM_T::PHCHGNXT: D6 Mask                  */
N
N#define PWM_PHCHGNXT_D7_Pos              (7)                                               /*!< PWM_T::PHCHGNXT: D7 Position              */
N#define PWM_PHCHGNXT_D7_Msk              (0x1ul << PWM_PHCHGNXT_D7_Pos)                    /*!< PWM_T::PHCHGNXT: D7 Mask                  */
N
N#define PWM_PHCHGNXT_PWM0_Pos            (8)                                               /*!< PWM_T::PHCHGNXT: PWM0 Position            */
N#define PWM_PHCHGNXT_PWM0_Msk            (0x1ul << PWM_PHCHGNXT_PWM0_Pos)                  /*!< PWM_T::PHCHGNXT: PWM0 Mask                */
N
N#define PWM_PHCHGNXT_PWM1_Pos            (9)                                               /*!< PWM_T::PHCHGNXT: PWM1 Position            */
N#define PWM_PHCHGNXT_PWM1_Msk            (0x1ul << PWM_PHCHGNXT_PWM1_Pos)                  /*!< PWM_T::PHCHGNXT: PWM1 Mask                */
N
N#define PWM_PHCHGNXT_PWM2_Pos            (10)                                              /*!< PWM_T::PHCHGNXT: PWM2 Position            */
N#define PWM_PHCHGNXT_PWM2_Msk            (0x1ul << PWM_PHCHGNXT_PWM2_Pos)                  /*!< PWM_T::PHCHGNXT: PWM2 Mask                */
N
N#define PWM_PHCHGNXT_PWM3_Pos            (11)                                              /*!< PWM_T::PHCHGNXT: PWM3 Position            */
N#define PWM_PHCHGNXT_PWM3_Msk            (0x1ul << PWM_PHCHGNXT_PWM3_Pos)                  /*!< PWM_T::PHCHGNXT: PWM3 Mask                */
N
N#define PWM_PHCHGNXT_PWM4_Pos            (12)                                              /*!< PWM_T::PHCHGNXT: PWM4 Position            */
N#define PWM_PHCHGNXT_PWM4_Msk            (0x1ul << PWM_PHCHGNXT_PWM4_Pos)                  /*!< PWM_T::PHCHGNXT: PWM4 Mask                */
N
N#define PWM_PHCHGNXT_PWM5_Pos            (13)                                              /*!< PWM_T::PHCHGNXT: PWM5 Position            */
N#define PWM_PHCHGNXT_PWM5_Msk            (0x1ul << PWM_PHCHGNXT_PWM5_Pos)                  /*!< PWM_T::PHCHGNXT: PWM5 Mask                */
N
N#define PWM_PHCHGNXT_ACCNT0_Pos          (14)                                              /*!< PWM_T::PHCHGNXT: ACCNT0 Position          */
N#define PWM_PHCHGNXT_ACCNT0_Msk          (0x1ul << PWM_PHCHGNXT_ACCNT0_Pos)                /*!< PWM_T::PHCHGNXT: ACCNT0 Mask              */
N
N#define PWM_PHCHGNXT_ACCNT1_Pos          (15)                                              /*!< PWM_T::PHCHGNXT: ACCNT1 Position          */
N#define PWM_PHCHGNXT_ACCNT1_Msk          (0x1ul << PWM_PHCHGNXT_ACCNT1_Pos)                /*!< PWM_T::PHCHGNXT: ACCNT1 Mask              */
N
N#define PWM_PHCHGNXT_CH01TOFF1_Pos       (16)                                              /*!< PWM_T::PHCHGNXT: CH01TOFF1 Position       */
N#define PWM_PHCHGNXT_CH01TOFF1_Msk       (0x1ul << PWM_PHCHGNXT_CH01TOFF1_Pos)             /*!< PWM_T::PHCHGNXT: CH01TOFF1 Mask           */
N
N#define PWM_PHCHGNXT_CH11TOFF1_Pos       (17)                                              /*!< PWM_T::PHCHGNXT: CH11TOFF1 Position       */
N#define PWM_PHCHGNXT_CH11TOFF1_Msk       (0x1ul << PWM_PHCHGNXT_CH11TOFF1_Pos)             /*!< PWM_T::PHCHGNXT: CH11TOFF1 Mask           */
N
N#define PWM_PHCHGNXT_CH21TOFF1_Pos       (18)                                              /*!< PWM_T::PHCHGNXT: CH21TOFF1 Position       */
N#define PWM_PHCHGNXT_CH21TOFF1_Msk       (0x1ul << PWM_PHCHGNXT_CH21TOFF1_Pos)             /*!< PWM_T::PHCHGNXT: CH21TOFF1 Mask           */
N
N#define PWM_PHCHGNXT_CH31TOFF1_Pos       (19)                                              /*!< PWM_T::PHCHGNXT: CH31TOFF1 Position       */
N#define PWM_PHCHGNXT_CH31TOFF1_Msk       (0x1ul << PWM_PHCHGNXT_CH31TOFF1_Pos)             /*!< PWM_T::PHCHGNXT: CH31TOFF1 Mask           */
N
N#define PWM_PHCHGNXT_CMP1SEL_Pos         (20)                                              /*!< PWM_T::PHCHGNXT: CMP1SEL Position         */
N#define PWM_PHCHGNXT_CMP1SEL_Msk         (0x3ul << PWM_PHCHGNXT_CMP1SEL_Pos)               /*!< PWM_T::PHCHGNXT: CMP1SEL Mask             */
N
N#define PWM_PHCHGNXT_T1_Pos              (22)                                              /*!< PWM_T::PHCHGNXT: T1 Position              */
N#define PWM_PHCHGNXT_T1_Msk              (0x1ul << PWM_PHCHGNXT_T1_Pos)                    /*!< PWM_T::PHCHGNXT: T1 Mask                  */
N
N#define PWM_PHCHGNXT_CE1_Pos             (23)                                              /*!< PWM_T::PHCHGNXT: CE1 Position             */
N#define PWM_PHCHGNXT_CE1_Msk             (0x1ul << PWM_PHCHGNXT_CE1_Pos)                   /*!< PWM_T::PHCHGNXT: CE1 Mask                 */
N
N#define PWM_PHCHGNXT_CH01TOFF0_Pos       (24)                                              /*!< PWM_T::PHCHGNXT: CH01TOFF0 Position       */
N#define PWM_PHCHGNXT_CH01TOFF0_Msk       (0x1ul << PWM_PHCHGNXT_CH01TOFF0_Pos)             /*!< PWM_T::PHCHGNXT: CH01TOFF0 Mask           */
N
N#define PWM_PHCHGNXT_CH11TOFF0_Pos       (25)                                              /*!< PWM_T::PHCHGNXT: CH11TOFF0 Position       */
N#define PWM_PHCHGNXT_CH11TOFF0_Msk       (0x1ul << PWM_PHCHGNXT_CH11TOFF0_Pos)             /*!< PWM_T::PHCHGNXT: CH11TOFF0 Mask           */
N
N#define PWM_PHCHGNXT_CH21TOFF0_Pos       (26)                                              /*!< PWM_T::PHCHGNXT: CH21TOFF0 Position       */
N#define PWM_PHCHGNXT_CH21TOFF0_Msk       (0x1ul << PWM_PHCHGNXT_CH21TOFF0_Pos)             /*!< PWM_T::PHCHGNXT: CH21TOFF0 Mask           */
N
N#define PWM_PHCHGNXT_CH31TOFF0_Pos       (27)                                              /*!< PWM_T::PHCHGNXT: CH31TOFF0 Position       */
N#define PWM_PHCHGNXT_CH31TOFF0_Msk       (0x1ul << PWM_PHCHGNXT_CH31TOFF0_Pos)             /*!< PWM_T::PHCHGNXT: CH31TOFF0 Mask           */
N
N#define PWM_PHCHGNXT_CMP0SEL_Pos         (28)                                              /*!< PWM_T::PHCHGNXT: CMP0SEL Position         */
N#define PWM_PHCHGNXT_CMP0SEL_Msk         (0x3ul << PWM_PHCHGNXT_CMP0SEL_Pos)               /*!< PWM_T::PHCHGNXT: CMP0SEL Mask             */
N
N#define PWM_PHCHGNXT_T0_Pos              (30)                                              /*!< PWM_T::PHCHGNXT: T0 Position              */
N#define PWM_PHCHGNXT_T0_Msk              (0x1ul << PWM_PHCHGNXT_T0_Pos)                    /*!< PWM_T::PHCHGNXT: T0 Mask                  */
N
N#define PWM_PHCHGNXT_CE0_Pos             (31)                                              /*!< PWM_T::PHCHGNXT: CE0 Position             */
N#define PWM_PHCHGNXT_CE0_Msk             (0x1ul << PWM_PHCHGNXT_CE0_Pos)                   /*!< PWM_T::PHCHGNXT: CE0 Mask                 */
N
N#define PWM_PHCHGMASK_MASK6_Pos          (6)                                               /*!< PWM_T::PHCHGMASK: MASK6 Position          */
N#define PWM_PHCHGMASK_MASK6_Msk          (0x1ul << PWM_PHCHGMASK_MASK6_Pos)                /*!< PWM_T::PHCHGMASK: MASK6 Mask              */
N
N#define PWM_PHCHGMASK_MASK7_Pos          (7)                                               /*!< PWM_T::PHCHGMASK: MASK7 Position          */
N#define PWM_PHCHGMASK_MASK7_Msk          (0x1ul << PWM_PHCHGMASK_MASK7_Pos)                /*!< PWM_T::PHCHGMASK: MASK7 Mask              */
N
N#define PWM_PHCHGMASK_CMPMASK_Pos        (8)                                               /*!< PWM_T::PHCHGMASK: CMPMASK Position        */
N#define PWM_PHCHGMASK_CMPMASK_Msk        (0x3ul << PWM_PHCHGMASK_CMPMASK_Pos)              /*!< PWM_T::PHCHGMASK: CMPMASK Mask            */
N
N#define PWM_PHCHGMASK_CMPMASK0_Pos       (8)                                               /*!< PWM_T::PHCHGMASK: CMPMASK0 Position       */
N#define PWM_PHCHGMASK_CMPMASK0_Msk       (0x1ul << PWM_PHCHGMASK_CMPMASK0_Pos)             /*!< PWM_T::PHCHGMASK: CMPMASK0 Mask           */
N
N#define PWM_PHCHGMASK_CMPMASK1_Pos       (9)                                               /*!< PWM_T::PHCHGMASK: CMPMASK1 Position       */
N#define PWM_PHCHGMASK_CMPMASK1_Msk       (0x1ul << PWM_PHCHGMASK_CMPMASK1_Pos)             /*!< PWM_T::PHCHGMASK: CMPMASK1 Mask           */
N
N#define PWM_INTACCUCTL_INTACCUEN0_Pos    (0)                                               /*!< PWM_T::INTACCUCTL: INTACCUEN0 Position    */
N#define PWM_INTACCUCTL_INTACCUEN0_Msk    (0x1ul << PWM_INTACCUCTL_INTACCUEN0_Pos)          /*!< PWM_T::INTACCUCTL: INTACCUEN0 Mask        */
N
N#define PWM_INTACCUCTL_PERIODCNT_Pos     (4)                                               /*!< PWM_T::INTACCUCTL: PERIODCNT Position     */
N#define PWM_INTACCUCTL_PERIODCNT_Msk     (0xful << PWM_INTACCUCTL_PERIODCNT_Pos)           /*!< PWM_T::INTACCUCTL: PERIODCNT Mask         */
N
N/**@}*/ /* PWM_CONST */
N/**@}*/ /* end of PWM register group */
N
N
N/*---------------------- Serial Peripheral Interface Controller -------------------------*/
N/**
N    @addtogroup SPI Serial Peripheral Interface Controller(SPI)
N    Memory Mapped Structure for SPI Controller
N@{ */
N
N
Ntypedef struct {
N
N    /**
N     * @var SPI_T::CNTRL
N     * Offset: 0x00  SPI Control and Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |GO_BUSY   |SPI Transfer Control Bit And Busy Status
N     * |        |          |If FIFO mode is enabled, this bit will be controlled by hardware and is Read only.
N     * |        |          |If FIFO mode is disabled, during the data transfer, this bit keeps the value of 1.
N     * |        |          |As the transfer is finished, this bit will be cleared automatically.
N     * |        |          |0 = Writing 0 to this bit to stop data transfer if SPI is transferring.
N     * |        |          |1 = In Master mode, writing 1 to this bit to start the SPI data transfer; in Slave mode, writing 1 to this bit indicates that the slave is ready to communicate with a master.
N     * |        |          |Note 1: When FIFO mode is disabled, all configurations should be ready before writing 1 to the GO_BUSY bit.
N     * |        |          |Note 2: In SPI Slave mode, if FIFO mode is disabled and the SPI bus clock is kept at idle state during a data transfer, the GO_BUSY bit will not be cleared to 0 when slave select signal goes to inactive state.
N     * |[1]     |RX_NEG    |Receive On Negative Edge
N     * |        |          |0 = The received data input signal latched on the Rising edge of SPICLK.
N     * |        |          |1 = The received data input signal latched on the Falling edge of SPICLK.
N     * |[2]     |TX_NEG    |Transmit On Negative Edge
N     * |        |          |0 = The transmitted data output signal is driven on the Rising edge of SPICLK.
N     * |        |          |1 = The transmitted data output signal is driven on the Falling edge of SPICLK.
N     * |[7:3]   |TX_BIT_LEN|Transmit Bit Length
N     * |        |          |This field specifies how many bits are transmitted in one transmit/receive.
N     * |        |          |The minimum bit length is 8 bits and can up to 32 bits.
N     * |        |          |TX_BIT_LEN = 0x08 ... 8 bits.
N     * |        |          |TX_BIT_LEN = 0x09 ... 9 bits.
N     * |        |          |.....
N     * |        |          |TX_BIT_LEN = 0x1F ... 31 bits.
N     * |        |          |TX_BIT_LEN = 0x00 ... 32 bits.
N     * |[10]    |LSB       |LSB First
N     * |        |          |0 = The MSB is transmitted/received first.
N     * |        |          |1 = The LSB is transmitted/received first.
N     * |[11]    |CLKP      |Clock Polarity
N     * |        |          |0 = SPICLK idle low.
N     * |        |          |1 = SPICLK idle high.
N     * |[15:12] |SP_CYCLE  |Suspend Interval (Master Only)
N     * |        |          |The four bits provide configurable suspend interval between two successive transactions in a transfer.
N     * |        |          |The definition of the suspend interval is the interval between the last clock edge of the preceding transaction word and the first clock edge of the following transaction word.
N     * |        |          |The default value is 0x3.
N     * |        |          |The period of the suspend interval is obtained according to the following equation:
N     * |        |          |(SP_CYCLE[3:0] + 0.5) * period of SPICLK clock cycle
N     * |        |          |Example:
N     * |        |          |SP_CYCLE = 0x0 ... 0.5 SPICLK clock cycle.
N     * |        |          |SP_CYCLE = 0x1 ... 1.5 SPICLK clock cycle.
N     * |        |          |.....
N     * |        |          |SP_CYCLE = 0xE ... 14.5 SPICLK clock cycle.
N     * |        |          |SP_CYCLE = 0xF ... 15.5 SPICLK clock cycle.
N     * |[16]    |IF        |Unit-transfer Interrupt Flag
N     * |        |          |0 = The transfer does not finish yet.
N     * |        |          |1 = The SPI controller has finished one unit transfer.
N     * |        |          |Note 1: This bit will be cleared by writing 1 to itself.
N     * |        |          |Note 2: It's a mutual mirror bit of SPI_STATUS[16].
N     * |[17]    |IE        |Unit-transfer Interrupt Enable Control
N     * |        |          |0 = SPI unit-transfer interrupt Disabled.
N     * |        |          |1 = SPI unit-transfer interrupt Enabled.
N     * |[18]    |SLAVE     |Slave Mode Control
N     * |        |          |0 = Master mode.
N     * |        |          |1 = Slave mode.
N     * |[19]    |REORDER   |Byte Reorder Function
N     * |        |          |0 = Byte reorder function Disabled.
N     * |        |          |1 = Byte reorder function Enabled.
N     * |        |          |Note: This setting is only available if TX_BIT_LEN is defined as 16, 24, and 32 bits.
N     * |[21]    |FIFO      |FIFO Mode Enable Control
N     * |        |          |0 = FIFO Mode Disabled.
N     * |        |          |1 = FIFO Mode Enabled.
N     * |        |          |Note 1: Before enabling FIFO mode, the other related settings should be set in advance.
N     * |        |          |Note 2: In Master mode, if the FIFO mode is enabled, the GO_BUSY bit will be set to 1 automatically after writing data into the 4-depth transmit FIFO.
N     * |        |          |When all data stored at transmit FIFO buffer are transferred, the GO_BUSY bit will back to 0.
N     * |[24]    |RX_EMPTY  |Receive FIFO Buffer Empty Indicator (Read Only)
N     * |        |          |0 = The receive FIFO buffer is not empty.
N     * |        |          |1 = The receive FIFO buffer is empty.
N     * |        |          |Note: It's a mutual mirror bit of SPI_CNTRL[24].
N     * |[25]    |RX_FULL   |Receive FIFO Buffer Full Indicator (Read Only)
N     * |        |          |0 = The receive FIFO buffer is not full.
N     * |        |          |1 = The receive FIFO buffer is full.
N     * |        |          |Note: It's a mutual mirror bit of SPI_STATUS[25]
N     * |[26]    |TX_EMPTY  |Transmit FIFO Buffer Empty Indicator (Read Only)
N     * |        |          |0 = The transmit FIFO buffer is not empty.
N     * |        |          |1 = The transmit FIFO buffer is empty.
N     * |        |          |Note: It's a mutual mirror bit of SPI_STAUTS[26].
N     * |[27]    |TX_FULL   |Transmit FIFO Buffer Full Indicator (Read Only)
N     * |        |          |0 =The transmit FIFO buffer is not full.
N     * |        |          |1 =The transmit FIFO buffer is full.
N     * |        |          |Note: It's a mutual mirror bit of SPI_STATUS[27].
N     * @var SPI_T::DIVIDER
N     * Offset: 0x04  SPI Clock Divider Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |DIVIDER   |Clock Divider Bits (Master Only)
N     * |        |          |The value in this field is the frequency divider to determine the SPI peripheral clock frequency fspi, and the SPI master's bus clock frequency on the SPICLK output pin.
N     * |        |          |The frequency is obtained according to the following equation:
N     * |        |          |If the bit of BCn, SPI_CNTRL2[31], is set to 0.
N     * |        |          |else if BCn is set to 1,
N     * |        |          |where
N     * |        |          |is the SPI peripheral clock source which is defined in the CLKSEL1 register.
N     * @var SPI_T::SSR
N     * Offset: 0x08  SPI Slave Select Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |SSR       |Slave Select Control Bit (Master Only)
N     * |        |          |If AUTOSS bit is 0,
N     * |        |          |0 = Set the SPISS line to inactive state.
N     * |        |          |1 = Set the proper SPISS line to active state.
N     * |        |          |If AUTOSS bit is 1,
N     * |        |          |0 = Keep the SPISS line at inactive state.
N     * |        |          |1 = Select the SPISS line to be automatically driven to active state for the duration of transmission/reception, and will be driven to inactive state for the rest of the time.
N     * |        |          |The active state of SPISS is specified in SS_LVL bit.
N     * |[2]     |SS_LVL    |Slave Select Active Level (Slave Only)
N     * |        |          |It defines the active status of slave select signal (SPISS).
N     * |        |          |If SS_LTRIG bit is 1:
N     * |        |          |0 = The slave select signal SPISS is active at Low-level.
N     * |        |          |1 = The slave select signal SPISS is active at High-level.
N     * |        |          |If SS_LTRIG bit is 0:
N     * |        |          |0 = The slave select signal SPISS is active at Falling-edge.
N     * |        |          |1 = The slave select signal SPISS is active at Rising-edge.
N     * |[3]     |AUTOSS    |Automatic Slave Selection Function Enable Bit (Master Only)
N     * |        |          |0 = SPISS pin signal will be asserted/de-asserted by setting /clearing SSR bit.
N     * |        |          |1 = SPISS pin signal will be generated automatically, which means that slave select signal will be asserted by the SPI controller when transmit/receive is started by setting GO_BUSY, and will be de-asserted after each transmit/receive is finished.
N     * |[4]     |SS_LTRIG  |Slave Select Level Trigger Enable Bit (Slave Only)
N     * |        |          |0 = The input slave select signal is edge-trigger.
N     * |        |          |1 = The input slave select signal is level-trigger.
N     * |[5]     |LTRIG_FLAG|Level Trigger Flag (Read Only, Slave Only)
N     * |        |          |When the SS_LTRIG bit is set in Slave mode, this bit can be read to indicate the received bit number is met the requirement or not.
N     * |        |          |0 = The transaction number or the transferred bit length of one transaction does not meet the specified requirements.
N     * |        |          |1 = The transaction number and the transferred bit length met the specified requirements which defined in TX_BIT_LEN.
N     * @var SPI_T::RX
N     * Offset: 0x10  SPI Data Receive Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |RX        |Data Receive Bits (Read Only)
N     * |        |          |The Data Receive Registers hold the value of received data of the last executed transfer.
N     * |        |          |Valid bits depend on the transmit bit length field in the SPI_CNTRL register.
N     * |        |          |For example, if TX_BIT_LEN is set to 0x08, bit RX [7:0] holds the received data.
N     * |        |          |The values of the other bits are unknown.
N     * @var SPI_T::TX
N     * Offset: 0x20  SPI Data Transmit Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |TX        |Data Transmit Bits (Write Only)
N     * |        |          |The Data Transmit Registers hold the data to be transmitted in the next transfer.
N     * |        |          |Valid bits depend on the transmit bit length field in the CNTRL register.
N     * |        |          |For example, if TX_BIT_LEN is set to 0x08, the bit TX [7:0] will be transmitted in next transfer.
N     * @var SPI_T::CNTRL2
N     * Offset: 0x3C  SPI Control and Status Register 2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[8]     |NOSLVSEL  |Slave 3-wire Mode Enable Control (Slave Only)
N     * |        |          |The SPI controller work with 3-wire interface including SPICLK, SPI_MISO, and SPI_MOSI
N     * |        |          |0 = The controller is 4-wire bi-direction interface.
N     * |        |          |1 = The controller is 3-wire bi-direction interface in Slave mode.
N     * |        |          |The controller will be ready to transmit/receive data after the GO_BUSY bit is set to 1.
N     * |        |          |Note: In Slave 3-wire mode, the SS_LTRIG bit (SPI_SSR[4]) shall be set as 1.
N     * |[9]     |SLV_ABORT |Slave 3-wire Mode Abort Control Bit (Slave Only)
N     * |        |          |In normal operation, there is an interrupt event when the number of received bits meets the requirement which defined in TX_BIT_LEN.
N     * |        |          |If the number of received bits is less than the requirement and there is no more bus clock input over one transfer time in Slave 3-wire mode, user can set this bit to force the current transfer done and then user can get a unit transfer interrupt event.
N     * |        |          |0 = No force the transfer done when the NOSLVSEL bit is set to 1.
N     * |        |          |1 = Force the transfer done when the NOSLVSEL bit is set to 1.
N     * |        |          |Note: This bit will be cleared to 0 automatically by hardware after it is set to 1 by software.
N     * |[10]    |SSTA_INTEN|Slave 3-wire Mode Start Interrupt Enable Control (Slave Only)
N     * |        |          |It is used to enable interrupt when the transfer has started in slave 3-wire mode.
N     * |        |          |If there is no transfer done interrupt over the time period which is defined by user after the transfer start, user can set the SLV_ABORT bit to force the transfer done.
N     * |        |          |0 = Transaction start interrupt Disabled.
N     * |        |          |1 = Transaction start interrupt Enabled.
N     * |        |          |Note: It will be cleared to 0 as the current transfer is done or the SLV_START_INTSTS bit is cleared to 0.
N     * |[11]    |SLV_START_INTSTS|Slave 3-wire Mode Start Interrupt Status (Slave Only)
N     * |        |          |This bit dedicates if a transaction has started in slave 3-wire mode.
N     * |        |          |0 = Slave does not detect any SPI bus clock transfer since the SSTA_INTEN bit was set to 1.
N     * |        |          |1 = The transfer has started in slave 3-wire mode.
N     * |        |          |Note 1: It will be cleared automatically when a transaction is done or by writing 1 to this bit.
N     * |        |          |Note 2: It is a mutual mirror bit of SPI_STATUS[11].
N     * |[16]    |SS_INT_OPT|Slave Select Inactive Interrupt Option (Slave Only)
N     * |        |          |0 = As the slave select signal goes to inactive level, the IF bit will NOT be set to 1.
N     * |        |          |1 = As the slave select signal goes to inactive level, the IF bit will be set to 1.
N     * |        |          |Note: This setting is only available if the SPI controller is configured as level trigger in slave device.
N     * |[31]    |BCn       |Clock Configuration Backward Compatible Option
N     * |        |          |0 = The clock configuration is backward compatible.
N     * |        |          |1 = The clock configuration is not backward compatible.
N     * |        |          |Note: Refer to the description of SPI_DIVIDER register for details.
N     * @var SPI_T::FIFO_CTL
N     * Offset: 0x40  SPI FIFO Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RX_CLR    |Clear Receive FIFO Buffer
N     * |        |          |0 = No effect.
N     * |        |          |1 = Clear receive FIFO buffer.
N     * |        |          |Note: This bit will be cleared to 0 by hardware after software sets it to 1 and the receive FIFO is cleared.
N     * |[1]     |TX_CLR    |Clear Transmit FIFO Buffer
N     * |        |          |0 = No effect.
N     * |        |          |1 = Clear transmit FIFO buffer.
N     * |        |          |Note: This bit will be cleared to 0 by hardware after software sets it to 1 and the transmit FIFO is cleared.
N     * |[2]     |RX_INTEN  |Receive Threshold Interrupt Enable Control
N     * |        |          |0 = Receive threshold interrupt Disabled.
N     * |        |          |1 = Receive threshold interrupt Enabled.
N     * |[3]     |TX_INTEN  |Transmit Threshold Interrupt Enable Control
N     * |        |          |0 = Transmit threshold interrupt Disabled.
N     * |        |          |1 = Transmit threshold interrupt Enabled.
N     * |[6]     |RXOV_INTEN|Receive FIFO Overrun Interrupt Enable Control
N     * |        |          |0 = Receive FIFO overrun interrupt Disabled.
N     * |        |          |1 = Receive FIFO overrun interrupt Enabled.
N     * |[21]    |TIMEOUT_INTEN|Receive FIFO Time-out Interrupt Enable Control
N     * |        |          |0 = Time-out interrupt Disabled.
N     * |        |          |1 = Time-out interrupt Enabled.
N     * |[25:24] |RX_THRESHOLD|Received FIFO Threshold
N     * |        |          |If the valid data count of the receive FIFO buffer is larger than the RX_THRESHOLD setting, the RX_INTSTS bit will be set to 1, else the RX_INTSTS bit will be cleared to 0.
N     * |[29:28] |TX_THRESHOLD|Transmit FIFO Threshold
N     * |        |          |If the valid data count of the transmit FIFO buffer is less than or equal to the TX_THRESHOLD setting, the TX_INTSTS bit will be set to 1, else the TX_INTSTS bit will be cleared to 0.
N     * @var SPI_T::STATUS
N     * Offset: 0x44  SPI Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RX_INTSTS |Receive FIFO Threshold Interrupt Status (Read Only)
N     * |        |          |0 = The valid data count within the Rx FIFO buffer is smaller than or equal to the setting value of RX_THRESHOLD.
N     * |        |          |1 = The valid data count within the receive FIFO buffer is larger than the setting value of RX_THRESHOLD.
N     * |        |          |Note: If RX_INTEN = 1 and RX_INTSTS = 1, the SPI controller will generate a SPI interrupt request.
N     * |[2]     |RX_OVERRUN|Receive FIFO Overrun Status
N     * |        |          |When the receive FIFO buffer is full, the follow-up data will be dropped and this bit will be set to 1.
N     * |        |          |0 = No overrun in receive FIFO.
N     * |        |          |1 = Overrun in receive FIFO.
N     * |        |          |Note: This bit will be cleared by writing 1 to itself.
N     * |[4]     |TX_INTSTS |Transmit FIFO Threshold Interrupt Status (Read Only)
N     * |        |          |0 = The valid data count within the transmit FIFO buffer is larger than the setting value of TX_THRESHOLD.
N     * |        |          |1 = The valid data count within the transmit FIFO buffer is less than or equal to the setting value of TX_THRESHOLD.
N     * |        |          |Note: If TX_INTEN = 1 and TX_INTSTS = 1, the SPI controller will generate a SPI interrupt request.
N     * |[11]    |SLV_START_INTSTS|Slave Start Interrupt Status (Slave Only)
N     * |        |          |It is used to dedicate that the transfer has started in slave 3-wire mode.
N     * |        |          |0 = Slave does not detect any SPI bus clock transfer since the SSTA_INTEN bit was set to 1.
N     * |        |          |1 = The transfer has started in slave 3-wire mode.
N     * |        |          |Note 1: It will be cleared as transfer done or by writing one to this bit.
N     * |        |          |Note 2: It's a mutual mirror bit of SPI_CNTRL2[11].
N     * |[15:12] |RX_FIFO_COUNT|Receive FIFO Data Count (Read Only)
N     * |        |          |Indicates the valid data count of receive FIFO buffer.
N     * |[16]    |IF        |SPI Unit-transfer Interrupt Flag
N     * |        |          |0 = The transfer does not finish yet.
N     * |        |          |1 = The SPI controller has finished one unit transfer.
N     * |        |          |Note 1: This bit will be cleared by writing 1 to itself.
N     * |        |          |Note 2: It's a mutual mirror bit of SPI_CNTRL[16].
N     * |[20]    |TIMEOUT   |Time-out Interrupt Flag
N     * |        |          |0 = No receive FIFO time-out event.
N     * |        |          |1 = The receive FIFO buffer is not empty and it does not be read over 64 SPI clock periods in Master mode or over 576 SPI peripheral clock periods in Slave mode.
N     * |        |          |When the received FIFO buffer is read by software, the time-out status will be cleared automatically.
N     * |        |          |Note: This bit will be cleared by writing 1 to itself.
N     * |[24]    |RX_EMPTY  |Receive FIFO Buffer Empty Indicator (Read Only)
N     * |        |          |0 = The receive FIFO buffer is not empty.
N     * |        |          |1 = The receive FIFO buffer is empty.
N     * |        |          |Note: It's a mutual mirror bit of SPI_CNTRL[24].
N     * |[25]    |RX_FULL   |Receive FIFO Buffer Full Indicator (Read Only)
N     * |        |          |0 = The receive FIFO buffer is not full.
N     * |        |          |1 = The receive FIFO buffer is full.
N     * |        |          |Note: It's a mutual mirror bit of SPI_CNTRL[25].
N     * |[26]    |TX_EMPTY  |Transmit FIFO Buffer Empty Indicator (Read Only)
N     * |        |          |0 = The transmit FIFO buffer is not empty.
N     * |        |          |1 = The transmit FIFO buffer is empty.
N     * |        |          |Note: It's a mutual mirror bit of SPI_CNTRL[26].
N     * |[27]    |TX_FULL   |Transmit FIFO Buffer Full Indicator (Read Only)
N     * |        |          |0 = The transmit FIFO buffer is not full.
N     * |        |          |1 = The transmit FIFO buffer is full.
N     * |        |          |Note: It's a mutual mirror bit of SPI_CNTRL[27].
N     * |[31:28] |TX_FIFO_COUNT|Transmit FIFO Data Count (Read Only)
N     * |        |          |Indicates the valid data count of transmit FIFO buffer.
N     */
N
N    __IO uint32_t CNTRL;         /* Offset: 0x00  SPI Control and Status Register                                    */
X    volatile uint32_t CNTRL;          
N    __IO uint32_t DIVIDER;       /* Offset: 0x04  SPI Clock Divider Register                                         */
X    volatile uint32_t DIVIDER;        
N    __IO uint32_t SSR;           /* Offset: 0x08  SPI Slave Select Register                                          */
X    volatile uint32_t SSR;            
N    /// @cond HIDDEN_SYMBOLS
N    __I  uint32_t RESERVE0[1];
X    volatile const  uint32_t RESERVE0[1];
N    /// @endcond //HIDDEN_SYMBOLS
N    __I  uint32_t RX;            /* Offset: 0x10  SPI Data Receive Register                                          */
X    volatile const  uint32_t RX;             
N    /// @cond HIDDEN_SYMBOLS
N    __I  uint32_t RESERVE1[3];
X    volatile const  uint32_t RESERVE1[3];
N    /// @endcond //HIDDEN_SYMBOLS
N    __O  uint32_t TX;            /* Offset: 0x20  SPI Data Transmit Register                                         */
X    volatile  uint32_t TX;             
N    /// @cond HIDDEN_SYMBOLS
N    __I  uint32_t RESERVE2[6];
X    volatile const  uint32_t RESERVE2[6];
N    /// @endcond //HIDDEN_SYMBOLS
N    __IO uint32_t CNTRL2;        /* Offset: 0x3C  SPI Control and Status Register 2                                  */
X    volatile uint32_t CNTRL2;         
N    __IO uint32_t FIFO_CTL;      /* Offset: 0x40  SPI FIFO Control Register                                          */
X    volatile uint32_t FIFO_CTL;       
N    __IO uint32_t STATUS;        /* Offset: 0x44  SPI Status Register                                                */
X    volatile uint32_t STATUS;         
N
N} SPI_T;
N
N
N
N/**
N    @addtogroup SPI_CONST SPI Bit Field Definition
N    Constant Definitions for SPI Controller
N@{ */
N
N#define SPI_CNTRL_GO_BUSY_Pos            (0)                                               /*!< SPI_T::CNTRL: GO_BUSY Position            */
N#define SPI_CNTRL_GO_BUSY_Msk            (0x1ul << SPI_CNTRL_GO_BUSY_Pos)                  /*!< SPI_T::CNTRL: GO_BUSY Mask                */
N
N#define SPI_CNTRL_RX_NEG_Pos             (1)                                               /*!< SPI_T::CNTRL: RX_NEG Position             */
N#define SPI_CNTRL_RX_NEG_Msk             (0x1ul << SPI_CNTRL_RX_NEG_Pos)                   /*!< SPI_T::CNTRL: RX_NEG Mask                 */
N
N#define SPI_CNTRL_TX_NEG_Pos             (2)                                               /*!< SPI_T::CNTRL: TX_NEG Position             */
N#define SPI_CNTRL_TX_NEG_Msk             (0x1ul << SPI_CNTRL_TX_NEG_Pos)                   /*!< SPI_T::CNTRL: TX_NEG Mask                 */
N
N#define SPI_CNTRL_TX_BIT_LEN_Pos         (3)                                               /*!< SPI_T::CNTRL: TX_BIT_LEN Position         */
N#define SPI_CNTRL_TX_BIT_LEN_Msk         (0x1ful << SPI_CNTRL_TX_BIT_LEN_Pos)              /*!< SPI_T::CNTRL: TX_BIT_LEN Mask             */
N
N#define SPI_CNTRL_LSB_Pos                (10)                                              /*!< SPI_T::CNTRL: LSB Position                */
N#define SPI_CNTRL_LSB_Msk                (0x1ul << SPI_CNTRL_LSB_Pos)                      /*!< SPI_T::CNTRL: LSB Mask                    */
N
N#define SPI_CNTRL_CLKP_Pos               (11)                                              /*!< SPI_T::CNTRL: CLKP Position               */
N#define SPI_CNTRL_CLKP_Msk               (0x1ul << SPI_CNTRL_CLKP_Pos)                     /*!< SPI_T::CNTRL: CLKP Mask                   */
N
N#define SPI_CNTRL_SP_CYCLE_Pos           (12)                                              /*!< SPI_T::CNTRL: SP_CYCLE Position           */
N#define SPI_CNTRL_SP_CYCLE_Msk           (0xful << SPI_CNTRL_SP_CYCLE_Pos)                 /*!< SPI_T::CNTRL: SP_CYCLE Mask               */
N
N#define SPI_CNTRL_IF_Pos                 (16)                                              /*!< SPI_T::CNTRL: IF Position                 */
N#define SPI_CNTRL_IF_Msk                 (0x1ul << SPI_CNTRL_IF_Pos)                       /*!< SPI_T::CNTRL: IF Mask                     */
N
N#define SPI_CNTRL_IE_Pos                 (17)                                              /*!< SPI_T::CNTRL: IE Position                 */
N#define SPI_CNTRL_IE_Msk                 (0x1ul << SPI_CNTRL_IE_Pos)                       /*!< SPI_T::CNTRL: IE Mask                     */
N
N#define SPI_CNTRL_SLAVE_Pos              (18)                                              /*!< SPI_T::CNTRL: SLAVE Position              */
N#define SPI_CNTRL_SLAVE_Msk              (0x1ul << SPI_CNTRL_SLAVE_Pos)                    /*!< SPI_T::CNTRL: SLAVE Mask                  */
N
N#define SPI_CNTRL_REORDER_Pos            (19)                                              /*!< SPI_T::CNTRL: REORDER Position            */
N#define SPI_CNTRL_REORDER_Msk            (0x1ul << SPI_CNTRL_REORDER_Pos)                  /*!< SPI_T::CNTRL: REORDER Mask                */
N
N#define SPI_CNTRL_FIFO_Pos               (21)                                              /*!< SPI_T::CNTRL: FIFO Position               */
N#define SPI_CNTRL_FIFO_Msk               (0x1ul << SPI_CNTRL_FIFO_Pos)                     /*!< SPI_T::CNTRL: FIFO Mask                   */
N
N#define SPI_CNTRL_RX_EMPTY_Pos           (24)                                              /*!< SPI_T::CNTRL: RX_EMPTY Position           */
N#define SPI_CNTRL_RX_EMPTY_Msk           (0x1ul << SPI_CNTRL_RX_EMPTY_Pos)                 /*!< SPI_T::CNTRL: RX_EMPTY Mask               */
N
N#define SPI_CNTRL_RX_FULL_Pos            (25)                                              /*!< SPI_T::CNTRL: RX_FULL Position            */
N#define SPI_CNTRL_RX_FULL_Msk            (0x1ul << SPI_CNTRL_RX_FULL_Pos)                  /*!< SPI_T::CNTRL: RX_FULL Mask                */
N
N#define SPI_CNTRL_TX_EMPTY_Pos           (26)                                              /*!< SPI_T::CNTRL: TX_EMPTY Position           */
N#define SPI_CNTRL_TX_EMPTY_Msk           (0x1ul << SPI_CNTRL_TX_EMPTY_Pos)                 /*!< SPI_T::CNTRL: TX_EMPTY Mask               */
N
N#define SPI_CNTRL_TX_FULL_Pos            (27)                                              /*!< SPI_T::CNTRL: TX_FULL Position            */
N#define SPI_CNTRL_TX_FULL_Msk            (0x1ul << SPI_CNTRL_TX_FULL_Pos)                  /*!< SPI_T::CNTRL: TX_FULL Mask                */
N
N#define SPI_DIVIDER_DIVIDER_Pos          (0)                                               /*!< SPI_T::DIVIDER: DIVIDER Position          */
N#define SPI_DIVIDER_DIVIDER_Msk          (0xfful << SPI_DIVIDER_DIVIDER_Pos)               /*!< SPI_T::DIVIDER: DIVIDER Mask              */
N
N#define SPI_SSR_SSR_Pos                  (0)                                               /*!< SPI_T::SSR: SSR Position                  */
N#define SPI_SSR_SSR_Msk                  (0x1ul << SPI_SSR_SSR_Pos)                        /*!< SPI_T::SSR: SSR Mask                      */
N
N#define SPI_SSR_SS_LVL_Pos               (2)                                               /*!< SPI_T::SSR: SS_LVL Position               */
N#define SPI_SSR_SS_LVL_Msk               (0x1ul << SPI_SSR_SS_LVL_Pos)                     /*!< SPI_T::SSR: SS_LVL Mask                   */
N
N#define SPI_SSR_AUTOSS_Pos               (3)                                               /*!< SPI_T::SSR: AUTOSS Position               */
N#define SPI_SSR_AUTOSS_Msk               (0x1ul << SPI_SSR_AUTOSS_Pos)                     /*!< SPI_T::SSR: AUTOSS Mask                   */
N
N#define SPI_SSR_SS_LTRIG_Pos             (4)                                               /*!< SPI_T::SSR: SS_LTRIG Position             */
N#define SPI_SSR_SS_LTRIG_Msk             (0x1ul << SPI_SSR_SS_LTRIG_Pos)                   /*!< SPI_T::SSR: SS_LTRIG Mask                 */
N
N#define SPI_SSR_LTRIG_FLAG_Pos           (5)                                               /*!< SPI_T::SSR: LTRIG_FLAG Position           */
N#define SPI_SSR_LTRIG_FLAG_Msk           (0x1ul << SPI_SSR_LTRIG_FLAG_Pos)                 /*!< SPI_T::SSR: LTRIG_FLAG Mask               */
N
N#define SPI_RX_RX_Pos                    (0)                                               /*!< SPI_T::RX: RX Position                    */
N#define SPI_RX_RX_Msk                    (0xfffffffful << SPI_RX_RX_Pos)                   /*!< SPI_T::RX: RX Mask                        */
N
N#define SPI_TX_TX_Pos                    (0)                                               /*!< SPI_T::TX: TX Position                    */
N#define SPI_TX_TX_Msk                    (0xfffffffful << SPI_TX_TX_Pos)                   /*!< SPI_T::TX: TX Mask                        */
N
N#define SPI_CNTRL2_NOSLVSEL_Pos          (8)                                               /*!< SPI_T::CNTRL2: NOSLVSEL Position          */
N#define SPI_CNTRL2_NOSLVSEL_Msk          (0x1ul << SPI_CNTRL2_NOSLVSEL_Pos)                /*!< SPI_T::CNTRL2: NOSLVSEL Mask              */
N
N#define SPI_CNTRL2_SLV_ABORT_Pos         (9)                                               /*!< SPI_T::CNTRL2: SLV_ABORT Position         */
N#define SPI_CNTRL2_SLV_ABORT_Msk         (0x1ul << SPI_CNTRL2_SLV_ABORT_Pos)               /*!< SPI_T::CNTRL2: SLV_ABORT Mask             */
N
N#define SPI_CNTRL2_SSTA_INTEN_Pos        (10)                                              /*!< SPI_T::CNTRL2: SSTA_INTEN Position        */
N#define SPI_CNTRL2_SSTA_INTEN_Msk        (0x1ul << SPI_CNTRL2_SSTA_INTEN_Pos)              /*!< SPI_T::CNTRL2: SSTA_INTEN Mask            */
N
N#define SPI_CNTRL2_SLV_START_INTSTS_Pos  (11)                                              /*!< SPI_T::CNTRL2: SLV_START_INTSTS Position  */
N#define SPI_CNTRL2_SLV_START_INTSTS_Msk  (0x1ul << SPI_CNTRL2_SLV_START_INTSTS_Pos)        /*!< SPI_T::CNTRL2: SLV_START_INTSTS Mask      */
N
N#define SPI_CNTRL2_SS_INT_OPT_Pos        (16)                                              /*!< SPI_T::CNTRL2: SS_INT_OPT Position        */
N#define SPI_CNTRL2_SS_INT_OPT_Msk        (0x1ul << SPI_CNTRL2_SS_INT_OPT_Pos)              /*!< SPI_T::CNTRL2: SS_INT_OPT Mask            */
N
N#define SPI_CNTRL2_BCn_Pos               (31)                                              /*!< SPI_T::CNTRL2: BCn Position               */
N#define SPI_CNTRL2_BCn_Msk               (0x1ul << SPI_CNTRL2_BCn_Pos)                     /*!< SPI_T::CNTRL2: BCn Mask                   */
N
N#define SPI_FIFO_CTL_RX_CLR_Pos          (0)                                               /*!< SPI_T::FIFO_CTL: RX_CLR Position          */
N#define SPI_FIFO_CTL_RX_CLR_Msk          (0x1ul << SPI_FIFO_CTL_RX_CLR_Pos)                /*!< SPI_T::FIFO_CTL: RX_CLR Mask              */
N
N#define SPI_FIFO_CTL_TX_CLR_Pos          (1)                                               /*!< SPI_T::FIFO_CTL: TX_CLR Position          */
N#define SPI_FIFO_CTL_TX_CLR_Msk          (0x1ul << SPI_FIFO_CTL_TX_CLR_Pos)                /*!< SPI_T::FIFO_CTL: TX_CLR Mask              */
N
N#define SPI_FIFO_CTL_RX_INTEN_Pos        (2)                                               /*!< SPI_T::FIFO_CTL: RX_INTEN Position        */
N#define SPI_FIFO_CTL_RX_INTEN_Msk        (0x1ul << SPI_FIFO_CTL_RX_INTEN_Pos)              /*!< SPI_T::FIFO_CTL: RX_INTEN Mask            */
N
N#define SPI_FIFO_CTL_TX_INTEN_Pos        (3)                                               /*!< SPI_T::FIFO_CTL: TX_INTEN Position        */
N#define SPI_FIFO_CTL_TX_INTEN_Msk        (0x1ul << SPI_FIFO_CTL_TX_INTEN_Pos)              /*!< SPI_T::FIFO_CTL: TX_INTEN Mask            */
N
N#define SPI_FIFO_CTL_RXOV_INTEN_Pos      (6)                                               /*!< SPI_T::FIFO_CTL: RXOV_INTEN Position      */
N#define SPI_FIFO_CTL_RXOV_INTEN_Msk      (0x1ul << SPI_FIFO_CTL_RXOV_INTEN_Pos)            /*!< SPI_T::FIFO_CTL: RXOV_INTEN Mask          */
N
N#define SPI_FIFO_CTL_TIMEOUT_INTEN_Pos   (21)                                              /*!< SPI_T::FIFO_CTL: TIMEOUT_INTEN Position   */
N#define SPI_FIFO_CTL_TIMEOUT_INTEN_Msk   (0x1ul << SPI_FIFO_CTL_TIMEOUT_INTEN_Pos)         /*!< SPI_T::FIFO_CTL: TIMEOUT_INTEN Mask       */
N
N#define SPI_FIFO_CTL_RX_THRESHOLD_Pos    (24)                                              /*!< SPI_T::FIFO_CTL: RX_THRESHOLD Position    */
N#define SPI_FIFO_CTL_RX_THRESHOLD_Msk    (0x3ul << SPI_FIFO_CTL_RX_THRESHOLD_Pos)          /*!< SPI_T::FIFO_CTL: RX_THRESHOLD Mask        */
N
N#define SPI_FIFO_CTL_TX_THRESHOLD_Pos    (28)                                              /*!< SPI_T::FIFO_CTL: TX_THRESHOLD Position    */
N#define SPI_FIFO_CTL_TX_THRESHOLD_Msk    (0x3ul << SPI_FIFO_CTL_TX_THRESHOLD_Pos)          /*!< SPI_T::FIFO_CTL: TX_THRESHOLD Mask        */
N
N#define SPI_STATUS_RX_INTSTS_Pos         (0)                                               /*!< SPI_T::STATUS: RX_INTSTS Position         */
N#define SPI_STATUS_RX_INTSTS_Msk         (0x1ul << SPI_STATUS_RX_INTSTS_Pos)               /*!< SPI_T::STATUS: RX_INTSTS Mask             */
N
N#define SPI_STATUS_RX_OVERRUN_Pos        (2)                                               /*!< SPI_T::STATUS: RX_OVERRUN Position        */
N#define SPI_STATUS_RX_OVERRUN_Msk        (0x1ul << SPI_STATUS_RX_OVERRUN_Pos)              /*!< SPI_T::STATUS: RX_OVERRUN Mask            */
N
N#define SPI_STATUS_TX_INTSTS_Pos         (4)                                               /*!< SPI_T::STATUS: TX_INTSTS Position         */
N#define SPI_STATUS_TX_INTSTS_Msk         (0x1ul << SPI_STATUS_TX_INTSTS_Pos)               /*!< SPI_T::STATUS: TX_INTSTS Mask             */
N
N#define SPI_STATUS_SLV_START_INTSTS_Pos  (11)                                              /*!< SPI_T::STATUS: SLV_START_INTSTS Position  */
N#define SPI_STATUS_SLV_START_INTSTS_Msk  (0x1ul << SPI_STATUS_SLV_START_INTSTS_Pos)        /*!< SPI_T::STATUS: SLV_START_INTSTS Mask      */
N
N#define SPI_STATUS_RX_FIFO_COUNT_Pos     (12)                                              /*!< SPI_T::STATUS: RX_FIFO_COUNT Position     */
N#define SPI_STATUS_RX_FIFO_COUNT_Msk     (0xful << SPI_STATUS_RX_FIFO_COUNT_Pos)           /*!< SPI_T::STATUS: RX_FIFO_COUNT Mask         */
N
N#define SPI_STATUS_IF_Pos                (16)                                              /*!< SPI_T::STATUS: IF Position                */
N#define SPI_STATUS_IF_Msk                (0x1ul << SPI_STATUS_IF_Pos)                      /*!< SPI_T::STATUS: IF Mask                    */
N
N#define SPI_STATUS_TIMEOUT_Pos           (20)                                              /*!< SPI_T::STATUS: TIMEOUT Position           */
N#define SPI_STATUS_TIMEOUT_Msk           (0x1ul << SPI_STATUS_TIMEOUT_Pos)                 /*!< SPI_T::STATUS: TIMEOUT Mask               */
N
N#define SPI_STATUS_RX_EMPTY_Pos          (24)                                              /*!< SPI_T::STATUS: RX_EMPTY Position          */
N#define SPI_STATUS_RX_EMPTY_Msk          (0x1ul << SPI_STATUS_RX_EMPTY_Pos)                /*!< SPI_T::STATUS: RX_EMPTY Mask              */
N
N#define SPI_STATUS_RX_FULL_Pos           (25)                                              /*!< SPI_T::STATUS: RX_FULL Position           */
N#define SPI_STATUS_RX_FULL_Msk           (0x1ul << SPI_STATUS_RX_FULL_Pos)                 /*!< SPI_T::STATUS: RX_FULL Mask               */
N
N#define SPI_STATUS_TX_EMPTY_Pos          (26)                                              /*!< SPI_T::STATUS: TX_EMPTY Position          */
N#define SPI_STATUS_TX_EMPTY_Msk          (0x1ul << SPI_STATUS_TX_EMPTY_Pos)                /*!< SPI_T::STATUS: TX_EMPTY Mask              */
N
N#define SPI_STATUS_TX_FULL_Pos           (27)                                              /*!< SPI_T::STATUS: TX_FULL Position           */
N#define SPI_STATUS_TX_FULL_Msk           (0x1ul << SPI_STATUS_TX_FULL_Pos)                 /*!< SPI_T::STATUS: TX_FULL Mask               */
N
N#define SPI_STATUS_TX_FIFO_COUNT_Pos     (28)                                              /*!< SPI_T::STATUS: TX_FIFO_COUNT Position     */
N#define SPI_STATUS_TX_FIFO_COUNT_Msk     (0xful << SPI_STATUS_TX_FIFO_COUNT_Pos)           /*!< SPI_T::STATUS: TX_FIFO_COUNT Mask         */
N
N/**@}*/ /* SPI_CONST */
N/**@}*/ /* end of SPI register group */
N
N
N/*---------------------- Timer Controller -------------------------*/
N/**
N    @addtogroup TMR Timer Controller(TMR)
N    Memory Mapped Structure for TMR Controller
N@{ */
N
N
Ntypedef struct {
N
N    /**
N     * @var TIMER_T::TCSR
N     * Offset: 0x00  Timer Control and Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |PRESCALE  |Prescale Counter
N     * |        |          |Timer input clock source is divided by (PRESCALE+1) before it is fed to the Timer up counter.
N     * |        |          |If this field is 0 (PRESCALE = 0), then there is no scaling.
N     * |[16]    |TDR_EN    |Data Load Enable Control
N     * |        |          |When TDR_EN is set, TDR (Timer Data Register) will be updated continuously with the 24-bit up-timer value as the timer is counting.
N     * |        |          |0 = Timer Data Register update Disabled.
N     * |        |          |1 = Timer Data Register update Enabled while Timer counter is active.
N     * |[17]    |PERIODIC_SEL|Periodic Mode Behavior Selection
N     * |        |          |0 = In One-shot or Periodic mode, when write new TCMP, timer counter will reset.
N     * |        |          |1 = In One-shot or Periodic mode, when write new TCMP if new TCMP > TDR(current counter) , timer counter keep counting and will not reset.
N     * |        |          |If new TCMP <= TDR(current counter) , timer counter will reset.
N     * |[18]    |TOUT_PIN  |Toggle Out Pin Selection
N     * |        |          |When Timer is set to toggle mode,
N     * |        |          |0 = Time0/1 toggle output pin is T0/T1 pin.
N     * |        |          |1 = Time0/1 toggle output pin is T0EX/T1EX pin.
N     * |[19]    |CAP_SRC   |Capture Pin Source Selection
N     * |        |          |0 = Capture Function source is from TxEX pin.
N     * |        |          |1 = Capture Function source is from ACMPx output signal.
N     * |[23]    |WAKE_EN   |Wake-up Enable Control
N     * |        |          |When WAKE_EN (UA_IER[6]) is set and the TIF or TEXIF (TEXISR[0]) is set, the timer controller will generator a wake-up trigger event to CPU.
N     * |        |          |0 = Wake-up trigger event Disabled.
N     * |        |          |1 = Wake-up trigger event Enabled.
N     * |[24]    |CTB       |Counter Mode Enable Control
N     * |        |          |This bit is for external counting pin function enabled.
N     * |        |          |When timer is used as an event counter, this bit should be set to 1 and select HCLK as timer clock source.
N     * |        |          |Please refer to section 6.12.5.3 for detail description.
N     * |        |          |0 = External event counter mode Disabled.
N     * |        |          |1 = External event counter mode Enabled.
N     * |[25]    |CACT      |Timer Active Status (Read Only)
N     * |        |          |This bit indicates the 24-bit up counter status.
N     * |        |          |0 = 24-bit up counter is not active.
N     * |        |          |1 = 24-bit up counter is active.
N     * |[26]    |CRST      |Timer Reset
N     * |        |          |0 = No effect.
N     * |        |          |1 = Reset 8-bit prescale counter, 24-bit up counter value and CEN bit if CACT is 1.
N     * |[28:27] |MODE      |Timer Operating Mode
N     * |        |          |00 = The timer is operating in the One-shot mode.
N     * |        |          |The associated interrupt signal is generated once (if IE is enabled) and CEN is automatically cleared by hardware.
N     * |        |          |01 = The timer is operating in Periodic mode.
N     * |        |          |The associated interrupt signal is generated periodically (if IE is enabled).
N     * |        |          |10 = The timer is operating in Toggle mode.
N     * |        |          |The interrupt signal is generated periodically (if   IE is enabled).
N     * |        |          |The associated signal (tout) is changing back and forth with 50% duty cycle.
N     * |        |          |11 = The timer is operating in Continuous Counting mode.
N     * |        |          |The associated interrupt signal is generated when TDR = TCMPR (if IE is enabled).
N     * |        |          |However, the 24-bit up-timer counts continuously.
N     * |        |          |Please refer to 6.12.5.2 for detailed description about Continuous Counting mode operation.
N     * |[29]    |IE        |Interrupt Enable Control
N     * |        |          |0 = Timer Interrupt function Disabled.
N     * |        |          |1 = Timer Interrupt function Enabled.
N     * |        |          |If this bit is enabled, when the timer interrupt flag (TIF) is set to 1, the timer interrupt signal is generated and inform to CPU.
N     * |[30]    |CEN       |Timer Enable Control
N     * |        |          |0 = Stops/Suspends counting.
N     * |        |          |1 = Starts counting.
N     * |        |          |Note1: In stop status, and then set CEN to 1 will enable the 24-bit up counter to keep  counting from the last stop counting value.
N     * |        |          |Note2: This bit is auto-cleared by hardware in one-shot mode (MODE (TCSRx[28:27]) = 00) when the timer interrupt flag (TIF) is generated.
N     * |[31]    |DBGACK_TMR|ICE Debug Mode Acknowledge Disable Control (Write Protect)
N     * |        |          |0 = ICE debug mode acknowledgement effects TIMER counting.
N     * |        |          |Timer counter will be held while CPU is held by ICE.
N     * |        |          |1 = ICE debug mode acknowledgement Disabled.
N     * |        |          |Timer counter will keep going no matter CPU is held by ICE or not.
N     * @var TIMER_T::TCMPR
N     * Offset: 0x04  Timer Compare Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[23:0]  |TCMP      |Timer Compared Value
N     * |        |          |TCMP is a 24-bit compared value register.
N     * |        |          |When the internal 24-bit up counter value is equal to TCMP value, the TIF flag will set to 1.
N     * |        |          |Time-out period = (Period of Timer clock source) * (8-bit PRESCALE + 1) * (24-bit TCMP).
N     * |        |          |Note1: Never write 0x0 or 0x1 in TCMP field, or the core will run into unknown state.
N     * @var TIMER_T::TISR
N     * Offset: 0x08  Timer Interrupt Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TIF       |Timer Interrupt Flag
N     * |        |          |This bit indicates the interrupt flag status of Timer while TDR value reaches to TCMP value.
N     * |        |          |0 = No effect.
N     * |        |          |1 = TDR value matches the TCMP value.
N     * |        |          |Note: This bit is cleared by writing 1 to it.
N     * |[1]     |TWF       |Timer Wake-up Flag
N     * |        |          |This bit indicates the interrupt wake-up flag status of Time.
N     * |        |          |0 = Timer does not cause chip wake-up.
N     * |        |          |1 = Chip wake-up from Idle or Power-down mode if Timer time-out interrupt signal generated.
N     * |        |          |Note: This bit is cleared by writing 1 to it.
N     * @var TIMER_T::TDR
N     * Offset: 0x0C  Timer Data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[23:0]  |TDR       |Timer Data Register
N     * |        |          |If TDR_EN (TCSRx[16]) is set to 1, TDR register value will be updated continuously to monitor 24-bit up counter value.
N     * @var TIMER_T::TCAP
N     * Offset: 0x10  Timer Capture Data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[23:0]  |TCAP      |Timer Capture Data Register
N     * |        |          |When TEXIF flag is set to 1, the current TDR value will be auto-loaded into this TCAP filed immediately.
N     * @var TIMER_T::TEXCON
N     * Offset: 0x14  Timer External Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TX_PHASE  |Timer External Count Pin Phase Detect Selection
N     * |        |          |This bit indicates the detection phase of Tx (x = 0~1) pin.
N     * |        |          |0 = A falling edge of Tx (x = 0~1) pin will be counted.
N     * |        |          |1 = A rising edge of Tx (x = 0~1) pin will be counted.
N     * |[2:1]   |TEX_EDGE  |Timer External Pin Edge Detection
N     * |        |          |00 = A 1 to 0 transition on TxEX (x = 0~1) will be detected.
N     * |        |          |01 = A 0 to 1 transition on TxEX (x = 0~1) will be detected.
N     * |        |          |10 = Either 1 to 0 or 0 to 1 transition on TxEX (x = 0~1) will be detected.
N     * |        |          |11 = Reserved.
N     * |[3]     |TEXEN     |Timer External Pin Function Enable Control
N     * |        |          |This bit enables the RSTCAPSEL function on the TxEX (x = 0~1) pin.
N     * |        |          |0 = RSTCAPSEL function of TxEX (x = 0~1) pin will be ignored.
N     * |        |          |1 = RSTCAPSEL function of TxEX (x = 0~1) pin is active.
N     * |[4]     |RSTCAPSEL |Timer External Reset Counter / Timer External Capture Mode Selection
N     * |        |          |0 = Transition on TxEX (x = 0~1) pin is using to save the TDR value into TCAP value if TEXIF flag is set to 1.
N     * |        |          |1 = Transition on TxEX (x = 0~1) pin is using to reset the 24-bit up counter.
N     * |[5]     |TEXIEN    |Timer External Capture Interrupt Enable Control
N     * |        |          |0 = TxEX (x = 0~1) pin detection Interrupt Disabled.
N     * |        |          |1 = TxEX (x = 0~1) pin detection Interrupt Enabled.
N     * |        |          |If TEXIEN enabled, Timer will raise an external capture interrupt signal and inform to CPU while TEXIF flag is set to 1.
N     * |[6]     |TEXDB     |Timer External Capture Input Pin De-bounce Enable Control
N     * |        |          |0 = TxEX (x = 0~1) pin de-bounce Disabled.
N     * |        |          |1 = TxEX (x = 0~1) pin de-bounce Enabled.
N     * |        |          |If this bit is enabled, the edge detection of TxEX (x = 0~1) pin is detected with de-bounce circuit.
N     * |[7]     |TCDB      |Timer External Counter Input Pin De-bounce Enable Control
N     * |        |          |0 = Tx (x = 0~1) pin de-bounce Disabled.
N     * |        |          |1 = Tx (x = 0~1) pin de-bounce Enabled.
N     * |        |          |If this bit is enabled, the edge detection of Tx (x = 0~1) pin is detected with de-bounce circuit.
N     * |[8]     |CAP_MODE  |Capture Mode Selection
N     * |        |          |0 = Timer counter reset function or free-counting mode of timer capture function.
N     * |        |          |1 = Trigger-counting mode of timer capture function.
N     * @var TIMER_T::TEXISR
N     * Offset: 0x18  Timer External Interrupt Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TEXIF     |Timer External Interrupt Flag
N     * |        |          |This bit indicates the external capture interrupt flag status
N     * |        |          |When TEXEN enabled, TxEX (x = 0, 1) pin selected as external capture function, and a transition on TxEX (x = 0, 1) pin matched the TEX_EDGE setting, this flag will set to 1 by hardware.
N     * |        |          |0 = TxEX (x = 0, 1) pin interrupt did not occur.
N     * |        |          |1 = TxEX (x = 0, 1) pin interrupt occurred.
N     * |        |          |Note: This bit is cleared by writing 1 to it
N     */
N
N    __IO uint32_t TCSR;         /* Offset: 0x00  Timer Control and Status Register                                 */
X    volatile uint32_t TCSR;          
N    __IO uint32_t TCMPR;        /* Offset: 0x04  Timer Compare Register                                            */
X    volatile uint32_t TCMPR;         
N    __IO uint32_t TISR;         /* Offset: 0x08  Timer Interrupt Status Register                                   */
X    volatile uint32_t TISR;          
N    __I  uint32_t TDR;          /* Offset: 0x0C  Timer Data Register                                               */
X    volatile const  uint32_t TDR;           
N    __I  uint32_t TCAP;         /* Offset: 0x10  Timer Capture Data Register                                       */
X    volatile const  uint32_t TCAP;          
N    __IO uint32_t TEXCON;       /* Offset: 0x14  Timer External Control Register                                   */
X    volatile uint32_t TEXCON;        
N    __IO uint32_t TEXISR;       /* Offset: 0x18  Timer External Interrupt Status Register                          */
X    volatile uint32_t TEXISR;        
N} TIMER_T;
N
N
N
N/**
N    @addtogroup TMR_CONST TMR Bit Field Definition
N    Constant Definitions for TMR Controller
N@{ */
N
N#define TIMER_TCSR_PRESCALE_Pos           (0)                                               /*!< TIMER_T::TCSR: PRESCALE Position           */
N#define TIMER_TCSR_PRESCALE_Msk           (0xfful << TIMER_TCSR_PRESCALE_Pos)               /*!< TIMER_T::TCSR: PRESCALE Mask               */
N
N#define TIMER_TCSR_TDR_EN_Pos             (16)                                              /*!< TIMER_T::TCSR: TDR_EN Position             */
N#define TIMER_TCSR_TDR_EN_Msk             (0x1ul << TIMER_TCSR_TDR_EN_Pos)                  /*!< TIMER_T::TCSR: TDR_EN Mask                 */
N
N#define TIMER_TCSR_PERIODIC_SEL_Pos       (17)                                              /*!< TIMER_T::TCSR: PERIODIC_SEL Position       */
N#define TIMER_TCSR_PERIODIC_SEL_Msk       (0x1ul << TIMER_TCSR_PERIODIC_SEL_Pos)            /*!< TIMER_T::TCSR: PERIODIC_SEL Mask           */
N
N#define TIMER_TCSR_TOGGLE_PIN_Pos         (18)                                              /*!< TIMER TCSR: TOGGLE_PIN Position            */
N#define TIMER_TCSR_TOGGLE_PIN_Msk         (0x1ul << TIMER_TCSR_TOGGLE_PIN_Pos)              /*!< TIMER TCSR: TOGGLE_PIN Mask                */
N
N#define TIMER_TCSR_TOUT_PIN_Pos           (18)                                              /*!< TIMER_T::TCSR: TOUT_PIN Position           */
N#define TIMER_TCSR_TOUT_PIN_Msk           (0x1ul << TIMER_TCSR_TOUT_PIN_Pos)                /*!< TIMER_T::TCSR: TOUT_PIN Mask               */
N
N#define TIMER_TCSR_CAP_SRC_Pos            (19)                                              /*!< TIMER_T::TCSR: CAP_SRC Position            */
N#define TIMER_TCSR_CAP_SRC_Msk            (0x1ul << TIMER_TCSR_CAP_SRC_Pos)                 /*!< TIMER_T::TCSR: CAP_SRC Mask                */
N
N#define TIMER_TCSR_WAKE_EN_Pos            (23)                                              /*!< TIMER_T::TCSR: WAKE_EN Position            */
N#define TIMER_TCSR_WAKE_EN_Msk            (0x1ul << TIMER_TCSR_WAKE_EN_Pos)                 /*!< TIMER_T::TCSR: WAKE_EN Mask                */
N
N#define TIMER_TCSR_CTB_Pos                (24)                                              /*!< TIMER_T::TCSR: CTB Position                */
N#define TIMER_TCSR_CTB_Msk                (0x1ul << TIMER_TCSR_CTB_Pos)                     /*!< TIMER_T::TCSR: CTB Mask                    */
N
N#define TIMER_TCSR_CACT_Pos               (25)                                              /*!< TIMER_T::TCSR: CACT Position               */
N#define TIMER_TCSR_CACT_Msk               (0x1ul << TIMER_TCSR_CACT_Pos)                    /*!< TIMER_T::TCSR: CACT Mask                   */
N
N#define TIMER_TCSR_CRST_Pos               (26)                                              /*!< TIMER_T::TCSR: CRST Position               */
N#define TIMER_TCSR_CRST_Msk               (0x1ul << TIMER_TCSR_CRST_Pos)                    /*!< TIMER_T::TCSR: CRST Mask                   */
N
N#define TIMER_TCSR_MODE_Pos               (27)                                              /*!< TIMER_T::TCSR: MODE Position               */
N#define TIMER_TCSR_MODE_Msk               (0x3ul << TIMER_TCSR_MODE_Pos)                    /*!< TIMER_T::TCSR: MODE Mask                   */
N
N#define TIMER_TCSR_IE_Pos                 (29)                                              /*!< TIMER_T::TCSR: IE Position                 */
N#define TIMER_TCSR_IE_Msk                 (0x1ul << TIMER_TCSR_IE_Pos)                      /*!< TIMER_T::TCSR: IE Mask                     */
N
N#define TIMER_TCSR_CEN_Pos                (30)                                              /*!< TIMER_T::TCSR: CEN Position                */
N#define TIMER_TCSR_CEN_Msk                (0x1ul << TIMER_TCSR_CEN_Pos)                     /*!< TIMER_T::TCSR: CEN Mask                    */
N
N#define TIMER_TCSR_DBGACK_TMR_Pos         (31)                                              /*!< TIMER_T::TCSR: DBGACK_TMR Position         */
N#define TIMER_TCSR_DBGACK_TMR_Msk         (0x1ul << TIMER_TCSR_DBGACK_TMR_Pos)              /*!< TIMER_T::TCSR: DBGACK_TMR Mask             */
N
N#define TIMER_TCMP_TCMP_Pos               (0)                                               /*!< TIMER_T::TCMPR: TCMP Position              */
N#define TIMER_TCMP_TCMP_Msk               (0xfffffful << TIMER_TCMP_TCMP_Pos)               /*!< TIMER_T::TCMPR: TCMP Mask                  */
N
N#define TIMER_TISR_TIF_Pos                (0)                                               /*!< TIMER_T::TISR: TIF Position                */
N#define TIMER_TISR_TIF_Msk                (0x1ul << TIMER_TISR_TIF_Pos)                     /*!< TIMER_T::TISR: TIF Mask                    */
N
N#define TIMER_TISR_TWF_Pos                (1)                                               /*!< TIMER_T::TISR: TWF Position                */
N#define TIMER_TISR_TWF_Msk                (0x1ul << TIMER_TISR_TWF_Pos)                     /*!< TIMER_T::TISR: TWF Mask                    */
N
N#define TIMER_TDR_TDR_Pos                 (0)                                               /*!< TIMER_T::TDR: TDR Position                 */
N#define TIMER_TDR_TDR_Msk                 (0xfffffful << TIMER_TDR_TDR_Pos)                 /*!< TIMER_T::TDR: TDR Mask                     */
N
N#define TIMER_TCAP_TCAP_Pos               (0)                                               /*!< TIMER_T::TCAP: TCAP Position               */
N#define TIMER_TCAP_TCAP_Msk               (0xfffffful << TIMER_TCAP_TCAP_Pos)               /*!< TIMER_T::TCAP: TCAP Mask                   */
N
N#define TIMER_TEXCON_TX_PHASE_Pos         (0)                                               /*!< TIMER_T::TEXCON: TX_PHASE Position         */
N#define TIMER_TEXCON_TX_PHASE_Msk         (0x1ul << TIMER_TEXCON_TX_PHASE_Pos)              /*!< TIMER_T::TEXCON: TX_PHASE Mask             */
N
N#define TIMER_TEXCON_TEX_EDGE_Pos         (1)                                               /*!< TIMER_T::TEXCON: TEX_EDGE Position         */
N#define TIMER_TEXCON_TEX_EDGE_Msk         (0x3ul << TIMER_TEXCON_TEX_EDGE_Pos)              /*!< TIMER_T::TEXCON: TEX_EDGE Mask             */
N
N#define TIMER_TEXCON_TEXEN_Pos            (3)                                               /*!< TIMER_T::TEXCON: TEXEN Position            */
N#define TIMER_TEXCON_TEXEN_Msk            (0x1ul << TIMER_TEXCON_TEXEN_Pos)                 /*!< TIMER_T::TEXCON: TEXEN Mask                */
N
N#define TIMER_TEXCON_RSTCAPSEL_Pos        (4)                                               /*!< TIMER_T::TEXCON: RSTCAPSEL Position        */
N#define TIMER_TEXCON_RSTCAPSEL_Msk        (0x1ul << TIMER_TEXCON_RSTCAPSEL_Pos)             /*!< TIMER_T::TEXCON: RSTCAPSEL Mask            */
N
N#define TIMER_TEXCON_TEXIEN_Pos           (5)                                               /*!< TIMER_T::TEXCON: TEXIEN Position           */
N#define TIMER_TEXCON_TEXIEN_Msk           (0x1ul << TIMER_TEXCON_TEXIEN_Pos)                /*!< TIMER_T::TEXCON: TEXIEN Mask               */
N
N#define TIMER_TEXCON_TEXDB_Pos            (6)                                               /*!< TIMER_T::TEXCON: TEXDB Position            */
N#define TIMER_TEXCON_TEXDB_Msk            (0x1ul << TIMER_TEXCON_TEXDB_Pos)                 /*!< TIMER_T::TEXCON: TEXDB Mask                */
N
N#define TIMER_TEXCON_TCDB_Pos             (7)                                               /*!< TIMER_T::TEXCON: TCDB Position             */
N#define TIMER_TEXCON_TCDB_Msk             (0x1ul << TIMER_TEXCON_TCDB_Pos)                  /*!< TIMER_T::TEXCON: TCDB Mask                 */
N
N#define TIMER_TEXCON_CAP_MODE_Pos         (8)                                               /*!< TIMER_T::TEXCON: CAP_MODE Position         */
N#define TIMER_TEXCON_CAP_MODE_Msk         (0x1ul << TIMER_TEXCON_CAP_MODE_Pos)              /*!< TIMER_T::TEXCON: CAP_MODE Mask             */
N
N#define TIMER_TEXISR_TEXIF_Pos            (0)                                               /*!< TIMER_T::TEXISR: TEXIF Position            */
N#define TIMER_TEXISR_TEXIF_Msk            (0x1ul << TIMER_TEXISR_TEXIF_Pos)                 /*!< TIMER_T::TEXISR: TEXIF Mask                */
N
N/**@}*/ /* TMR_CONST */
N/**@}*/ /* end of TMR register group */
N
N
N/*---------------------- Universal Asynchronous Receiver/Transmitter Controller -------------------------*/
N/**
N    @addtogroup UART Universal Asynchronous Receiver/Transmitter Controller(UART)
N    Memory Mapped Structure for UART Controller
N@{ */
N
N
Ntypedef struct {
N
N    /**
N     * @var UART_T::RBR
N     * Offset: 0x00  UART Receive Buffer Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |RBR       |Receive Buffer Bits (Read Only)
N     * |        |          |By reading this register, the UART Controller will return an 8-bit data received from RX pin (LSB first).
N     * @var UART_T::THR
N     * Offset: 0x00  UART Transmit Holding Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |THR       |Transmit Holding Bits
N     * |        |          |By writing to this register, the UART sends out an 8-bit data through the TX pin (LSB first).
N     * @var UART_T::IER
N     * Offset: 0x04  UART Interrupt Enable Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RDA_IEN   |Receive Data Available Interrupt Enable Control
N     * |        |          |0 = RDA_INT Masked off.
N     * |        |          |1 = RDA_INT Enabled.
N     * |[1]     |THRE_IEN  |Transmit Holding Register Empty Interrupt Enable Control
N     * |        |          |0 = THRE_INT Masked off.
N     * |        |          |1 = THRE_INT Enabled.
N     * |[2]     |RLS_IEN   |Receive Line Status Interrupt Enable Control
N     * |        |          |0 = RLS_INT Masked off.
N     * |        |          |1 = RLS_INT Enabled.
N     * |[3]     |MODEM_IEN |Modem Status Interrupt Enable Control
N     * |        |          |0 = MODEM_INT Masked off.
N     * |        |          |1 = MODEM_INT Enabled.
N     * |[4]     |RTO_IEN   |RX Time-out Interrupt Enable Control
N     * |        |          |0 = TOUT_INT Masked off.
N     * |        |          |1 = TOUT_INT Enabled.
N     * |[5]     |BUF_ERR_IEN|Buffer Error Interrupt Enable Control
N     * |        |          |0 = INT_BUF_ERR Masked Disabled.
N     * |        |          |1 = INT_BUF_ERR Enabled.
N     * |[6]     |WAKE_EN   |Wake-up CPU Function Enable Control
N     * |        |          |0 = UART wake-up function Disabled.
N     * |        |          |1 = UART Wake-up function Enabled.
N     * |        |          |Note: when the chip is in Power-down mode, an external CTS change will wake-up chip from Power-down mode.
N     * |[11]    |TIME_OUT_EN|Time-out Counter Enable Control
N     * |        |          |0 = Time-out counter Disabled.
N     * |        |          |1 = Time-out counter Enabled.
N     * |[12]    |AUTO_RTS_EN|RTS Auto Flow Control Enable Control
N     * |        |          |0 = RTS auto flow control Disabled.
N     * |        |          |1 = RTS auto flow control Enabled.
N     * |        |          |Note: When RTS auto-flow is enabled, if the number of bytes in the RX FIFO equals the RTS_TRI_LEV (UA_FCR [19:16]), the UART will de-assert RTS signal.
N     * |[13]    |AUTO_CTS_EN|CTS Auto Flow Control Enable Control
N     * |        |          |0 = CTS auto flow control Disabled.
N     * |        |          |1 = CTS auto flow control Enabled.
N     * |        |          |Note: When CTS auto-flow is enabled, the UART will send data to external device when CTS input assert (UART will not send data to device until CTS is asserted).
N     * @var UART_T::FCR
N     * Offset: 0x08  UART FIFO Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |RFR       |RX Field Software Reset
N     * |        |          |When RX_RST is set, all the byte in the receiver FIFO and RX internal state machine are cleared.
N     * |        |          |0 = No effect.
N     * |        |          |1 = The RX internal state machine and pointers reset.
N     * |        |          |Note: This bit will auto clear needs at least 3 UART Controller peripheral clock cycles.
N     * |[2]     |TFR       |TX Field Software Reset
N     * |        |          |When TX_RST is set, all the byte in the transmit FIFO and TX internal state machine are cleared.
N     * |        |          |0 = No effect.
N     * |        |          |1 = The TX internal state machine and pointers reset.
N     * |        |          |Note: This bit will auto clear needs at least 3 UART Controller peripheral clock cycles.
N     * |[7:4]   |RFITL     |RX FIFO Interrupt (RDA_INT) Trigger Level
N     * |        |          |When the number of bytes in the receive FIFO equals the RFITL then the RDA_IF will be set (if RDA_IEN in UA_IER register is enable, an interrupt will generated).
N     * |        |          |0000 = RX FIFO Interrupt Trigger Level is 1 byte.
N     * |        |          |0001 = RX FIFO Interrupt Trigger Level is 4 bytes.
N     * |        |          |0010 = RX FIFO Interrupt Trigger Level is 8 bytes.
N     * |        |          |0011 = RX FIFO Interrupt Trigger Level is 14 bytes.
N     * |        |          |Other = Reserved.
N     * |[8]     |RX_DIS    |Receiver Disable Control
N     * |        |          |The receiver is disabled or not (setting 1 to disable the receiver).
N     * |        |          |0 = Receiver Enabled.
N     * |        |          |1 = Receiver Disabled.
N     * |        |          |Note1: This field is only used for RS-485 Normal Multi-drop mode.
N     * |        |          |It should be programmed firstly to avoid receiving unknown data before RS-485_NMM (UA_ALT_CSR [8]) is programmed.
N     * |        |          |Note2: After RS-485 receives an address byte in RS-485 Normal Multi-drop mode, this bit (RX_DIS) will be cleared to "0" by hardware.
N     * |[19:16] |RTS_TRI_LEV|RTS Trigger Level (For Auto-flow Control Use)
N     * |        |          |0000 = RTS Trigger Level is 1 byte.
N     * |        |          |0001 = RTS Trigger Level is 4 bytes.
N     * |        |          |0010 = RTS Trigger Level is 8 bytes.
N     * |        |          |0011 = RTS Trigger Level is 14 bytes.
N     * |        |          |Other = Reserved.
N     * |        |          |Note: This field is used for RTS auto-flow control.
N     * @var UART_T::LCR
N     * Offset: 0x0C  UART Line Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |WLS       |Word Length Selection
N     * |        |          |00 = Word length is 5-bit.
N     * |        |          |01 = Word length is 6-bit.
N     * |        |          |10 = Word length is 7-bit.
N     * |        |          |11 = Word length is 8-bit.
N     * |[2]     |NSB       |Number Of "STOP Bit"
N     * |        |          |0 = One "STOP bit" is generated in the transmitted data.
N     * |        |          |1 = When select 5-bit word length, 1.5 "STOP bit" is generated in the transmitted data.
N     * |        |          |When select 6-, 7- and 8-bit word length, 2 "STOP bit" is generated in the transmitted data.
N     * |[3]     |PBE       |Parity Bit Enable Control
N     * |        |          |0 = No parity bit.
N     * |        |          |1 = Parity bit is generated on each outgoing character and is checked on each incoming data.
N     * |[4]     |EPE       |Even Parity Enable Control
N     * |        |          |0 = Odd number of logic 1's is transmitted and checked in each word.
N     * |        |          |1 = Even number of logic 1's is transmitted and checked in each word.
N     * |        |          |This bit has effect only when PBE (UA_LCR[3]) is set.
N     * |[5]     |SPE       |Stick Parity Enable Control
N     * |        |          |0 = Stick parity Disabled.
N     * |        |          |1 = If PBE (UA_LCR[3]) and EBE (UA_LCR[4]) are logic 1, the parity bit is transmitted and checked as logic 0.
N     * |        |          |If PBE (UA_LCR[3]) is 1 and EBE (UA_LCR[4]) is 0 then the parity bit is transmitted and checked as 1.
N     * |[6]     |BCB       |Break Control Bit
N     * |        |          |When this bit is set to logic 1, the serial data output (TX) is forced to the Spacing State (logic 0).
N     * |        |          |This bit acts only on TX and has no effect on the transmitter logic.
N     * |        |          |0 = Break control Disabled.
N     * |        |          |1 = Break control Enabled.
N     * @var UART_T::MCR
N     * Offset: 0x10  UART Modem Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |RTS       |RTS (Request-to-send) Signal Control
N     * |        |          |This bit is direct control internal RTS signal active or not, and then drive the RTS pin output with LEV_RTS bit configuration.
N     * |        |          |0 = RTS signal is active.
N     * |        |          |1 = RTS signal is inactive.
N     * |        |          |Note1: This RTS signal control bit is not effective when RTS auto-flow control (AUTO_RTS_EN) is enabled in UART function mode.
N     * |        |          |Note2: This RTS signal control bit is not effective when RS-485 auto direction mode (RS485_AUD) is enabled in RS-485 function mode.
N     * |[9]     |LEV_RTS   |RTS Pin Active Level
N     * |        |          |This bit defines the active level state of RTS pin output.
N     * |        |          |0 = RTS pin output is high level active.
N     * |        |          |1 = RTS pin output is low level active.
N     * |        |          |Note1: Refer to and UART function mode.
N     * |        |          |Note2: Refer to and for RS-485 function mode.
N     * |[13]    |RTS_ST    |RTS Pin State (Read Only)
N     * |        |          |This bit mirror from RTS pin output of voltage logic status.
N     * |        |          |0 = RTS pin output is low level voltage logic state.
N     * |        |          |1 = RTS pin output is high level voltage logic state.
N     * @var UART_T::MSR
N     * Offset: 0x14  UART Modem Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |DCTSF     |Detect CTS State Change Flag
N     * |        |          |This bit is set whenever CTS input has change state, and it will generate Modem interrupt to CPU when MODEM_IEN (UA_IER [3]) is set to 1.
N     * |        |          |0 = CTS input has not change state.
N     * |        |          |1 = CTS input has change state.
N     * |        |          |Note: This bit is cleared by writing 1 to it.
N     * |[4]     |CTS_ST    |CTS Pin Status (Read Only)
N     * |        |          |This bit mirror from CTS pin input of voltage logic status.
N     * |        |          |0 = CTS pin input is low level voltage logic state.
N     * |        |          |1 = CTS pin input is high level voltage logic state.
N     * |        |          |Note: This bit echoes when UART Controller peripheral clock is enabled, and CTS multi-function port is selected.
N     * |[8]     |LEV_CTS   |CTS Pin Active Level
N     * |        |          |This bit defines the active level state of CTS pin input.
N     * |        |          |0 = CTS pin input is high level active.
N     * |        |          |1 = CTS pin input is low level active.
N     * |        |          |Note: Refer to
N     * @var UART_T::FSR
N     * Offset: 0x18  UART FIFO Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RX_OVER_IF|RX Overflow Error Interrupt Flag
N     * |        |          |This bit is set when RX FIFO overflow.
N     * |        |          |If the number of bytes of received data is greater than RX_FIFO (UA_RBR) size 16 bytes, this bit will be set.
N     * |        |          |0 = RX FIFO is not overflow.
N     * |        |          |1 = RX FIFO is overflow.
N     * |        |          |Note: This bit is cleared by writing 1 to it.
N     * |[3]     |RS485_ADD_DETF|RS-485 Address Byte Detection Flag
N     * |        |          |This bit is set to 1 while RS485_ADD_EN (UA_ALT_CSR[15]) is set to 1 to enable Address detection mode and receive detect a data with an address bit (bit 9 = 1).
N     * |        |          |Note1: This field is used for RS-485 function mode.
N     * |        |          |Note2: This bit is cleared by writing 1 to it.
N     * |[4]     |PEF       |Parity Error Flag (Read Only)
N     * |        |          |This bit is set to logic 1 whenever the received character does not have a valid "parity bit".
N     * |        |          |0 = No parity error is generated.
N     * |        |          |1 = Parity error is generated.Note: This bit is read only, but can be cleared by writing '1' to it .
N     * |[5]     |FEF       |Framing Error Flag (Read Only)
N     * |        |          |This bit is set to logic 1 whenever the received character does not have a valid "stop bit" (that is, the stop bit follows the last data bit or parity bit is detected as as logic 0).
N     * |        |          |0 = No framing error is generated.
N     * |        |          |1 = Framing error is generated.
N     * |        |          |Note: This bit is read only, but can be cleared by writing '1' to it .
N     * |[6]     |BIF       |Break Interrupt Flag (Read Only)
N     * |        |          |This bit is set to logic 1 whenever the received data input (RX) is held in the "spacing state" (logic 0) for longer than a full word transmission time (that is, the total time of "start bit" + data bits + parity + stop bits).
N     * |        |          |0 = No Break interrupt is generated.
N     * |        |          |1 = Break interrupt is generated.
N     * |        |          |Note: This bit is read only, but software can write 1 to clear it.
N     * |[13:8]  |RX_POINTER|RX FIFO Pointer (Read Only)
N     * |        |          |This field indicates the RX FIFO Buffer Pointer.
N     * |        |          |When UART receives one byte from external device, RX_POINTER increases one.
N     * |        |          |When one byte of RX FIFO is read by CPU, RX_POINTER decreases one.
N     * |        |          |The Maximum value shown in RX_POINTER is 15.
N     * |        |          |When the using level of RX FIFO Buffer equal to 16, the RX_FULL bit is set to 1 and RX_POINTER will show 0.
N     * |        |          |As one byte of RX FIFO is read by CPU, the RX_FULL bit is cleared to 0 and RX_POINTER will show 15.
N     * |[14]    |RX_EMPTY  |Receiver FIFO Empty (Read Only)
N     * |        |          |This bit initiate RX FIFO empty or not.
N     * |        |          |0 = RX FIFO is not empty.
N     * |        |          |1 = RX FIFO is empty.
N     * |        |          |Note: When the last byte of RX FIFO has been read by CPU, hardware sets this bit high.
N     * |        |          |It will be cleared when UART receives any new data.
N     * |[15]    |RX_FULL   |Receiver FIFO Full (Read Only)
N     * |        |          |This bit initiates RX FIFO full or not.
N     * |        |          |0 = RX FIFO is not full.
N     * |        |          |1 = RX FIFO is full.
N     * |        |          |Note: This bit is set when the number of usage in RX FIFO Buffer is equal to 16, otherwise is cleared by hardware.
N     * |[21:16] |TX_POINTER|TX FIFO Pointer (Read Only)
N     * |        |          |This field indicates the TX FIFO Buffer Pointer.
N     * |        |          |When CPU writes one byte into UA_THR, TX_POINTER increases one.
N     * |        |          |When one byte of TX FIFO is transferred to Transmitter Shift Register, TX_POINTER decreases one.
N     * |        |          |The Maximum value shown in TX_POINTER is 15.
N     * |        |          |When the using level of TX FIFO Buffer equal to 16, the TX_FULL bit is set to 1 and TX_POINTER will show 0.
N     * |        |          |As one byte of TX FIFO is transferred to Transmitter Shift Register, the TX_FULL bit is cleared to 0 and TX_POINTER will show 15.
N     * |[22]    |TX_EMPTY  |Transmitter FIFO Empty (Read Only)
N     * |        |          |This bit indicates TX FIFO is empty or not.
N     * |        |          |0 = TX FIFO is not empty.
N     * |        |          |1 = TX FIFO is empty.
N     * |        |          |Note: When the last byte of TX FIFO has been transferred to Transmitter Shift Register, hardware sets this bit high.
N     * |        |          |It will be cleared when writing data into THR (TX FIFO not empty).
N     * |[23]    |TX_FULL   |Transmitter FIFO Full (Read Only)
N     * |        |          |This bit indicates TX FIFO full or not.
N     * |        |          |0 = TX FIFO is not full.
N     * |        |          |1 = TX FIFO is full.
N     * |        |          |Note: This bit is set when the number of usage in TX FIFO Buffer is equal to 16, otherwise is cleared by hardware.
N     * |[24]    |TX_OVER_IF|TX Overflow Error Interrupt Flag
N     * |        |          |If TX FIFO (UA_THR) is full, an additional write to UA_THR will cause this bit to  logic 1.
N     * |        |          |0 = TX FIFO is not overflow.
N     * |        |          |1 = TX FIFO is overflow.
N     * |        |          |Note: This bit is cleared by writing 1 to it.
N     * |[28]    |TE_FLAG   |Transmitter Empty Flag (Read Only)
N     * |        |          |This bit is set by hardware when TX FIFO (UA_THR) is empty and the STOP bit of the last byte has been transmitted.
N     * |        |          |0 = TX FIFO is not empty.
N     * |        |          |1 = TX FIFO is empty and the STOP bit of the last byte has been transmitted.
N     * |        |          |Note: This bit is cleared automatically when TX FIFO is not empty or the last byte transmission has not completed.
N     * @var UART_T::ISR
N     * Offset: 0x1C  UART Interrupt Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RDA_IF    |Receive Data Available Interrupt Flag (Read Only)
N     * |        |          |When the number of bytes in the RX FIFO equals the RFITL then the RDA_IF will be set.
N     * |        |          |If RDA_IEN (UA_IER [0]) is enabled, the RDA interrupt will be generated.
N     * |        |          |0 = No RDA interrupt flag is generated.
N     * |        |          |1 = RDA interrupt flag is generated.
N     * |        |          |Note: This bit is read only and it will be cleared when the number of unread bytes of RX FIFO drops below the threshold level (RFITL).
N     * |[1]     |THRE_IF   |Transmit Holding Register Empty Interrupt Flag (Read Only)
N     * |        |          |This bit is set when the last data of TX FIFO is transferred to Transmitter Shift Register.
N     * |        |          |If THRE_IEN (UA_IER [1]) is enabled, the THRE interrupt will be generated.
N     * |        |          |0 = No THRE interrupt flag is generated.
N     * |        |          |1 = THRE interrupt flag is generated.
N     * |        |          |Note: This bit is read only and it will be cleared when writing data into THR (TX FIFO not empty).
N     * |[2]     |RLS_IF    |Receive Line Interrupt Flag (Read Only)
N     * |        |          |This bit is set when the RX receive data have parity error, framing error or break error (at least one of 3 bits, BIF, FEF and PEF, is set).
N     * |        |          |If RLS_IEN (UA_IER [2]) is enabled, the RLS interrupt will be generated.
N     * |        |          |0 = No RLS interrupt flag is generated.
N     * |        |          |1 = RLS interrupt flag is generated.
N     * |        |          |Note1: In RS-485 function mode, this field is set including "receiver detect and received address byte character (bit 9 = 1) bit".
N     * |        |          |At the same time, the bit of RS485_ADD_DETF (UA_FSR[3]) is also set.
N     * |        |          |Note2: This bit is read only and reset to 0 when all bits of BIF, FEF, PEF and RS485_ADD_DETF are cleared.
N     * |[3]     |MODEM_IF  |MODEM Interrupt Flag (Read Only)
N     * |        |          |This bit is set when the CTS pin has state change (DCTSF = 1).
N     * |        |          |If UA_IER [MODEM_IEN] is enabled, the Modem interrupt will be generated.
N     * |        |          |0 = No Modem interrupt flag is generated.
N     * |        |          |1 = Modem interrupt flag is generated.
N     * |        |          |Note: This bit is read only and reset to 0 when bit DCTSF is cleared by a write 1 on DCTSF.
N     * |[4]     |TOUT_IF   |Time-out Interrupt Flag (Read Only)
N     * |        |          |This bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the time-out counter equal to TOIC.
N     * |        |          |If RTO_IEN (UA_IER [4]) is enabled, the Tout interrupt will be generated.
N     * |        |          |0 = No Time-out interrupt flag is generated.
N     * |        |          |1 = Time-out interrupt flag is generated.
N     * |        |          |Note: This bit is read only and user can read UA_RBR (RX is in active) to clear it.
N     * |[5]     |BUF_ERR_IF|Buffer Error Interrupt Flag (Read Only)
N     * |        |          |This bit is set when the TX/RX FIFO overflow flag (TX_OVER_IF or RX_OVER_IF) is set.
N     * |        |          |When BUF_ERR_IF is set, the transfer is not correct.
N     * |        |          |If BUF_ERR_IEN (UA_IER [5]) is enabled, the buffer error interrupt will be generated.
N     * |        |          |0 = No buffer error interrupt flag is generated.
N     * |        |          |1 = Buffer error interrupt flag is generated.
N     * |        |          |Note: This bit is read only and reset to 0 when all bits of TX_OVER_IF and RX_OVER_IF are cleared.
N     * |[8]     |RDA_INT   |Receive Data Available Interrupt Indicator (Read Only)
N     * |        |          |This bit is set if RDA_IEN and RDA_IF are both set to 1.
N     * |        |          |This bit is set if RDA_IEN and RDA_IF are both set to 1.
N     * |        |          |0 = No RDA interrupt is generated.
N     * |        |          |1 = RDA interrupt is generated.
N     * |[9]     |THRE_INT  |Transmit Holding Register Empty Interrupt Indicator (Read Only)
N     * |        |          |This bit is set if THRE_IEN and THRE_IF are both set to 1.
N     * |        |          |0 = No THRE interrupt is generated.
N     * |        |          |1 = THRE interrupt is generated.
N     * |[10]    |RLS_INT   |Receive Line Status Interrupt (Read Only)
N     * |        |          |This bit is set if RLS_IEN and RLS_IF are both set to 1.
N     * |        |          |0 = No RLS interrupt is generated.
N     * |        |          |1 = RLS interrupt is generated.
N     * |[11]    |MODEM_INT |MODEM Status Interrupt Indicator (Read Only)
N     * |        |          |This bit is set if MODEM_IEN and MODEM_IF are both set to 1.
N     * |        |          |0 = No Modem interrupt is generated.
N     * |        |          |1 = Modem interrupt is generated.
N     * |[12]    |TOUT_INT  |Time-out Interrupt Indicator (Read Only)
N     * |        |          |This bit is set if RTO_IEN and TOUT_IF are both set to 1.
N     * |        |          |0 = No Time-out interrupt is generated.
N     * |        |          |1 = Time-out interrupt is generated.
N     * |[13]    |BUF_ERR_INT|Buffer Error Interrupt Indicator (Read Only)
N     * |        |          |This bit is set if BUF_ERR_IEN and BUF_ERR_IF are both set to 1.
N     * |        |          |0 = No buffer error interrupt is generated.
N     * |        |          |1 = buffer error interrupt is generated.
N     * @var UART_T::TOR
N     * Offset: 0x20  UART Time-out Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |TOIC      |Time-out Interrupt Comparator
N     * |        |          |The time-out counter resets and starts counting (the counting clock = baud rate) whenever the RX FIFO receives a new data word.
N     * |        |          |Once the content of time-out counter (TOUT_CNT) is equal to that of time-out interrupt comparator (TOIC), a receiver time-out interrupt (TOUT_INT) is generated if RTO_IEN (UA_IER [4]).
N     * |        |          |A new incoming data word or RX FIFO empty clears TOUT_INT.
N     * |        |          |In order to avoid receiver time-out interrupt generation immediately during one character is being received, TOIC value should be set between 40 and 255.
N     * |        |          |So, for example, if TOIC is set with 40, the time-out interrupt is generated after four characters are not received when 1 stop bit and no parity check is set for UART transfer.
N     * |[15:8]  |DLY       |TX Delay Time Value
N     * |        |          |This field is used to program the transfer delay time between the last stop bit and next start bit.
N     * @var UART_T::BAUD
N     * Offset: 0x24  UART Baud Rate Divisor Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |BRD       |Baud Rate Divider
N     * |        |          |The field indicates the baud rate divider.
N     * |[27:24] |DIVIDER_X |Divider X
N     * |        |          |The baud rate divider M = X+1.
N     * |[28]    |DIV_X_ONE |Divider X Equal 1
N     * |        |          |0 = Divider M = X (the equation of M = X+1, but DIVIDER_X[27:24] must >= 8).
N     * |        |          |1 = Divider M = 1 (the equation of M = 1, but BRD [15:0] must >= 8).
N     * |        |          |Refer to section "UART Controller Baud Rate Generator" for more information.
N     * |[29]    |DIV_X_EN  |Divider X Enable Control
N     * |        |          |The BRD = Baud Rate Divider, and the baud rate equation is:  Baud Rate = Clock / [M * (BRD + 2)], The default value of M is 16.
N     * |        |          |0 = Divider X Disabled (the equation of M = 16).
N     * |        |          |1 = Divider X Enabled (the equation of M = X+1, but DIVIDER_X [27:24] must >= 8).
N     * |        |          |Note: When in IrDA mode, this bit must be disabled.
N     * @var UART_T::IRCR
N     * Offset: 0x28  UART IrDA Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |TX_SELECT |TX_SELECT
N     * |        |          |0 = IrDA receiver Enabled.
N     * |        |          |1 = IrDA transmitter Enabled.
N     * |[5]     |INV_TX    |INV_TX
N     * |        |          |0 = No inversion.
N     * |        |          |1 = Inverse TX output signal.
N     * |[6]     |INV_RX    |INV_RX
N     * |        |          |0 = No inversion.
N     * |        |          |1 = Inverse RX input signal.
N     * @var UART_T::ALT_CSR
N     * Offset: 0x2C  UART Alternate Control/Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[8]     |RS485_NMM |RS-485 Normal Multi-drop Operation Mode (NMM) Control
N     * |        |          |0 = RS-485 Normal Multi-drop Operation Mode (NMM) Disabled.
N     * |        |          |1 = RS-485 Normal Multi-drop Operation Mode (NMM) Enabled.
N     * |        |          |Note: This bit cannot be active with RS485_AAD operation mode.
N     * |[9]     |RS485_AAD |RS-485 Auto Address Detection Operation Mode (AAD)
N     * |        |          |0 = RS-485 Auto Address Detection Operation Mode (AAD) Disabled.
N     * |        |          |1 = RS-485 Auto Address Detection Operation Mode (AAD) Enabled.
N     * |        |          |Note: This bit cannot be active with RS485_NMM operation mode.
N     * |[10]    |RS485_AUD |RS-485 Auto Direction Mode (AUD) Control
N     * |        |          |0 = RS-485 Auto Address Detection Operation Mode (AAD) Disabled.
N     * |        |          |1 = RS-485 Auto Address Detection Operation Mode (AAD) Enabled.
N     * |        |          |Note: This bit cannot be active with RS485_NMM operation mode.
N     * |[15]    |RS485_ADD_EN|RS-485 Address Detection Enable Control
N     * |        |          |This bit is used to enable RS-485 Address Detection mode.
N     * |        |          |0 = RS-485 address detection mode Disabled.
N     * |        |          |1 = RS-485 address detection mode Enabled.
N     * |        |          |Note: This field is used for RS-485 any operation mode.
N     * |[31:24] |ADDR_MATCH|Address Match Value
N     * |        |          |This field contains the RS-485 address match values.
N     * |        |          |Note: This field is used for RS-485 auto address detection mode.
N     * @var UART_T::FUN_SEL
N     * Offset: 0x30  UART Function Select Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |FUN_SEL   |Function Selection
N     * |        |          |00 = UART function mode.
N     * |        |          |01 = Reserved.
N     * |        |          |10 = IrDA function mode.
N     * |        |          |11 = RS-485 function mode.
N     */
N
N    union {
N        __I  uint32_t RBR;           /* Offset: 0x00  UART Receive Buffer Register                                       */
X        volatile const  uint32_t RBR;            
N        __O  uint32_t THR;           /* Offset: 0x00  UART Transmit Holding Register                                     */
X        volatile  uint32_t THR;            
N    };
N    __IO uint32_t IER;           /* Offset: 0x04  UART Interrupt Enable Control Register                             */
X    volatile uint32_t IER;            
N    __IO uint32_t FCR;           /* Offset: 0x08  UART FIFO Control Register                                         */
X    volatile uint32_t FCR;            
N    __IO uint32_t LCR;           /* Offset: 0x0C  UART Line Control Register                                         */
X    volatile uint32_t LCR;            
N    __IO uint32_t MCR;           /* Offset: 0x10  UART Modem Control Register                                        */
X    volatile uint32_t MCR;            
N    __IO uint32_t MSR;           /* Offset: 0x14  UART Modem Status Register                                         */
X    volatile uint32_t MSR;            
N    __IO uint32_t FSR;           /* Offset: 0x18  UART FIFO Status Register                                          */
X    volatile uint32_t FSR;            
N    __IO uint32_t ISR;           /* Offset: 0x1C  UART Interrupt Status Register                                     */
X    volatile uint32_t ISR;            
N    __IO uint32_t TOR;           /* Offset: 0x20  UART Time-out Register                                             */
X    volatile uint32_t TOR;            
N    __IO uint32_t BAUD;          /* Offset: 0x24  UART Baud Rate Divisor Register                                    */
X    volatile uint32_t BAUD;           
N    __IO uint32_t IRCR;          /* Offset: 0x28  UART IrDA Control Register                                         */
X    volatile uint32_t IRCR;           
N    __IO uint32_t ALT_CSR;       /* Offset: 0x2C  UART Alternate Control/Status Register                             */
X    volatile uint32_t ALT_CSR;        
N    __IO uint32_t FUN_SEL;       /* Offset: 0x30  UART Function Select Register                                      */
X    volatile uint32_t FUN_SEL;        
N
N} UART_T;
N
N
N
N/**
N    @addtogroup UART_CONST UART Bit Field Definition
N    Constant Definitions for UART Controller
N@{ */
N
N#define UART_RBR_RBR_Pos                 (0)                                               /*!< UART_T::RBR: RBR Position                 */
N#define UART_RBR_RBR_Msk                 (0xfful << UART_RBR_RBR_Pos)                      /*!< UART_T::RBR: RBR Mask                     */
N
N#define UART_THR_THR_Pos                 (0)                                               /*!< UART_T::THR: THR Position                 */
N#define UART_THR_THR_Msk                 (0xfful << UART_THR_THR_Pos)                      /*!< UART_T::THR: THR Mask                     */
N
N#define UART_IER_RDA_IEN_Pos             (0)                                               /*!< UART_T::IER: RDA_IEN Position             */
N#define UART_IER_RDA_IEN_Msk             (0x1ul << UART_IER_RDA_IEN_Pos)                   /*!< UART_T::IER: RDA_IEN Mask                 */
N
N#define UART_IER_THRE_IEN_Pos            (1)                                               /*!< UART_T::IER: THRE_IEN Position            */
N#define UART_IER_THRE_IEN_Msk            (0x1ul << UART_IER_THRE_IEN_Pos)                  /*!< UART_T::IER: THRE_IEN Mask                */
N
N#define UART_IER_RLS_IEN_Pos             (2)                                               /*!< UART_T::IER: RLS_IEN Position             */
N#define UART_IER_RLS_IEN_Msk             (0x1ul << UART_IER_RLS_IEN_Pos)                   /*!< UART_T::IER: RLS_IEN Mask                 */
N
N#define UART_IER_MODEM_IEN_Pos           (3)                                               /*!< UART_T::IER: MODEM_IEN Position           */
N#define UART_IER_MODEM_IEN_Msk           (0x1ul << UART_IER_MODEM_IEN_Pos)                 /*!< UART_T::IER: MODEM_IEN Mask               */
N
N#define UART_IER_RTO_IEN_Pos             (4)                                               /*!< UART_T::IER: RTO_IEN Position             */
N#define UART_IER_RTO_IEN_Msk             (0x1ul << UART_IER_RTO_IEN_Pos)                   /*!< UART_T::IER: RTO_IEN Mask                 */
N
N#define UART_IER_BUF_ERR_IEN_Pos         (5)                                               /*!< UART_T::IER: BUF_ERR_IEN Position         */
N#define UART_IER_BUF_ERR_IEN_Msk         (0x1ul << UART_IER_BUF_ERR_IEN_Pos)               /*!< UART_T::IER: BUF_ERR_IEN Mask             */
N
N#define UART_IER_WAKE_EN_Pos             (6)                                               /*!< UART_T::IER: WAKE_EN Position             */
N#define UART_IER_WAKE_EN_Msk             (0x1ul << UART_IER_WAKE_EN_Pos)                   /*!< UART_T::IER: WAKE_EN Mask                 */
N
N#define UART_IER_TIME_OUT_EN_Pos         (11)                                              /*!< UART_T::IER: TIME_OUT_EN Position         */
N#define UART_IER_TIME_OUT_EN_Msk         (0x1ul << UART_IER_TIME_OUT_EN_Pos)               /*!< UART_T::IER: TIME_OUT_EN Mask             */
N
N#define UART_IER_AUTO_RTS_EN_Pos         (12)                                              /*!< UART_T::IER: AUTO_RTS_EN Position         */
N#define UART_IER_AUTO_RTS_EN_Msk         (0x1ul << UART_IER_AUTO_RTS_EN_Pos)               /*!< UART_T::IER: AUTO_RTS_EN Mask             */
N
N#define UART_IER_AUTO_CTS_EN_Pos         (13)                                              /*!< UART_T::IER: AUTO_CTS_EN Position         */
N#define UART_IER_AUTO_CTS_EN_Msk         (0x1ul << UART_IER_AUTO_CTS_EN_Pos)               /*!< UART_T::IER: AUTO_CTS_EN Mask             */
N
N#define UART_FCR_RFR_Pos                 (1)                                               /*!< UART_T::FCR: RFR Position                 */
N#define UART_FCR_RFR_Msk                 (0x1ul << UART_FCR_RFR_Pos)                       /*!< UART_T::FCR: RFR Mask                     */
N
N#define UART_FCR_TFR_Pos                 (2)                                               /*!< UART_T::FCR: TFR Position                 */
N#define UART_FCR_TFR_Msk                 (0x1ul << UART_FCR_TFR_Pos)                       /*!< UART_T::FCR: TFR Mask                     */
N
N#define UART_FCR_RFITL_Pos               (4)                                               /*!< UART_T::FCR: RFITL Position               */
N#define UART_FCR_RFITL_Msk               (0xful << UART_FCR_RFITL_Pos)                     /*!< UART_T::FCR: RFITL Mask                   */
N
N#define UART_FCR_RX_DIS_Pos              (8)                                               /*!< UART_T::FCR: RX_DIS Position              */
N#define UART_FCR_RX_DIS_Msk              (0x1ul << UART_FCR_RX_DIS_Pos)                    /*!< UART_T::FCR: RX_DIS Mask                  */
N
N#define UART_FCR_RTS_TRI_LEV_Pos         (16)                                              /*!< UART_T::FCR: RTS_TRI_LEV Position         */
N#define UART_FCR_RTS_TRI_LEV_Msk         (0xful << UART_FCR_RTS_TRI_LEV_Pos)               /*!< UART_T::FCR: RTS_TRI_LEV Mask             */
N
N#define UART_LCR_WLS_Pos                 (0)                                               /*!< UART_T::LCR: WLS Position                 */
N#define UART_LCR_WLS_Msk                 (0x3ul << UART_LCR_WLS_Pos)                       /*!< UART_T::LCR: WLS Mask                     */
N
N#define UART_LCR_NSB_Pos                 (2)                                               /*!< UART_T::LCR: NSB Position                 */
N#define UART_LCR_NSB_Msk                 (0x1ul << UART_LCR_NSB_Pos)                       /*!< UART_T::LCR: NSB Mask                     */
N
N#define UART_LCR_PBE_Pos                 (3)                                               /*!< UART_T::LCR: PBE Position                 */
N#define UART_LCR_PBE_Msk                 (0x1ul << UART_LCR_PBE_Pos)                       /*!< UART_T::LCR: PBE Mask                     */
N
N#define UART_LCR_EPE_Pos                 (4)                                               /*!< UART_T::LCR: EPE Position                 */
N#define UART_LCR_EPE_Msk                 (0x1ul << UART_LCR_EPE_Pos)                       /*!< UART_T::LCR: EPE Mask                     */
N
N#define UART_LCR_SPE_Pos                 (5)                                               /*!< UART_T::LCR: SPE Position                 */
N#define UART_LCR_SPE_Msk                 (0x1ul << UART_LCR_SPE_Pos)                       /*!< UART_T::LCR: SPE Mask                     */
N
N#define UART_LCR_BCB_Pos                 (6)                                               /*!< UART_T::LCR: BCB Position                 */
N#define UART_LCR_BCB_Msk                 (0x1ul << UART_LCR_BCB_Pos)                       /*!< UART_T::LCR: BCB Mask                     */
N
N#define UART_MCR_RTS_Pos                 (1)                                               /*!< UART_T::MCR: RTS Position                */
N#define UART_MCR_RTS_Msk                 (0x1ul << UART_MCR_RTS_Pos)                       /*!< UART_T::MCR: RTS Mask                    */
N
N#define UART_MCR_LEV_RTS_Pos             (9)                                               /*!< UART_T::MCR: LEV_RTS Position             */
N#define UART_MCR_LEV_RTS_Msk             (0x1ul << UART_MCR_LEV_RTS_Pos)                   /*!< UART_T::MCR: LEV_RTS Mask                 */
N
N#define UART_MCR_RTS_ST_Pos              (13)                                              /*!< UART_T::MCR: RTS_ST Position              */
N#define UART_MCR_RTS_ST_Msk              (0x1ul << UART_MCR_RTS_ST_Pos)                    /*!< UART_T::MCR: RTS_ST Mask                  */
N
N#define UART_MSR_DCTSF_Pos               (0)                                               /*!< UART_T::MSR: DCTSF Position               */
N#define UART_MSR_DCTSF_Msk               (0x1ul << UART_MSR_DCTSF_Pos)                     /*!< UART_T::MSR: DCTSF Mask                   */
N
N#define UART_MSR_CTS_ST_Pos              (4)                                               /*!< UART_T::MSR: CTS_ST Position              */
N#define UART_MSR_CTS_ST_Msk              (0x1ul << UART_MSR_CTS_ST_Pos)                    /*!< UART_T::MSR: CTS_ST Mask                  */
N
N#define UART_MSR_LEV_CTS_Pos             (8)                                               /*!< UART_T::MSR: LEV_CTS Position             */
N#define UART_MSR_LEV_CTS_Msk             (0x1ul << UART_MSR_LEV_CTS_Pos)                   /*!< UART_T::MSR: LEV_CTS Mask                 */
N
N#define UART_FSR_RX_OVER_IF_Pos          (0)                                               /*!< UART_T::FSR: RX_OVER_IF Position          */
N#define UART_FSR_RX_OVER_IF_Msk          (0x1ul << UART_FSR_RX_OVER_IF_Pos)                /*!< UART_T::FSR: RX_OVER_IF Mask              */
N
N#define UART_FSR_RS485_ADD_DETF_Pos     (3)                                                /*!< UART_T::FSR: RS485_ADD_DETF Position     */
N#define UART_FSR_RS485_ADD_DETF_Msk     (0x1ul << UART_FSR_RS485_ADD_DETF_Pos)             /*!< UART_T::FSR: RS485_ADD_DETF Mask         */
N
N#define UART_FSR_PEF_Pos                 (4)                                               /*!< UART_T::FSR: PEF Position                 */
N#define UART_FSR_PEF_Msk                 (0x1ul << UART_FSR_PEF_Pos)                       /*!< UART_T::FSR: PEF Mask                     */
N
N#define UART_FSR_FEF_Pos                 (5)                                               /*!< UART_T::FSR: FEF Position                 */
N#define UART_FSR_FEF_Msk                 (0x1ul << UART_FSR_FEF_Pos)                       /*!< UART_T::FSR: FEF Mask                     */
N
N#define UART_FSR_BIF_Pos                 (6)                                               /*!< UART_T::FSR: BIF Position                 */
N#define UART_FSR_BIF_Msk                 (0x1ul << UART_FSR_BIF_Pos)                       /*!< UART_T::FSR: BIF Mask                     */
N
N#define UART_FSR_RX_POINTER_Pos          (8)                                               /*!< UART_T::FSR: RX_POINTER Position          */
N#define UART_FSR_RX_POINTER_Msk          (0x3ful << UART_FSR_RX_POINTER_Pos)               /*!< UART_T::FSR: RX_POINTER Mask              */
N
N#define UART_FSR_RX_EMPTY_Pos            (14)                                              /*!< UART_T::FSR: RX_EMPTY Position            */
N#define UART_FSR_RX_EMPTY_Msk            (0x1ul << UART_FSR_RX_EMPTY_Pos)                  /*!< UART_T::FSR: RX_EMPTY Mask                */
N
N#define UART_FSR_RX_FULL_Pos             (15)                                              /*!< UART_T::FSR: RX_FULL Position             */
N#define UART_FSR_RX_FULL_Msk             (0x1ul << UART_FSR_RX_FULL_Pos)                   /*!< UART_T::FSR: RX_FULL Mask                 */
N
N#define UART_FSR_TX_POINTER_Pos          (16)                                              /*!< UART_T::FSR: TX_POINTER Position          */
N#define UART_FSR_TX_POINTER_Msk          (0x3ful << UART_FSR_TX_POINTER_Pos)               /*!< UART_T::FSR: TX_POINTER Mask              */
N
N#define UART_FSR_TX_EMPTY_Pos            (22)                                              /*!< UART_T::FSR: TX_EMPTY Position            */
N#define UART_FSR_TX_EMPTY_Msk            (0x1ul << UART_FSR_TX_EMPTY_Pos)                  /*!< UART_T::FSR: TX_EMPTY Mask                */
N
N#define UART_FSR_TX_FULL_Pos             (23)                                              /*!< UART_T::FSR: TX_FULL Position             */
N#define UART_FSR_TX_FULL_Msk             (0x1ul << UART_FSR_TX_FULL_Pos)                   /*!< UART_T::FSR: TX_FULL Mask                 */
N
N#define UART_FSR_TX_OVER_IF_Pos          (24)                                              /*!< UART_T::FSR: TX_OVER_IF Position          */
N#define UART_FSR_TX_OVER_IF_Msk          (0x1ul << UART_FSR_TX_OVER_IF_Pos)                /*!< UART_T::FSR: TX_OVER_IF Mask              */
N
N#define UART_FSR_TE_FLAG_Pos             (28)                                              /*!< UART_T::FSR: TE_FLAG Position             */
N#define UART_FSR_TE_FLAG_Msk             (0x1ul << UART_FSR_TE_FLAG_Pos)                   /*!< UART_T::FSR: TE_FLAG Mask                 */
N
N#define UART_ISR_RDA_IF_Pos              (0)                                               /*!< UART_T::ISR: RDA_IF Position              */
N#define UART_ISR_RDA_IF_Msk              (0x1ul << UART_ISR_RDA_IF_Pos)                    /*!< UART_T::ISR: RDA_IF Mask                  */
N
N#define UART_ISR_THRE_IF_Pos             (1)                                               /*!< UART_T::ISR: THRE_IF Position             */
N#define UART_ISR_THRE_IF_Msk             (0x1ul << UART_ISR_THRE_IF_Pos)                   /*!< UART_T::ISR: THRE_IF Mask                 */
N
N#define UART_ISR_RLS_IF_Pos              (2)                                               /*!< UART_T::ISR: RLS_IF Position              */
N#define UART_ISR_RLS_IF_Msk              (0x1ul << UART_ISR_RLS_IF_Pos)                    /*!< UART_T::ISR: RLS_IF Mask                  */
N
N#define UART_ISR_MODEM_IF_Pos            (3)                                               /*!< UART_T::ISR: MODEM_IF Position            */
N#define UART_ISR_MODEM_IF_Msk            (0x1ul << UART_ISR_MODEM_IF_Pos)                  /*!< UART_T::ISR: MODEM_IF Mask                */
N
N#define UART_ISR_TOUT_IF_Pos             (4)                                               /*!< UART_T::ISR: TOUT_IF Position             */
N#define UART_ISR_TOUT_IF_Msk             (0x1ul << UART_ISR_TOUT_IF_Pos)                   /*!< UART_T::ISR: TOUT_IF Mask                 */
N
N#define UART_ISR_BUF_ERR_IF_Pos          (5)                                               /*!< UART_T::ISR: BUF_ERR_IF Position          */
N#define UART_ISR_BUF_ERR_IF_Msk          (0x1ul << UART_ISR_BUF_ERR_IF_Pos)                /*!< UART_T::ISR: BUF_ERR_IF Mask              */
N
N#define UART_ISR_RDA_INT_Pos             (8)                                               /*!< UART_T::ISR: RDA_INT Position             */
N#define UART_ISR_RDA_INT_Msk             (0x1ul << UART_ISR_RDA_INT_Pos)                   /*!< UART_T::ISR: RDA_INT Mask                 */
N
N#define UART_ISR_THRE_INT_Pos            (9)                                               /*!< UART_T::ISR: THRE_INT Position            */
N#define UART_ISR_THRE_INT_Msk            (0x1ul << UART_ISR_THRE_INT_Pos)                  /*!< UART_T::ISR: THRE_INT Mask                */
N
N#define UART_ISR_RLS_INT_Pos             (10)                                              /*!< UART_T::ISR: RLS_INT Position             */
N#define UART_ISR_RLS_INT_Msk             (0x1ul << UART_ISR_RLS_INT_Pos)                   /*!< UART_T::ISR: RLS_INT Mask                 */
N
N#define UART_ISR_MODEM_INT_Pos           (11)                                              /*!< UART_T::ISR: MODEM_INT Position           */
N#define UART_ISR_MODEM_INT_Msk           (0x1ul << UART_ISR_MODEM_INT_Pos)                 /*!< UART_T::ISR: MODEM_INT Mask               */
N
N#define UART_ISR_TOUT_INT_Pos            (12)                                              /*!< UART_T::ISR: TOUT_INT Position            */
N#define UART_ISR_TOUT_INT_Msk            (0x1ul << UART_ISR_TOUT_INT_Pos)                  /*!< UART_T::ISR: TOUT_INT Mask                */
N
N#define UART_ISR_BUF_ERR_INT_Pos         (13)                                              /*!< UART_T::ISR: BUF_ERR_INT Position         */
N#define UART_ISR_BUF_ERR_INT_Msk         (0x1ul << UART_ISR_BUF_ERR_INT_Pos)               /*!< UART_T::ISR: BUF_ERR_INT Mask             */
N
N#define UART_TOR_TOIC_Pos                (0)                                               /*!< UART_T::TOR: TOIC Position                */
N#define UART_TOR_TOIC_Msk                (0xfful << UART_TOR_TOIC_Pos)                     /*!< UART_T::TOR: TOIC Mask                    */
N
N#define UART_TOR_DLY_Pos                 (8)                                               /*!< UART_T::TOR: DLY Position                 */
N#define UART_TOR_DLY_Msk                 (0xfful << UART_TOR_DLY_Pos)                      /*!< UART_T::TOR: DLY Mask                     */
N
N#define UART_BAUD_BRD_Pos                (0)                                               /*!< UART_T::BAUD: BRD Position                */
N#define UART_BAUD_BRD_Msk                (0xfffful << UART_BAUD_BRD_Pos)                   /*!< UART_T::BAUD: BRD Mask                    */
N
N#define UART_BAUD_DIVIDER_X_Pos          (24)                                              /*!< UART_T::BAUD: DIVIDER_X Position          */
N#define UART_BAUD_DIVIDER_X_Msk          (0xful << UART_BAUD_DIVIDER_X_Pos)                /*!< UART_T::BAUD: DIVIDER_X Mask              */
N
N#define UART_BAUD_DIV_X_ONE_Pos          (28)                                              /*!< UART_T::BAUD: DIV_X_ONE Position          */
N#define UART_BAUD_DIV_X_ONE_Msk          (0x1ul << UART_BAUD_DIV_X_ONE_Pos)                /*!< UART_T::BAUD: DIV_X_ONE Mask              */
N
N#define UART_BAUD_DIV_X_EN_Pos           (29)                                              /*!< UART_T::BAUD: DIV_X_EN Position           */
N#define UART_BAUD_DIV_X_EN_Msk           (0x1ul << UART_BAUD_DIV_X_EN_Pos)                 /*!< UART_T::BAUD: DIV_X_EN Mask               */
N
N#define UART_IRCR_TX_SELECT_Pos          (1)                                               /*!< UART_T::IRCR: TX_SELECT Position          */
N#define UART_IRCR_TX_SELECT_Msk          (0x1ul << UART_IRCR_TX_SELECT_Pos)                /*!< UART_T::IRCR: TX_SELECT Mask              */
N
N#define UART_IRCR_INV_TX_Pos             (5)                                               /*!< UART_T::IRCR: INV_TX Position             */
N#define UART_IRCR_INV_TX_Msk             (0x1ul << UART_IRCR_INV_TX_Pos)                   /*!< UART_T::IRCR: INV_TX Mask                 */
N
N#define UART_IRCR_INV_RX_Pos             (6)                                               /*!< UART_T::IRCR: INV_RX Position             */
N#define UART_IRCR_INV_RX_Msk             (0x1ul << UART_IRCR_INV_RX_Pos)                   /*!< UART_T::IRCR: INV_RX Mask                 */
N
N#define UART_ALT_CSR_RS485_NMM_Pos       (8)                                               /*!< UART_T::ALT_CSR: RS485_NMM Position       */
N#define UART_ALT_CSR_RS485_NMM_Msk       (0x1ul << UART_ALT_CSR_RS485_NMM_Pos)             /*!< UART_T::ALT_CSR: RS485_NMM Mask           */
N
N#define UART_ALT_CSR_RS485_AAD_Pos       (9)                                               /*!< UART_T::ALT_CSR: RS485_AAD Position       */
N#define UART_ALT_CSR_RS485_AAD_Msk       (0x1ul << UART_ALT_CSR_RS485_AAD_Pos)             /*!< UART_T::ALT_CSR: RS485_AAD Mask           */
N
N#define UART_ALT_CSR_RS485_AUD_Pos       (10)                                              /*!< UART_T::ALT_CSR: RS485_AUD Position       */
N#define UART_ALT_CSR_RS485_AUD_Msk       (0x1ul << UART_ALT_CSR_RS485_AUD_Pos)             /*!< UART_T::ALT_CSR: RS485_AUD Mask           */
N
N#define UART_ALT_CSR_RS485_ADD_EN_Pos    (15)                                              /*!< UART_T::ALT_CSR: RS485_ADD_EN Position    */
N#define UART_ALT_CSR_RS485_ADD_EN_Msk    (0x1ul << UART_ALT_CSR_RS485_ADD_EN_Pos)          /*!< UART_T::ALT_CSR: RS485_ADD_EN Mask        */
N
N#define UART_ALT_CSR_ADDR_MATCH_Pos      (24)                                              /*!< UART_T::ALT_CSR: ADDR_MATCH Position      */
N#define UART_ALT_CSR_ADDR_MATCH_Msk      (0xfful << UART_ALT_CSR_ADDR_MATCH_Pos)           /*!< UART_T::ALT_CSR: ADDR_MATCH Mask          */
N
N#define UART_FUN_SEL_FUN_SEL_Pos         (0)                                               /*!< UART_T::FUN_SEL: FUN_SEL Position         */
N#define UART_FUN_SEL_FUN_SEL_Msk         (0x3ul << UART_FUN_SEL_FUN_SEL_Pos)               /*!< UART_T::FUN_SEL: FUN_SEL Mask             */
N
N/**@}*/ /* UART_CONST */
N/**@}*/ /* end of UART register group */
N
N
N/*---------------------- Watch Dog Timer Controller -------------------------*/
N/**
N    @addtogroup WDT Watch Dog Timer Controller(WDT)
N    Memory Mapped Structure for WDT Controller
N@{ */
N
N
Ntypedef struct {
N
N    /**
N     * @var WDT_T::WTCR
N     * Offset: 0x00  Watchdog Timer Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |WTR       |Reset Watchdog Timer Up Counter (Write Protect)
N     * |        |          |0 = No effect.
N     * |        |          |1 = Reset the internal 18-bit WDT up counter value.
N     * |        |          |Note: This bit will be automatically cleared by hardware.
N     * |[1]     |WTRE      |Watchdog Timer Time-out Reset Enable Control (Write Protect)
N     * |        |          |Setting this bit will enable the WDT time-out reset function if the WDT up counter value has not been cleared after the specific WDT reset delay period (1024 * TWDT) expires.
N     * |        |          |0 = WDT time-out reset function Disabled.
N     * |        |          |1 = WDT time-out reset function Enabled.
N     * |[2]     |WTRF      |Watchdog Timer Time-out Reset Flag
N     * |        |          |This bit indicates the system has been reset by WDT time-out reset or not.
N     * |        |          |0 = WDT time-out reset did not occur.
N     * |        |          |1 = WDT time-out reset occurred.
N     * |        |          |Note: This bit is cleared by writing 1 to it.
N     * |[3]     |WTIF      |Watchdog Timer Time-out Interrupt Flag
N     * |        |          |This bit will be set to 1 while WDT up counter value reaches the selected WDT time-out interval.
N     * |        |          |0 = WDT time-out interrupt did not occur.
N     * |        |          |1 = WDT time-out interrupt occurred.
N     * |        |          |Note: This bit is cleared by writing 1 to it.
N     * |[4]     |WTWKE     |Watchdog Timer Time-out Wake-up Function Control (Write Protect)
N     * |        |          |If this bit is set to 1, while WTIF is generated to 1 and WTIE enabled, the WDT time-out interrupt signal will generate a wake-up trigger event to chip.
N     * |        |          |0 = Wake-up trigger event Disabled if WDT time-out interrupt signal generated.
N     * |        |          |1 = Wake-up trigger event Enabled if WDT time-out interrupt signal generated.
N     * |        |          |Note: Chip can be woken-up by WDT time-out interrupt signal generated only if WDT clock source is selected to 10 kHz oscillator.
N     * |[5]     |WTWKF     |Watchdog Timer Time-out Wake-up Flag
N     * |        |          |This bit indicates the interrupt wake-up flag status of WDT.
N     * |        |          |0 = WDT does not cause chip wake-up.
N     * |        |          |1 = Chip wake-up from Idle or Power-down mode if WDT time-out interrupt signal generated.
N     * |        |          |Note: This bit is cleared by writing 1 to it.
N     * |[6]     |WTIE      |Watchdog Timer Time-out Interrupt Enable Control (Write Protect)
N     * |        |          |If this bit is enabled, the WDT time-out interrupt signal is generated and inform to CPU.
N     * |        |          |0 = WDT time-out interrupt Disabled.
N     * |        |          |1 = WDT time-out interrupt Enabled.
N     * |[7]     |WTE       |Watchdog Timer Enable Control (Write Protect)
N     * |        |          |0 = WDT Disabled. (This action will reset the internal up counter value.)
N     * |        |          |1 = WDT Enabled.
N     * |[10:8]  |WTIS      |Watchdog Timer Interval Selection
N     * |        |          |These three bits select the time-out interval for the Watchdog Timer.
N     * |        |          |000 = 24 * TWDT.
N     * |        |          |001 = 26 * TWDT.
N     * |        |          |010 = 28 * TWDT.
N     * |        |          |011 = 210 * TWDT.
N     * |        |          |100 = 212 * TWDT.
N     * |        |          |101 = 214 * TWDT.
N     * |        |          |110 = 216 * TWDT.
N     * |        |          |111 = 218 * TWDT.
N     * |[31]    |DBGACK_WDT|ICE Debug Mode Acknowledge Disable Control (Write Protect)
N     * |        |          |0 = ICE debug mode acknowledgement effects WDT counting.
N     * |        |          |WDT up counter will be kept while CPU is hanging by ICE.
N     * |        |          |1 = ICE debug mode acknowledgement Disabled.
N     * |        |          |WDT up counter will keep going no matter CPU is hanging by ICE or not.
N     */
N
N    __IO uint32_t WTCR;          /* Offset: 0x00  Watchdog Timer Control Register                                    */
X    volatile uint32_t WTCR;           
N
N} WDT_T;
N
N
N
N/**
N    @addtogroup WDT_CONST WDT Bit Field Definition
N    Constant Definitions for WDT Controller
N@{ */
N
N#define WDT_WTCR_WTR_Pos                 (0)                                               /*!< WDT_T::WTCR: WTR Position                 */
N#define WDT_WTCR_WTR_Msk                 (0x1ul << WDT_WTCR_WTR_Pos)                       /*!< WDT_T::WTCR: WTR Mask                     */
N
N#define WDT_WTCR_WTRE_Pos                (1)                                               /*!< WDT_T::WTCR: WTRE Position                */
N#define WDT_WTCR_WTRE_Msk                (0x1ul << WDT_WTCR_WTRE_Pos)                      /*!< WDT_T::WTCR: WTRE Mask                    */
N
N#define WDT_WTCR_WTRF_Pos                (2)                                               /*!< WDT_T::WTCR: WTRF Position                */
N#define WDT_WTCR_WTRF_Msk                (0x1ul << WDT_WTCR_WTRF_Pos)                      /*!< WDT_T::WTCR: WTRF Mask                    */
N
N#define WDT_WTCR_WTIF_Pos                (3)                                               /*!< WDT_T::WTCR: WTIF Position                */
N#define WDT_WTCR_WTIF_Msk                (0x1ul << WDT_WTCR_WTIF_Pos)                      /*!< WDT_T::WTCR: WTIF Mask                    */
N
N#define WDT_WTCR_WTWKE_Pos               (4)                                               /*!< WDT_T::WTCR: WTWKE Position               */
N#define WDT_WTCR_WTWKE_Msk               (0x1ul << WDT_WTCR_WTWKE_Pos)                     /*!< WDT_T::WTCR: WTWKE Mask                   */
N
N#define WDT_WTCR_WTWKF_Pos               (5)                                               /*!< WDT_T::WTCR: WTWKF Position               */
N#define WDT_WTCR_WTWKF_Msk               (0x1ul << WDT_WTCR_WTWKF_Pos)                     /*!< WDT_T::WTCR: WTWKF Mask                   */
N
N#define WDT_WTCR_WTIE_Pos                (6)                                               /*!< WDT_T::WTCR: WTIE Position                */
N#define WDT_WTCR_WTIE_Msk                (0x1ul << WDT_WTCR_WTIE_Pos)                      /*!< WDT_T::WTCR: WTIE Mask                    */
N
N#define WDT_WTCR_WTE_Pos                 (7)                                               /*!< WDT_T::WTCR: WTE Position                 */
N#define WDT_WTCR_WTE_Msk                 (0x1ul << WDT_WTCR_WTE_Pos)                       /*!< WDT_T::WTCR: WTE Mask                     */
N
N#define WDT_WTCR_WTIS_Pos                (8)                                               /*!< WDT_T::WTCR: WTIS Position                */
N#define WDT_WTCR_WTIS_Msk                (0x7ul << WDT_WTCR_WTIS_Pos)                      /*!< WDT_T::WTCR: WTIS Mask                    */
N
N#define WDT_WTCR_DBGACK_WDT_Pos          (31)                                              /*!< WDT_T::WTCR: DBGACK_WDT Position          */
N#define WDT_WTCR_DBGACK_WDT_Msk          (0x1ul << WDT_WTCR_DBGACK_WDT_Pos)                /*!< WDT_T::WTCR: DBGACK_WDT Mask              */
N
N/**@}*/ /* WDT_CONST */
N/**@}*/ /* end of WDT register group */
N
N
N#if defined ( __CC_ARM   )
X#if 1L
N#pragma no_anon_unions
N#endif
N
N/** @addtogroup MINI51_PERIPHERAL_MEM_MAP MINI51 Peripheral Memory Map
N  Memory Mapped Structure for MINI51 Series Peripheral
N  @{
N */
N/* Peripheral and SRAM base address */
N#define FLASH_BASE            ((uint32_t)0x00000000)    ///< Flash base address
N#define SRAM_BASE             ((uint32_t)0x20000000)    ///< SRAM base address
N#define APB1PERIPH_BASE       ((uint32_t)0x40000000)    ///< APB1 base address
N#define APB2PERIPH_BASE       ((uint32_t)0x40100000)    ///< APB2 base address
N#define AHBPERIPH_BASE        ((uint32_t)0x50000000)    ///< AHB base address
N
N/* Peripheral memory map */
N#define WDT_BASE              (APB1PERIPH_BASE + 0x04000)    ///< WDT register base address
N#define TIMER0_BASE           (APB1PERIPH_BASE + 0x10000)    ///< TIMER0 register base address
N#define TIMER1_BASE           (APB1PERIPH_BASE + 0x10020)    ///< TIMER1 register base address
N#define I2C_BASE              (APB1PERIPH_BASE + 0x20000)    ///< I2C register base address
N#define SPI_BASE              (APB1PERIPH_BASE + 0x30000)    ///< SPI register base address
N#define PWM_BASE              (APB1PERIPH_BASE + 0x40000)    ///< PWM register base address
N#define UART_BASE             (APB1PERIPH_BASE + 0x50000)    ///< UART register base address
N#define ACMP_BASE             (APB1PERIPH_BASE + 0xD0000)    ///< ACMP register base address
N#define ADC_BASE              (APB1PERIPH_BASE + 0xE0000)    ///< ADC register base address
N
N#define GCR_BASE              (AHBPERIPH_BASE + 0x00000)    ///< GCR register base address
N#define CLK_BASE              (AHBPERIPH_BASE + 0x00200)    ///< CLK register base address
N#define INT_BASE              (AHBPERIPH_BASE + 0x00300)    ///< INT register base address
N#define P0_BASE               (AHBPERIPH_BASE + 0x04000)    ///< GPIO Port 0 register base address
N#define P1_BASE               (AHBPERIPH_BASE + 0x04040)    ///< GPIO Port 1 register base address
N#define P2_BASE               (AHBPERIPH_BASE + 0x04080)    ///< GPIO Port 2 register base address
N#define P3_BASE               (AHBPERIPH_BASE + 0x040C0)    ///< GPIO Port 3 register base address
N#define P4_BASE               (AHBPERIPH_BASE + 0x04100)    ///< GPIO Port 4 register base address
N#define P5_BASE               (AHBPERIPH_BASE + 0x04140)    ///< GPIO Port 5 register base address
N#define GPIO_DBNCECON_BASE    (AHBPERIPH_BASE + 0x04180)    ///< GPIO De-bounce register vase
N#define GPIO_PIN_DATA_BASE    (AHBPERIPH_BASE + 0x04200)    ///< GPIO pin data register base address
N#define GPIOBIT0_BASE         (AHBPERIPH_BASE + 0x04200)    ///< GPIO Port 0 bit access register base address
N#define GPIOBIT1_BASE         (AHBPERIPH_BASE + 0x04220)    ///< GPIO Port 1 bit access register base address
N#define GPIOBIT2_BASE         (AHBPERIPH_BASE + 0x04240)    ///< GPIO Port 2 bit access register base address
N#define GPIOBIT3_BASE         (AHBPERIPH_BASE + 0x04260)    ///< GPIO Port 3 bit access register base address
N#define GPIOBIT4_BASE         (AHBPERIPH_BASE + 0x04280)    ///< GPIO Port 4 bit access register base address
N#define GPIOBIT5_BASE         (AHBPERIPH_BASE + 0x042A0)    ///< GPIO Port 5 bit access register base address
N#define FMC_BASE              (AHBPERIPH_BASE + 0x0C000)    ///< FMC register base address
N
N/*@}*/ /* end of group MINI51_PERIPHERAL_MEM_MAP */
N
N
N/** @addtogroup MINI51_PERIPHERAL_DECLARATION MINI51 Peripheral Declaration
N  The Declaration of MINI51 Series Peripheral
N  @{
N */
N#define WDT                   ((WDT_T *) WDT_BASE)              ///< Pointer to WDT register structure
N#define TIMER0                ((TIMER_T *) TIMER0_BASE)         ///< Pointer to Timer 0 register structure
N#define TIMER1                ((TIMER_T *) TIMER1_BASE)         ///< Pointer to Timer 1 register structure
N#define I2C                   ((I2C_T *) I2C_BASE)              ///< Pointer to I2C register structure
N#define I2C0                  ((I2C_T *) I2C_BASE)              ///< Pointer to I2C register structure
N#define SPI                   ((SPI_T *) SPI_BASE)              ///< Pointer to SPI register structure
N#define SPI0                  ((SPI_T *) SPI_BASE)              ///< Pointer to SPI register structure
N#define PWM                   ((PWM_T *) PWM_BASE)              ///< Pointer to PWM register structure
N#define UART                  ((UART_T *) UART_BASE)            ///< Pointer to UART register structure
N#define UART0                 ((UART_T *) UART_BASE)            ///< Pointer to UART register structure
N#define ADC                   ((ADC_T *) ADC_BASE)              ///< Pointer to ADC register structure
N#define ACMP                  ((ACMP_T *) ACMP_BASE)            ///< Pointer to ACMP register structure
N
N#define SYS                   ((GCR_T *) GCR_BASE)              ///< Pointer to SYS register structure
N#define CLK                   ((CLK_T *) CLK_BASE)              ///< Pointer to CLK register structure
N#define INT                   ((INT_T *) INT_BASE)              ///< Pointer to INT register structure
N#define P0                    ((GPIO_T *) P0_BASE)              ///< Pointer to GPIO port 0 register structure
N#define P1                    ((GPIO_T *) P1_BASE)              ///< Pointer to GPIO port 1 register structure 
N#define P2                    ((GPIO_T *) P2_BASE)              ///< Pointer to GPIO port 2 register structure
N#define P3                    ((GPIO_T *) P3_BASE)              ///< Pointer to GPIO port 3 register structure
N#define P4                    ((GPIO_T *) P4_BASE)              ///< Pointer to GPIO port 4 register structure
N#define P5                    ((GPIO_T *) P5_BASE)              ///< Pointer to GPIO port 5 register structure
N#define GPIO                  ((GPIO_DBNCECON_T *) GPIO_DBNCECON_BASE)      ///< Pointer to GPIO de-bounce register structure
N#define GPIOBIT0              ((GPIOBIT_T *) GPIOBIT0_BASE)     ///< Pointer to GPIO port 0 bit access register structure
N#define GPIOBIT1              ((GPIOBIT_T *) GPIOBIT1_BASE)     ///< Pointer to GPIO port 1 bit access register structure
N#define GPIOBIT2              ((GPIOBIT_T *) GPIOBIT2_BASE)     ///< Pointer to GPIO port 2 bit access register structure
N#define GPIOBIT3              ((GPIOBIT_T *) GPIOBIT3_BASE)     ///< Pointer to GPIO port 3 bit access register structure
N#define GPIOBIT4              ((GPIOBIT_T *) GPIOBIT4_BASE)     ///< Pointer to GPIO port 4 bit access register structure
N#define GPIOBIT5              ((GPIOBIT_T *) GPIOBIT5_BASE)     ///< Pointer to GPIO port 5 bit access register structure
N#define FMC                   ((FMC_T *) FMC_BASE)              ///< Pointer to FMC register structure
N
N/*@}*/ /* end of group MINI51_PERIPHERAL_DECLARATION */
N/*@}*/ /* end of group MINI51_Peripherals */
N
N/** @addtogroup MINI51_IO_ROUTINE MINI51 I/O routines
N  The Declaration of MINI51 I/O routines
N  @{
N */
N
Ntypedef volatile unsigned char  vu8;        ///< Define 8-bit unsigned volatile data type
Ntypedef volatile unsigned short vu16;       ///< Define 16-bit unsigned volatile data type
Ntypedef volatile unsigned long  vu32;       ///< Define 32-bit unsigned volatile data type
N
N/**
N  * @brief Get a 8-bit unsigned value from specified address
N  * @param[in] addr Address to get 8-bit data from
N  * @return  8-bit unsigned value stored in specified address
N  */
N#define M8(addr)  (*((vu8  *) (addr)))
N
N/**
N  * @brief Get a 16-bit unsigned value from specified address
N  * @param[in] addr Address to get 16-bit data from
N  * @return  16-bit unsigned value stored in specified address
N  * @note The input address must be 16-bit aligned
N  */
N#define M16(addr) (*((vu16 *) (addr)))
N
N/**
N  * @brief Get a 32-bit unsigned value from specified address
N  * @param[in] addr Address to get 32-bit data from
N  * @return  32-bit unsigned value stored in specified address
N  * @note The input address must be 32-bit aligned
N  */
N#define M32(addr) (*((vu32 *) (addr)))
N
N/**
N  * @brief Set a 32-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 32-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 32-bit aligned
N  */
N#define outpw(port,value)     *((volatile unsigned int *)(port)) = value
N
N/**
N  * @brief Get a 32-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 32-bit data from
N  * @return  32-bit unsigned value stored in specified I/O port
N  * @note The input port must be 32-bit aligned
N  */
N#define inpw(port)            (*((volatile unsigned int *)(port)))
N
N/**
N  * @brief Set a 16-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 16-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 16-bit aligned
N  */
N#define outps(port,value)     *((volatile unsigned short *)(port)) = value
N
N/**
N  * @brief Get a 16-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 16-bit data from
N  * @return  16-bit unsigned value stored in specified I/O port
N  * @note The input port must be 16-bit aligned
N  */
N#define inps(port)            (*((volatile unsigned short *)(port)))
N
N/**
N  * @brief Set a 8-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 8-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  */
N#define outpb(port,value)     *((volatile unsigned char *)(port)) = value
N
N/**
N  * @brief Get a 8-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 8-bit data from
N  * @return  8-bit unsigned value stored in specified I/O port
N  */
N#define inpb(port)            (*((volatile unsigned char *)(port)))
N
N/**
N  * @brief Set a 32-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 32-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 32-bit aligned
N  */
N#define outp32(port,value)    *((volatile unsigned int *)(port)) = value
N
N/**
N  * @brief Get a 32-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 32-bit data from
N  * @return  32-bit unsigned value stored in specified I/O port
N  * @note The input port must be 32-bit aligned
N  */
N#define inp32(port)           (*((volatile unsigned int *)(port)))
N
N/**
N  * @brief Set a 16-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 16-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 16-bit aligned
N  */
N#define outp16(port,value)    *((volatile unsigned short *)(port)) = value
N
N/**
N  * @brief Get a 16-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 16-bit data from
N  * @return  16-bit unsigned value stored in specified I/O port
N  * @note The input port must be 16-bit aligned
N  */
N#define inp16(port)           (*((volatile unsigned short *)(port)))
N
N/**
N  * @brief Set a 8-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 8-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  */
N#define outp8(port,value)     *((volatile unsigned char *)(port)) = value
N
N/**
N  * @brief Get a 8-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 8-bit data from
N  * @return  8-bit unsigned value stored in specified I/O port
N  */
N#define inp8(port)            (*((volatile unsigned char *)(port)))
N
N
N/*@}*/ /* end of group MINI51_IO_ROUTINE */
N
N/******************************************************************************/
N/*                Legacy Constants                                            */
N/******************************************************************************/
N/** @addtogroup MINI51_legacy_Constants MINI51 Legacy Constants
N  MINI51 Legacy Constants
N  @{
N*/
N
N#ifndef NULL
N#define NULL           (0)      ///< NULL pointer
N#endif
N
N#define TRUE           (1)      ///< Boolean true, define to use in API parameters or return value
N#define FALSE          (0)      ///< Boolean false, define to use in API parameters or return value
N
N#define ENABLE         (1)      ///< Enable, define to use in API parameters
N#define DISABLE        (0)      ///< Disable, define to use in API parameters
N
N/* Define one bit mask */
N#define BIT0     (0x00000001)       ///< Bit 0 mask of an 32 bit integer
N#define BIT1     (0x00000002)       ///< Bit 1 mask of an 32 bit integer
N#define BIT2     (0x00000004)       ///< Bit 2 mask of an 32 bit integer
N#define BIT3     (0x00000008)       ///< Bit 3 mask of an 32 bit integer
N#define BIT4     (0x00000010)       ///< Bit 4 mask of an 32 bit integer
N#define BIT5     (0x00000020)       ///< Bit 5 mask of an 32 bit integer
N#define BIT6     (0x00000040)       ///< Bit 6 mask of an 32 bit integer
N#define BIT7     (0x00000080)       ///< Bit 7 mask of an 32 bit integer
N#define BIT8     (0x00000100)       ///< Bit 8 mask of an 32 bit integer
N#define BIT9     (0x00000200)       ///< Bit 9 mask of an 32 bit integer
N#define BIT10    (0x00000400)       ///< Bit 10 mask of an 32 bit integer
N#define BIT11    (0x00000800)       ///< Bit 11 mask of an 32 bit integer
N#define BIT12    (0x00001000)       ///< Bit 12 mask of an 32 bit integer
N#define BIT13    (0x00002000)       ///< Bit 13 mask of an 32 bit integer
N#define BIT14    (0x00004000)       ///< Bit 14 mask of an 32 bit integer
N#define BIT15    (0x00008000)       ///< Bit 15 mask of an 32 bit integer
N#define BIT16    (0x00010000)       ///< Bit 16 mask of an 32 bit integer
N#define BIT17    (0x00020000)       ///< Bit 17 mask of an 32 bit integer
N#define BIT18    (0x00040000)       ///< Bit 18 mask of an 32 bit integer
N#define BIT19    (0x00080000)       ///< Bit 19 mask of an 32 bit integer
N#define BIT20    (0x00100000)       ///< Bit 20 mask of an 32 bit integer
N#define BIT21    (0x00200000)       ///< Bit 21 mask of an 32 bit integer
N#define BIT22    (0x00400000)       ///< Bit 22 mask of an 32 bit integer
N#define BIT23    (0x00800000)       ///< Bit 23 mask of an 32 bit integer
N#define BIT24    (0x01000000)       ///< Bit 24 mask of an 32 bit integer
N#define BIT25    (0x02000000)       ///< Bit 25 mask of an 32 bit integer
N#define BIT26    (0x04000000)       ///< Bit 26 mask of an 32 bit integer
N#define BIT27    (0x08000000)       ///< Bit 27 mask of an 32 bit integer
N#define BIT28    (0x10000000)       ///< Bit 28 mask of an 32 bit integer
N#define BIT29    (0x20000000)       ///< Bit 29 mask of an 32 bit integer
N#define BIT30    (0x40000000)       ///< Bit 30 mask of an 32 bit integer
N#define BIT31    (0x80000000)       ///< Bit 31 mask of an 32 bit integer
N
N/* Byte Mask Definitions */
N#define BYTE0_Msk              (0x000000FF)         ///< Mask to get bit0~bit7 from a 32 bit integer
N#define BYTE1_Msk              (0x0000FF00)         ///< Mask to get bit8~bit15 from a 32 bit integer
N#define BYTE2_Msk              (0x00FF0000)         ///< Mask to get bit16~bit23 from a 32 bit integer
N#define BYTE3_Msk              (0xFF000000)         ///< Mask to get bit24~bit31 from a 32 bit integer
N
N#define GET_BYTE0(u32Param)    ((u32Param & BYTE0_Msk)      )  /*!< Extract Byte 0 (Bit  0~ 7) from parameter u32Param */
N#define GET_BYTE1(u32Param)    ((u32Param & BYTE1_Msk) >>  8)  /*!< Extract Byte 1 (Bit  8~15) from parameter u32Param */
N#define GET_BYTE2(u32Param)    ((u32Param & BYTE2_Msk) >> 16)  /*!< Extract Byte 2 (Bit 16~23) from parameter u32Param */
N#define GET_BYTE3(u32Param)    ((u32Param & BYTE3_Msk) >> 24)  /*!< Extract Byte 3 (Bit 24~31) from parameter u32Param */
N
N/*@}*/ /* end of group MINI51_legacy_Constants */
N
N/*@}*/ /* end of group MINI51_Definitions */
N
N#ifdef __cplusplus
S}
N#endif
N
N
N/******************************************************************************/
N/*                         Peripheral header files                            */
N/******************************************************************************/
N#include "sys.h"
L 1 "C:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.1.0\Device\Mini51\Driver\sys.h" 1
N/**************************************************************************//**
N * @file     sys.h
N * @version  V1.00
N * $Revision: 17 $
N * $Date: 15/09/25 9:20a $ 
N * @brief    Mini51 series SYS driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/ 
N#ifndef __SYS_H__
N#define __SYS_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N    
N/** @addtogroup MINI51_Device_Driver MINI51 Device Driver
N  @{
N*/
N
N/** @addtogroup MINI51_SYS_Driver SYS Driver
N  @{
N*/
N
N/** @addtogroup MINI51_SYS_EXPORTED_CONSTANTS SYS Exported Constants
N  @{
N*/    
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Module Reset Control Resister constant definitions.                                                    */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_RST  ((0x4<<24) | SYS_IPRSTC2_ADC_RST_Pos  ) /*!< ADC  reset is one of the SYS_ResetModule parameter */
N#define ACMP_RST ((0x4<<24) | SYS_IPRSTC2_ACMP_RST_Pos ) /*!< ACMP reset is one of the SYS_ResetModule parameter */
N#define PWM_RST  ((0x4<<24) | SYS_IPRSTC2_PWM_RST_Pos  ) /*!< PWM  reset is one of the SYS_ResetModule parameter */
N#define UART_RST ((0x4<<24) | SYS_IPRSTC2_UART_RST_Pos ) /*!< UART reset is one of the SYS_ResetModule parameter */
N#define SPI_RST  ((0x4<<24) | SYS_IPRSTC2_SPI_RST_Pos  ) /*!< SPI  reset is one of the SYS_ResetModule parameter */
N#define I2C_RST  ((0x4<<24) | SYS_IPRSTC2_I2C_RST_Pos  ) /*!< I2C  reset is one of the SYS_ResetModule parameter */
N#define TMR1_RST ((0x4<<24) | SYS_IPRSTC2_TMR1_RST_Pos ) /*!< TMR1 reset is one of the SYS_ResetModule parameter */
N#define TMR0_RST ((0x4<<24) | SYS_IPRSTC2_TMR0_RST_Pos ) /*!< TMR0 reset is one of the SYS_ResetModule parameter */
N#define GPIO_RST ((0x4<<24) | SYS_IPRSTC2_GPIO_RST_Pos ) /*!< GPIO reset is one of the SYS_ResetModule parameter */
N    
N    
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Brown Out Detector Threshold Voltage Selection constant definitions.                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SYS_BODCR_BOD_RST_EN              (1UL<<SYS_BODCR_BOD_RSTEN_Pos)    /*!< Brown-out Reset Enable */
N#define SYS_BODCR_BOD_INTERRUPT_EN        (0UL<<SYS_BODCR_BOD_RSTEN_Pos)    /*!< Brown-out Interrupt Enable */
N#define SYS_BODCR_BOD_DISABLE             (3UL<<SYS_BODCR_BOD_VL_Pos)       /*!< Disable Brown Out Detector */ 
N#define SYS_BODCR_BOD_VL_4_4V             (3UL<<SYS_BODCR_BOD_VL_Pos)       /*!< Setting Brown Out Detector Threshold Voltage as 4.4V */ 
N#define SYS_BODCR_BOD_VL_3_7V             (2UL<<SYS_BODCR_BOD_VL_Pos)       /*!< Setting Brown Out Detector Threshold Voltage as 3.7V */
N#define SYS_BODCR_BOD_VL_2_7V             (1UL<<SYS_BODCR_BOD_VL_Pos)       /*!< Setting Brown Out Detector Threshold Voltage as 2.7V */
N#define SYS_BODCR_BOD_VL_2_2V             (0UL<<SYS_BODCR_BOD_VL_Pos)       /*!< Setting Brown Out Detector Threshold Voltage as 2.2V */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Multi-Function constant definitions.                                                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SYS_MFP_TYPE_Msk(bit)       (1UL << ((bit) +16)) /*!< TYPE mask for Multiple Function Port */
N#define SYS_MFP_ALT_Msk(bit)        (1UL << ((bit) + 8)) /*!< ALT mask for Multiple Function Port */
N#define SYS_MFP_MFP_Msk(bit)        (1UL << ((bit)    )) /*!< MFP mask for Multiple Function Port */
N
N#define SYS_MFP_P00_GPIO    0x00000000UL /*!< P0_MFP pin 0 setting for GPIO */      
N#define SYS_MFP_P00_CTS     0x00000100UL /*!< P0_MFP pin 0 setting for CTS  */      
N#define SYS_MFP_P00_TXD     0x00000101UL /*!< P0_MFP pin 0 setting for TXD  */      
N#define SYS_MFP_P00_Msk     0x01000101UL /*!< P0_MFP pin 0 mask             */      
N        
N#define SYS_MFP_P01_GPIO    0x00000000UL /*!< P0_MFP pin 1 setting for GPIO  */      
N#define SYS_MFP_P01_SPISS   0x00000002UL /*!< P0_MFP pin 1 setting for SPISS */      
N#define SYS_MFP_P01_RTS     0x00000200UL /*!< P0_MFP pin 1 setting for RTS   */      
N#define SYS_MFP_P01_RXD     0x00000202UL /*!< P0_MFP pin 1 setting for RXD   */      
N#define SYS_MFP_P01_Msk     0x02000202UL /*!< P0_MFP pin 1 mask              */      
N        
N#define SYS_MFP_P04_GPIO    0x00000000UL /*!< P0_MFP pin 4 setting for GPIO   */      
N#define SYS_MFP_P04_SPISS   0x00001000UL /*!< P0_MFP pin 4 setting for SPISS1 */      
N#define SYS_MFP_P04_PWM5    0x00001010UL /*!< P0_MFP pin 4 setting for PWM5   */      
N#define SYS_MFP_P04_Msk     0x00001010UL /*!< P0_MFP pin 4 mask               */      
N        
N#define SYS_MFP_P05_GPIO    0x00000000UL /*!< P0_MFP pin 5 setting for GPIO   */      
N#define SYS_MFP_P05_MOSI    0x00002000UL /*!< P0_MFP pin 5 setting for MOSI   */      
N#define SYS_MFP_P05_Msk     0x00002020UL /*!< P0_MFP pin 5 mask               */      
N        
N#define SYS_MFP_P06_GPIO    0x00000000UL /*!< P0_MFP pin 6 setting for GPIO   */      
N#define SYS_MFP_P06_MISO    0x00004000UL /*!< P0_MFP pin 6 setting for MISO   */      
N#define SYS_MFP_P06_Msk     0x00004040UL /*!< P0_MFP pin 6 mask               */      
N        
N#define SYS_MFP_P07_GPIO    0x00000000UL /*!< P0_MFP pin 7 setting for GPIO    */      
N#define SYS_MFP_P07_SPICLK  0x00008000UL /*!< P0_MFP pin 7 setting for SPICLK  */      
N#define SYS_MFP_P07_Msk     0x00008080UL /*!< P0_MFP pin 7 mask                */      
N        
N#define SYS_MFP_P10_GPIO    0x00000000UL /*!< P1_MFP pin 0 setting for GPIO */      
N#define SYS_MFP_P10_AIN1    0x00000001UL /*!< P1_MFP pin 0 setting for AIN1 */      
N#define SYS_MFP_P10_CPP0    0x00000101UL /*!< P1_MFP pin 0 setting for CPP0 */      
N#define SYS_MFP_P10_Msk     0x00000101UL /*!< P1_MFP pin 0 mask             */      
N        
N#define SYS_MFP_P12_GPIO    0x00000000UL /*!< P1_MFP pin 2 setting for GPIO */      
N#define SYS_MFP_P12_AIN2    0x00000004UL /*!< P1_MFP pin 2 setting for AIN2 */      
N#define SYS_MFP_P12_RXD     0x00000400UL /*!< P1_MFP pin 2 setting for RXD  */      
N#define SYS_MFP_P12_CPP0    0x00000404UL /*!< P1_MFP pin 2 setting for CPP0 */      
N#define SYS_MFP_P12_Msk     0x00000404UL /*!< P1_MFP pin 2 mask             */      
N        
N#define SYS_MFP_P13_GPIO    0x00000000UL /*!< P1_MFP pin 3 setting for GPIO */      
N#define SYS_MFP_P13_AIN3    0x00000008UL /*!< P1_MFP pin 3 setting for AIN3 */      
N#define SYS_MFP_P13_TXD     0x00000800UL /*!< P1_MFP pin 3 setting for TXD  */      
N#define SYS_MFP_P13_CPP0    0x00000808UL /*!< P1_MFP pin 3 setting for CPP0 */      
N#define SYS_MFP_P13_Msk     0x00000808UL /*!< P1_MFP pin 3 mask             */      
N        
N#define SYS_MFP_P14_GPIO    0x00000000UL /*!< P1_MFP pin 4 setting for GPIO   */      
N#define SYS_MFP_P14_AIN4    0x00000010UL /*!< P1_MFP pin 4 setting for AIN4   */      
N#define SYS_MFP_P14_CPN0    0x00001010UL /*!< P1_MFP pin 4 setting for CPN0   */      
N#define SYS_MFP_P14_Msk     0x00001010UL /*!< P1_MFP pin 4 mask               */      
N        
N#define SYS_MFP_P15_GPIO    0x00000000UL /*!< P1_MFP pin 5 setting for GPIO   */      
N#define SYS_MFP_P15_AIN5    0x00000020UL /*!< P1_MFP pin 5 setting for AIN5   */      
N#define SYS_MFP_P15_CPP0    0x00002020UL /*!< P1_MFP pin 5 setting for CPP0   */      
N#define SYS_MFP_P15_Msk     0x00002020UL /*!< P1_MFP pin 5 mask               */      
N        
N#define SYS_MFP_P22_GPIO    0x00000000UL /*!< P2_MFP pin 2 setting for GPIO */      
N#define SYS_MFP_P22_PWM0    0x00000400UL /*!< P2_MFP pin 2 setting for PWM0 */      
N#define SYS_MFP_P22_Msk     0x00000404UL /*!< P2_MFP pin 2 mask             */      
N        
N#define SYS_MFP_P23_GPIO    0x00000000UL /*!< P2_MFP pin 3 setting for GPIO */      
N#define SYS_MFP_P23_PWM1    0x00000800UL /*!< P2_MFP pin 3 setting for PWM1 */      
N#define SYS_MFP_P23_Msk     0x00000808UL /*!< P2_MFP pin 3 mask             */      
N        
N#define SYS_MFP_P24_GPIO    0x00000000UL /*!< P2_MFP pin 4 setting for GPIO */      
N#define SYS_MFP_P24_PWM2    0x00001000UL /*!< P2_MFP pin 4 setting for PWM2 */      
N#define SYS_MFP_P24_Msk     0x00001010UL /*!< P2_MFP pin 4 mask             */      
N        
N#define SYS_MFP_P25_GPIO    0x00000000UL /*!< P2_MFP pin 5 setting for GPIO */      
N#define SYS_MFP_P25_PWM3    0x00002000UL /*!< P2_MFP pin 5 setting for PWM3 */      
N#define SYS_MFP_P25_Msk     0x00002020UL /*!< P2_MFP pin 5 mask             */      
N        
N#define SYS_MFP_P26_GPIO    0x00000000UL /*!< P2_MFP pin 6 setting for GPIO */      
N#define SYS_MFP_P26_PWM4    0x00004000UL /*!< P2_MFP pin 6 setting for PWM4 */      
N#define SYS_MFP_P26_CPO1    0x00004040UL /*!< P2_MFP pin 6 setting for CPO1 */      
N#define SYS_MFP_P26_Msk     0x00004040UL /*!< P2_MFP pin 6 mask             */      
N        
N#define SYS_MFP_P30_GPIO    0x00000000UL /*!< P3_MFP pin 0 setting for GPIO */      
N#define SYS_MFP_P30_CPN1    0x00000100UL /*!< P3_MFP pin 0 setting for CPN1 */      
N#define SYS_MFP_P30_AIN6    0x00000101UL /*!< P3_MFP pin 0 setting for AIN6 */      
N#define SYS_MFP_P30_Msk     0x00000101UL /*!< P3_MFP pin 0 mask             */      
N
N#define SYS_MFP_P31_GPIO    0x00000000UL /*!< P3_MFP pin 1 setting for GPIO */      
N#define SYS_MFP_P31_CPP1    0x00000200UL /*!< P3_MFP pin 1 setting for CPP1 */      
N#define SYS_MFP_P31_AIN7    0x00000202UL /*!< P3_MFP pin 1 setting for AIN7 */      
N#define SYS_MFP_P31_Msk     0x00000202UL /*!< P3_MFP pin 1 mask             */      
N
N#define SYS_MFP_P32_GPIO    0x00000000UL /*!< P3_MFP pin 2 setting for GPIO  */
N#define SYS_MFP_P32_INT0    0x00000004UL /*!< P3_MFP pin 2 setting for /INT0 */            
N#define SYS_MFP_P32_T0EX    0x00000400UL /*!< P3_MFP pin 2 setting for T0EX  */      
N#define SYS_MFP_P32_STADC   0x00000404UL /*!< P3_MFP pin 2 setting for STADC */
N#define SYS_MFP_P32_CPP1    0x01000000UL /*!< P3_MFP pin 2 setting for CPP1  */
N#define SYS_MFP_P32_Msk     0x01000404UL /*!< P3_MFP pin 2 mask              */      
N
N#define SYS_MFP_P34_GPIO    0x00000000UL /*!< P3_MFP pin 4 setting for GPIO */
N#define SYS_MFP_P34_T0      0x00000010UL /*!< P3_MFP pin 4 setting for T0   */
N#define SYS_MFP_P34_SDA     0x00001000UL /*!< P3_MFP pin 4 setting for SDA  */
N#define SYS_MFP_P34_CPP1    0x00001010UL /*!< P3_MFP pin 4 setting for CPP1 */
N#define SYS_MFP_P34_Msk     0x00001010UL /*!< P3_MFP pin 4 mask             */
N
N#define SYS_MFP_P35_GPIO    0x00000000UL /*!< P3_MFP pin 5 setting for GPIO */
N#define SYS_MFP_P35_T1      0x00000020UL /*!< P3_MFP pin 5 setting for T1   */
N#define SYS_MFP_P35_SCL     0x00002000UL /*!< P3_MFP pin 5 setting for SCL  */
N#define SYS_MFP_P35_CPP1    0x00002020UL /*!< P3_MFP pin 5 setting for CPP1 */
N#define SYS_MFP_P35_Msk     0x00002020UL /*!< P3_MFP pin 5 mask             */
N
N#define SYS_MFP_P36_GPIO    0x00000000UL /*!< P3_MFP pin 6 setting for GPIO */
N#define SYS_MFP_P36_T1EX    0x00000040UL /*!< P3_MFP pin 6 setting for T1EX */
N#define SYS_MFP_P36_CKO     0x00004000UL /*!< P3_MFP pin 6 setting for CKO  */
N#define SYS_MFP_P36_CPO0    0x00004040UL /*!< P3_MFP pin 6 setting for CPO0 */
N#define SYS_MFP_P36_Msk     0x00004040UL /*!< P3_MFP pin 6 mask             */
N
N#define SYS_MFP_P46_GPIO    0x00000000UL /*!< P4_MFP pin 6 setting for GPIO    */
N#define SYS_MFP_P46_ICE_CLK 0x00000040UL /*!< P4_MFP pin 6 setting for ICE_CLK */
N#define SYS_MFP_P46_Msk     0x00004040UL /*!< P4_MFP pin 6 mask                */
N        
N#define SYS_MFP_P47_GPIO    0x00000000UL /*!< P4_MFP pin 7 setting for GPIO    */
N#define SYS_MFP_P47_ICE_DAT 0x00000080UL /*!< P4_MFP pin 7 setting for ICE_DAT */
N#define SYS_MFP_P47_Msk     0x00008080UL /*!< P4_MFP pin 7 mask                */
N
N#define SYS_MFP_P50_GPIO    0x00000000UL /*!< P5_MFP pin 0 setting for GPIO */
N#define SYS_MFP_P50_XTAL1   0x00000001UL /*!< P5_MFP pin 0 setting for XTAL1*/
N#define SYS_MFP_P50_Msk     0x00000101UL /*!< P5_MFP pin 0 mask             */
N
N#define SYS_MFP_P51_GPIO    0x00000000UL /*!< P5_MFP pin 1 setting for GPIO */
N#define SYS_MFP_P51_XTAL2   0x00000002UL /*!< P5_MFP pin 1 setting for XTAL2*/
N#define SYS_MFP_P51_Msk     0x00000202UL /*!< P5_MFP pin 1 mask             */
N
N#define SYS_MFP_P52_GPIO    0x00000000UL /*!< P5_MFP pin 2 setting for GPIO */
N#define SYS_MFP_P52_INT1    0x00000004UL /*!< P5_MFP pin 2 setting for /INT1*/
N#define SYS_MFP_P52_Msk     0x00000404UL /*!< P5_MFP pin 2 mask             */
N
N#define SYS_MFP_P53_GPIO    0x00000000UL /*!< P5_MFP pin 3 setting for GPIO */
N#define SYS_MFP_P53_AIN0    0x00000008UL /*!< P5_MFP pin 3 setting for AIN0 */
N#define SYS_MFP_P53_Msk     0x00000808UL /*!< P5_MFP pin 3 mask             */
N
N#define SYS_MFP_P54_GPIO    0x00000000UL /*!< P5_MFP pin 4 setting for GPIO */
N#define SYS_MFP_P54_Msk     0x00001010UL /*!< P5_MFP pin 4 mask             */
N
N#define SYS_MFP_P55_GPIO    0x00000000UL /*!< P5_MFP pin 5 setting for GPIO */
N#define SYS_MFP_P55_Msk     0x00002020UL /*!< P5_MFP pin 5 mask             */
N    
N
N
N/*@}*/ /* end of group MINI51_SYS_EXPORTED_CONSTANTS */
N
N/** @addtogroup MINI51_SYS_EXPORTED_FUNCTIONS SYS Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Clear Brown-out detector interrupt flag
N  * @param      None
N  * @return     None
N  * @details    This macro clear Brown-out detector interrupt flag.
N  */
N#define SYS_CLEAR_BOD_INT_FLAG()        (SYS->BODCTL |= SYS_BODCR_BOD_INTF_Msk)
N
N/**
N  * @brief      Set Brown-out detector function to normal mode
N  * @param      None
N  * @return     None
N  * @details    This macro set Brown-out detector to normal mode.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_CLEAR_BOD_LPM()             (SYS->BODCTL &= ~SYS_BODCR_BOD_LPM_Msk)
N
N/**
N  * @brief      Disable Brown-out detector function
N  * @param      None
N  * @return     None
N  * @details    This macro disable Brown-out detector function.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_DISABLE_BOD()               (SYS->BODCTL = (SYS->BODCTL &~(SYS_BODCR_BOD_VL_Msk|SYS_BODCR_BOD_VL_EXT_Msk))|SYS_BODCR_BOD_DISABLE)
N
N/**
N  * @brief      Enable Brown-out detector function
N  * @param      None
N  * @return     None
N  * @details    This macro enable Brown-out detector function and set BOD_LV=3.7V
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_ENABLE_BOD()                (SYS->BODCTL = (SYS->BODCTL & ~SYS_BODCR_BOD_VL_Msk) | SYS_BODCR_BOD_VL_3_7V)
N
N/**
N  * @brief      Get Brown-out detector interrupt flag
N  * @param      None
N  * @retval     0   Brown-out detect interrupt flag is not set.
N  * @retval     >=1 Brown-out detect interrupt flag is set.
N  * @details    This macro get Brown-out detector interrupt flag.
N  */
N#define SYS_GET_BOD_INT_FLAG()          (SYS->BODCTL & SYS_BODCR_BOD_INTF_Msk)
N
N/**
N  * @brief      Get Brown-out detector status
N  * @param      None
N  * @retval     0   System voltage is higher than BOD threshold voltage setting or BOD function is disabled.
N  * @retval     >=1 System voltage is lower than BOD threshold voltage setting.
N  * @details    This macro get Brown-out detector output status.
N  *             If the BOD function is disabled, this function always return 0.
N  */
N#define SYS_GET_BOD_OUTPUT()            (SYS->BODCTL & SYS_BODCR_BOD_OUT_Msk)
N
N/**
N  * @brief      Enable Brown-out detector interrupt function
N  * @param      None
N  * @return     None
N  * @details    This macro enable Brown-out detector interrupt function.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_DISABLE_BOD_RST()           (SYS->BODCTL &= ~SYS_BODCR_BOD_RSTEN_Msk)
N
N/**
N  * @brief      Enable Brown-out detector reset function
N  * @param      None
N  * @return     None
N  * @details    This macro enable Brown-out detect reset function.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_ENABLE_BOD_RST()            (SYS->BODCTL |= SYS_BODCR_BOD_RSTEN_Msk)
N
N/**
N  * @brief      Set Brown-out detector function low power mode
N  * @param      None
N  * @return     None
N  * @details    This macro set Brown-out detector to low power mode.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_SET_BOD_LPM()               (SYS->BODCTL |= SYS_BODCR_BOD_LPM_Msk)
N
N/**
N  * @brief      Set Brown-out detector voltage level
N  * @param[in]  u32Level is Brown-out voltage level. Including :
N  *             - \ref SYS_BODCR_BOD_VL_4_4V
N  *             - \ref SYS_BODCR_BOD_VL_3_7V
N  *             - \ref SYS_BODCR_BOD_VL_2_7V
N  *             - \ref SYS_BODCR_BOD_VL_2_2V
N  * @return     None
N  * @details    This macro set Brown-out detector voltage level.
N  *             The write-protection function should be disabled before using this macro.
N  */
N#define SYS_SET_BOD_LEVEL(u32Level) (SYS->BODCTL = (SYS->BODCTL & ~SYS_BODCR_BOD_VL_Msk) | u32Level)
N
N/**
N  * @brief      Get reset source is from Brown-out detector reset
N  * @param      None
N  * @retval     0   Previous reset source is not from Brown-out detector reset
N  * @retval     >=1 Previous reset source is from Brown-out detector reset
N  * @details    This macro get previous reset source is from Brown-out detect reset or not.
N  */
N#define SYS_IS_BOD_RST()                (SYS->RSTSRC & SYS_RSTSRC_RSTS_BOD_Msk)
N
N/**
N  * @brief      Get reset source is from CPU reset
N  * @param      None
N  * @retval     0   Previous reset source is not from CPU reset
N  * @retval     >=1 Previous reset source is from CPU reset
N  * @details    This macro get previous reset source is from CPU reset.
N  */
N#define SYS_IS_CPU_RST()                (SYS->RSTSRC & SYS_RSTSRC_RSTS_CPU_Msk)
N
N/**
N  * @brief      Get reset source is from Power-on Reset
N  * @param      None
N  * @retval     0   Previous reset source is not from Power-on Reset
N  * @retval     >=1 Previous reset source is from Power-on Reset
N  * @details    This macro get previous reset source is from Power-on Reset.
N  */
N#define SYS_IS_POR_RST()                (SYS->RSTSRC & SYS_RSTSRC_RSTS_POR_Msk)
N
N/**
N  * @brief      Get reset source is from reset pin reset
N  * @param      None
N  * @retval     0   Previous reset source is not from reset pin reset
N  * @retval     >=1 Previous reset source is from reset pin reset
N  * @details    This macro get previous reset source is from reset pin reset.
N  */
N#define SYS_IS_RSTPIN_RST()             (SYS->RSTSRC & SYS_RSTSRC_RSTS_RESET_Msk)
N
N/**
N  * @brief      Get reset source is from system reset
N  * @param      None
N  * @retval     0   Previous reset source is not from system reset
N  * @retval     >=1 Previous reset source is from system reset
N  * @details    This macro get previous reset source is from system reset.
N  */
N#define SYS_IS_SYSTEM_RST()             (SYS->RSTSRC & SYS_RSTSRC_RSTS_MCU_Msk)
N
N/**
N  * @brief      Get reset source is from window watch dog reset
N  * @param      None
N  * @retval     0   Previous reset source is not from window watch dog reset
N  * @retval     >=1 Previous reset source is from window watch dog reset
N  * @details    This macro get previous reset source is from window watch dog reset.
N  */
N#define SYS_IS_WDT_RST()                (SYS->RSTSRC & SYS_RSTSRC_RSTS_WDT_Msk)
N
N/**
N  * @brief      Disable Power-on Reset function
N  * @param      None
N  * @return     None
N  * @details    This macro disable Power-on Reset function.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_DISABLE_POR()               (SYS->PORCR = 0x5AA5)
N
N/**
N  * @brief      Enable Power-on Reset function
N  * @param      None
N  * @return     None
N  * @details    This macro enable Power-on Reset function.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_ENABLE_POR()                (SYS->PORCR = 0)
N
N/**
N  * @brief      Clear reset source flag
N  * @param[in]  u32RstSrc is reset source. Including :
N  *             - \ref SYS_RSTSRC_RSTS_POR_Msk
N  *             - \ref SYS_RSTSRC_RSTS_RESET_Msk
N  *             - \ref SYS_RSTSRC_RSTS_WDT_Msk
N  *             - \ref SYS_RSTSRC_RSTS_BOD_Msk
N  *             - \ref SYS_RSTSRC_RSTS_MCU_Msk
N  *             - \ref SYS_RSTSRC_RSTS_CPU_Msk
N  * @return     None
N  * @details    This macro clear reset source flag.
N  */
N#define SYS_CLEAR_RST_SOURCE(u32RstSrc) (SYS->RSTSRC = u32RstSrc )
N
N    
Nvoid SYS_ClearResetSrc(uint32_t u32Src);
Nuint32_t SYS_GetBODStatus(void);
Nuint32_t SYS_GetResetSrc(void);
Nuint32_t SYS_IsRegLocked(void);
Nvoid SYS_LockReg(void);
Nvoid SYS_UnlockReg(void);
Nuint32_t  SYS_ReadPDID(void);
Nvoid SYS_ResetChip(void);
Nvoid SYS_ResetCPU(void);
Nvoid SYS_ResetModule(uint32_t u32ModuleIndex);
Nvoid SYS_EnableBOD(int32_t i32Mode, uint32_t u32BODLevel);
Nvoid SYS_DisableBOD(void);    
N
N/*@}*/ /* end of group MINI51_SYS_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group MINI51_SYS_Driver */
N
N/*@}*/ /* end of group MINI51_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__SYS_H__
L 5949 "C:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.1.0\Device\Mini51\Include\Mini51Series.h" 2
N#include "clk.h"
L 1 "C:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.1.0\Device\Mini51\Driver\clk.h" 1
N/**************************************************************************//**
N * @file     clk.h
N * @version  V1.00
N * $Revision: 19 $
N * $Date: 15/09/25 9:19a $ 
N * @brief    Mini51 series CLK driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/ 
N#ifndef __CLK_H__
N#define __CLK_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup MINI51_Device_Driver MINI51 Device Driver
N  @{
N*/
N
N/** @addtogroup MINI51_CLK_Driver CLK Driver
N  @{
N*/
N
N
N
N/** @addtogroup MINI51_CLK_EXPORTED_CONSTANTS CLK Exported Constants
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  PWRCON constant definitions.                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_PWRCON_XTL12M              0x01UL /*!< Setting External Crystal Oscillator as 12MHz         */
N#define CLK_PWRCON_HXT                 0x01UL /*!< Setting External Crystal Oscillator as 12MHz         */
N#define CLK_PWRCON_XTL32K              0x02UL /*!< Setting External Crystal Oscillator as 32KHz         */
N#define CLK_PWRCON_LXT                 0x02UL /*!< Setting External Crystal Oscillator as 32KHz         */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKSEL0 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKSEL0_HCLK_S_XTAL          0x00UL /*!< Setting clock source as external XTAL */ 
N#define CLK_CLKSEL0_HCLK_S_IRC10K        0x03UL /*!< Setting clock source as internal 10KHz RC clock */
N#define CLK_CLKSEL0_HCLK_S_LIRC          0x03UL /*!< Setting clock source as internal 10KHz RC clock */
N#define CLK_CLKSEL0_HCLK_S_IRC22M        0x07UL /*!< Setting clock source as internal 22.1184MHz RC clock */
N#define CLK_CLKSEL0_HCLK_S_HIRC          0x07UL /*!< Setting clock source as internal 22.1184MHz RC clock */
N#define CLK_CLKSEL0_STCLK_S_XTAL         0x00UL /*!< Setting clock source as external XTAL */ 
N#define CLK_CLKSEL0_STCLK_S_XTAL_DIV2    0x10UL /*!< Setting clock source as external XTAL/2 */
N#define CLK_CLKSEL0_STCLK_S_HCLK_DIV2    0x18UL /*!< Setting clock source as HCLK/2 */
N#define CLK_CLKSEL0_STCLK_S_IRC22M_DIV2  0x38UL /*!< Setting clock source as internal 22.1184MHz RC clock/2 */
N#define CLK_CLKSEL0_STCLK_S_HIRC_DIV2    0x38UL /*!< Setting clock source as internal 22.1184MHz RC clock/2 */
N#define CLK_CLKSEL0_STCLK_S_HCLK         0x08UL /*!< Setting clock source as HCLK */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKSEL1 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKSEL1_WDT_S_XTAL          0x00000000UL /*!< Setting WDT clock source as external XTAL */ 
N#define CLK_CLKSEL1_WDT_S_HCLK_DIV2048  0x00000002UL /*!< Setting WDT clock source as HCLK/2048 */
N#define CLK_CLKSEL1_WDT_S_IRC10K        0x00000003UL /*!< Setting WDT clock source as internal 10KHz RC clock */
N#define CLK_CLKSEL1_WDT_S_LIRC          0x00000003UL /*!< Setting WDT clock source as internal 10KHz RC clock */
N#define CLK_CLKSEL1_ADC_S_XTAL          0x00000000UL /*!< Setting ADC clock source as external XTAL */
N#define CLK_CLKSEL1_ADC_S_HCLK          0x00000008UL /*!< Setting ADC clock source as HCLK */
N#define CLK_CLKSEL1_ADC_S_IRC22M        0x0000000CUL /*!< Setting ADC clock source as internal 22.1184MHz RC clock */
N#define CLK_CLKSEL1_ADC_S_HIRC          0x0000000CUL /*!< Setting ADC clock source as internal 22.1184MHz RC clock */
N#define CLK_CLKSEL1_SPI_S_HXTorLXT      0x00000000UL /*!< Setting SPI clock source as HXT or LXT */
N#define CLK_CLKSEL1_SPI_S_HCLK          0x00000010UL /*!< Setting SPI clock source as HCLK */
N#define CLK_CLKSEL1_TMR0_S_XTAL         0x00000000UL /*!< Setting Timer 0 clock source as external XTAL */
N#define CLK_CLKSEL1_TMR0_S_IRC10K       0x00000100UL /*!< Setting Timer 0 clock source as internal 10KHz RC clock */
N#define CLK_CLKSEL1_TMR0_S_LIRC         0x00000100UL /*!< Setting Timer 0 clock source as internal 10KHz RC clock */
N#define CLK_CLKSEL1_TMR0_S_HCLK         0x00000200UL /*!< Setting Timer 0 clock source as HCLK */
N#define CLK_CLKSEL1_TMR0_S_IRC22M       0x00000700UL /*!< Setting Timer 0 clock source as internal 22.1184MHz RC clock */
N#define CLK_CLKSEL1_TMR0_S_HIRC         0x00000700UL /*!< Setting Timer 0 clock source as internal 22.1184MHz RC clock */
N#define CLK_CLKSEL1_TMR1_S_XTAL         0x00000000UL /*!< Setting Timer 1 clock source as external XTAL */
N#define CLK_CLKSEL1_TMR1_S_IRC10K       0x00001000UL /*!< Setting Timer 1 clock source as internal 10KHz RC clock */
N#define CLK_CLKSEL1_TMR1_S_LIRC         0x00001000UL /*!< Setting Timer 1 clock source as internal 10KHz RC clock */
N#define CLK_CLKSEL1_TMR1_S_HCLK         0x00002000UL /*!< Setting Timer 1 clock source as HCLK */
N#define CLK_CLKSEL1_TMR1_S_IRC22M       0x00007000UL /*!< Setting Timer 1 clock source as internal 22.1184MHz RC clock */
N#define CLK_CLKSEL1_TMR1_S_HIRC         0x00007000UL /*!< Setting Timer 1 clock source as internal 22.1184MHz RC clock */
N#define CLK_CLKSEL1_UART_S_XTAL         0x00000000UL /*!< Setting UART clock source as external XTAL */
N#define CLK_CLKSEL1_UART_S_IRC22M       0x02000000UL /*!< Setting UART clock source as external internal 22.1184MHz RC clock */
N#define CLK_CLKSEL1_UART_S_HIRC         0x02000000UL /*!< Setting UART clock source as external internal 22.1184MHz RC clock */
N#define CLK_CLKSEL1_PWM01_S_HCLK        0x20000000UL /*!< Setting PWM01 clock source as external HCLK */
N#define CLK_CLKSEL1_PWM23_S_HCLK        0x80000000UL /*!< Setting PWM23 clock source as external HCLK */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKSEL2 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKSEL2_FRQDIV_XTAL        0x00000000UL /*!< Setting FRQDIV clock source as external XTAL */ 
N#define CLK_CLKSEL2_FRQDIV_HXT         0x00000000UL /*!< Setting FRQDIV clock source as external XTAL */ 
N#define CLK_CLKSEL2_FRQDIV_LXT         0x00000000UL /*!< Setting FRQDIV clock source as external XTAL */ 
N#define CLK_CLKSEL2_FRQDIV_HCLK        0x00000008UL /*!< Setting FRQDIV clock source as HCLK */
N#define CLK_CLKSEL2_FRQDIV_IRC22M      0x0000000CUL /*!< Setting FRQDIV clock source as internal 22.1184MHz RC clock */
N#define CLK_CLKSEL2_FRQDIV_HIRC        0x0000000CUL /*!< Setting FRQDIV clock source as internal 22.1184MHz RC clock */
N#define CLK_CLKSEL2_PWM45_S_HCLK       0x00000020UL /*!< Setting PWM45 clock source as HCLK */
N
N       
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKDIV constant definitions.                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKDIV_ADC(x)  (((x)-1) << 16) /*!< CLKDIV Setting for ADC clock divider. It could be 1~256 */ 
N#define CLK_CLKDIV_UART(x) (((x)-1) <<  8) /*!< CLKDIV Setting for UART clock divider. It could be 1~16 */ 
N#define CLK_CLKDIV_HCLK(x)  ((x)-1)        /*!< CLKDIV Setting for HCLK clock divider. It could be 1~16 */ 
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  MODULE constant definitions.                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/ 
N#define MODULE_APBCLK(x)                   ((x >>31) & 0x1)    /*!< Calculate APBCLK offset on MODULE index */ 
N#define MODULE_CLKSEL(x)                   ((x >>29) & 0x3)    /*!< Calculate CLKSEL offset on MODULE index */ 
N#define MODULE_CLKSEL_Msk(x)               ((x >>25) & 0xf)    /*!< Calculate CLKSEL mask offset on MODULE index */ 
N#define MODULE_CLKSEL_Pos(x)               ((x >>20) & 0x1f)   /*!< Calculate CLKSEL position offset on MODULE index */ 
N#define MODULE_CLKDIV(x)                   ((x >>18) & 0x3)    /*!< Calculate APBCLK CLKDIV on MODULE index */ 
N#define MODULE_CLKDIV_Msk(x)               ((x >>10) & 0xff)   /*!< Calculate CLKDIV mask offset on MODULE index */ 
N#define MODULE_CLKDIV_Pos(x)               ((x >>5 ) & 0x1f)   /*!< Calculate CLKDIV position offset on MODULE index */ 
N#define MODULE_IP_EN_Pos(x)                ((x >>0 ) & 0x1f)   /*!< Calculate APBCLK offset on MODULE index */ 
N#define MODULE_NoMsk                       0x0                 /*!< Not mask on MODULE index */ 
N#define NA                                 MODULE_NoMsk        /*!< Not Available */
N
N#define MODULE_APBCLK_ENC(x)        (((x) & 0x01) << 31)   /*!< MODULE index, 0x0:AHBCLK, 0x1:APBCLK */
N#define MODULE_CLKSEL_ENC(x)        (((x) & 0x03) << 29)   /*!< CLKSEL offset on MODULE index, 0x0:CLKSEL0, 0x1:CLKSEL1 0x3 CLKSEL2*/
N#define MODULE_CLKSEL_Msk_ENC(x)    (((x) & 0x0f) << 25)   /*!< CLKSEL mask offset on MODULE index */
N#define MODULE_CLKSEL_Pos_ENC(x)    (((x) & 0x1f) << 20)   /*!< CLKSEL position offset on MODULE index */
N#define MODULE_CLKDIV_ENC(x)        (((x) & 0x03) << 18)   /*!< APBCLK CLKDIV on MODULE index, 0x0:CLKDIV */
N#define MODULE_CLKDIV_Msk_ENC(x)    (((x) & 0xff) << 10)   /*!< CLKDIV mask offset on MODULE index */
N#define MODULE_CLKDIV_Pos_ENC(x)    (((x) & 0x1f) <<  5)   /*!< CLKDIV position offset on MODULE index */
N#define MODULE_IP_EN_Pos_ENC(x)     (((x) & 0x1f) <<  0)   /*!< APBCLK offset on MODULE index */
N/*-------------------------------------------------------------------------------------------------------------------------------*/        
N/*   APBCLK(1) | CLKSEL(2) | CLKSEL_Msk(4) |    CLKSEL_Pos(5)    | CLKDIV(2) | CLKDIV_Msk(8) |     CLKDIV_Pos(5)  |  IP_EN_Pos(5)        */
N/*-------------------------------------------------------------------------------------------------------------------------------*/
N#define WDT_MODULE        ((0x0<<31)|(0x1<<29)|(0x3<<25)|( 0<<20)|(0x3<<18)|(MODULE_NoMsk<<10)|(31<<5)|CLK_APBCLK_WDT_EN_Pos )  /*!< Watchdog Timer Module */ 
N#define TMR0_MODULE       ((0x0<<31)|(0x1<<29)|(0x7<<25)|( 8<<20)|(0x3<<18)|(MODULE_NoMsk<<10)|(31<<5)|CLK_APBCLK_TMR0_EN_Pos)  /*!< Timer0 Module */ 
N#define TMR1_MODULE       ((0x0<<31)|(0x1<<29)|(0x7<<25)|(12<<20)|(0x3<<18)|(MODULE_NoMsk<<10)|(31<<5)|CLK_APBCLK_TMR1_EN_Pos)  /*!< Timer1 Module */ 
N#define FDIV_MODULE       ((0x0<<31)|(0x3<<29)|(0x3<<25)|( 2<<20)|(0x3<<18)|(MODULE_NoMsk<<10)|(31<<5)|CLK_APBCLK_FDIV_EN_Pos)  /*!< Frequency Divider Output Module */ 
N#define I2C_MODULE        ((0x0<<31)|(0x3<<29)|(MODULE_NoMsk<<25)|(31<<20)|(0x3<<18)|(MODULE_NoMsk<<10)|(31<<5)|CLK_APBCLK_I2C_EN_Pos)   /*!< I2C Module */ 
N#define SPI_MODULE        ((0x0<<31)|(0x1<<29)|(0x1<<25)|( 4<<20)|(0x3<<18)|(MODULE_NoMsk<<10)|(31<<5)|CLK_APBCLK_SPI_EN_Pos)   /*!< SPI Module */ 
N#define UART_MODULE       ((0x0<<31)|(0x1<<29)|(0x3<<25)|(24<<20)|(0x0<<18)|(0x0F<<10)|( 8<<5)|CLK_APBCLK_UART_EN_Pos)          /*!< UART Module */ 
N#define PWM01_MODULE      ((0x0<<31)|(0x1<<29)|(0x3<<25)|(28<<20)|(0x3<<18)|(MODULE_NoMsk<<10)|(31<<5)|CLK_APBCLK_PWM01_EN_Pos) /*!< PWM Channel0 and Channel1 Module */ 
N#define PWM23_MODULE      ((0x0<<31)|(0x1<<29)|(0x3<<25)|(30<<20)|(0x3<<18)|(MODULE_NoMsk<<10)|(31<<5)|CLK_APBCLK_PWM23_EN_Pos) /*!< PWM Channel2 and Channel3 Module */ 
N#define PWM45_MODULE      ((0x0<<31)|(0x3<<29)|(0x3<<25)|( 4<<20)|(0x3<<18)|(MODULE_NoMsk<<10)|(31<<5)|CLK_APBCLK_PWM45_EN_Pos) /*!< PWM Channel4 and Channel5 Module */ 
N#define ADC_MODULE        ((0x0<<31)|(0x1<<29)|(0x3<<25)|( 2<<20)|(0x0<<18)|(0xFF<<10)|(16<<5)|CLK_APBCLK_ADC_EN_Pos)           /*!< ADC Module */ 
N#define ACMP_MODULE       ((0x0<<31)|(0x3<<29)|(MODULE_NoMsk<<25)|(31<<20)|(0x3<<18)|(MODULE_NoMsk<<10)|(31<<5)|CLK_APBCLK_ACMP_EN_Pos)  /*!< ACMP Module */
N
N/*@}*/ /* end of group MINI51_CLK_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup MINI51_CLK_EXPORTED_FUNCTIONS CLK Exported Functions
N  @{
N*/
N
Nvoid CLK_DisableCKO(void);
Nvoid CLK_EnableCKO(uint32_t u32ClkSrc, uint32_t u32ClkDiv, uint32_t u32ClkDivBy1En);
Nvoid CLK_PowerDown(void);
Nvoid CLK_Idle(void);
Nuint32_t CLK_GetHXTFreq(void);
Nuint32_t CLK_GetLXTFreq(void);
Nuint32_t CLK_GetHCLKFreq(void);
Nuint32_t CLK_GetPCLKFreq(void);
Nuint32_t CLK_GetCPUFreq(void);
Nvoid CLK_SetHCLK(uint32_t u32ClkSrc, uint32_t u32ClkDiv);
Nvoid CLK_SetModuleClock(uint32_t u32ModuleIdx, uint32_t u32ClkSrc, uint32_t u32ClkDiv);
Nvoid CLK_SetSysTickClockSrc(uint32_t u32ClkSrc);
Nvoid CLK_EnableSysTick(uint32_t u32ClkSrc, uint32_t u32Count);
Nvoid CLK_DisableSysTick(void);
Nvoid CLK_EnableXtalRC(uint32_t u32ClkMask);
Nvoid CLK_DisableXtalRC(uint32_t u32ClkMask);
Nvoid CLK_EnableModuleClock(uint32_t u32ModuleIdx);
Nvoid CLK_DisableModuleClock(uint32_t u32ModuleIdx);
Nvoid CLK_SysTickDelay(uint32_t us);
Nuint32_t CLK_WaitClockReady(uint32_t u32ClkMask);
N
N
N
N/*@}*/ /* end of group MINI51_CLK_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group MINI51_CLK_Driver */
N
N/*@}*/ /* end of group MINI51_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__CLK_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 5950 "C:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.1.0\Device\Mini51\Include\Mini51Series.h" 2
N#include "acmp.h"
L 1 "C:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.1.0\Device\Mini51\Driver\acmp.h" 1
N/**************************************************************************//**
N * @file     acmp.h
N * @version  V1.00
N * $Revision: 4 $
N * $Date: 15/09/22 7:50p $
N * @brief    Mini51 series Analog Comparator(ACMP) driver header file
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N#ifndef __ACMP_H__
N#define __ACMP_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup MINI51_Device_Driver MINI51 Device Driver
N  @{
N*/
N
N/** @addtogroup MINI51_ACMP_Driver ACMP Driver
N  @{
N*/
N
N/** @addtogroup MINI51_ACMP_EXPORTED_CONSTANTS ACMP Exported Constants
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ACMP_CR constant definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ACMP_VNEG_PIN             (0xFFUL)                         ///< Selecting the voltage of ACMP negative input pin as the source of ACMP V- \hideinitializer
N#define ACMP_VNEG_BANDGAP         (0x00UL)                         ///< Selecting band-gap voltage as the source of ACMP V- \hideinitializer
N#define ACMP_VNEG_4_OVER_24_VDD   (0x80UL)                         ///< Selecting 4/24 VDD as the source of ACMP V- \hideinitializer
N#define ACMP_VNEG_5_OVER_24_VDD   (0x81UL)                         ///< Selecting 5/24 VDD as the source of ACMP V- \hideinitializer
N#define ACMP_VNEG_6_OVER_24_VDD   (0x82UL)                         ///< Selecting 6/24 VDD as the source of ACMP V- \hideinitializer
N#define ACMP_VNEG_7_OVER_24_VDD   (0x83UL)                         ///< Selecting 7/24 VDD as the source of ACMP V- \hideinitializer
N#define ACMP_VNEG_8_OVER_24_VDD   (0x84UL)                         ///< Selecting 8/24 VDD as the source of ACMP V- \hideinitializer
N#define ACMP_VNEG_9_OVER_24_VDD   (0x85UL)                         ///< Selecting 9/24 VDD as the source of ACMP V- \hideinitializer
N#define ACMP_VNEG_10_OVER_24_VDD  (0x86UL)                         ///< Selecting 10/24 VDD as the source of ACMP V- \hideinitializer
N#define ACMP_VNEG_11_OVER_24_VDD  (0x87UL)                         ///< Selecting 11/24 VDD as the source of ACMP V- \hideinitializer
N#define ACMP_VNEG_12_OVER_24_VDD  (0x88UL)                         ///< Selecting 12/24 VDD as the source of ACMP V- \hideinitializer
N#define ACMP_VNEG_13_OVER_24_VDD  (0x89UL)                         ///< Selecting 13/24 VDD as the source of ACMP V- \hideinitializer
N#define ACMP_VNEG_14_OVER_24_VDD  (0x8AUL)                         ///< Selecting 14/24 VDD as the source of ACMP V- \hideinitializer
N#define ACMP_VNEG_15_OVER_24_VDD  (0x8BUL)                         ///< Selecting 15/24 VDD as the source of ACMP V- \hideinitializer
N#define ACMP_VNEG_16_OVER_24_VDD  (0x8CUL)                         ///< Selecting 16/24 VDD as the source of ACMP V- \hideinitializer
N#define ACMP_VNEG_17_OVER_24_VDD  (0x8DUL)                         ///< Selecting 17/24 VDD as the source of ACMP V- \hideinitializer
N#define ACMP_VNEG_18_OVER_24_VDD  (0x8EUL)                         ///< Selecting 18/24 VDD as the source of ACMP V- \hideinitializer
N#define ACMP_VNEG_19_OVER_24_VDD  (0x8FUL)                         ///< Selecting 19/24 VDD as the source of ACMP V- \hideinitializer
N#define ACMP_HYSTERESIS_ENABLE    (1UL << ACMP_CMPCR_HYSEN_Pos)    ///< Enable hysteresis function \hideinitializer
N#define ACMP_HYSTERESIS_DISABLE   (0UL)                            ///< Disable hysteresis function \hideinitializer
N#define ACMP_CH0_POSPIN_P15       (0UL)                            ///< Selecting P1.5 as ACMP Channel 0 positive input pin \hideinitializer
N#define ACMP_CH0_POSPIN_P10       (1UL << ACMP_CMPCR_CPPSEL_Pos)   ///< Selecting P1.0 as ACMP Channel 0 positive input pin \hideinitializer
N#define ACMP_CH0_POSPIN_P12       (2UL << ACMP_CMPCR_CPPSEL_Pos)   ///< Selecting P1.2 as ACMP Channel 0 positive input pin \hideinitializer
N#define ACMP_CH0_POSPIN_P13       (3UL << ACMP_CMPCR_CPPSEL_Pos)   ///< Selecting P1.3 as ACMP Channel 0 positive input pin \hideinitializer
N#define ACMP_CH1_POSPIN_P31       (0UL)                            ///< Selecting P3.1 as ACMP Channel 1 positive input pin \hideinitializer
N#define ACMP_CH1_POSPIN_P32       (1UL << ACMP_CMPCR_CPPSEL_Pos)   ///< Selecting P3.2 as ACMP Channel 1 positive input pin \hideinitializer
N#define ACMP_CH1_POSPIN_P34       (2UL << ACMP_CMPCR_CPPSEL_Pos)   ///< Selecting P3.4 as ACMP Channel 1 positive input pin \hideinitializer
N#define ACMP_CH1_POSPIN_P35       (3UL << ACMP_CMPCR_CPPSEL_Pos)   ///< Selecting P3.5 as ACMP Channel 1 positive input pin \hideinitializer
N
N
N/*@}*/ /* end of group MINI51_ACMP_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup MINI51_ACMP_EXPORTED_FUNCTIONS ACMP Exported Functions
N  @{
N*/
N
N/**
N  * @brief This macro is used to select ACMP negative input source
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] u32ChNum The ACMP number, ether 0 or 1
N  * @param[in] u32Src is comparator negative input selection.  Including :
N  *                  - \ref ACMP_VNEG_PIN
N  *                  - \ref ACMP_VNEG_BANDGAP
N  *                  - \ref ACMP_VNEG_4_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_5_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_6_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_7_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_8_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_9_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_10_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_11_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_12_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_13_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_14_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_15_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_16_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_17_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_18_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_19_OVER_24_VDD
N  *
N  * @return None
N  * @note The V- setting is shared by both comparators if input source is not coming from PIN
N  * \hideinitializer
N  */
N#define ACMP_SET_NEG_SRC(acmp, u32ChNum, u32Src) do{\
N                                                     if(u32Src == ACMP_VNEG_PIN)\
N                                                         ACMP->CMPCR[u32ChNum] &= ~ACMP_CMPCR_NEGSEL_Msk;\
N                                                     else {\
N                                                         ACMP->CMPCR[u32ChNum] |= ACMP_CMPCR_NEGSEL_Msk;\
N                                                         ACMP->CMPRVCR = u32Src;\
N                                                     }\
N                                                 }while(0)
X#define ACMP_SET_NEG_SRC(acmp, u32ChNum, u32Src) do{                                                     if(u32Src == ACMP_VNEG_PIN)                                                         ACMP->CMPCR[u32ChNum] &= ~ACMP_CMPCR_NEGSEL_Msk;                                                     else {                                                         ACMP->CMPCR[u32ChNum] |= ACMP_CMPCR_NEGSEL_Msk;                                                         ACMP->CMPRVCR = u32Src;                                                     }                                                 }while(0)
N
N/**
N  * @brief This macro is used to enable hysteresis function
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] u32ChNum The ACMP number, ether 0 or 1
N  * @return None
N  * \hideinitializer
N  */
N#define ACMP_ENABLE_HYSTERESIS(acmp, u32ChNum) (ACMP->CMPCR[u32ChNum] |= ACMP_CMPCR_HYSEN_Msk)
N
N/**
N  * @brief This macro is used to disable hysteresis function
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] u32ChNum The ACMP number, ether 0 or 1
N  * @return None
N  * \hideinitializer
N  */
N#define ACMP_DISABLE_HYSTERESIS(acmp, u32ChNum) (ACMP->CMPCR[u32ChNum] &= ~ACMP_CMPCR_HYSEN_Msk)
N
N/**
N  * @brief This macro is used to enable interrupt
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] u32ChNum The ACMP number, ether 0 or 1
N  * @return None
N  * \hideinitializer
N  */
N#define ACMP_ENABLE_INT(acmp, u32ChNum) (ACMP->CMPCR[u32ChNum] |= ACMP_CMPCR_ACMPIE_Msk)
N
N/**
N  * @brief This macro is used to disable interrupt
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] u32ChNum The ACMP number, ether 0 or 1
N  * @return None
N  * \hideinitializer
N  */
N#define ACMP_DISABLE_INT(acmp, u32ChNum) (ACMP->CMPCR[u32ChNum] &= ~ACMP_CMPCR_ACMPIE_Msk)
N
N
N/**
N  * @brief This macro is used to enable ACMP
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * \hideinitializer
N  */
N#define ACMP_ENABLE(acmp, u32ChNum) (ACMP->CMPCR[u32ChNum] |= ACMP_CMPCR_ACMPEN_Msk)
N
N/**
N  * @brief This macro is used to disable ACMP
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] u32ChNum The ACMP number, ether 0 or 1
N  * @return None
N  * \hideinitializer
N  */
N#define ACMP_DISABLE(acmp, u32ChNum) (ACMP->CMPCR[u32ChNum] &= ~ACMP_CMPCR_ACMPEN_Msk)
N
N/**
N  * @brief This macro is used to get ACMP output value
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] u32ChNum The ACMP number, ether 0 or 1
N  * @return  1 or 0
N  * \hideinitializer
N  */
N#define ACMP_GET_OUTPUT(acmp, u32ChNum) (ACMP->CMPSR & (ACMP_CMPSR_ACMPCO0_Msk<<(u32ChNum))?1:0)
N
N/**
N  * @brief This macro is used to get ACMP interrupt flag
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] u32ChNum The ACMP number, ether 0 or 1
N  * @return   ACMP interrupt occurred or not
N  * \hideinitializer
N  */
N#define ACMP_GET_INT_FLAG(acmp, u32ChNum) (ACMP->CMPSR & (ACMP_CMPSR_ACMPF0_Msk<<(u32ChNum))?1:0)
N
N/**
N  * @brief This macro is used to clear ACMP interrupt flag
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] u32ChNum The ACMP number, ether 0 or 1
N  * @return   None
N  * \hideinitializer
N  */
N#define ACMP_CLR_INT_FLAG(acmp, u32ChNum) (ACMP->CMPSR = (ACMP_CMPSR_ACMPF0_Msk<<(u32ChNum)))
N
N/**
N  * @brief This macro is used to select the V+ pin of ACMP
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] u32ChNum The ACMP number, ether 0 or 1
N  * @param[in] u32Pin The input pin. For channel 0, valid values are \ref ACMP_CH0_POSPIN_P15,
N  *            \ref ACMP_CH0_POSPIN_P10, \ref ACMP_CH0_POSPIN_P12, and \ref ACMP_CH0_POSPIN_P13. For
N  *            channel 1, valid values are , \ref ACMP_CH1_POSPIN_P31, \ref ACMP_CH1_POSPIN_P32,
N  *            \ref ACMP_CH1_POSPIN_P34, and \ref ACMP_CH1_POSPIN_P35.
N  * @return   None
N  * @note   Except this setting, multi-function pin also needs to be configured
N  * \hideinitializer
N  */
N#define ACMP_SELECT_P(acmp, u32ChNum, u32Pin)  (ACMP->CMPCR[u32ChNum] = (ACMP->CMPCR[u32ChNum] & ~ACMP_CMPCR_CPPSEL_Msk) | u32Pin)
N/**
N  * @brief This macro is used to set the level of CRV(Comparator Reference Voltage)
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] u32Level CRV level, possible values are
N  *                  - \ref ACMP_VNEG_4_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_5_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_6_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_7_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_8_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_9_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_10_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_11_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_12_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_13_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_14_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_15_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_16_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_17_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_18_OVER_24_VDD
N  *                  - \ref ACMP_VNEG_19_OVER_24_VDD
N  * @return   None
N  * \hideinitializer
N  */
N#define ACMP_CRV_SEL(acmp, u32Level) (ACMP->CMPRVCR = (ACMP->CMPRVCR & ~ACMP_CMPRVCR_CRVS_Msk) | (u32Level & ~ACMP_CMPRVCR_OUT_SEL_Msk))
N/**
N  * @brief This macro is used to enable CRV(Comparator Reference Voltage)
N  * @param[in] acmp The base address of ACMP module
N  * @return   None
N  * \hideinitializer
N  */
N#define ACMP_ENABLE_CRV(acmp) (ACMP->CMPRVCR |= ACMP_CMPRVCR_OUT_SEL_Msk)
N/**
N  * @brief This macro is used to disable CRV(Comparator Reference Voltage)
N  * @param[in] acmp The base address of ACMP module
N  * @return   None
N  * \hideinitializer
N  */
N#define ACMP_DISABLE_CRV(acmp) (ACMP->CMPRVCR &= ~ACMP_CMPRVCR_OUT_SEL_Msk)
N
N/**
N  * @brief This macro is used to enable ACMP falling edge trigger Timer/PWM
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] u32ChNum The ACMP number, ether 0 or 1
N  * @return   None
N  * \hideinitializer
N  */
N#define ACMP_ENABLE_FALLING_EDGE_TRIGGER(acmp, u32ChNum) (ACMP->CMPCR[u32ChNum] |= ACMP_CMPCR_FALLING_Msk)
N
N/**
N  * @brief This macro is used to disable ACMP falling edge trigger Timer/PWM
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] u32ChNum The ACMP number, ether 0 or 1
N  * @return   None
N  * \hideinitializer
N  */
N#define ACMP_DISABLE_FALLING_EDGE_TRIGGER(acmp, u32ChNum) (ACMP->CMPCR[u32ChNum] &= ~ACMP_CMPCR_FALLING_Msk)
N
N/**
N  * @brief This macro is used to enable ACMP rising edge trigger Timer/PWM
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] u32ChNum The ACMP number, ether 0 or 1
N  * @return   None
N  * \hideinitializer
N  */
N#define ACMP_ENABLE_RISING_EDGE_TRIGGER(acmp, u32ChNum) (ACMP->CMPCR[u32ChNum] |= ACMP_CMPCR_RISING_Msk)
N
N/**
N  * @brief This macro is used to disable ACMP rising edge trigger Timer/PWM
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] u32ChNum The ACMP number, ether 0 or 1
N  * \hideinitializer
N  */
N#define ACMP_DISABLE_RISING_EDGE_TRIGGER(acmp, u32ChNum) (ACMP->CMPCR[u32ChNum] &= ~ACMP_CMPCR_RISING_Msk)
N
Nvoid ACMP_Open(ACMP_T *acmp, uint32_t u32ChNum, uint32_t u32NegSrc, uint32_t u32HysteresisEn);
Nvoid ACMP_Close(ACMP_T *acmp, uint32_t u32ChNum);
N
N/*@}*/ /* end of group MINI51_ACMP_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group MINI51_ACMP_Driver */
N
N/*@}*/ /* end of group MINI51_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__ACMP_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 5951 "C:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.1.0\Device\Mini51\Include\Mini51Series.h" 2
N#include "adc.h"
L 1 "C:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.1.0\Device\Mini51\Driver\adc.h" 1
N/**************************************************************************//**
N * @file     adc.h
N * @version  V1.00
N * $Revision: 9 $
N * $Date: 14/01/14 5:29p $ 
N * @brief    Mini51 series ADC driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/ 
N#ifndef __ADC_H__
N#define __ADC_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup MINI51_Device_Driver MINI51 Device Driver
N  @{
N*/
N
N/** @addtogroup MINI51_ADC_Driver ADC Driver
N  @{
N*/
N
N/** @addtogroup MINI51_ADC_EXPORTED_CONSTANTS ADC Exported Constants
N  @{
N*/
N
N#define ADC_CH7_EXT                     (0UL)                       /*!< Use external input pin as ADC channel 7 source */
N#define ADC_CH7_BGP                     (ADC_ADCHER_PRESEL_Msk)     /*!< Use internal band-gap voltage (VBG) as channel 7 source. */
N#define ADC_CMP_LESS_THAN               (0UL)                       /*!< ADC compare condition less than */
N#define ADC_CMP_GREATER_OR_EQUAL_TO     (ADC_ADCMPR_CMPCOND_Msk)    /*!< ADC compare condition greater or equal to */
N#define ADC_TRIGGER_BY_EXT_PIN          (0UL)                       /*!< ADC trigger by STADC (P3.2) pin */
N#define ADC_TRIGGER_BY_PWM              (ADC_ADCR_TRGS_Msk)         /*!< ADC trigger by PWM events */
N#define ADC_FALLING_EDGE_TRIGGER        (0UL)                       /*!< External pin falling edge trigger ADC */
N#define ADC_RISING_EDGE_TRIGGER         (ADC_ADCR_TRGCOND_Msk)      /*!< External pin rising edge trigger ADC */
N#define ADC_ADF_INT                     (ADC_ADSR_ADF_Msk)          /*!< ADC convert complete interrupt */
N#define ADC_CMP0_INT                    (ADC_ADSR_CMPF0_Msk)        /*!< ADC comparator 0 interrupt */
N#define ADC_CMP1_INT                    (ADC_ADSR_CMPF1_Msk)        /*!< ADC comparator 0 interrupt */
N#define ADC_SAMPLE_CLOCK_0              (0UL)                       /*!< ADC sample time is 0 ADC clock */
N#define ADC_SAMPLE_CLOCK_1              (1UL)                       /*!< ADC sample time is 1 ADC clock */
N#define ADC_SAMPLE_CLOCK_2              (2UL)                       /*!< ADC sample time is 2 ADC clock */
N#define ADC_SAMPLE_CLOCK_4              (3UL)                       /*!< ADC sample time is 4 ADC clock */
N#define ADC_SAMPLE_CLOCK_8              (4UL)                       /*!< ADC sample time is 8 ADC clock */
N#define ADC_SAMPLE_CLOCK_16             (5UL)                       /*!< ADC sample time is 16 ADC clock */
N#define ADC_SAMPLE_CLOCK_32             (6UL)                       /*!< ADC sample time is 32 ADC clock */
N#define ADC_SAMPLE_CLOCK_64             (7UL)                       /*!< ADC sample time is 64 ADC clock */
N#define ADC_SAMPLE_CLOCK_128            (8UL)                       /*!< ADC sample time is 128 ADC clock */
N#define ADC_SAMPLE_CLOCK_256            (9UL)                       /*!< ADC sample time is 256 ADC clock */
N#define ADC_SAMPLE_CLOCK_512            (10UL)                      /*!< ADC sample time is 512 ADC clock */
N#define ADC_SAMPLE_CLOCK_1024           (11UL)                      /*!< ADC sample time is 1024 ADC clock */
N
N/*@}*/ /* end of group MINI51_ADC_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup MINI51_ADC_EXPORTED_FUNCTIONS ADC Exported Functions
N  @{
N*/
N
N
N/**
N  * @brief Configure the analog input source of channel 7
N  * @param[in] adc Base address of ADC module
N  * @param[in] u32Source Decides the analog input source of channel 7, valid values are
N  *                     - \ref ADC_CH7_EXT
N  *                     - \ref ADC_CH7_BGP
N  * @return None
N  * @note While using VBG as channel 7 source, ADC module clock must /b not exceed 300kHz 
N  * \hideinitializer
N  */
N#define ADC_CONFIG_CH7(adc, u32Source) (ADC->ADCHER = (ADC->ADCHER & ~ADC_ADCHER_PRESEL_Msk) | (u32Source))
N
N/**
N  * @brief Get the latest ADC conversion data
N  * @param[in] adc Base address of ADC module
N  * @param[in] u32ChNum Currently not used
N  * @return  Latest ADC conversion data
N  * \hideinitializer
N  */
N#define ADC_GET_CONVERSION_DATA(adc, u32ChNum) (ADC->ADDR & ADC_ADDR_RSLT_Msk)
N
N/**
N  * @brief Return the user-specified interrupt flags
N  * @param[in] adc Base address of ADC module
N  * @param[in] u32Mask The combination of following interrupt status bits. Each bit corresponds to a interrupt status.
N  *                     - \ref ADC_ADF_INT
N  *                     - \ref ADC_CMP0_INT
N  *                     - \ref ADC_CMP1_INT
N  * @return  User specified interrupt flags
N  * \hideinitializer
N  */
N#define ADC_GET_INT_FLAG(adc, u32Mask) (ADC->ADSR & (u32Mask))
N
N/**
N  * @brief This macro clear the selected interrupt status bits
N  * @param[in] adc Base address of ADC module
N  * @param[in] u32Mask The combination of following interrupt status bits. Each bit corresponds to a interrupt status.
N  *                     - \ref ADC_ADF_INT
N  *                     - \ref ADC_CMP0_INT
N  *                     - \ref ADC_CMP1_INT
N  * @return  None
N  * \hideinitializer
N  */
N#define ADC_CLR_INT_FLAG(adc, u32Mask) (ADC->ADSR = (ADC->ADSR & ~(ADC_ADSR_ADF_Msk | \
N                                                                       ADC_ADSR_CMPF0_Msk | \
N                                                                       ADC_ADSR_CMPF1_Msk)) | (u32Mask))
X#define ADC_CLR_INT_FLAG(adc, u32Mask) (ADC->ADSR = (ADC->ADSR & ~(ADC_ADSR_ADF_Msk |                                                                        ADC_ADSR_CMPF0_Msk |                                                                        ADC_ADSR_CMPF1_Msk)) | (u32Mask))
N
N/**
N  * @brief Get the busy state of ADC
N  * @param[in] adc Base address of ADC module
N  * @return busy state of ADC
N  * @retval 0 ADC is not busy
N  * @retval 1 ADC is busy
N  * \hideinitializer
N  */
N#define ADC_IS_BUSY(adc) (ADC->ADSR & ADC_ADSR_BUSY_Msk ? 1 : 0)
N     
N/**
N  * @brief Check if the ADC conversion data is over written or not
N  * @param[in] adc Base address of ADC module
N  * @param[in] u32ChNum Currently not used
N  * @return Over run state of ADC data
N  * @retval 0 ADC data is not overrun
N  * @retval 1 ADC data us overrun
N  * \hideinitializer
N  */     
N#define ADC_IS_DATA_OVERRUN(adc, u32ChNum) (ADC->ADSR & ADC_ADSR_OVERRUN_Msk ? 1 : 0)
N
N/**
N  * @brief Check if the ADC conversion data is valid or not
N  * @param[in] adc Base address of ADC module
N  * @param[in] u32ChNum Currently not used
N  * @return Valid state of ADC data
N  * @retval 0 ADC data is not valid
N  * @retval 1 ADC data us valid
N  * \hideinitializer
N  */  
N#define ADC_IS_DATA_VALID(adc, u32ChNum) (ADC->ADSR & ADC_ADSR_VALID_Msk ? 1 : 0)
N
N/**
N  * @brief Power down ADC module
N  * @param[in] adc Base address of ADC module
N  * @return None
N  * \hideinitializer
N  */
N#define ADC_POWER_DOWN(adc) (ADC->ADCR &= ~ADC_ADCR_ADEN_Msk)
N
N/**
N  * @brief Power on ADC module
N  * @param[in] adc Base address of ADC module
N  * @return None
N  * \hideinitializer
N  */
N#define ADC_POWER_ON(adc) (ADC->ADCR |= ADC_ADCR_ADEN_Msk)                                                        
N
N/**
N  * @brief Configure the comparator 0 and enable it
N  * @param[in] adc Base address of ADC module
N  * @param[in] u32ChNum  Specifies the source channel, valid value are from 0 to 7
N  * @param[in] u32Condition Specifies the compare condition
N  *                     - \ref ADC_CMP_LESS_THAN
N  *                     - \ref ADC_CMP_GREATER_OR_EQUAL_TO
N  * @param[in] u32Data Specifies the compare value. Valid value are between 0 ~ 0x3FF
N  * @param[in] u32MatchCount Specifies the match count setting, valid values are between 1~16
N  * @return None
N  * @details For example, ADC_ENABLE_CMP0(ADC, 5, ADC_CMP_GREATER_OR_EQUAL_TO, 0x800, 10);
N  *          Means ADC will assert comparator 0 flag if channel 5 conversion result is 
N  *          greater or equal to 0x800 for 10 times continuously.
N  * \hideinitializer
N  */ 
N#define ADC_ENABLE_CMP0(adc, \
N                        u32ChNum, \
N                        u32Condition, \
N                        u32Data, \
N                        u32MatchCount) (ADC->ADCMPR[0] = ((u32ChNum) << ADC_ADCMPR_CMPCH_Pos) | \
N                                                                   (u32Condition) | \
N                                                                   ((u32Data) << ADC_ADCMPR_CMPD_Pos) | \
N                                                                   (((u32MatchCount) - 1) << ADC_ADCMPR_CMPMATCNT_Pos) |\
N                                                                   ADC_ADCMPR_CMPEN_Msk)
X#define ADC_ENABLE_CMP0(adc,                         u32ChNum,                         u32Condition,                         u32Data,                         u32MatchCount) (ADC->ADCMPR[0] = ((u32ChNum) << ADC_ADCMPR_CMPCH_Pos) |                                                                    (u32Condition) |                                                                    ((u32Data) << ADC_ADCMPR_CMPD_Pos) |                                                                    (((u32MatchCount) - 1) << ADC_ADCMPR_CMPMATCNT_Pos) |                                                                   ADC_ADCMPR_CMPEN_Msk)
N                                                                   
N/**
N  * @brief Disable comparator 0
N  * @param[in] adc Base address of ADC module
N  * \hideinitializer
N  */  
N#define ADC_DISABLE_CMP0(adc) (ADC->ADCMPR[0] = 0)              
N
N/**
N  * @brief Configure the comparator 1 and enable it
N  * @param[in] adc Base address of ADC module
N  * @param[in] u32ChNum  Specifies the source channel, valid value are from 0 to 7
N  * @param[in] u32Condition Specifies the compare condition
N  *                     - \ref ADC_CMP_LESS_THAN
N  *                     - \ref ADC_CMP_GREATER_OR_EQUAL_TO
N  * @param[in] u32Data Specifies the compare value. Valid value are between 0 ~ 0x3FF
N  * @param[in] u32MatchCount Specifies the match count setting, valid values are between 1~16
N  * @return None
N  * @details For example, ADC_ENABLE_CMP1(ADC, 5, ADC_CMP_GREATER_OR_EQUAL_TO, 0x800, 10);
N  *          Means ADC will assert comparator 1 flag if channel 5 conversion result is 
N  *          greater or equal to 0x800 for 10 times continuously.
N  * \hideinitializer
N  */                     
N#define ADC_ENABLE_CMP1(adc, \
N                        u32ChNum, \
N                        u32Condition, \
N                        u32Data, \
N                        u32MatchCount) (ADC->ADCMPR[1] = ((u32ChNum) << ADC_ADCMPR_CMPCH_Pos) | \
N                                                                   (u32Condition) | \
N                                                                   ((u32Data) << ADC_ADCMPR_CMPD_Pos) | \
N                                                                   ((u32MatchCount - 1) << ADC_ADCMPR_CMPMATCNT_Pos) |\
N                                                                   ADC_ADCMPR_CMPEN_Msk)  
X#define ADC_ENABLE_CMP1(adc,                         u32ChNum,                         u32Condition,                         u32Data,                         u32MatchCount) (ADC->ADCMPR[1] = ((u32ChNum) << ADC_ADCMPR_CMPCH_Pos) |                                                                    (u32Condition) |                                                                    ((u32Data) << ADC_ADCMPR_CMPD_Pos) |                                                                    ((u32MatchCount - 1) << ADC_ADCMPR_CMPMATCNT_Pos) |                                                                   ADC_ADCMPR_CMPEN_Msk)  
N
N/**
N  * @brief Disable comparator 1
N  * @param[in] adc Base address of ADC module
N  * \hideinitializer
N  */                          
N#define ADC_DISABLE_CMP1(adc) (ADC->ADCMPR[1] = 0)
N
N/**
N  * @brief Set ADC input channel. Enabled channel will be converted while ADC starts.
N  * @param[in] adc Base address of ADC module
N  * @param[in] u32Mask  Channel enable bit. Each bit corresponds to a input channel. Bit 0 is channel 0, bit 1 is channel 1...
N  * @return None
N  * @note Mini51 series MCU ADC can only convert 1 channel at a time. If more than 1 channels are enabled, only channel
N  *       with smallest number will be convert.
N  * \hideinitializer
N  */   
N#define ADC_SET_INPUT_CHANNEL(adc, u32Mask) (ADC->ADCHER = (ADC->ADCHER & ~ADC_ADCHER_CHEN_Msk) | (u32Mask))
N
N/**
N  * @brief Start the A/D conversion.
N  * @param[in] adc Base address of ADC module
N  * @return None
N  * \hideinitializer
N  */
N#define ADC_START_CONV(adc) (ADC->ADCR |= ADC_ADCR_ADST_Msk)
N
N/**
N  * @brief Stop the A/D conversion.
N  * @param[in] adc Base address of ADC module
N  * @return None
N  * \hideinitializer
N  */
N#define ADC_STOP_CONV(adc) (ADC->ADCR &= ~ADC_ADCR_ADST_Msk)
N
Nvoid ADC_Open(ADC_T *adc,
N               uint32_t u32InputMode, 
N               uint32_t u32OpMode,  
N               uint32_t u32ChMask);
Nvoid ADC_Close(ADC_T *adc);
Nvoid ADC_EnableHWTrigger(ADC_T *adc,
N                         uint32_t u32Source,
N                         uint32_t u32Param);
Nvoid ADC_DisableHWTrigger(ADC_T *adc);
Nvoid ADC_SetExtraSampleTime(ADC_T *adc,
N                            uint32_t u32ChNum,
N                            uint32_t u32SampleTime);
Nvoid ADC_EnableInt(ADC_T *adc, uint32_t u32Mask);
Nvoid ADC_DisableInt(ADC_T *adc, uint32_t u32Mask);
N                   
N                   
N                   
N/*@}*/ /* end of group MINI51_ADC_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group MINI51_ADC_Driver */
N
N/*@}*/ /* end of group MINI51_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__ADC_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 5952 "C:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.1.0\Device\Mini51\Include\Mini51Series.h" 2
N#include "fmc.h"
L 1 "C:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.1.0\Device\Mini51\Driver\fmc.h" 1
N/**************************************************************************//**
N * @file     FMC.h
N * @version  V1.00
N * $Revision: 11 $
N * $Date: 15/09/16 11:12a $
N * @brief    MINI51 series FMC driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N ******************************************************************************/
N#ifndef __FMC_H__
N#define __FMC_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N    
N/** @addtogroup MINI51_Device_Driver MINI51 Device Driver
N  @{
N*/
N
N/** @addtogroup MINI51_FMC_Driver FMC Driver
N  @{
N*/
N
N/** @addtogroup MINI51_FMC_EXPORTED_CONSTANTS FMC Exported Constants
N  @{
N*/
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define Base Address                                                                                     */
N/*---------------------------------------------------------------------------------------------------------*/
N#define FMC_APROM_BASE          0x00000000UL    /*!< APROM  Base Address         */  
N#define FMC_LDROM_BASE          0x00100000UL    /*!< LDROM  Base Address         */
N#define FMC_LDROM_END           0x00100800UL    /*!< LDROM  End Address          */
N#define FMC_CONFIG_BASE         0x00300000UL    /*!< CONFIG Base Address         */
N
N#define FMC_FLASH_PAGE_SIZE     0x200           /*!< Flash Page Size (512 Bytes) */
N#define FMC_LDROM_SIZE          0x800           /*!< LDROM Size (2 Kbytes)       */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  ISPCMD constant definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define FMC_ISPCMD_READ         0x00            /*!< ISP Command: Read Flash        */
N#define FMC_ISPCMD_PROGRAM      0x21            /*!< ISP Command: Program Flash     */
N#define FMC_ISPCMD_PAGE_ERASE   0x22            /*!< ISP Command: Page Erase Flash  */
N#define FMC_ISPCMD_READ_CID     0x0B            /*!< ISP Command: Read Company ID   */
N#define FMC_ISPCMD_READ_PID     0x0C            /*!< ISP Command: Read Product ID   */
N#define FMC_ISPCMD_READ_UID     0x04            /*!< ISP Command: Read Unique ID    */
N#define FMC_ISPCMD_VECMAP       0x2E            /*!< ISP Command: Vector Page Remap */
N
N
N/*@}*/ /* end of group MINI51_FMC_EXPORTED_CONSTANTS */
N
N/** @addtogroup MINI51_FMC_EXPORTED_FUNCTIONS FMC Exported Functions
N  @{
N*/
N
N#define FMC_SET_APROM_BOOT()        (FMC->ISPCON &= ~FMC_ISPCON_BS_Msk)         /*!< Select booting from APROM  */
N#define FMC_SET_LDROM_BOOT()        (FMC->ISPCON |= FMC_ISPCON_BS_Msk)          /*!< Select booting from LDROM  */
N#define FMC_DISABLE_AP_UPDATE()     (FMC->ISPCON &= ~FMC_ISPCON_APUEN_Msk)      /*!< Disable APROM update  */
N#define FMC_DISABLE_CFG_UPDATE()    (FMC->ISPCON &= ~FMC_ISPCON_CFGUEN_Msk)     /*!< Disable User Config update  */
N#define FMC_DISABLE_LD_UPDATE()     (FMC->ISPCON &= ~FMC_ISPCON_LDUEN_Msk)      /*!< Disable LDROM update  */
N#define FMC_DISABLE_ISP()           (FMC->ISPCON &= ~FMC_ISPCON_ISPEN_Msk)      /*!< Disable ISP function  */
N#define FMC_ENABLE_AP_UPDATE()      (FMC->ISPCON |=  FMC_ISPCON_APUEN_Msk)      /*!< Enable APROM update  */
N#define FMC_ENABLE_LD_UPDATE()      (FMC->ISPCON |=  FMC_ISPCON_LDUEN_Msk)      /*!< Enable LDROM update  */
N#define FMC_ENABLE_CFG_UPDATE()     (FMC->ISPCON |=  FMC_ISPCON_CFGUEN_Msk)     /*!< Enable User Config update  */
N#define FMC_ENABLE_ISP()            (FMC->ISPCON |=  FMC_ISPCON_ISPEN_Msk)      /*!< Enable ISP function  */
N#define FMC_GET_FAIL_FLAG()         ((FMC->ISPCON & FMC_ISPCON_ISPFF_Msk) ? 1 : 0)  /*!< Get ISP fail flag      */
N#define FMC_CLR_FAIL_FLAG()         (FMC->ISPCON |= FMC_ISPCON_ISPFF_Msk)       /*!< Clear ISP fail flag        */
N
N
Nextern void FMC_Close(void);
Nextern int32_t FMC_Erase(uint32_t u32PageAddr);
Nextern int32_t FMC_GetBootSource(void);
Nextern void FMC_Open(void);
Nextern uint32_t FMC_Read (uint32_t u32Addr);
Nextern uint32_t FMC_ReadCID(void);
Nextern uint32_t FMC_ReadPID(void);
Nextern uint32_t FMC_ReadUCID(uint32_t u32Index);
Nextern uint32_t FMC_ReadUID(uint32_t u32Index);
Nextern uint32_t FMC_ReadDataFlashBaseAddr(void);
Nextern void FMC_SetVectorPageAddr(uint32_t u32PageAddr);
Nextern uint32_t FMC_GetVectorPageAddr(void);
Nextern void FMC_Write(uint32_t u32Addr, uint32_t u32Data);
Nextern int32_t FMC_ReadConfig(uint32_t *u32Config, uint32_t u32Count);
Nextern int32_t FMC_WriteConfig(uint32_t *u32Config, uint32_t u32Count);
N
N
N/*@}*/ /* end of group MINI51_FMC_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group MINI51_FMC_Driver */
N
N/*@}*/ /* end of group MINI51_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif
N
L 5953 "C:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.1.0\Device\Mini51\Include\Mini51Series.h" 2
N#include "gpio.h"
L 1 "C:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.1.0\Device\Mini51\Driver\gpio.h" 1
N/**************************************************************************//**
N * @file     gpio.h
N * @version  V1.00
N * $Revision: 9 $
N * $Date: 15/10/06 10:44a $ 
N * @brief    Mini51 series GPIO driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/ 
N#ifndef __GPIO_H__
N#define __GPIO_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup MINI51_Device_Driver MINI51 Device Driver
N  @{
N*/
N
N/** @addtogroup MINI51_GPIO_Driver GPIO Driver
N  @{
N*/
N
N/** @addtogroup MINI51_GPIO_EXPORTED_CONSTANTS GPIO Exported Constants
N  @{
N*/
N#define GPIO_PIN_MAX    8   /*!< Specify Maximum Pins of Each GPIO Port */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  PMD Constant Definitions                                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_PMD_INPUT              0x0UL                  /*!< Input Mode */
N#define GPIO_PMD_OUTPUT             0x1UL                  /*!< Output Mode */
N#define GPIO_PMD_OPEN_DRAIN         0x2UL                  /*!< Open-Drain Mode */
N#define GPIO_PMD_QUASI              0x3UL                  /*!< Quasi-bidirectional Mode */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  GPIO Interrupt Type Constant Definitions                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_INT_RISING             0x00010000UL /*!< Interrupt enable by Input Rising Edge */
N#define GPIO_INT_FALLING            0x00000001UL /*!< Interrupt enable by Input Falling Edge */
N#define GPIO_INT_BOTH_EDGE          0x00010001UL /*!< Interrupt enable by both Rising Edge and Falling Edge */
N#define GPIO_INT_HIGH               0x01010000UL /*!< Interrupt enable by Level-High */    
N#define GPIO_INT_LOW                0x01000001UL /*!< Interrupt enable by Level-Level */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  IMD Constant Definitions                                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_IMD_EDGE               0UL               /*!< IMD Setting for Edge Trigger Mode */
N#define GPIO_IMD_LEVEL              1UL               /*!< IMD Setting for Edge Level Mode */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  DBNCECON Constant Definitions                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_DBNCECON_ICLK_ON           0x00000020UL /*!< DBNCECON setting for all IO pins edge detection circuit is always active after reset */ 
N#define GPIO_DBNCECON_ICLK_OFF          0x00000000UL /*!< DBNCECON setting for edge detection circuit is active only if IO pin corresponding GPIOx_IEN bit is set to 1 */ 
N
N#define GPIO_DBNCECON_DBCLKSRC_IRC10K   0x00000010UL /*!< DBNCECON setting for de-bounce counter clock source is the internal 10 kHz */ 
N#define GPIO_DBNCECON_DBCLKSRC_HCLK     0x00000000UL /*!< DBNCECON setting for de-bounce counter clock source is the internal HCLK */ 
N
N#define GPIO_DBNCECON_DBCLKSEL_1        0x00000000UL /*!< DBNCECON setting for sampling cycle = 1 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_2        0x00000001UL /*!< DBNCECON setting for sampling cycle = 2 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_4        0x00000002UL /*!< DBNCECON setting for sampling cycle = 4 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_8        0x00000003UL /*!< DBNCECON setting for sampling cycle = 8 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_16       0x00000004UL /*!< DBNCECON setting for sampling cycle = 16 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_32       0x00000005UL /*!< DBNCECON setting for sampling cycle = 32 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_64       0x00000006UL /*!< DBNCECON setting for sampling cycle = 64 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_128      0x00000007UL /*!< DBNCECON setting for sampling cycle = 128 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_256      0x00000008UL /*!< DBNCECON setting for sampling cycle = 256 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_512      0x00000009UL /*!< DBNCECON setting for sampling cycle = 512 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_1024     0x0000000AUL /*!< DBNCECON setting for sampling cycle = 1024 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_2048     0x0000000BUL /*!< DBNCECON setting for sampling cycle = 2048 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_4096     0x0000000CUL /*!< DBNCECON setting for sampling cycle = 4096 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_8192     0x0000000DUL /*!< DBNCECON setting for sampling cycle = 8192 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_16384    0x0000000EUL /*!< DBNCECON setting for sampling cycle = 16384 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_32768    0x0000000FUL /*!< DBNCECON setting for sampling cycle = 32768 clocks */
N
N/** Define GPIO Pin Data Input/Output. It could be used to control each I/O pin by pin address mapping.
N *  Example 1:
N *  
N *      P00 = 1; 
N *  
N *  It is used to set P0.0 to high;
N *  
N *  Example 2:
N *  
N *      if (P00)
N *          P00 = 0;
N *  
N *  If P0.0 pin status is high, then set P0.0 data output to low.
N */
N#define GPIO_PIN_ADDR(port, pin)    (*((volatile uint32_t *)((GPIOBIT0_BASE+(0x20*(port))) + ((pin)<<2)))) 
N#define P00             GPIO_PIN_ADDR(0, 0) /*!< Specify P00 Pin Data Input/Output */
N#define P01             GPIO_PIN_ADDR(0, 1) /*!< Specify P01 Pin Data Input/Output */
N#define P02             GPIO_PIN_ADDR(0, 2) /*!< Specify P02 Pin Data Input/Output */
N#define P03             GPIO_PIN_ADDR(0, 3) /*!< Specify P03 Pin Data Input/Output */
N#define P04             GPIO_PIN_ADDR(0, 4) /*!< Specify P04 Pin Data Input/Output */
N#define P05             GPIO_PIN_ADDR(0, 5) /*!< Specify P05 Pin Data Input/Output */
N#define P06             GPIO_PIN_ADDR(0, 6) /*!< Specify P06 Pin Data Input/Output */
N#define P07             GPIO_PIN_ADDR(0, 7) /*!< Specify P07 Pin Data Input/Output */
N#define P10             GPIO_PIN_ADDR(1, 0) /*!< Specify P10 Pin Data Input/Output */
N#define P11             GPIO_PIN_ADDR(1, 1) /*!< Specify P11 Pin Data Input/Output */
N#define P12             GPIO_PIN_ADDR(1, 2) /*!< Specify P12 Pin Data Input/Output */
N#define P13             GPIO_PIN_ADDR(1, 3) /*!< Specify P13 Pin Data Input/Output */
N#define P14             GPIO_PIN_ADDR(1, 4) /*!< Specify P14 Pin Data Input/Output */
N#define P15             GPIO_PIN_ADDR(1, 5) /*!< Specify P15 Pin Data Input/Output */
N#define P16             GPIO_PIN_ADDR(1, 6) /*!< Specify P16 Pin Data Input/Output */
N#define P17             GPIO_PIN_ADDR(1, 7) /*!< Specify P17 Pin Data Input/Output */
N#define P20             GPIO_PIN_ADDR(2, 0) /*!< Specify P20 Pin Data Input/Output */
N#define P21             GPIO_PIN_ADDR(2, 1) /*!< Specify P21 Pin Data Input/Output */
N#define P22             GPIO_PIN_ADDR(2, 2) /*!< Specify P22 Pin Data Input/Output */
N#define P23             GPIO_PIN_ADDR(2, 3) /*!< Specify P23 Pin Data Input/Output */
N#define P24             GPIO_PIN_ADDR(2, 4) /*!< Specify P24 Pin Data Input/Output */
N#define P25             GPIO_PIN_ADDR(2, 5) /*!< Specify P25 Pin Data Input/Output */
N#define P26             GPIO_PIN_ADDR(2, 6) /*!< Specify P26 Pin Data Input/Output */
N#define P27             GPIO_PIN_ADDR(2, 7) /*!< Specify P27 Pin Data Input/Output */
N#define P30             GPIO_PIN_ADDR(3, 0) /*!< Specify P30 Pin Data Input/Output */
N#define P31             GPIO_PIN_ADDR(3, 1) /*!< Specify P31 Pin Data Input/Output */
N#define P32             GPIO_PIN_ADDR(3, 2) /*!< Specify P32 Pin Data Input/Output */
N#define P33             GPIO_PIN_ADDR(3, 3) /*!< Specify P33 Pin Data Input/Output */
N#define P34             GPIO_PIN_ADDR(3, 4) /*!< Specify P34 Pin Data Input/Output */
N#define P35             GPIO_PIN_ADDR(3, 5) /*!< Specify P35 Pin Data Input/Output */
N#define P36             GPIO_PIN_ADDR(3, 6) /*!< Specify P36 Pin Data Input/Output */
N#define P37             GPIO_PIN_ADDR(3, 7) /*!< Specify P37 Pin Data Input/Output */
N#define P40             GPIO_PIN_ADDR(4, 0) /*!< Specify P40 Pin Data Input/Output */
N#define P41             GPIO_PIN_ADDR(4, 1) /*!< Specify P41 Pin Data Input/Output */
N#define P42             GPIO_PIN_ADDR(4, 2) /*!< Specify P42 Pin Data Input/Output */
N#define P43             GPIO_PIN_ADDR(4, 3) /*!< Specify P43 Pin Data Input/Output */
N#define P44             GPIO_PIN_ADDR(4, 4) /*!< Specify P44 Pin Data Input/Output */
N#define P45             GPIO_PIN_ADDR(4, 5) /*!< Specify P45 Pin Data Input/Output */
N#define P46             GPIO_PIN_ADDR(4, 6) /*!< Specify P46 Pin Data Input/Output */
N#define P47             GPIO_PIN_ADDR(4, 7) /*!< Specify P47 Pin Data Input/Output */
N#define P50             GPIO_PIN_ADDR(5, 0) /*!< Specify P50 Pin Data Input/Output */
N#define P51             GPIO_PIN_ADDR(5, 1) /*!< Specify P51 Pin Data Input/Output */
N#define P52             GPIO_PIN_ADDR(5, 2) /*!< Specify P52 Pin Data Input/Output */
N#define P53             GPIO_PIN_ADDR(5, 3) /*!< Specify P53 Pin Data Input/Output */
N#define P54             GPIO_PIN_ADDR(5, 4) /*!< Specify P54 Pin Data Input/Output */
N#define P55             GPIO_PIN_ADDR(5, 5) /*!< Specify P55 Pin Data Input/Output */
N
N/*@}*/ /* end of group MINI51_GPIO_EXPORTED_CONSTANTS */
N
N/** @addtogroup MINI51_GPIO_EXPORTED_FUNCTIONS GPIO Exported Functions
N  @{
N*/
N
N/**
N * @brief       Clear GPIO Pin Interrupt Flag
N *
N * @param[in]   gpio        GPIO port. It could be \ref P0, \ref P1, \ref P2, \ref P3, \ref P4 or \ref P5.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port. \ref BIT0, \ref BIT1, \ref BIT2,.. \ref BIT7
N *
N * @return      None
N *
N * @details     Clear the interrupt status of specified GPIO pin.
N */
N#define GPIO_CLR_INT_FLAG(gpio, u32PinMask)   ((gpio)->ISRC = u32PinMask)
N
N/**
N * @brief       Disable Pin De-bounce Function
N *
N * @param[in]   gpio        GPIO port. It could be \ref P0, \ref P1, \ref P2, \ref P3, \ref P4 or \ref P5.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port. \ref BIT0, \ref BIT1, \ref BIT2,.. \ref BIT7
N *
N * @return      None
N *
N * @details     Disable the interrupt de-bounce function of specified GPIO pin.
N */
N#define GPIO_DISABLE_DEBOUNCE(gpio, u32PinMask)   ((gpio)->DBEN &= ~u32PinMask)
N
N/**
N * @brief       Enable Pin De-bounce Function
N *
N * @param[in]   gpio        GPIO port. It could be \ref P0, \ref P1, \ref P2, \ref P3, \ref P4 or \ref P5.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port. \ref BIT0, \ref BIT1, \ref BIT2,.. \ref BIT7
N *
N * @return      None
N *
N * @details     Enable the interrupt de-bounce function of specified GPIO pin.
N */
N#define GPIO_ENABLE_DEBOUNCE(gpio, u32PinMask)    ((gpio)->DBEN |= u32PinMask)
N
N/**
N * @brief       Disable I/O Digital Input Path
N *
N * @param[in]   gpio        GPIO port. It could be \ref P0, \ref P1, \ref P2, \ref P3, \ref P4 or \ref P5.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port. \ref BIT0, \ref BIT1, \ref BIT2,.. \ref BIT7
N *
N * @return      None
N *
N * @details     Disable I/O digital input path of specified GPIO pin.
N */
N#define GPIO_DISABLE_DIGITAL_PATH(gpio, u32PinMask)   ((gpio)->OFFD |= (u32PinMask << 16))
N
N/**
N * @brief       Enable I/O Digital Input Path
N *
N * @param[in]   gpio        GPIO port. It could be \ref P0, \ref P1, \ref P2, \ref P3, \ref P4 or \ref P5.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port. \ref BIT0, \ref BIT1, \ref BIT2,.. \ref BIT7
N *
N * @return      None
N *
N * @details     Enable I/O digital input path of specified GPIO pin.
N */
N#define GPIO_ENABLE_DIGITAL_PATH(gpio, u32PinMask)    ((gpio)->OFFD &= ~(u32PinMask << 16))
N
N/**
N * @brief       Disable I/O DOUT mask
N *
N * @param[in]   gpio        GPIO port. It could be \ref P0, \ref P1, \ref P2, \ref P3, \ref P4 or \ref P5.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port. \ref BIT0, \ref BIT1, \ref BIT2,.. \ref BIT7
N *
N * @return      None
N *
N * @details     Disable I/O DOUT mask of specified GPIO pin.
N */
N#define GPIO_DISABLE_DOUT_MASK(gpio, u32PinMask)   ((gpio)->DMASK |= u32PinMask)
N
N/**
N * @brief       Enable I/O DOUT mask
N *
N * @param[in]   gpio        GPIO port. It could be \ref P0, \ref P1, \ref P2, \ref P3, \ref P4 or \ref P5.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port. \ref BIT0, \ref BIT1, \ref BIT2,.. \ref BIT7
N *
N * @return      None
N *
N * @details     Enable I/O DOUT mask of specified GPIO pin.
N */
N#define GPIO_ENABLE_DOUT_MASK(gpio, u32PinMask)   ((gpio)->DMASK &= ~u32PinMask)
N
N/**
N * @brief       Get GPIO Pin Interrupt Flag
N *
N * @param[in]   gpio        GPIO port. It could be \ref P0, \ref P1, \ref P2, \ref P3, \ref P4 or \ref P5.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port. \ref BIT0, \ref BIT1, \ref BIT2,.. \ref BIT7
N *
N * @retval      0           No interrupt at specified GPIO pin
N * @retval      1           The specified GPIO pin generate an interrupt
N *
N * @details     Get the interrupt status of specified GPIO pin.
N */
N#define GPIO_GET_INT_FLAG(gpio, u32PinMask)   ((gpio)->ISRC & u32PinMask)
N
N/**
N * @brief       Set De-bounce Sampling Cycle Time
N *
N * @param[in]   clksrc      The de-bounce counter clock source. It could be \ref GPIO_DBNCECON_DBCLKSRC_HCLK or \ref GPIO_DBNCECON_DBCLKSRC_IRC10K.
N * @param[in]   clksel      The de-bounce sampling cycle selection. It could be \n
N *                              \ref GPIO_DBNCECON_DBCLKSEL_1, \ref GPIO_DBNCECON_DBCLKSEL_2, \ref GPIO_DBNCECON_DBCLKSEL_4, \ref GPIO_DBNCECON_DBCLKSEL_8, \n
N *                              \ref GPIO_DBNCECON_DBCLKSEL_16, \ref GPIO_DBNCECON_DBCLKSEL_32, \ref GPIO_DBNCECON_DBCLKSEL_64, \ref GPIO_DBNCECON_DBCLKSEL_128, \n
N *                              \ref GPIO_DBNCECON_DBCLKSEL_256, \ref GPIO_DBNCECON_DBCLKSEL_512, \ref GPIO_DBNCECON_DBCLKSEL_1024, \ref GPIO_DBNCECON_DBCLKSEL_2048, \n
N *                              \ref GPIO_DBNCECON_DBCLKSEL_4096, \ref GPIO_DBNCECON_DBCLKSEL_8192, \ref GPIO_DBNCECON_DBCLKSEL_16384, \ref GPIO_DBNCECON_DBCLKSEL_32768.
N *
N * @return      None
N *
N * @details     Set the interrupt de-bounce sampling cycle time based on the debounce counter clock source, below is an example.
N * \code
N *     // It's meaning the De-debounce counter clock source is internal 10 KHz and sampling cycle selection is 4.
N *     //   Then the target de-bounce sampling cycle time is (2^4)*(1/(10*1000)) s = 16*0.0001 s = 1600 us,
N *     //   and system will sampling interrupt input once per 1600 us. 
N *     _GPIO_SET_DEBOUNCE_TIME(GPIO_DBNCECON_DBCLKSRC_IRC10K, GPIO_DBNCECON_DBCLKSEL_4);
N * \endcode
N */
N#define GPIO_SET_DEBOUNCE_TIME(clksrc, clksel)  (GPIO->DBNCECON = (GPIO_DBNCECON_ICLK_ON_Msk | clksrc | clksel))
N
N/**
N * @brief       Get GPIO Port IN Data
N *
N * @param[in]   gpio        GPIO port. It could be \ref P0, \ref P1, \ref P2, \ref P3, \ref P4 or \ref P5.
N *
N * @retval      The specified port data
N *
N * @details     Get the PIN register of specified GPIO port.
N */
N#define GPIO_GET_IN_DATA(gpio)   ((gpio)->PIN)
N
N/**
N * @brief       Set GPIO Port OUT Data
N *
N * @param[in]   gpio        GPIO port. It could be \ref P0, \ref P1, \ref P2, \ref P3, \ref P4 or \ref P5.
N * @param[in]   data        GPIO port data.
N *
N * @retval      None
N *
N * @details     Set the Data into specified GPIO port.
N */
N#define GPIO_SET_OUT_DATA(gpio, data)   ((gpio)->DOUT = (data))
N
N/**
N * @brief       Toggle Specified GPIO pin
N *
N * @param[in]   u32Pin       Pxy
N *
N * @retval      None
N *
N * @details     Toggle the specified GPIO pint.
N */
N#define GPIO_TOGGLE(u32Pin)   ((u32Pin) ^= 1)
N
N/**
N * @brief       Enable External GPIO interrupt 0
N *
N * @param[in]   gpio            GPIO port. It could be \ref P0, \ref P1, \ref P2, \ref P3, \ref P4 or \ref P5.
N * @param[in]   u32Pin          The pin of specified GPIO port.
N * @param[in]   u32IntAttribs   The interrupt attribute of specified GPIO pin. It could be \n
N *                              \ref GPIO_INT_RISING, \ref GPIO_INT_FALLING, \ref GPIO_INT_BOTH_EDGE, \ref GPIO_INT_HIGH, \ref GPIO_INT_LOW.
N *
N * @return      None
N *
N * @details     This function is used to enable specified GPIO pin interrupt.
N */
N#define GPIO_EnableEINT0    GPIO_EnableInt
N
N
N/**
N * @brief       Disable External GPIO interrupt 0
N *
N * @param[in]   gpio        GPIO port. It could be \ref P0, \ref P1, \ref P2, \ref P3, \ref P4 or \ref P5.
N * @param[in]   u32Pin      The pin of specified GPIO port. It could be 0 ~ 7.
N *
N * @return      None
N *
N * @details     This function is used to enable specified GPIO pin interrupt.
N */
N#define GPIO_DisableEINT0   GPIO_DisableInt
N
N
N/**
N * @brief       Enable External GPIO interrupt 1
N *
N * @param[in]   gpio            GPIO port. It could be \ref P0, \ref P1, \ref P2, \ref P3, \ref P4 or \ref P5.
N * @param[in]   u32Pin          The pin of specified GPIO port.
N * @param[in]   u32IntAttribs   The interrupt attribute of specified GPIO pin. It could be \n
N *                              \ref GPIO_INT_RISING, \ref GPIO_INT_FALLING, \ref GPIO_INT_BOTH_EDGE, \ref GPIO_INT_HIGH, \ref GPIO_INT_LOW.
N *
N * @return      None
N *
N * @details     This function is used to enable specified GPIO pin interrupt.
N */
N#define GPIO_EnableEINT1    GPIO_EnableInt
N
N
N/**
N * @brief       Disable External GPIO interrupt 1
N *
N * @param[in]   gpio        GPIO port. It could be \ref P0, \ref P1, \ref P2, \ref P3, \ref P4 or \ref P5.
N * @param[in]   u32Pin      The pin of specified GPIO port. It could be 0 ~ 7.
N *
N * @return      None
N *
N * @details     This function is used to enable specified GPIO pin interrupt.
N */
N#define GPIO_DisableEINT1   GPIO_DisableInt
N
N
Nvoid GPIO_SetMode(GPIO_T *gpio, uint32_t u32PinMask, uint32_t u32Mode);
Nvoid GPIO_EnableInt(GPIO_T *gpio, uint32_t u32Pin, uint32_t u32IntAttribs);
Nvoid GPIO_DisableInt(GPIO_T *gpio, uint32_t u32Pin);
N
N
N
N/*@}*/ /* end of group MINI51_GPIO_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group MINI51_GPIO_Driver */
N
N/*@}*/ /* end of group MINI51_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__GPIO_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 5954 "C:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.1.0\Device\Mini51\Include\Mini51Series.h" 2
N#include "i2c.h"
L 1 "C:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.1.0\Device\Mini51\Driver\i2c.h" 1
N/**************************************************************************//**
N * @file     i2c.h
N * @version  V1.00
N * $Revision: 12 $
N * $Date: 15/12/31 1:06p $ 
N * @brief    Mini51 series I2C driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/ 
N#ifndef __I2C_H__
N#define __I2C_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup MINI51_Device_Driver MINI51 Device Driver
N  @{
N*/
N
N/** @addtogroup MINI51_I2C_Driver I2C Driver
N  @{
N*/
N
N
N/** @addtogroup MINI51_I2C_EXPORTED_CONSTANTS I2C Exported Constants
N  @{
N*/
N
N#define I2C_STA 0x20    /*!< I2C START */
N#define I2C_STO 0x10    /*!< I2C STOP */
N#define I2C_SI  0x08    /*!< I2C SI */
N#define I2C_AA  0x04    /*!< I2C ACK */
N
N/*@}*/ /* end of group MINI51_I2C_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup MINI51_I2C_EXPORTED_FUNCTIONS I2C Exported Functions
N  @{
N*/
N
N/**
N  * @brief This macro sets the I2C control register at one time.
N  * @param i2c is the base address of I2C module.
N  * @param u8Ctrl is the register value of I2C control register.
N  * @return none
N  */
N#define I2C_SET_CONTROL_REG(i2c, u8Ctrl) ( (i2c)->I2CON = ((i2c)->I2CON & ~0x3c) | u8Ctrl )
N
N/**
N  * @brief This macro only set START bit to the control register of I2C module.
N  * @param i2c is the base address of I2C module.
N  * @return none
N  */
N#define I2C_START(i2c) ( (i2c)->I2CON = ((i2c)->I2CON & ~I2C_I2CON_SI_Msk) | I2C_I2CON_STA_Msk )
N
N/**
N  * @brief This macro only set STOP bit to the control register of I2C module.
N  * @param i2c is the base address of I2C module.
N  * @return none
N  */
N#define I2C_STOP(i2c) \
Ndo { \
N    (i2c)->I2CON |= (I2C_I2CON_SI_Msk | I2C_I2CON_STO_Msk); \
N    while((i2c)->I2CON & I2C_I2CON_STO_Msk); \
N} while(0)
X#define I2C_STOP(i2c) do {     (i2c)->I2CON |= (I2C_I2CON_SI_Msk | I2C_I2CON_STO_Msk);     while((i2c)->I2CON & I2C_I2CON_STO_Msk); } while(0)
N
N/**
N  * @brief This macro will return when I2C module is ready.
N  * @param i2c is the base address of I2C module.
N  * @return none
N  */
N#define  I2C_WAIT_READY(i2c) while(!((i2c)->I2CON & I2C_I2CON_SI_Msk))
N
N/**
N  * @brief This macro disables the FIFO function.
N  * @param i2c is the base address of I2C module.
N  * @return none
N  */
N#define  I2C_DISABLE_FIFO(i2c) ( (i2c)->I2CON2 &= ~I2C_I2CON2_TWOFF_EN_Msk )
N
N/**
N  * @brief This macro enables the FIFO function.
N  * @param i2c is the base address of I2C module.
N  * @return none
N  */
N#define I2C_ENABLE_FIFO(i2c) ( (i2c)->I2CON2 |= I2C_I2CON2_TWOFF_EN_Msk )
N
N/**
N  * @brief This macro disables clock stretch function.
N  * @param i2c is the base address of I2C module.
N  * @return none
N  */
N#define I2C_DISABLE_CLOCK_STRETCH(i2c) ( (i2c)->I2CON2 |= I2C_I2CON2_NOSTRETCH_Msk )
N
N/**
N  * @brief This macro enables clock stretch function.
N  * @param i2c is the base address of I2C module.
N  * @return none
N  */
N#define I2C_ENABLE_CLOCK_STRETCH(i2c) ( (i2c)->I2CON2 &= ~I2C_I2CON2_NOSTRETCH_Msk )
N
N/**
N  * @brief This macro disables over-run interrupt.
N  * @param i2c is the base address of I2C module.
N  * @return none
N  */
N#define I2C_DISABLE_OVERRUN_INT(i2c) ( (i2c)->I2CON2 &= ~I2C_I2CON2_OVER_INTEN_Msk )
N
N/**
N  * @brief This macro enables over-run interrupt.
N  * @param i2c is the base address of I2C module.
N  * @return none
N  */
N#define I2C_ENABLE_OVERRUN_INT(i2c) ( (i2c)->I2CON2 |= I2C_I2CON2_OVER_INTEN_Msk )
N
N/**
N  * @brief This macro enables under-run interrupt.
N  * @param i2c is the base address of I2C module.
N  * @return none
N  */
N#define I2C_ENABLE_UNDERRUN_INT(i2c) ( (i2c)->I2CON2 |= I2C_I2CON2_UNDER_INTEN_Msk )
N
N/**
N  * @brief This macro disables under-run interrupt.
N  * @param i2c is the base address of I2C module.
N  * @return none
N  */
N#define I2C_DISABLE_UNDERRUN_INT(i2c) ( (i2c)->I2CON2 &= ~I2C_I2CON2_UNDER_INTEN_Msk )
N
N/**
N  * @brief This macro returns the data stored in data register of I2C module.
N  * @param i2c is the base address of I2C module.
N  * @return Data.
N  */
N#define I2C_GET_DATA(i2c) ( (i2c)->I2CDAT )
N
N/**
N  * @brief This macro writes the data to data register of I2C module.
N  * @param i2c is the base address of I2C module.
N  * @param u8Data is the data which will be write to data register of I2C module.
N  * @return none
N  */
N#define I2C_SET_DATA(i2c, u8Data) ( (i2c)->I2CDAT = u8Data )
N
N/**
N  * @brief This macro returns the status of I2C module.
N  * @param i2c is the base address of I2C module.
N  * @return Status.
N  */
N#define I2C_GET_STATUS(i2c) ( (i2c)->I2CSTATUS )
N
N/**
N  * @brief This macro returns timeout flag.
N  * @param i2c is the base address of I2C module.
N  * @return Status.
N  * @retval 0 Flag is not set.
N  * @retval 1 Flag is set.
N  */
N#define I2C_GET_TIMEOUT_FLAG(i2c) ( ((i2c)->I2CTOC & I2C_I2CTOC_TIF_Msk) == I2C_I2CTOC_TIF_Msk ? 1:0  )
N
N/**
N  * @brief This macro returns wakeup flag.
N  * @param i2c is the base address of I2C module.
N  * @return Status.
N  * @retval 0 Flag is not set.
N  * @retval 1 Flag is set.
N  */
N#define I2C_GET_WAKEUP_FLAG(i2c) ( ((i2c)->I2CSTATUS2 & I2C_I2CSTATUS2_WAKEUP_Msk) == I2C_I2CSTATUS2_WAKEUP_Msk ? 1:0  )
N
N/**
N  * @brief This macro clears wakeup flag.
N  * @param i2c is the base address of I2C module.
N  * @return none
N  */
N#define I2C_CLEAR_WAKEUP_FLAG(i2c)  ((i2c)->I2CSTATUS2 |= I2C_I2CSTATUS2_WAKEUP_Msk )
N
Nuint32_t I2C_Open(I2C_T *i2c, uint32_t u32BusClock);
Nvoid I2C_Close(I2C_T *i2c);
Nvoid I2C_ClearTimeoutFlag(I2C_T *i2c);
Nvoid I2C_Trigger(I2C_T *i2c, uint8_t u8Start, uint8_t u8Stop, uint8_t u8Si, uint8_t u8Ack);
Nvoid I2C_DisableInt(I2C_T *i2c);
Nvoid I2C_EnableInt(I2C_T *i2c);
Nuint32_t I2C_GetBusClockFreq(I2C_T *i2c);
Nuint32_t I2C_SetBusClockFreq(I2C_T *i2c, uint32_t u32BusClock);
Nuint32_t I2C_GetIntFlag(I2C_T *i2c);
Nuint32_t I2C_GetStatus(I2C_T *i2c);
Nuint32_t I2C_GetData(I2C_T *i2c);
Nvoid I2C_SetData(I2C_T *i2c, uint8_t u8Data);
Nvoid I2C_SetSlaveAddr(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddr, uint8_t u8GCMode);
Nvoid I2C_SetSlaveAddrMask(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddrMask);
Nvoid I2C_EnableTimeout(I2C_T *i2c, uint8_t u8LongTimeout);
Nvoid I2C_DisableTimeout(I2C_T *i2c);
Nvoid I2C_EnableWakeup(I2C_T *i2c);
Nvoid I2C_DisableWakeup(I2C_T *i2c);
N
N/*@}*/ /* end of group MINI51_I2C_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group MINI51_I2C_Driver */
N
N/*@}*/ /* end of group MINI51_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__I2C_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 5955 "C:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.1.0\Device\Mini51\Include\Mini51Series.h" 2
N#include "pwm.h"
L 1 "C:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.1.0\Device\Mini51\Driver\pwm.h" 1
N/**************************************************************************//**
N * @file     pwm.h
N * @version  V1.00
N * $Revision: 11 $
N * $Date: 15/09/23 1:57p $ 
N * @brief    Mini51 series PWM driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/ 
N#ifndef __PWM_H__
N#define __PWM_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup MINI51_Device_Driver MINI51 Device Driver
N  @{
N*/
N
N/** @addtogroup MINI51_PWM_Driver PWM Driver
N  @{
N*/
N
N/** @addtogroup MINI51_PWM_EXPORTED_CONSTANTS PWM Exported Constants
N  @{
N*/
N#define PWM_CHANNEL_NUM                     (6)   /*!< PWM channel number */
N#define PWM_CLK_DIV_1                       (4UL) /*!< PWM clock divide by 1 */
N#define PWM_CLK_DIV_2                       (0UL) /*!< PWM clock divide by 2 */
N#define PWM_CLK_DIV_4                       (1UL) /*!< PWM clock divide by 4 */
N#define PWM_CLK_DIV_8                       (2UL) /*!< PWM clock divide by 8 */
N#define PWM_CLK_DIV_16                      (3UL) /*!< PWM clock divide by 16 */
N#define PWM_EDGE_ALIGNED                    (0UL)                   /*!< PWM working in edge aligned type */
N#define PWM_CENTER_ALIGNED                  (PWM_PCR_PWMTYPE_Msk)   /*!< PWM working in center aligned type */
N#define PWM_TRIGGER_ADC_CNTR_IS_0           PWM_TRGCON0_P0TRGEN_Msk     /*!< PWM trigger ADC while counter matches 0 */
N#define PWM_TRIGGER_ADC_CNTR_IS_CMR_D       PWM_TRGCON0_CM0TRGFEN_Msk   /*!< PWM trigger ADC while counter matches CMR during down count */
N#define PWM_TRIGGER_ADC_CNTR_IS_CNR         PWM_TRGCON0_CNT0TRGEN_Msk   /*!< PWM trigger ADC while counter matches CNR */
N#define PWM_TRIGGER_ADC_CNTR_IS_CMR_U       PWM_TRGCON0_CM0TRGREN_Msk   /*!< PWM trigger ADC while counter matches CMR during up count  */
N#define PWM_FB0_EINT0       (PWM_PFBCON_BKEN0_Msk)                              /*!< External interrupt 0 as fault brake 0 source */
N#define PWM_FB0_ACMP1       (PWM_PFBCON_BKEN0_Msk | PWM_PFBCON_CPO1BKEN_Msk)    /*!< Comparator 1 as fault brake 0 source */
N#define PWM_FB1_EINT1       (PWM_PFBCON_BKEN1_Msk)                              /*!< External interrupt 1 as fault brake 1 source */
N#define PWM_FB1_ACMP0       (PWM_PFBCON_BKEN1_Msk | PWM_PFBCON_CPO0BKEN_Msk)    /*!< Comparator 0 as fault brake 1 source */
N#define PWM_PERIOD_INT_UNDERFLOW            (0)                         /*!< PWM period interrupt trigger if counter underflow */
N#define PWM_PERIOD_INT_MATCH_CNR            (PWM_PIER_INT_TYPE_Msk)     /*!< PWM period interrupt trigger if counter match CNR */
N
N/*@}*/ /* end of group MINI51_PWM_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup MINI51_PWM_EXPORTED_FUNCTIONS PWM Exported Functions
N  @{
N*/
N
N/**
N * @brief This macro enable complementary mode
N * @param[in] pwm The base address of PWM module
N * @return None
N * \hideinitializer
N */
N#define PWM_ENABLE_COMPLEMENTARY_MODE(pwm) (PWM->PCR = (PWM->PCR & ~PWM_PCR_PWMMOD_Msk) |(1UL << PWM_PCR_PWMMOD_Pos))
N
N/**
N * @brief This macro disable complementary mode, and enable independent mode.
N * @param[in] pwm The base address of PWM module
N * @return None
N * \hideinitializer
N */
N#define PWM_DISABLE_COMPLEMENTARY_MODE(pwm) (PWM->PCR &= ~PWM_PCR_PWMMOD_Msk)
N
N/**
N * @brief This macro enable group mode
N * @param[in] pwm The base address of PWM module
N * @return None
N * \hideinitializer
N */
N#define PWM_ENABLE_GROUP_MODE(pwm) (PWM->PCR |= PWM_PCR_GRP_Msk)
N
N/**
N * @brief This macro disable group mode
N * @param[in] pwm The base address of PWM module
N * @return None
N * \hideinitializer
N */
N#define PWM_DISABLE_GROUP_MODE(pwm) (PWM->PCR &= ~PWM_PCR_GRP_Msk)
N
N/**
N * @brief This macro enable synchronous mode
N * @param[in] pwm The base address of PWM module
N * @return None
N * \hideinitializer
N */
N#define PWM_ENABLE_SYNC_MODE(pwm) (PWM->PCR = (PWM->PCR & ~PWM_PCR_PWMMOD_Msk) |(2UL << PWM_PCR_PWMMOD_Pos))
N 
N/**
N * @brief This macro disable synchronous mode, and enable independent mode.
N * @param[in] pwm The base address of PWM module
N * @return None
N * \hideinitializer
N */
N#define PWM_DISABLE_SYNC_MODE(pwm) (PWM->PCR &= ~PWM_PCR_PWMMOD_Msk)
N
N/**
N * @brief This macro enable output inverter of specified channel(s)
N * @param[in] pwm The base address of PWM module
N * @param[in] u32ChannelMask Combination of enabled channels. Each bit corresponds to a channel
N *                           Bit 0 represents channel 0, bit 1 represents channel 1...
N * @return None
N * \hideinitializer
N */
N#define PWM_ENABLE_OUTPUT_INVERTER(pwm, u32ChannelMask) \
N    do{ \
N        int i;\
N        for(i = 0; i < 6; i++) { \
N            if((u32ChannelMask) & (1 << i)) {\
N                PWM->PCR |= (1 << (PWM_PCR_CH0INV_Pos + (i * 4))); \
N            }\
N        } \
N    }while(0)
X#define PWM_ENABLE_OUTPUT_INVERTER(pwm, u32ChannelMask)     do{         int i;        for(i = 0; i < 6; i++) {             if((u32ChannelMask) & (1 << i)) {                PWM->PCR |= (1 << (PWM_PCR_CH0INV_Pos + (i * 4)));             }        }     }while(0)
N
N/**
N * @brief This macro set the prescaler of the selected channel
N * @param[in] pwm The base address of PWM module
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~5
N * @param[in] u32Prescaler Clock prescaler of specified channel. Valid values are between 1 ~ 0xFF
N * @return None
N * @note Every even channel N, and channel (N + 1) share a prescaler. So if channel 0 prescaler changed, 
N *       channel 1 will also be affected.
N * \hideinitializer
N */
N#define PWM_SET_PRESCALER(pwm, u32ChannelNum, u32Prescaler) \
N    (PWM->PPR = (PWM->PPR & ~(PWM_PPR_CP01_Msk << (((u32ChannelNum) >> 1) * 8))) | ((u32Prescaler) << (((u32ChannelNum) >> 1) * 8))) 
X#define PWM_SET_PRESCALER(pwm, u32ChannelNum, u32Prescaler)     (PWM->PPR = (PWM->PPR & ~(PWM_PPR_CP01_Msk << (((u32ChannelNum) >> 1) * 8))) | ((u32Prescaler) << (((u32ChannelNum) >> 1) * 8))) 
N
N/**
N * @brief This macro set the divider of the selected channel
N * @param[in] pwm The base address of PWM module
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~5
N * @param[in] u32Divider Clock divider of specified channel. Valid values are
N *              - \ref PWM_CLK_DIV_1
N *              - \ref PWM_CLK_DIV_2
N *              - \ref PWM_CLK_DIV_4
N *              - \ref PWM_CLK_DIV_8
N *              - \ref PWM_CLK_DIV_16 
N * @return None
N * \hideinitializer
N */
N#define PWM_SET_DIVIDER(pwm, u32ChannelNum, u32Divider) \
N    (PWM->CSR = (PWM->CSR & ~(PWM_CSR_CSR0_Msk << ((u32ChannelNum) * 4))) | ((u32Divider) << ((u32ChannelNum) * 4)))
X#define PWM_SET_DIVIDER(pwm, u32ChannelNum, u32Divider)     (PWM->CSR = (PWM->CSR & ~(PWM_CSR_CSR0_Msk << ((u32ChannelNum) * 4))) | ((u32Divider) << ((u32ChannelNum) * 4)))
N
N/**
N * @brief This macro set the duty of the selected channel
N * @param[in] pwm The base address of PWM module
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~5 
N * @param[in] u32CMR Duty of specified channel. Valid values are between 0~0xFFFF
N * @return None
N * @note This new setting will take effect on next PWM period
N * \hideinitializer
N */
N#define PWM_SET_CMR(pwm, u32ChannelNum, u32CMR) (PWM->CMR[u32ChannelNum] = (u32CMR))
N
N/**
N * @brief This macro set the period of the selected channel
N * @param[in] pwm The base address of PWM module
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~5 
N * @param[in] u32CNR Period of specified channel. Valid values are between 0~0xFFFF
N * @return None
N * @note This new setting will take effect on next PWM period
N * @note PWM counter will stop if period length set to 0
N * \hideinitializer
N */
N#define PWM_SET_CNR(pwm, u32ChannelNum, u32CNR)  (PWM->CNR[u32ChannelNum] = (u32CNR))
N
N/**
N * @brief This macro set the PWM aligned type
N * @param[in] pwm The base address of PWM module
N * @param[in] u32ChannelMask This parameter is not used
N * @param[in] u32AlignedType PWM aligned type, valid values are:
N *                  - PWM_EDGE_ALIGNED
N *                  - PWM_CENTER_ALIGNED
N * @return None
N * \hideinitializer
N */
N#define PWM_SET_ALIGNED_TYPE(pwm, u32ChannelMask, u32AlignedType) \
N    (PWM->PCR = (PWM->PCR & ~PWM_PCR_PWMTYPE_Msk) | (u32AlignedType))
X#define PWM_SET_ALIGNED_TYPE(pwm, u32ChannelMask, u32AlignedType)     (PWM->PCR = (PWM->PCR & ~PWM_PCR_PWMTYPE_Msk) | (u32AlignedType))
N
N
Nuint32_t PWM_ConfigOutputChannel(PWM_T *pwm,
N                                  uint32_t u32ChannelNum, 
N                                  uint32_t u32Frequency, 
N                                  uint32_t u32DutyCycle);
Nvoid PWM_Start(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_Stop(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_ForceStop(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_EnableADCTrigger(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition);
Nvoid PWM_DisableADCTrigger(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_ClearADCTriggerFlag(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition);
Nuint32_t PWM_GetADCTriggerFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnableFaultBrake(PWM_T *pwm, 
N                           uint32_t u32ChannelMask, 
N                           uint32_t u32LevelMask, 
N                           uint32_t u32BrakeSource);
Nvoid PWM_ClearFaultBrakeFlag(PWM_T *pwm, uint32_t u32BrakeSource);
Nvoid PWM_EnableOutput(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_DisableOutput(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_EnableDeadZone(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Duration);
Nvoid PWM_DisableDeadZone(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnableDutyInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32IntDutyType);
Nvoid PWM_DisableDutyInt(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_ClearDutyIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nuint32_t PWM_GetDutyIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnableFaultBrakeInt(PWM_T *pwm, uint32_t u32BrakeSource);
Nvoid PWM_DisableFaultBrakeInt(PWM_T *pwm, uint32_t u32BrakeSource);
Nvoid PWM_ClearFaultBrakeIntFlag(PWM_T *pwm, uint32_t u32BrakeSource);
Nuint32_t PWM_GetFaultBrakeIntFlag(PWM_T *pwm, uint32_t u32BrakeSource);
Nvoid PWM_EnablePeriodInt(PWM_T *pwm, uint32_t u32ChannelNum,  uint32_t u32IntPeriodType);
Nvoid PWM_DisablePeriodInt(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_ClearPeriodIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nuint32_t PWM_GetPeriodIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
N
N
N
N/*@}*/ /* end of group MINI51_PWM_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group MINI51_PWM_Driver */
N
N/*@}*/ /* end of group MINI51_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__PWM_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 5956 "C:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.1.0\Device\Mini51\Include\Mini51Series.h" 2
N#include "spi.h"
L 1 "C:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.1.0\Device\Mini51\Driver\spi.h" 1
N/**************************************************************************//**
N * @file     spi.h
N * @version  V1.00
N * $Revision: 15 $
N * $Date: 15/10/01 11:36a $ 
N * @brief    Mini51 series SPI driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/ 
N#ifndef __SPI_H__
N#define __SPI_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup MINI51_Device_Driver MINI51 Device Driver
N  @{
N*/
N
N/** @addtogroup MINI51_SPI_Driver SPI Driver
N  @{
N*/
N
N/** @addtogroup MINI51_SPI_EXPORTED_CONSTANTS SPI Exported Constants
N  @{
N*/
N
N#define SPI_MODE_0        (SPI_CNTRL_TX_NEG_Msk)                            /*!< CLKP=0; RX_NEG=0; TX_NEG=1 */
N#define SPI_MODE_1        (SPI_CNTRL_RX_NEG_Msk)                            /*!< CLKP=0; RX_NEG=1; TX_NEG=0 */
N#define SPI_MODE_2        (SPI_CNTRL_CLKP_Msk | SPI_CNTRL_RX_NEG_Msk)       /*!< CLKP=1; RX_NEG=1; TX_NEG=0 */
N#define SPI_MODE_3        (SPI_CNTRL_CLKP_Msk | SPI_CNTRL_TX_NEG_Msk)       /*!< CLKP=1; RX_NEG=0; TX_NEG=1 */
N
N#define SPI_SLAVE         (SPI_CNTRL_SLAVE_Msk)                             /*!< Set as slave */
N#define SPI_MASTER        (0x0)                                             /*!< Set as master */
N
N#define SPI_SS                (SPI_SSR_SSR_Msk)                             /*!< Set SS0 */
N#define SPI_SS_ACTIVE_HIGH    (SPI_SSR_SS_LVL_Msk)                          /*!< SS active high */
N#define SPI_SS_ACTIVE_LOW     (0x0)                                         /*!< SS active low */
N
N#define SPI_IE_MASK                        (0x01)                           /*!< Interrupt enable mask */
N#define SPI_SSTA_INTEN_MASK                (0x04)                           /*!< Slave 3-Wire mode start interrupt enable mask */
N#define SPI_FIFO_TX_INTEN_MASK             (0x08)                           /*!< FIFO TX interrupt mask */
N#define SPI_FIFO_RX_INTEN_MASK             (0x10)                           /*!< FIFO RX interrupt mask */
N#define SPI_FIFO_RXOV_INTEN_MASK           (0x20)                           /*!< FIFO RX overrun interrupt mask */
N#define SPI_FIFO_TIMEOUT_INTEN_MASK        (0x40)                           /*!< FIFO timeout interrupt mask */
N
N
N/*@}*/ /* end of group MINI51_SPI_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup MINI51_SPI_EXPORTED_FUNCTIONS SPI Exported Functions
N  @{
N*/
N
N/**
N  * @brief  Abort the current transfer in slave 3-wire mode.
N  * @param  spi is the base address of SPI module.
N  * @return none
N  */
N#define  SPI_ABORT_3WIRE_TRANSFER(spi) ( (spi)->CNTRL2 |= SPI_CNTRL2_SLV_ABORT_Msk )
N
N/**
N  * @brief  Clear the slave 3-wire mode start interrupt flag.
N  * @param  spi is the base address of SPI module.
N  * @return none
N  */
N#define SPI_CLR_3WIRE_START_INT_FLAG(spi) ( (spi)->STATUS = SPI_STATUS_SLV_START_INTSTS_Msk )
N
N/**
N  * @brief  Clear the unit transfer interrupt flag.
N  * @param  spi is the base address of SPI module.
N  * @return none
N  */
N#define SPI_CLR_UNIT_TRANS_INT_FLAG(spi) ( (spi)->STATUS = SPI_STATUS_IF_Msk )
N
N/**
N  * @brief  Disable slave 3-wire mode.
N  * @param  spi is the base address of SPI module.
N  * @return none
N  */
N#define SPI_DISABLE_3WIRE_MODE(spi) ( (spi)->CNTRL2 &= ~SPI_CNTRL2_NOSLVSEL_Msk )
N
N/**
N  * @brief  Enable slave 3-wire mode.
N  * @param  spi is the base address of SPI module.
N  * @return none
N  */
N#define SPI_ENABLE_3WIRE_MODE(spi) ( (spi)->CNTRL2 |= SPI_CNTRL2_NOSLVSEL_Msk )
N
N/**
N  * @brief  Get the count of available data in RX FIFO.
N  * @param  spi is the base address of SPI module.
N  * @return The count of available data in RX FIFO.
N  */
N#define SPI_GET_RX_FIFO_COUNT(spi) ( (((spi)->STATUS & SPI_STATUS_RX_FIFO_COUNT_Msk) >> SPI_STATUS_RX_FIFO_COUNT_Pos) & 0xf )
N
N/**
N  * @brief  Get the Rx FIFO empty flag.
N  * @param  spi is the base address of SPI module.
N  * @return Rx FIFO flag
N  * @retval 0 Rx FIFO is not empty
N  * @retval 1 Rx FIFO is empty
N  */
N#define SPI_GET_RX_FIFO_EMPTY_FLAG(spi) ( ((spi)->STATUS & SPI_STATUS_RX_EMPTY_Msk) == SPI_STATUS_RX_EMPTY_Msk ? 1:0 )
N
N/**
N  * @brief  Get the Tx FIFO empty flag.
N  * @param  spi is the base address of SPI module.
N  * @return Tx FIFO flag
N  * @retval 0 Tx FIFO is not empty
N  * @retval 1 Tx FIFO is empty
N  */
N#define SPI_GET_TX_FIFO_EMPTY_FLAG(spi) ( ((spi)->STATUS & SPI_STATUS_TX_EMPTY_Msk) == SPI_STATUS_TX_EMPTY_Msk ? 1:0 )
N
N/**
N  * @brief  Get the Tx FIFO full flag.
N  * @param  spi is the base address of SPI module.
N  * @return Tx FIFO flag
N  * @retval 0 Tx FIFO is not full
N  * @retval 1 Tx FIFO is full
N  */
N#define SPI_GET_TX_FIFO_FULL_FLAG(spi) ( ((spi)->STATUS & SPI_STATUS_TX_FULL_Msk) == SPI_STATUS_TX_FULL_Msk ? 1:0 )
N
N/**
N  * @brief  Get the datum read from Rx FIFO.
N  * @param  spi is the base address of SPI module.
N  * @return Data in Rx buffer
N  */
N#define SPI_READ_RX(spi) ( (spi)->RX )
N
N/**
N  * @brief  Write datum to TX register.
N  * @param  spi is the base address of SPI module.
N  * @param  u32TxData is the datum which user attempt to transfer through SPI bus.
N  * @return none
N  */
N#define SPI_WRITE_TX(spi, u32TxData) ( (spi)->TX = u32TxData )
N
N/**
N  * @brief  Disable automatic slave select function and set SPI_SS pin to high state.
N  * @param  spi is the base address of SPI module.
N  * @return none
N  */
Nstatic __INLINE void SPI_SET_SS_HIGH(SPI_T *spi)
Xstatic __inline void SPI_SET_SS_HIGH(SPI_T *spi)
N{
N  spi->SSR &= ~SPI_SSR_AUTOSS_Msk;  
X  spi->SSR &= ~(0x1ul << (3));  
N  spi->SSR |= (SPI_SSR_LTRIG_FLAG_Msk | SPI_SSR_SS_LVL_Msk | SPI_SSR_SSR_Msk);  
X  spi->SSR |= ((0x1ul << (5)) | (0x1ul << (2)) | (0x1ul << (0)));  
N}
N
N/**
N  * @brief  Disable automatic slave select function and set SPI_SS pin to low state.
N  * @param  spi is the base address of SPI module.
N  * @return none
N  */
Nstatic __INLINE void SPI_SET_SS_LOW(SPI_T *spi)
Xstatic __inline void SPI_SET_SS_LOW(SPI_T *spi)
N{
N  spi->SSR &= ~SPI_SSR_AUTOSS_Msk;
X  spi->SSR &= ~(0x1ul << (3));
N  spi->SSR |= SPI_SSR_LTRIG_FLAG_Msk;  
X  spi->SSR |= (0x1ul << (5));  
N  spi->SSR &= ~SPI_SSR_SS_LVL_Msk;
X  spi->SSR &= ~(0x1ul << (2));
N  spi->SSR |= SPI_SSR_SSR_Msk;
X  spi->SSR |= (0x1ul << (0));
N}
N
N/**
N  * @brief Enable byte reorder function.
N  * @param  spi is the base address of SPI module.
N  * @return none
N  */
N#define SPI_ENABLE_BYTE_REORDER(spi) ( (spi)->CNTRL |= SPI_CNTRL_REORDER_Msk )
N
N/**
N  * @brief  Disable byte reorder function.
N  * @param  spi is the base address of SPI module.
N  * @return none
N  */
N#define SPI_DISABLE_BYTE_REORDER(spi) ( (spi)->CNTRL &= ~SPI_CNTRL_REORDER_Msk )
N
N/**
N  * @brief  Set the length of suspend interval.
N  * @param  spi is the base address of SPI module.
N  * @param  u32SuspCycle decides the length of suspend interval.
N  * @return none
N  */
N#define SPI_SET_SUSPEND_CYCLE(spi, u32SuspCycle) ( (spi)->CNTRL = ((spi)->CNTRL & ~SPI_CNTRL_SP_CYCLE_Msk) | (u32SuspCycle << SPI_CNTRL_SP_CYCLE_Pos) )
N
N/**
N  * @brief  Set the SPI transfer sequence with LSB first.
N  * @param  spi is the base address of SPI module.
N  * @return none
N  */
N#define SPI_SET_LSB_FIRST(spi) ( (spi)->CNTRL |= SPI_CNTRL_LSB_Msk )
N
N/**
N  * @brief  Set the SPI transfer sequence with MSB first.
N  * @param  spi is the base address of SPI module.
N  * @return none
N  */
N#define SPI_SET_MSB_FIRST(spi) ( (spi)->CNTRL &= ~SPI_CNTRL_LSB_Msk )
N
N/**
N  * @brief  Set the data width of a SPI transaction.
N  * @param  spi is the base address of SPI module.
N  * @param  u32Width is the bit width of transfer data.  
N  * @return none
N  */
Nstatic __INLINE void SPI_SET_DATA_WIDTH(SPI_T *spi, uint32_t u32Width)
Xstatic __inline void SPI_SET_DATA_WIDTH(SPI_T *spi, uint32_t u32Width)
N{
N   if(u32Width == 32)
N        u32Width = 0;
N        
N   spi->CNTRL = (spi->CNTRL & ~SPI_CNTRL_TX_BIT_LEN_Msk) | (u32Width << SPI_CNTRL_TX_BIT_LEN_Pos);
X   spi->CNTRL = (spi->CNTRL & ~(0x1ful << (3))) | (u32Width << (3));
N}
N
N/**
N  * @brief  Get the SPI busy state.
N  * @param  spi is the base address of SPI module.
N  * @return SPI busy status
N  * @retval 0 SPI module is not busy
N  * @retval 1 SPI module is busy
N  */
N#define SPI_IS_BUSY(spi) ( ((spi)->CNTRL & SPI_CNTRL_GO_BUSY_Msk) == SPI_CNTRL_GO_BUSY_Msk ? 1:0 )
N
N/**
N  * @brief  Set the GO_BUSY bit to trigger SPI transfer.
N  * @param  spi is the base address of SPI module.
N  * @return none
N  */
N#define SPI_TRIGGER(spi) ( (spi)->CNTRL |= SPI_CNTRL_GO_BUSY_Msk )
N
Nuint32_t SPI_Open(SPI_T *spi, uint32_t u32MasterSlave, uint32_t u32SPIMode, uint32_t u32DataWidth, uint32_t u32BusClock);
Nvoid SPI_Close(SPI_T *spi);
Nvoid SPI_ClearRxFIFO(SPI_T *spi);
Nvoid SPI_ClearTxFIFO(SPI_T *spi);
Nvoid SPI_DisableAutoSS(SPI_T *spi);
Nvoid SPI_EnableAutoSS(SPI_T *spi, uint32_t u32SSPinMask, uint32_t u32ActiveLevel);
Nuint32_t SPI_SetBusClock(SPI_T *spi, uint32_t u32BusClock);
Nvoid SPI_EnableFIFO(SPI_T *spi, uint32_t u32TxThreshold, uint32_t u32RxThreshold);
Nvoid SPI_DisableFIFO(SPI_T *spi);
Nuint32_t SPI_GetBusClock(SPI_T *spi);
Nvoid SPI_EnableInt(SPI_T *spi, uint32_t u32Mask);
Nvoid SPI_DisableInt(SPI_T *spi, uint32_t u32Mask);
N
N/*@}*/ /* end of group MINI51_SPI_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group MINI51_SPI_Driver */
N
N/*@}*/ /* end of group MINI51_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__SPI_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 5957 "C:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.1.0\Device\Mini51\Include\Mini51Series.h" 2
N#include "timer.h"
L 1 "C:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.1.0\Device\Mini51\Driver\timer.h" 1
N/**************************************************************************//**
N * @file     timer.h
N * @version  V1.00
N * $Revision: 9 $
N * $Date: 14/01/13 7:43p $
N * @brief    Mini51 series TIMER driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __TIMER_H__
N#define __TIMER_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup MINI51_Device_Driver MINI51 Device Driver
N  @{
N*/
N
N/** @addtogroup MINI51_TIMER_Driver TIMER Driver
N  @{
N*/
N
N/** @addtogroup MINI51_TIMER_EXPORTED_CONSTANTS TIMER Exported Constants
N  @{
N*/
N
N#define TIMER_ONESHOT_MODE                  (0UL)                           /*!< Timer working in one shot mode */
N#define TIMER_PERIODIC_MODE                 (1UL << TIMER_TCSR_MODE_Pos)    /*!< Timer working in periodic mode */
N#define TIMER_TOGGLE_MODE                   (2UL << TIMER_TCSR_MODE_Pos)    /*!< Timer working in toggle mode */
N#define TIMER_CONTINUOUS_MODE               (3UL << TIMER_TCSR_MODE_Pos)    /*!< Timer working in continuous mode */
N#define TIMER_CAPTURE_FREE_COUNTING_MODE    (0UL)                           /*!< Free counting mode */
N#define TIMER_CAPTURE_TRIGGER_COUNTING_MODE (TIMER_TEXCON_CAP_MODE_Msk)     /*!< Trigger counting mode */
N#define TIMER_CAPTURE_COUNTER_RESET_MODE    (TIMER_TEXCON_RSTCAPSEL_Msk)    /*!< Counter reset mode */
N#define TIMER_CAPTURE_FALLING_EDGE              (0UL)                               /*!< Falling edge trigger timer capture */
N#define TIMER_CAPTURE_RISING_EDGE               (1UL << TIMER_TEXCON_TEX_EDGE_Pos)  /*!< Rising edge trigger timer capture */
N#define TIMER_CAPTURE_FALLING_THEN_RISING_EDGE  (2UL << TIMER_TEXCON_TEX_EDGE_Pos)  /*!< Falling edge then rising edge trigger timer capture */
N#define TIMER_CAPTURE_RISING_THEN_FALLING_EDGE  (3UL << TIMER_TEXCON_TEX_EDGE_Pos)  /*!< Rising edge then falling edge trigger timer capture */
N#define TIMER_COUNTER_RISING_EDGE           (TIMER_TEXCON_TX_PHASE_Msk)     /*!< Counter increase on rising edge */
N#define TIMER_COUNTER_FALLING_EDGE          (0UL)                           /*!< Counter increase on falling edge */
N#define TIMER_TOGGLE_TX                     (0UL)                           /*!< Timer use Tx, x = 0, 1 pin as toggle output pin   */
N#define TIMER_TOGGLE_TXEX                   (TIMER_TCSR_TOGGLE_PIN_Msk)     /*!< Timer use TxEX, x = 0, 1 pin as toggle output pin */
N
N/*@}*/ /* end of group MINI51_TIMER_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup MINI51_TIMER_EXPORTED_FUNCTIONS TIMER Exported Functions
N  @{
N*/
N
N/**
N  * @brief This macro is used to set new Timer compared value
N  * @param[in] timer The base address of Timer module
N  * @param[in] u32Value  Timer compare value. Valid values are between 2 to 0xFFFFFF
N  * @return None
N  * \hideinitializer
N  */
N#define TIMER_SET_CMP_VALUE(timer, u32Value) ((timer)->TCMPR = (u32Value))
N
N/**
N  * @brief This macro is used to set new Timer prescale value
N  * @param[in] timer The base address of Timer module
N  * @param[in] u32Value  Timer prescale value. Valid values are between 0 to 0xFF
N  * @return None
N  * @note Clock input is divided by (prescale + 1) before it is fed into timer
N  * \hideinitializer
N  */
N#define TIMER_SET_PRESCALE_VALUE(timer, u32Value) ((timer)->TCSR = ((timer)->TCSR & ~TIMER_TCSR_PRESCALE_Msk) | (u32Value))
N
N/**
N  * @brief This macro is used to check if specify Timer is inactive or active
N  * @param[in] timer The base address of Timer module
N  * @return timer is activate or inactivate
N  * @retval 0 Timer 24-bit up counter is inactive
N  * @retval 1 Timer 24-bit up counter is active
N  * \hideinitializer
N  */
N#define TIMER_IS_ACTIVE(timer) ((timer)->TCSR & TIMER_TCSR_CACT_Msk ? 1 : 0)
N
N/**
N  * @brief This macro is used to select Timer toggle output pin
N  * @param[in] timer The base address of Timer module
N  * @param[in] u32ToutSel Toggle output pin selection, valid values are
N  *                 - \ref TIMER_TOGGLE_TX
N  *                 - \ref TIMER_TOGGLE_TXEX
N  * @return None
N  * \hideinitializer
N  */
N#define TIMER_SELECT_TOUT_PIN(timer, u32ToutSel) ((timer)->TCSR = ((timer)->TCSR & ~TIMER_TCSR_TOGGLE_PIN_Msk) | (u32ToutSel))
N
N
N
N/**
N  * @brief This function is used to start Timer counting
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_Start(TIMER_T *timer)
Xstatic __inline void TIMER_Start(TIMER_T *timer)
N{
N    timer->TCSR |= TIMER_TCSR_CEN_Msk;
X    timer->TCSR |= (0x1ul << (30));
N}
N
N/**
N  * @brief This function is used to stop Timer counting
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_Stop(TIMER_T *timer)
Xstatic __inline void TIMER_Stop(TIMER_T *timer)
N{
N    timer->TCSR &= ~TIMER_TCSR_CEN_Msk;
X    timer->TCSR &= ~(0x1ul << (30));
N}
N
N/**
N  * @brief This function is used to enable the Timer wake-up function
N  * @param[in] timer The base address of Timer module
N  * @return None
N  * @note  To wake the system from power down mode, timer clock source must be ether LXT or LIRC
N  */
N__STATIC_INLINE void TIMER_EnableWakeup(TIMER_T *timer)
Xstatic __inline void TIMER_EnableWakeup(TIMER_T *timer)
N{
N    timer->TCSR |= TIMER_TCSR_WAKE_EN_Msk;
X    timer->TCSR |= (0x1ul << (23));
N}
N
N/**
N  * @brief This function is used to disable the Timer wake-up function
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_DisableWakeup(TIMER_T *timer)
Xstatic __inline void TIMER_DisableWakeup(TIMER_T *timer)
N{
N    timer->TCSR &= ~TIMER_TCSR_WAKE_EN_Msk;
X    timer->TCSR &= ~(0x1ul << (23));
N}
N
N
N/**
N  * @brief This function is used to enable the capture pin detection de-bounce function.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_EnableCaptureDebounce(TIMER_T *timer)
Xstatic __inline void TIMER_EnableCaptureDebounce(TIMER_T *timer)
N{
N    timer->TEXCON |= TIMER_TEXCON_TEXDB_Msk;
X    timer->TEXCON |= (0x1ul << (6));
N}
N
N/**
N  * @brief This function is used to disable the capture pin detection de-bounce function.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_DisableCaptureDebounce(TIMER_T *timer)
Xstatic __inline void TIMER_DisableCaptureDebounce(TIMER_T *timer)
N{
N    timer->TEXCON &= ~TIMER_TEXCON_TEXDB_Msk;
X    timer->TEXCON &= ~(0x1ul << (6));
N}
N
N
N/**
N  * @brief This function is used to enable the counter pin detection de-bounce function.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_EnableEventCounterDebounce(TIMER_T *timer)
Xstatic __inline void TIMER_EnableEventCounterDebounce(TIMER_T *timer)
N{
N    timer->TEXCON |= TIMER_TEXCON_TCDB_Msk;
X    timer->TEXCON |= (0x1ul << (7));
N}
N
N/**
N  * @brief This function is used to disable the counter pin detection de-bounce function.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_DisableEventCounterDebounce(TIMER_T *timer)
Xstatic __inline void TIMER_DisableEventCounterDebounce(TIMER_T *timer)
N{
N    timer->TEXCON &= ~TIMER_TEXCON_TCDB_Msk;
X    timer->TEXCON &= ~(0x1ul << (7));
N}
N
N/**
N  * @brief This function is used to enable the Timer time-out interrupt function.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_EnableInt(TIMER_T *timer)
Xstatic __inline void TIMER_EnableInt(TIMER_T *timer)
N{
N    timer->TCSR |= TIMER_TCSR_IE_Msk;
X    timer->TCSR |= (0x1ul << (29));
N}
N
N/**
N  * @brief This function is used to disable the Timer time-out interrupt function.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_DisableInt(TIMER_T *timer)
Xstatic __inline void TIMER_DisableInt(TIMER_T *timer)
N{
N    timer->TCSR &= ~TIMER_TCSR_IE_Msk;
X    timer->TCSR &= ~(0x1ul << (29));
N}
N
N/**
N  * @brief This function is used to enable the Timer capture trigger interrupt function.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_EnableCaptureInt(TIMER_T *timer)
Xstatic __inline void TIMER_EnableCaptureInt(TIMER_T *timer)
N{
N    timer->TEXCON |= TIMER_TEXCON_TEXIEN_Msk;
X    timer->TEXCON |= (0x1ul << (5));
N}
N
N/**
N  * @brief This function is used to disable the Timer capture trigger interrupt function.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_DisableCaptureInt(TIMER_T *timer)
Xstatic __inline void TIMER_DisableCaptureInt(TIMER_T *timer)
N{
N    timer->TEXCON &= ~TIMER_TEXCON_TEXIEN_Msk;
X    timer->TEXCON &= ~(0x1ul << (5));
N}
N
N/**
N  * @brief This function indicates Timer time-out interrupt occurred or not.
N  * @param[in] timer The base address of Timer module
N  * @return Timer time-out interrupt occurred or not
N  * @retval 0 Timer time-out interrupt did not occur
N  * @retval 1 Timer time-out interrupt occurred
N  */
N__STATIC_INLINE uint32_t TIMER_GetIntFlag(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetIntFlag(TIMER_T *timer)
N{
N    return(timer->TISR & TIMER_TISR_TIF_Msk ? 1 : 0);
X    return(timer->TISR & (0x1ul << (0)) ? 1 : 0);
N}
N
N/**
N  * @brief This function clears the Timer time-out interrupt flag.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_ClearIntFlag(TIMER_T *timer)
Xstatic __inline void TIMER_ClearIntFlag(TIMER_T *timer)
N{
N    timer->TISR = TIMER_TISR_TIF_Msk;
X    timer->TISR = (0x1ul << (0));
N}
N
N/**
N  * @brief This function indicates Timer capture interrupt occurred or not.
N  * @param[in] timer The base address of Timer module
N  * @return Timer capture interrupt occurred or not
N  * @retval 0 Timer capture interrupt did not occur
N  * @retval 1 Timer capture interrupt occurred
N  */
N__STATIC_INLINE uint32_t TIMER_GetCaptureIntFlag(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetCaptureIntFlag(TIMER_T *timer)
N{
N    return timer->TEXISR;
N}
N
N/**
N  * @brief This function clears the Timer capture interrupt flag.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_ClearCaptureIntFlag(TIMER_T *timer)
Xstatic __inline void TIMER_ClearCaptureIntFlag(TIMER_T *timer)
N{
N    timer->TEXISR = TIMER_TEXISR_TEXIF_Msk;
X    timer->TEXISR = (0x1ul << (0));
N}
N
N/**
N  * @brief This function indicates Timer has waked up system or not.
N  * @param[in] timer The base address of Timer module
N  * @return Timer has waked up system or not
N  * @retval 0 Timer did not wake up system
N  * @retval 1 Timer wake up system
N  */
N__STATIC_INLINE uint32_t TIMER_GetWakeupFlag(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetWakeupFlag(TIMER_T *timer)
N{
N    return (timer->TISR & TIMER_TISR_TWF_Msk ? 1 : 0);
X    return (timer->TISR & (0x1ul << (1)) ? 1 : 0);
N}
N
N/**
N  * @brief This function clears the Timer wakeup interrupt flag.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_ClearWakeupFlag(TIMER_T *timer)
Xstatic __inline void TIMER_ClearWakeupFlag(TIMER_T *timer)
N{
N    timer->TISR = TIMER_TISR_TWF_Msk;
X    timer->TISR = (0x1ul << (1));
N}
N
N/**
N  * @brief This function gets the Timer capture data.
N  * @param[in] timer The base address of Timer module
N  * @return Timer capture data value
N  */
N__STATIC_INLINE uint32_t TIMER_GetCaptureData(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetCaptureData(TIMER_T *timer)
N{
N    return timer->TCAP;
N}
N
N/**
N  * @brief This function reports the current timer counter value.
N  * @param[in] timer The base address of Timer module
N  * @return Timer counter value
N  */
N__STATIC_INLINE uint32_t TIMER_GetCounter(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetCounter(TIMER_T *timer)
N{
N    return timer->TDR;
N}
N
Nuint32_t TIMER_Open(TIMER_T *timer, uint32_t u32Mode, uint32_t u32Freq);
Nvoid TIMER_Close(TIMER_T *timer);
Nvoid TIMER_Delay(TIMER_T *timer, uint32_t u32Usec);
Nvoid TIMER_EnableCapture(TIMER_T *timer, uint32_t u32CapMode, uint32_t u32Edge);
Nvoid TIMER_DisableCapture(TIMER_T *timer);
Nvoid TIMER_EnableEventCounter(TIMER_T *timer, uint32_t u32Edge);
Nvoid TIMER_DisableEventCounter(TIMER_T *timer);
Nuint32_t TIMER_GetModuleClock(TIMER_T *timer);
N
N
N/*@}*/ /* end of group MINI51_TIMER_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group MINI51_TIMER_Driver */
N
N/*@}*/ /* end of group MINI51_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__TIMER_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 5958 "C:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.1.0\Device\Mini51\Include\Mini51Series.h" 2
N#include "uart.h"
L 1 "C:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.1.0\Device\Mini51\Driver\uart.h" 1
N/**************************************************************************//**
N * @file     UART.h
N * @version  V1.00
N * $Revision: 13 $
N * $Date: 15/09/25 10:11a $ 
N * @brief    Mini51 series UART driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/ 
N#ifndef __UART_H__
N#define __UART_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup MINI51_Device_Driver MINI51 Device Driver
N  @{
N*/
N
N/** @addtogroup MINI51_UART_Driver UART Driver
N  @{
N*/
N
N/** @addtogroup MINI51_UART_EXPORTED_CONSTANTS UART Exported Constants
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UA_FCR constants definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N
N#define UART_FCR_RFITL_1BYTE        (0x0 << UART_FCR_RFITL_Pos)   /*!< UA_FCR setting to set RX FIFO Trigger Level to 1 bit */
N#define UART_FCR_RFITL_4BYTES       (0x1 << UART_FCR_RFITL_Pos)   /*!< UA_FCR setting to set RX FIFO Trigger Level to 4 bits */
N#define UART_FCR_RFITL_8BYTES       (0x2 << UART_FCR_RFITL_Pos)   /*!< UA_FCR setting to set RX FIFO Trigger Level to 8 bits */
N#define UART_FCR_RFITL_14BYTES      (0x3 << UART_FCR_RFITL_Pos)   /*!< UA_FCR setting to set RX FIFO Trigger Level to 14 bits */
N
N#define UART_FCR_RTS_TRI_LEV_1BYTE        (0x0 << UART_FCR_RTS_TRI_LEV_Pos)  /*!< UA_FCR setting to set RTS Trigger Level to 1 bit */
N#define UART_FCR_RTS_TRI_LEV_4BYTES       (0x1 << UART_FCR_RTS_TRI_LEV_Pos)  /*!< UA_FCR setting to set RTS Trigger Level to 4 bits */
N#define UART_FCR_RTS_TRI_LEV_8BYTES       (0x2 << UART_FCR_RTS_TRI_LEV_Pos)  /*!< UA_FCR setting to set RTS Trigger Level to 8 bits */
N#define UART_FCR_RTS_TRI_LEV_14BYTES      (0x3 << UART_FCR_RTS_TRI_LEV_Pos)  /*!< UA_FCR setting to set RTS Trigger Level to 14 bits */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UA_LCR constants definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_WORD_LEN_5        (0) /*!< UA_LCR setting to set UART word length to 5 bits */
N#define UART_WORD_LEN_6        (1) /*!< UA_LCR setting to set UART word length to 6 bits */
N#define UART_WORD_LEN_7        (2) /*!< UA_LCR setting to set UART word length to 7 bits */
N#define UART_WORD_LEN_8        (3) /*!< UA_LCR setting to set UART word length to 8 bits */
N
N#define UART_PARITY_NONE    (0x0 << UART_LCR_PBE_Pos) /*!< UA_LCR setting to set UART as no parity   */
N#define UART_PARITY_ODD     (0x1 << UART_LCR_PBE_Pos) /*!< UA_LCR setting to set UART as odd parity  */
N#define UART_PARITY_EVEN    (0x3 << UART_LCR_PBE_Pos) /*!< UA_LCR setting to set UART as even parity */
N#define UART_PARITY_MARK    (0x5 << UART_LCR_PBE_Pos) /*!< UA_LCR setting to keep parity bit as '1'  */
N#define UART_PARITY_SPACE   (0x7 << UART_LCR_PBE_Pos) /*!< UA_LCR setting to keep parity bit as '0'  */
N
N#define UART_STOP_BIT_1     (0x0 << UART_LCR_NSB_Pos) /*!< UA_LCR setting for one stop bit  */
N#define UART_STOP_BIT_1_5   (0x1 << UART_LCR_NSB_Pos) /*!< UA_LCR setting for 1.5 stop bit when 5-bit word length  */
N#define UART_STOP_BIT_2     (0x1 << UART_LCR_NSB_Pos) /*!< UA_LCR setting for two stop bit when 6, 7, 8-bit word length */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART RTS LEVEL TRIGGER constants definitions                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_RTS_IS_HIGH_LEV_TRG    (0x1 << UART_MCR_LEV_RTS_Pos) /*!< Set RTS is High Level Trigger   */
N#define UART_RTS_IS_LOW_LEV_TRG     (0x0 << UART_MCR_LEV_RTS_Pos) /*!< Set RTS is Low Level Trigger    */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UA_FUNC_SEL constants definitions                                                                       */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_FUNC_SEL_UART    (0x0 << UART_FUN_SEL_FUN_SEL_Pos) /*!< UA_FUNC_SEL setting to set UART Function  (Default) */
N#define UART_FUNC_SEL_IrDA    (0x2 << UART_FUN_SEL_FUN_SEL_Pos) /*!< UA_FUNC_SEL setting to set IrDA Function            */
N#define UART_FUNC_SEL_RS485   (0x3 << UART_FUN_SEL_FUN_SEL_Pos) /*!< UA_FUNC_SEL setting to set RS485 Function           */
N
N
N/*@}*/ /* end of group MINI51_UART_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup MINI51_UART_EXPORTED_FUNCTIONS UART Exported Functions
N  @{
N*/
N
N/**
N *    @brief    Calculate UART baudrate mode0 divider
N *
N *    @param    None
N *    
N *    @return    UART baudrate mode0 register setting value
N *    
N */
N#define UART_BAUD_MODE0        (0)
N
N/**
N *    @brief    Calculate UART baudrate mode0 divider
N *
N *    @param    None
N *    
N *    @return    UART baudrate mode2 register setting value
N *    
N */
N#define UART_BAUD_MODE2        (UART_BAUD_DIV_X_EN_Msk | UART_BAUD_DIV_X_ONE_Msk)
N
N
N/**
N *    @brief    Calculate UART baudrate mode0 divider
N *
N *    @param    u32SrcFreq      UART clock frequency
N *    @param    u32BaudRate     Baudrate of UART module
N *    
N *    @return    UART baudrate mode0 divider
N *    
N */
N#define UART_BAUD_MODE0_DIVIDER(u32SrcFreq, u32BaudRate)    (((u32SrcFreq + (u32BaudRate*8)) / u32BaudRate >> 4)-2)
N
N/**
N *    @brief    Calculate UART baudrate mode2 divider
N *
N *    @param    u32SrcFreq    UART clock frequency
N *    @param    u32BaudRate    Baudrate of UART module
N *    
N *    @return    UART baudrate mode2 divider  
N */
N#define UART_BAUD_MODE2_DIVIDER(u32SrcFreq, u32BaudRate)    (((u32SrcFreq + (u32BaudRate/2)) / u32BaudRate)-2)     
N
N
N/**
N *    @brief    Write Data to Tx data register
N *
N *    @param    uart        The base address of UART module.
N *    @param    u8Data  Data byte to transmit 
N *                          
N *    @return    None
N */
N#define UART_WRITE(uart, u8Data)    (uart->THR = (u8Data))
N
N/**
N *    @brief    Read Rx data register
N *
N *    @param    uart        The base address of UART module. 
N *
N *    @return    The oldest data byte in RX FIFO 
N */
N#define UART_READ(uart)    (uart->RBR)
N
N
N/**
N *    @brief    Get Tx empty register value. 
N *
N *    @param    uart        The base address of UART module  
N *
N *    @return    Tx empty register value. 
N */
N#define UART_GET_TX_EMPTY(uart)    (uart->FSR & UART_FSR_TX_EMPTY_Msk) 
N
N
N/**
N *    @brief    Get Rx empty register value. 
N *
N *    @param    uart        The base address of UART module 
N * 
N *    @return    Rx empty register value.
N */
N#define UART_GET_RX_EMPTY(uart)    (uart->FSR & UART_FSR_RX_EMPTY_Msk) 
N
N/**
N *    @brief    Check specified uart port transmission is over. 
N *
N *    @param    uart        The base address of UART module 
N * 
N *    @return    TE_Flag.
N */
N#define UART_IS_TX_EMPTY(uart)    ((uart->FSR & UART_FSR_TE_FLAG_Msk) >> UART_FSR_TE_FLAG_Pos) 
N
N
N/**
N *    @brief    Wait specified uart port transmission is over 
N *
N *    @param    uart        The base address of UART module 
N *
N *    @return    None 
N */
N#define UART_WAIT_TX_EMPTY(uart)    while(!(((uart->FSR) & UART_FSR_TE_FLAG_Msk) >> UART_FSR_TE_FLAG_Pos))
N                                     
N/**
N *    @brief    Check RDA_IF is set or not
N *
N *    @param    uart        The base address of UART module 
N *
N *    @return     
N *            0 : The number of bytes in the RX FIFO is less than the RFITL  
N *            1 : The number of bytes in the RX FIFO equals or larger than RFITL
N */
N#define UART_IS_RX_READY(uart)    ((uart->ISR & UART_ISR_RDA_IF_Msk)>>UART_ISR_RDA_IF_Pos)
N
N
N/**
N *    @brief    Check TX FIFO is full or not 
N *
N *    @param    uart        The base address of UART module 
N *
N *    @return     
N *            1 = TX FIFO is full
N *            0 = TX FIFO is not full
N */
N#define UART_IS_TX_FULL(uart)    ((uart->FSR & UART_FSR_TX_FULL_Msk)>>UART_FSR_TX_FULL_Pos)
N
N/**
N *    @brief    Check RX FIFO is full or not 
N *
N *    @param    uart        The base address of UART module  
N *
N *    @return
N *            1 = RX FIFO is full
N *            0 = RX FIFO is not full
N *
N */
N#define UART_IS_RX_FULL(uart)    ((uart->FSR & UART_FSR_RX_FULL_Msk)>>UART_FSR_RX_FULL_Pos)
N
N
N/**
N *    @brief    Get Tx full register value 
N *
N *    @param    uart        The base address of UART module 
N *
N *    @return    Tx full register value 
N */
N#define UART_GET_TX_FULL(uart)    (uart->FSR & UART_FSR_TX_FULL_Msk)
N
N
N/**
N *    @brief    Get Rx full register value 
N *
N *    @param    uart        The base address of UART module 
N *
N *    @return    Rx full register value 
N */
N#define UART_GET_RX_FULL(uart)    (uart->FSR & UART_FSR_RX_FULL_Msk)
N
N
N/**
N *    @brief    Enable specified interrupt
N *
N *    @param    uart        The base address of UART module  
N *    @param    u32eIntSel    Interrupt type select 
N *                        - UART_IER_TIME_OUT_EN_Msk    : Rx Time Out interrupt
N *                        - UART_IER_WAKE_EN_Msk        : Wakeup interrupt
N *                        - UART_IER_BUF_ERR_IEN_Msk    : Buffer Error interrupt   
N *                        - UART_IER_RTO_IEN_Msk        : Rx time-out interrupt       
N *                        - UART_IER_MODEM_IEN_Msk    : Modem interrupt           
N *                        - UART_IER_RLS_IEN_Msk        : Rx Line status interrupt                              
N *                        - UART_IER_THRE_IEN_Msk        : Tx empty interrupt          
N *                        - UART_IER_RDA_IEN_Msk        : Rx ready interrupt           
N *
N *    @return    None                                                    
N */
N#define UART_ENABLE_INT(uart, u32eIntSel)    (uart->IER |= (u32eIntSel))
N
N
N/**
N *    @brief    Disable specified interrupt  
N *
N *    @param    uart        The base address of UART module 
N *    @param    u32eIntSel    Interrupt type select 
N *                        - UART_IER_TIME_OUT_EN_Msk    : Rx Time Out interrupt
N *                        - UART_IER_WAKE_EN_Msk           : Wakeup interrupt
N *                        - UART_IER_BUF_ERR_IEN_Msk    : Buffer Error interrupt   
N *                        - UART_IER_RTO_IEN_Msk         : Rx time-out interrupt       
N *                        - UART_IER_MODEM_IEN_Msk       : Modem interrupt           
N *                        - UART_IER_RLS_IEN_Msk         : Rx Line status interrupt                              
N *                        - UART_IER_THRE_IEN_Msk        : Tx empty interrupt          
N *                        - UART_IER_RDA_IEN_Msk         : Rx ready interrupt          
N *    @return    None                                                    
N */
N#define UART_DISABLE_INT(uart, u32eIntSel)    (uart->IER &= ~ (u32eIntSel))
N
N
N/**
N *    @brief    Get specified interrupt flag/status
N *
N *    @param    uart            The base address of UART module 
N *    @param    u32eIntTypeFlag    Interrupt Type Flag,should be   
N *                            - UART_IER_TIME_OUT_EN_Msk    : Rx Time Out interrupt
N *                            - UART_IER_WAKE_EN_Msk           : Wakeup interrupt
N *                            - UART_IER_BUF_ERR_IEN_Msk    : Buffer Error interrupt   
N *                            - UART_IER_RTO_IEN_Msk         : Rx time-out interrupt       
N *                            - UART_IER_MODEM_IEN_Msk       : Modem interrupt           
N *                            - UART_IER_RLS_IEN_Msk         : Rx Line status interrupt                              
N *                            - UART_IER_THRE_IEN_Msk        : Tx empty interrupt          
N *                            - UART_IER_RDA_IEN_Msk         : Rx ready interrupt      
N *
N *    @return
N *            0 = The specified interrupt is not happened. 
N *            1 = The specified interrupt is happened.                                                      
N */                                                                                      
N#define UART_GET_INT_FLAG(uart,u32eIntTypeFlag)    ((uart->ISR & (u32eIntTypeFlag))?1:0)
N
N
N/**
N *    @brief    Set RTS pin is low
N *
N *    @param    uart        The base address of UART module 
N *    @return    None
N */ 
N__INLINE void UART_CLEAR_RTS(UART_T* uart)  
X__inline void UART_CLEAR_RTS(UART_T* uart)  
N{
N    uart->MCR |= UART_MCR_LEV_RTS_Msk;
X    uart->MCR |= (0x1ul << (9));
N    uart->MCR &= ~UART_MCR_RTS_Msk;
X    uart->MCR &= ~(0x1ul << (1));
N}
N
N/**
N *    @brief    Set RTS pin is high
N *
N *    @param    uart        The base address of UART module 
N *    @return    None
N */ 
N__INLINE void UART_SET_RTS(UART_T* uart)
X__inline void UART_SET_RTS(UART_T* uart)
N{
N    uart->MCR |= UART_MCR_LEV_RTS_Msk | UART_MCR_RTS_Msk;
X    uart->MCR |= (0x1ul << (9)) | (0x1ul << (1));
N}
N
N/**
N *	@brief	Clear RS-485 Address Byte Detection Flag
N *
N *	@param	uart	The base address of UART module 
N *	@return	None
N */                                                                                                                                 
N#define UART_RS485_CLEAR_ADDR_FLAG(uart)    (uart->FSR  |= UART_FSR_RS485_ADD_DETF_Msk)
N
N
N/**
N *    @brief    Get RS-485 Address Byte Detection Flag
N *
N *    @param    uart        The base address of UART module 
N *    @return    RS-485 Address Byte Detection Flag
N */    
N#define UART_RS485_GET_ADDR_FLAG(uart)    ((uart->FSR  & UART_FSR_RS485_ADD_DETF_Msk) >> UART_FSR_RS485_ADD_DETF_Pos)
N
N
Nvoid UART_ClearIntFlag(UART_T* uart , uint32_t u32InterruptFlag);
Nvoid UART_Close(UART_T* uart );
Nvoid UART_DisableFlowCtrl(UART_T* uart );
Nvoid UART_DisableInt(UART_T*  uart, uint32_t u32InterruptFlag );
Nvoid UART_EnableFlowCtrl(UART_T* uart );
Nvoid UART_EnableInt(UART_T*  uart, uint32_t u32InterruptFlag );
Nvoid UART_Open(UART_T* uart, uint32_t u32baudrate);
Nuint32_t UART_Read(UART_T* uart, uint8_t *pu8RxBuf, uint32_t u32ReadBytes);
Nvoid UART_SetLine_Config(UART_T* uart, uint32_t u32baudrate, uint32_t u32data_width, uint32_t u32parity, uint32_t  u32stop_bits);
Nvoid UART_SetTimeoutCnt(UART_T* uart, uint32_t u32TOC);
Nvoid UART_SelectIrDAMode(UART_T* uart, uint32_t u32Buadrate, uint32_t u32Direction);
Nvoid UART_SelectRS485Mode(UART_T* uart, uint32_t u32Mode, uint32_t u32Addr);
Nuint32_t UART_Write(UART_T* uart,uint8_t *pu8TxBuf, uint32_t u32WriteBytes);
N
N
N/*@}*/ /* end of group MINI51_UART_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group MINI51_UART_Driver */
N
N/*@}*/ /* end of group MINI51_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__UART_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
N
N
N
N
N
N
N
N
L 5959 "C:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.1.0\Device\Mini51\Include\Mini51Series.h" 2
N#include "wdt.h"
L 1 "C:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.1.0\Device\Mini51\Driver\wdt.h" 1
N/**************************************************************************//**
N * @file     wdt.h
N * @version  V1.00
N * $Revision: 7 $
N * $Date: 14/01/14 5:29p $ 
N * @brief    Mini51 series WDT driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/ 
N#ifndef __WDT_H__
N#define __WDT_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup MINI51_Device_Driver MINI51 Device Driver
N  @{
N*/
N
N/** @addtogroup MINI51_WDT_Driver WDT Driver
N  @{
N*/
N
N/** @addtogroup MINI51_WDT_EXPORTED_CONSTANTS WDT Exported Constants
N  @{
N*/
N#define WDT_TIMEOUT_2POW4          (0UL << WDT_WTCR_WTIS_Pos) /*!< WDT setting for timeout interval = 2^4 * WDT clocks */
N#define WDT_TIMEOUT_2POW6          (1UL << WDT_WTCR_WTIS_Pos) /*!< WDT setting for timeout interval = 2^6 * WDT clocks */
N#define WDT_TIMEOUT_2POW8          (2UL << WDT_WTCR_WTIS_Pos) /*!< WDT setting for timeout interval = 2^8 * WDT clocks */
N#define WDT_TIMEOUT_2POW10         (3UL << WDT_WTCR_WTIS_Pos) /*!< WDT setting for timeout interval = 2^10 * WDT clocks */
N#define WDT_TIMEOUT_2POW12         (4UL << WDT_WTCR_WTIS_Pos) /*!< WDT setting for timeout interval = 2^12 * WDT clocks */
N#define WDT_TIMEOUT_2POW14         (5UL << WDT_WTCR_WTIS_Pos) /*!< WDT setting for timeout interval = 2^14 * WDT clocks */
N#define WDT_TIMEOUT_2POW16         (6UL << WDT_WTCR_WTIS_Pos) /*!< WDT setting for timeout interval = 2^16 * WDT clocks */
N#define WDT_TIMEOUT_2POW18         (7UL << WDT_WTCR_WTIS_Pos) /*!< WDT setting for timeout interval = 2^18 * WDT clocks */
N
N/*@}*/ /* end of group MINI51_WDT_EXPORTED_CONSTANTS */
N    
N    
N/** @addtogroup MINI51_WDT_EXPORTED_FUNCTIONS WDT Exported Functions
N  @{
N*/
N
N/** 
N  * @brief This macro clear WDT time-out reset system flag. 
N  * \hideinitializer
N  */
N#define WDT_CLEAR_RESET_FLAG()  (WDT->WTCR = (WDT->WTCR & ~(WDT_WTCR_WTIF_Msk | WDT_WTCR_WTWKF_Msk)) | WDT_WTCR_WTRF_Msk)
N
N/** 
N  * @brief This macro clear WDT time-out interrupt flag. 
N  * \hideinitializer
N  */
N#define WDT_CLEAR_TIMEOUT_INT_FLAG() (WDT->WTCR = (WDT->WTCR & ~(WDT_WTCR_WTRF_Msk | WDT_WTCR_WTWKF_Msk)) | WDT_WTCR_WTIF_Msk)
N
N/** 
N  * @brief This macro clear WDT time-out wake-up system flag. 
N  * \hideinitializer
N  */
N#define WDT_CLEAR_TIMEOUT_WAKEUP_FLAG() (WDT->WTCR = (WDT->WTCR & ~(WDT_WTCR_WTRF_Msk | WDT_WTCR_WTIF_Msk)) | WDT_WTCR_WTWKF_Msk)
N
N/** 
N  * @brief This macro indicate WDT time-out to reset system or not.
N  * @return WDT reset system or not
N  * @retval 0 WDT did not cause system reset
N  * @retval 1 WDT caused system reset 
N  * \hideinitializer
N  */
N#define WDT_GET_RESET_FLAG() (WDT->WTCR & WDT_WTCR_WTRF_Msk ? 1 : 0)
N
N/** 
N  * @brief This macro indicate WDT time-out interrupt occurred or not.
N  * @return WDT time-out interrupt occurred or not
N  * @retval 0 WDT time-out interrupt did not occur
N  * @retval 1 WDT time-out interrupt occurred 
N  * \hideinitializer
N  */
N#define WDT_GET_TIMEOUT_INT_FLAG() (WDT->WTCR & WDT_WTCR_WTIF_Msk ? 1 : 0)
N
N/** 
N  * @brief This macro indicate WDT time-out waked system up or not
N  * @return WDT time-out waked system up or not
N  * @retval 0 WDT did not wake up system
N  * @retval 1 WDT waked up system
N  * \hideinitializer
N  */
N#define WDT_GET_TIMEOUT_WAKEUP_FLAG() (WDT->WTCR & WDT_WTCR_WTWKF_Msk ? 1 : 0)
N
N/** 
N  * @brief This macro is used to reset 18-bit WDT counter.
N  * @details If WDT is activated and enabled to reset system, software must reset WDT counter 
N  *  before WDT time-out plus reset delay reached. Or WDT generate a reset signal.
N  * \hideinitializer
N  */
N#define WDT_RESET_COUNTER() (WDT->WTCR  = (WDT->WTCR & ~(WDT_WTCR_WTIF_Msk | WDT_WTCR_WTWKF_Msk | WDT_WTCR_WTRF_Msk)) | WDT_WTCR_WTR_Msk)
N
N
Nvoid  WDT_Open(uint32_t u32TimeoutInterval,
N                  uint32_t u32ResetDelay,
N                  uint32_t u32EnableReset,
N                  uint32_t u32EnableWakeup);  
Nvoid WDT_Close(void);
N
Nvoid WDT_EnableInt(void);
Nvoid WDT_DisableInt(void);
N
N/*@}*/ /* end of group MINI51_WDT_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group MINI51_WDT_Driver */
N
N/*@}*/ /* end of group MINI51_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__WDT_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 5960 "C:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.1.0\Device\Mini51\Include\Mini51Series.h" 2
N
N#endif  // __MINI51SERIES_H__
N
N/*** (C) COPYRIGHT 2013-2016 Nuvoton Technology Corp. ***/
L 5 "User\global.h" 2
N
N#define WHAT_EVER_DO_NOT_CARE		1
N
N#define DEBUG_ACMP_OUT_PORT			P3
N#define DEBUG_ACMP_OUT_PIN			BIT6
N#define DEBUG_GPIO_PORT					P5
N#define DEBUG_GPIO_PIN					BIT0
N#define DEBUG_TX_PORT						P0
N#define DEBUG_TX_PIN						BIT0
N#define DEBUG_RX_PORT						P1
N#define DEBUG_RX_PIN						BIT2
N#define LOW_REG_CLR_MASK				0xFFFF0000
N#define HIGH_REG_CLR_MASK				0x0000FFFF
N
N#define TIMER_INVALID_CNT 		0xFFFFFFFF
N#define BIT_MASK							0x00000001
N
N//#define unSystemTick 				SysTick->VAL
N
N#define SET           			(1)     
N#define RESET          			(0)      
N
N#define INDEX_INCREASE(INDEX, MAX)	((INDEX) = (((INDEX) < ((MAX) - 1)) ? ((INDEX) + 1) : 0))
N
Nextern __IO uint32_t unSystemTick;
Xextern volatile uint32_t unSystemTick;
N
Ntypedef struct {
N	__IO uint16_t unNULL;
X	volatile uint16_t unNULL;
N	struct {
N		__IO uint16_t bMotorNeedToRun :1;
X		volatile uint16_t bMotorNeedToRun :1;
N		__IO uint16_t bRotateDirection :1;
X		volatile uint16_t bRotateDirection :1;
N	} MCR;
N	struct {
N		__IO uint16_t bMotorPowerOn :1;
X		volatile uint16_t bMotorPowerOn :1;
N		__IO uint16_t bZeroCrossDetecting :1;
X		volatile uint16_t bZeroCrossDetecting :1;
N		__IO uint16_t bLocked :1;
X		volatile uint16_t bLocked :1;
N		__IO uint16_t bThisPhaseDetectedZX :1;
X		volatile uint16_t bThisPhaseDetectedZX :1;
N		__IO uint16_t bNewComFrameReceived :1;
X		volatile uint16_t bNewComFrameReceived :1;
N	} MSR;
N	__IO uint16_t unMissedZXD_CNT;
X	volatile uint16_t unMissedZXD_CNT;
N	__IO uint16_t unSuccessZXD_CNT;
X	volatile uint16_t unSuccessZXD_CNT;
N	__IO uint16_t unLocatingDuty; /*!<  PWM Locating Duty  */
X	volatile uint16_t unLocatingDuty;  
N	__IO uint16_t unRampUpDuty; /*!<  PWM Ramp Up Start Duty  */
X	volatile uint16_t unRampUpDuty;  
N	__IO uint16_t unTargetDuty; /*!<  PWM Target (Locked State) Duty  */
X	volatile uint16_t unTargetDuty;  
N	__IO uint16_t unActualDuty; /*!<  PWM Actual Duty  */
X	volatile uint16_t unActualDuty;  
N	__IO uint16_t unLocatingPeriod; /*!<  Locating State One Phase Period  */
X	volatile uint16_t unLocatingPeriod;  
N	__IO uint16_t unSpeedADC; /*!<  ADC read data, used to determine Target Duty */
X	volatile uint16_t unSpeedADC;  
N	__IO uint16_t unReserved1; /*!<  For 4 bytes alignment */
X	volatile uint16_t unReserved1;  
N	__IO uint32_t unRampUpPeriod; /*!<  Ramp Up Start One Phase Period  */
X	volatile uint32_t unRampUpPeriod;  
N	__IO uint32_t unActualPeriod; /*!<  Actual One Phase Period  */
X	volatile uint32_t unActualPeriod;  
N	__IO uint32_t unPhaseChangeCNT; /*!<  Phase changed counter  */
X	volatile uint32_t unPhaseChangeCNT;  
N	__IO uint16_t unRPM; /*!<  Actual RPM  */
X	volatile uint16_t unRPM;  
N	__IO uint16_t unBattery; /*!<  Battery Voltage  */
X	volatile uint16_t unBattery;  
N	__IO uint16_t unCurrent; /*!<  Current  */
X	volatile uint16_t unCurrent;  
N	__IO uint16_t unReserved2; /*!<  For 4 bytes alignment  */
X	volatile uint16_t unReserved2;  
N	__IO uint32_t unCommOK_CNT; /*!<  Communication OK number */
X	volatile uint32_t unCommOK_CNT;  
N	__IO uint32_t unCommErrCNT; /*!<  Communication error number */
X	volatile uint32_t unCommErrCNT;  
N} MOTOR_T;
N
Ntypedef union {
N	uint16_t unValue[sizeof(MOTOR_T) / sizeof(uint16_t)];
N	MOTOR_T structMotor;
N} MOTOR_UNION_T;
N
N#include "BLDCSensorLess.h"
L 1 "User\BLDCSensorLess.h" 1
N#ifndef __BLDC_SENSOR_LESS_H__
N#define __BLDC_SENSOR_LESS_H__
N
N#include "global.h"
L 1 "User\global.h" 1
N#ifndef __GLOBAL_H__
S#define __GLOBAL_H__
S
S#include "Mini51Series.h"
S
S#define WHAT_EVER_DO_NOT_CARE		1
S
S#define DEBUG_ACMP_OUT_PORT			P3
S#define DEBUG_ACMP_OUT_PIN			BIT6
S#define DEBUG_GPIO_PORT					P5
S#define DEBUG_GPIO_PIN					BIT0
S#define DEBUG_TX_PORT						P0
S#define DEBUG_TX_PIN						BIT0
S#define DEBUG_RX_PORT						P1
S#define DEBUG_RX_PIN						BIT2
S#define LOW_REG_CLR_MASK				0xFFFF0000
S#define HIGH_REG_CLR_MASK				0x0000FFFF
S
S#define TIMER_INVALID_CNT 		0xFFFFFFFF
S#define BIT_MASK							0x00000001
S
S//#define unSystemTick 				SysTick->VAL
S
S#define SET           			(1)     
S#define RESET          			(0)      
S
S#define INDEX_INCREASE(INDEX, MAX)	((INDEX) = (((INDEX) < ((MAX) - 1)) ? ((INDEX) + 1) : 0))
S
Sextern __IO uint32_t unSystemTick;
S
Stypedef struct {
S	__IO uint16_t unNULL;
S	struct {
S		__IO uint16_t bMotorNeedToRun :1;
S		__IO uint16_t bRotateDirection :1;
S	} MCR;
S	struct {
S		__IO uint16_t bMotorPowerOn :1;
S		__IO uint16_t bZeroCrossDetecting :1;
S		__IO uint16_t bLocked :1;
S		__IO uint16_t bThisPhaseDetectedZX :1;
S		__IO uint16_t bNewComFrameReceived :1;
S	} MSR;
S	__IO uint16_t unMissedZXD_CNT;
S	__IO uint16_t unSuccessZXD_CNT;
S	__IO uint16_t unLocatingDuty; /*!<  PWM Locating Duty  */
S	__IO uint16_t unRampUpDuty; /*!<  PWM Ramp Up Start Duty  */
S	__IO uint16_t unTargetDuty; /*!<  PWM Target (Locked State) Duty  */
S	__IO uint16_t unActualDuty; /*!<  PWM Actual Duty  */
S	__IO uint16_t unLocatingPeriod; /*!<  Locating State One Phase Period  */
S	__IO uint16_t unSpeedADC; /*!<  ADC read data, used to determine Target Duty */
S	__IO uint16_t unReserved1; /*!<  For 4 bytes alignment */
S	__IO uint32_t unRampUpPeriod; /*!<  Ramp Up Start One Phase Period  */
S	__IO uint32_t unActualPeriod; /*!<  Actual One Phase Period  */
S	__IO uint32_t unPhaseChangeCNT; /*!<  Phase changed counter  */
S	__IO uint16_t unRPM; /*!<  Actual RPM  */
S	__IO uint16_t unBattery; /*!<  Battery Voltage  */
S	__IO uint16_t unCurrent; /*!<  Current  */
S	__IO uint16_t unReserved2; /*!<  For 4 bytes alignment  */
S	__IO uint32_t unCommOK_CNT; /*!<  Communication OK number */
S	__IO uint32_t unCommErrCNT; /*!<  Communication error number */
S} MOTOR_T;
S
Stypedef union {
S	uint16_t unValue[sizeof(MOTOR_T) / sizeof(uint16_t)];
S	MOTOR_T structMotor;
S} MOTOR_UNION_T;
S
S#include "BLDCSensorLess.h"
S#include "Communication.h"
S#include "Error.h"
S#include "Protection.h"
N#endif 
L 5 "User\BLDCSensorLess.h" 2
N
Ntypedef enum {
N	ENUM_TIM1_AVOID_ZXD = 0, ENUM_TIM1_ZXD_FILTER //,
N//		ENUM_TIM1_START_ZXD
N} ENUM_TIM1_USAGE;
N
N// GPIOs
N#define BRG_FAULT_PORT				P3
N#define BRG_FAULT_PIN_NUM			2
N#define BRG_FAULT_PIN				BIT2
N#define BRG_EN_PORT					P3
N#define BRG_EN_PIN					BIT0
N#define BRG_ENABLE					(P30 = 1)
N#define BRG_DISABLE					(P30 = 0)
N
N//	#define ACMP0_FALLING_ENABLE		(ACMP->CMPCR[0] = ACMP_CMPCR_FALLING_Msk | ACMP_CMPCR_HYSEN_Msk | ACMP_CMPCR_ACMPIE_Msk | ACMP_CMPCR_ACMPEN_Msk)
N//	#define ACMP0_RISING_ENABLE			(ACMP->CMPCR[0] = ACMP_CMPCR_RISING_Msk | ACMP_CMPCR_HYSEN_Msk | ACMP_CMPCR_ACMPIE_Msk | ACMP_CMPCR_ACMPEN_Msk)
N//	#define ACMP0_EDGE_SELECT			((PWM->PHCHG & DETEC_UP) ? (ACMP_CMPCR_RISING_Msk) : (ACMP_CMPCR_FALLING_Msk))
N#define DETEC_UP_POS				7
N#define DETEC_UP					(1ul << DETEC_UP_POS)
N#define ACMP0_EDGE_MATCH			(((PWM->PHCHG & DETEC_UP) >> DETEC_UP_POS) == (( ACMP->CMPSR & ACMP_CMPSR_ACMPCO0_Msk) >> ACMP_CMPSR_ACMPCO0_Pos))
N#define ACMP0_ENABLE				(ACMP->CMPCR[0] |= ACMP_CMPCR_HYSEN_Msk | ACMP_CMPCR_ACMPEN_Msk)
N#define ACMP0_INT_ENABLE			(ACMP->CMPCR[0] |= ACMP_CMPCR_ACMPIE_Msk)
N#define ACMP0_INT_DISABLE			(ACMP->CMPCR[0] &= (~ACMP_CMPCR_ACMPIE_Msk))
N#define AVOID_ZXD_AFTER_PHCHG		160	// 160/2M = 80us
N#define ZXD_FILTER_TIME				200	// 200/2M = 100us
N#define CALC_TIME_BT_ZXD_SET_TIM	60	// calculation time between after confirmed ZX and set TIMER0
N#define TIME_DEBT					(ZXD_FILTER_TIME + CALC_TIME_BT_ZXD_SET_TIM)	// Included ZXD filter time and calculation time between after confirmed ZX and set TIMER0
N#define ZXD_BEFORE_PHCHG			50	// 50/2M = 25us	// If it already need change phase when ZX was confirmed ZX, give some time to TIM0 to response
N#define ACMP_HYS_AVG_TIME			20	// Average Hysteresis time 20/2M = 10us
N#define MIN_PHASE_TIME				500	//(AVOID_ZXD_AFTER_PHCHG + ZXD_FILTER_TIME + 100)	// 1200/2M=0.6ms, 8333RPM if 42PC=1MC==7EC
N#define MAX_PHASE_TIME				(10000)	// Unit 2MH, 5ms, 286rpm if 42PC=1MC==7EC
N
N#define MINI51_TIM_CNT_MAX				0xFFFFFF
N#define GET_TIM1_CMP_VALUE(x)			(((x) >= MINI51_TIM_CNT_MAX) ? ((x) - MINI51_TIM_CNT_MAX) : (x))
N#define GET_TIMER_DIFF(iLast, iThis)	(((iThis) > (iLast)) ? ((iThis) - (iLast)) : ((iThis) + (MINI51_TIM_CNT_MAX - (iLast))))
N#define MAX_MISS_ZXD_THRESHOLD			12
N#define MIN_SUCC_ZXD_THRESHOLD			4
N
N#define MOSFET_DRV_0_4_PORT			P2
N#define MOSFET_DRV_5_PORT			P0
N#define MOSFET_DRV_0_PIN			BIT2
N#define MOSFET_DRV_1_PIN			BIT3
N#define MOSFET_DRV_2_PIN			BIT4
N#define MOSFET_DRV_3_PIN			BIT5
N#define MOSFET_DRV_4_PIN			BIT6
N#define MOSFET_DRV_5_PIN			BIT4
N
N#define MOSFET_AS_PIN_ADDR		(P22)
N#define MOSFET_BS_PIN_ADDR		(P24)
N#define MOSFET_CS_PIN_ADDR		(P26)
N#define MOSFET_AD_PIN_ADDR		(P23)
N#define MOSFET_BD_PIN_ADDR		(P25)
N#define MOSFET_CD_PIN_ADDR		(P04)
N
N#define GPIO_OFFD_OFF_SET		16
N#define ZERO_DETECT_PORT		P1
N#define ZERO_DETECT_A_PIN		((uint32_t)BIT0)
N#define ZERO_DETECT_B_PIN		((uint32_t)BIT3)
N#define ZERO_DETECT_C_PIN		((uint32_t)BIT5)
N#define ZERO_DETECT_M_PIN		((uint32_t)BIT4)
N
N#define PWM_PHCHG_PWM_MASK		(0x00003F00ul)
N#define PWM_PHCHG_D0_7_MASK		(0x000000FFul)
N#define PWM_PERIOD 				(884-1)	// PWM T=0.08ms, if target is 3K PRM, 42 E-Circle per M-Circle,
N// each PC should less than 0.5 ms.
N// So each E-Circle at least has 6 PWM circle
N
N#define ROTATE_CLOCKWISE		0
N#define ROTATE_ANTICLOCKWISE	1
N
N#define PWM_INT_ENABLE			(PWM_EnableDutyInt(PWM, 1, WHAT_EVER_DO_NOT_CARE))
N
N#define PWM_INT_DISABLE			(PWM->PIER = 0)
N
N#define IS_PWM_IRQ_ENABLED		(PWM->PIER)
N
N// To increase shut down speed we can just directly write a constant number into PHCHG register
N// But since we also have protection form driver IC, it is not so critical here
N// So better just shut down, not change other bit in the register
N// First write PHCHGNXT because between write PHCHG and PHCHGNXT time, PHCHG may be updated by PHCHGNXT
N//#define	MOSFET_ALL_OFF			(PWM->PHCHGNXT = (PWM->PHCHGNXT & (~PWM_PHCHG_PWM_MASK)) | PWM_PHCHG_D0_7_MASK); /
N//								(PWM->PHCHG = (PWM->PHCHG & (~PWM_PHCHG_PWM_MASK)) | PWM_PHCHG_D0_7_MASK);
N// After shut down all MOSFET you need to re-initialize all PHCHG register bits
N#define MOSFET_SHUT_DOWN_VAL		(0x000000FFul)
N#define	MOTOR_SHUT_DOWN				BRG_DISABLE; \
N									PWM_INT_DISABLE; \
N									(TIMER_Stop(TIMER0)); \
N									(TIMER_Stop(TIMER1)); \
N									(TIMER_DisableInt(TIMER0)); \
N									(TIMER_DisableInt(TIMER1)); \
N									(PWM->PHCHGNXT = MOSFET_SHUT_DOWN_VAL); \
N									(PWM->PHCHG = MOSFET_SHUT_DOWN_VAL)
X#define	MOTOR_SHUT_DOWN				BRG_DISABLE; 									PWM_INT_DISABLE; 									(TIMER_Stop(TIMER0)); 									(TIMER_Stop(TIMER1)); 									(TIMER_DisableInt(TIMER0)); 									(TIMER_DisableInt(TIMER1)); 									(PWM->PHCHGNXT = MOSFET_SHUT_DOWN_VAL); 									(PWM->PHCHG = MOSFET_SHUT_DOWN_VAL)
N
N//(ACMP->CMPCR[0] &= ~(ACMP_CMPCR_ACMPIE_Msk | ACMP_CMPCR_ACMPEN_Msk));
N#define MOTOR_SET_DUTY(x)			(PWM->CMR[1] = (x)); \
N									(PWM->CMR[3] = (x)); \
N									(PWM->CMR[5] = (x))
X#define MOTOR_SET_DUTY(x)			(PWM->CMR[1] = (x)); 									(PWM->CMR[3] = (x)); 									(PWM->CMR[5] = (x))
N//#define MOTOR_SET_DUTY(x)			(PWM->CMR[0] = (x)); \
N//									(PWM->CMR[2] = (x)); \
N//									(PWM->CMR[4] = (x))
X
N//#define MOTOR_SET_DUTY(x)			(PWM->CMR[0] = (x)); \
N//									(PWM->CMR[1] = (x)); \
N//									(PWM->CMR[2] = (x)); \
N//									(PWM->CMR[3] = (x)); \
N//									(PWM->CMR[4] = (x)); \
N//									(PWM->CMR[5] = (x))
X
N
N#ifdef __USED_BY_BLDC_SENSOR_LESS_C__
S#define EXTERNAL_BLDC
S
S// UP side PWM
S#define PHASE_AB_PIN      		(0x0239ul)	// 0000 0010 0011 1001
S#define PHASE_AC_PIN     		(0x022Dul)	// 0000 0010 0010 1101
S#define PHASE_BC_PIN     		(0x0827ul)	// 0000 1000 0010 0111
S#define PHASE_BA_PIN      		(0x0836ul)  // 0000 1000 0011 0110
S#define PHASE_CA_PIN           	(0x201Eul)  // 0010 0000 0001 1110
S#define PHASE_CB_PIN			(0x201Bul)	// 0010 0000 0001 1011
S
S// Down side PWM
S//		#define PHASE_AB_PIN      		(0x0439ul)	// 0000 0100 0011 1001
S//		#define PHASE_AC_PIN     		(0x102Dul)	// 0001 0000 0010 1101
S//		#define PHASE_BC_PIN     		(0x1027ul)	// 0001 0000 0010 0111
S//		#define PHASE_BA_PIN      		(0x0136ul)  // 0000 0001 0011 0110
S//		#define PHASE_CA_PIN           	(0x011Eul)  // 0000 0001 0001 1110
S//		#define PHASE_CB_PIN			(0x041Bul)	// 0000 0100 0001 1011
S
S// Both sides PWM
S//		#define PHASE_AB_PIN      		(0x0339ul)	// 0000 0110 0011 1001
S//		#define PHASE_AC_PIN     		(0x122Dul)	// 0001 0010 0010 1101
S//		#define PHASE_BC_PIN     		(0x1827ul)	// 0001 1000 0010 0111
S//		#define PHASE_BA_PIN      		(0x0936ul)  // 0000 1001 0011 0110
S//		#define PHASE_CA_PIN           	(0x211Eul)  // 0010 0001 0001 1110
S//		#define PHASE_CB_PIN			(0x241Bul)	// 0010 0100 0001 1011
S//													//
S#define CMP0_PIN_P13			0x30000000  // P13 is selected as CMPP0 pin.
S#define CMP0_PIN_P12			0x20000000  // P12 is selected as CMPP0 pin.
S#define CMP0_PIN_P10			0x10000000  // P10 is selected as CMPP0 pin.
S#define CMP0_PIN_P15			0x00000000  // P15 is selected as CMPP0 pin.
S
Sconst uint32_t PHASE_TAB_CLOCKWISE[] = {
S	PWM_PHCHG_T0_Msk | CMP0_PIN_P15 | PHASE_AB_PIN,
S	PWM_PHCHG_T0_Msk | CMP0_PIN_P13 | PHASE_AC_PIN | DETEC_UP,
S	PWM_PHCHG_T0_Msk | CMP0_PIN_P10 | PHASE_BC_PIN,
S	PWM_PHCHG_T0_Msk | CMP0_PIN_P15 | PHASE_BA_PIN | DETEC_UP,
S	PWM_PHCHG_T0_Msk | CMP0_PIN_P13 | PHASE_CA_PIN,
S	PWM_PHCHG_T0_Msk | CMP0_PIN_P10 | PHASE_CB_PIN | DETEC_UP
S//			PWM_PHCHG_T0_Msk | CMP0_PIN_P15 | PHASE_AB_PIN | DETEC_UP,
S//			PWM_PHCHG_T0_Msk | CMP0_PIN_P13 | PHASE_AC_PIN,
S//			PWM_PHCHG_T0_Msk | CMP0_PIN_P10 | PHASE_BC_PIN | DETEC_UP,
S//			PWM_PHCHG_T0_Msk | CMP0_PIN_P15 | PHASE_BA_PIN,
S//			PWM_PHCHG_T0_Msk | CMP0_PIN_P13 | PHASE_CA_PIN | DETEC_UP,
S//			PWM_PHCHG_T0_Msk | CMP0_PIN_P10 | PHASE_CB_PIN
S};
Sconst uint32_t PHASE_TAB_ANTICLOCKWISE[] = {
S	PWM_PHCHG_T0_Msk | CMP0_PIN_P15 | PHASE_AB_PIN | DETEC_UP,
S	PWM_PHCHG_T0_Msk | CMP0_PIN_P10 | PHASE_CB_PIN ,
S	PWM_PHCHG_T0_Msk | CMP0_PIN_P13 | PHASE_CA_PIN | DETEC_UP,
S	PWM_PHCHG_T0_Msk | CMP0_PIN_P15 | PHASE_BA_PIN ,
S	PWM_PHCHG_T0_Msk | CMP0_PIN_P10 | PHASE_BC_PIN | DETEC_UP,
S	PWM_PHCHG_T0_Msk | CMP0_PIN_P13 | PHASE_AC_PIN
S};
S
Stypedef enum {
S	MOTOR_IDLE = 0,
S//			MOTOR_STOP, 
S	MOTOR_START,// if not already rotating then just jumo to MOTOR_LOCATE
S	MOTOR_LOCATE,
S	MOTOR_WAIT_AFTER_LOCATE,
S	MOTOR_RAMPUP_WO_ZXD,
S	MOTOR_RAMPUP_W_ZXD,
S	MOTOR_LOCKED
S}ENUM_MOTOR_STATE;
S
Stypedef enum {
S	DETECT_START = 0,
S	DETECT_PHASE_1_P,
S	DETECT_PHASE_1_A,
S	DETECT_PHASE_2_P,
S	DETECT_PHASE_2_A,
S	DETECT_PHASE_3_P,
S	DETECT_PHASE_3_A
S}ENUM_ROTATE_DETECT_STATE;
S
S//		typedef enum {
S//			ENUM_MOTOR_POWER_ON = 0,
S//			ENUM_MOTOR_ZX_DETECTING,
S//			ENUM_MOTOR_LOCKED
S//		}ENUM_MOTOR_SR_BIT;
S
Stypedef enum {
S	STATUS_ERROR = 0,
S	STATUS_FINISHED,
S	STATUS_WORKING = 0xFFFF
S}ENUM_STATUS;
S
Sconst uint8_t unLocatePhaseSequencyTable[] = {0, 1, 2, 1};
S
S#define IS_ROTATING_DETECTING							0xFFFF
S#define MAX_ROTATING_DETECT_PHASE_TIME					30	// half phase max 30ms
S#define MAX_ALREADY_ROTATING_DETECT_TIME				200	// 200ms used to detect is motor is already rotating
S#define RAMP_UP_MIN_PERIOD_NUM_THRS						300	// After ramp up to minimum period, force continue rotate these phases
S#define CHANGE_DT_PR_AFTER_PHASE_CHANGED_NUM			9		// Used in ramp up
S#define CHANGE_DUTY_AFTER_PHASE_CHANGED_NUM				5		// Used after locked
S
S//		#define MOTOR_RUNNING_MSK					(0x01ul)
S//		#define MOTOR_R_DIRECTION_MSK				(0x02ul)
S//		#define IS_MOTOR_NEED_TO_RUN(x)				((x) & MOTOR_RUNNING_MSK)
S
S//		#define IS_MOTOR_R_CLOCKWISE				(((tMotor.structMotor.MCR & MOTOR_R_DIRECTION_MSK) == 0) ? TRUE : FALSE)
S#define GET_PHASE_VALUE(x)					((tMotor.structMotor.MCR.bRotateDirection == ROTATE_CLOCKWISE) ? PHASE_TAB_CLOCKWISE[(x)] : PHASE_TAB_ANTICLOCKWISE[(x)])
S#define PHASE_NUMBER						(sizeof(PHASE_TAB_CLOCKWISE)/sizeof(uint32_t))
S#define PHASE_INCREASE(x) 					INDEX_INCREASE((x), PHASE_NUMBER) //((x) = (((x) == (PHASE_NUMBER - 1)) ? 0 : ((x) + 1)))
S
S//		#define RESET_MOTOR_SR_BIT(x)				(tMotor.structMotor.MSR &= (~(1ul << (x))))
S//		#define SET_MOTOR_SR_BIT(x)					(tMotor.structMotor.MSR |= (1ul << (x)))
S//		#define IS_MOTOR_STATUS_SET(x)				(tMotor.structMotor.MSR & (1ul << (x)))
S
S#define WAIT_AFTER_LOCATE_TIME				0	// ms
S
S#define MOTOR_RAMPUP_DT_MAX					(PWM_PERIOD - 200)
S#define MOTOR_RAMPUP_DT_FACTOR				(1.02)
S//		#define MOTOR_RAMPUP_DT_INCR(x)			((x) = (((x) > MOTOR_RAMPUP_DT_MAX) ? (x) : (uint16_t)((x) * MOTOR_RAMPUP_DT_FACTOR)))
S#define MOTOR_RAMPUP_DT_INCR(x)				((x) = (((x) > MOTOR_RAMPUP_DT_MAX) ? (x) : ((x) + 1)))
S
S#define MOTOR_RAMPUP_PR_MIN					(1000 - 1)	// frequency 2M, 2857RPM if 1MC==7EC==42PC
S#define MOTOR_RAMPUP_PR_FACTOR				(0.98)
S#define MOTOR_RAMPUP_PR_DCR(x)				((x) = (((x) < MOTOR_RAMPUP_PR_MIN) ? (x) : (uint16_t)((x) * MOTOR_RAMPUP_PR_FACTOR)))
S//		#define MOTOR_RAMPUP_PR_DCR(x)			((x) = (((x) < MOTOR_RAMPUP_PR_MIN) ? (x) : ((x) - 100)))
S#define MOTOR_START_ZXD_SPEED				(1600 - 1)	// frequency 2M,
S//		#define MOTOR_START_ZXD_MINROT_CNT			200	// After phase change xxx times at max speed of rampup, start to detect ZX
S
S#define MAX_MOTOR_PWR_DUTY 					(PWM_PERIOD - 150)
S#define MAX_SINGLE_PHASE_DURATION			80  // 80ms,
S//		typedef enum {
S//			PHASE_AB = 0,
S//			PHASE_AC,
S//			PHASE_BC,
S//			PHASE_BA,
S//			PHASE_CA,
S//			PHASE_CB
S//		} ENUM_MOTOR_PHASE;
S
S//		typedef enum {
S//			PHASE_AB = 0,
S//			PHASE_CB,
S//			PHASE_CA,
S//			PHASE_BA,
S//			PHASE_BC,
S//			PHASE_AC
S//		} ENUM_MOTOR_ANTICLOCKWISE_PHASE;
S
Sstatic ENUM_MOTOR_STATE tMotorState = MOTOR_IDLE;
Sstatic ENUM_ROTATE_DETECT_STATE tRotateDetectState = DETECT_START;
Sstatic uint8_t unLocateIndex;
Sstatic uint8_t unPhaseChangeCNT_AtCurrentPeriod; /* This variable is only used at start up ramp up stage.
S Only after phase has changed for a certain number at current period,
S the actual period will increase or decrease to target period. */
Sstatic uint8_t unPhaseChangeCNT_AtCurrentDuty; /* Only after phase has changed for a certain number at current duty,
S the actual duty will increase or decrease to target duty */
Sstatic uint16_t unPeriodChangeCNT_AfterPR_ReachMini; /* This variable is only used at start up ramp up stage.
S Phase period changed counter after phase period has been lower to
S ramp up min period*/
Sstatic uint32_t unLastPhaseChangeTime;
Sstatic uint32_t unRotateDetectStartTime;	// Used to record when enter motor start,
S// ALready rotating detect end time will be compared with this time
N#else
N#define EXTERNAL_BLDC extern
N#endif
NEXTERNAL_BLDC __IO MOTOR_UNION_T tMotor;	// Motor control register
Xextern volatile MOTOR_UNION_T tMotor;	
NEXTERNAL_BLDC __IO ENUM_TIM1_USAGE FLAG_TIM1_USEAGE;
Xextern volatile ENUM_TIM1_USAGE FLAG_TIM1_USEAGE;
NEXTERNAL_BLDC __IO uint32_t unLastZXDetectedTime;
Xextern volatile uint32_t unLastZXDetectedTime;
NEXTERNAL_BLDC __IO uint32_t unZXMatchCNT;
Xextern volatile uint32_t unZXMatchCNT;
N//EXTERNAL_BLDC uint32_t iPhaseChangeCNT4Period;	// Used to check if phase has been changed after every 60ms.
N// If not, force MOSFET OFF.
N// 60ms=1.39rps=83.33rpm, we should make sure 1st startup ramp phase < 60ms
N
NEXTERNAL_BLDC uint8_t unCurrentPhase;
Xextern uint8_t unCurrentPhase;
NEXTERNAL_BLDC uint8_t FLAG_PHASE_CHANGED;
Xextern uint8_t FLAG_PHASE_CHANGED;
NEXTERNAL_BLDC __INLINE void BLDC_stopMotor(void);
Xextern __inline void BLDC_stopMotor(void);
NEXTERNAL_BLDC void BLDC_SensorLessManager(void);
Xextern void BLDC_SensorLessManager(void);
N#endif
L 70 "User\global.h" 2
N#include "Communication.h"
L 1 "User\Communication.h" 1
N#ifndef __COMMUNICATION_H__
N#define __COMMUNICATION_H__
N
N#include "global.h"
N
N#ifdef __USED_BY_COMMUNICATION_C__
S#define EXTERNAL_COMM
S#define COM_SPI_TRANS_ERR_THRESHOLD		6
S#define REVS_BYTE_ORDER(unIndex)			((((unIndex) & BIT_MASK) == 0) ? ((unIndex) + 1) : ((unIndex) - 1))
Suint16_t CRC_TABLE16[] = {0x0000,0x8005,0x800F,0x000A,0x801B,0x001E,0x0014,0x8011,0x8033,0x0036,0x003C,0x8039,0x0028,0x802D,0x8027,0x0022,
S	0x8063,0x0066,0x006C,0x8069,0x0078,0x807D,0x8077,0x0072,0x0050,0x8055,0x805F,0x005A,0x804B,0x004E,0x0044,0x8041,
S	0x80C3,0x00C6,0x00CC,0x80C9,0x00D8,0x80DD,0x80D7,0x00D2,0x00F0,0x80F5,0x80FF,0x00FA,0x80EB,0x00EE,0x00E4,0x80E1,
S	0x00A0,0x80A5,0x80AF,0x00AA,0x80BB,0x00BE,0x00B4,0x80B1,0x8093,0x0096,0x009C,0x8099,0x0088,0x808D,0x8087,0x0082,
S	0x8183,0x0186,0x018C,0x8189,0x0198,0x819D,0x8197,0x0192,0x01B0,0x81B5,0x81BF,0x01BA,0x81AB,0x01AE,0x01A4,0x81A1,
S	0x01E0,0x81E5,0x81EF,0x01EA,0x81FB,0x01FE,0x01F4,0x81F1,0x81D3,0x01D6,0x01DC,0x81D9,0x01C8,0x81CD,0x81C7,0x01C2,
S	0x0140,0x8145,0x814F,0x014A,0x815B,0x015E,0x0154,0x8151,0x8173,0x0176,0x017C,0x8179,0x0168,0x816D,0x8167,0x0162,
S	0x8123,0x0126,0x012C,0x8129,0x0138,0x813D,0x8137,0x0132,0x0110,0x8115,0x811F,0x011A,0x810B,0x010E,0x0104,0x8101,
S	0x8303,0x0306,0x030C,0x8309,0x0318,0x831D,0x8317,0x0312,0x0330,0x8335,0x833F,0x033A,0x832B,0x032E,0x0324,0x8321,
S	0x0360,0x8365,0x836F,0x036A,0x837B,0x037E,0x0374,0x8371,0x8353,0x0356,0x035C,0x8359,0x0348,0x834D,0x8347,0x0342,
S	0x03C0,0x83C5,0x83CF,0x03CA,0x83DB,0x03DE,0x03D4,0x83D1,0x83F3,0x03F6,0x03FC,0x83F9,0x03E8,0x83ED,0x83E7,0x03E2,
S	0x83A3,0x03A6,0x03AC,0x83A9,0x03B8,0x83BD,0x83B7,0x03B2,0x0390,0x8395,0x839F,0x039A,0x838B,0x038E,0x0384,0x8381,
S	0x0280,0x8285,0x828F,0x028A,0x829B,0x029E,0x0294,0x8291,0x82B3,0x02B6,0x02BC,0x82B9,0x02A8,0x82AD,0x82A7,0x02A2,
S	0x82E3,0x02E6,0x02EC,0x82E9,0x02F8,0x82FD,0x82F7,0x02F2,0x02D0,0x82D5,0x82DF,0x02DA,0x82CB,0x02CE,0x02C4,0x82C1,
S	0x8243,0x0246,0x024C,0x8249,0x0258,0x825D,0x8257,0x0252,0x0270,0x8275,0x827F,0x027A,0x826B,0x026E,0x0264,0x8261,
S	0x0220,0x8225,0x822F,0x022A,0x823B,0x023E,0x0234,0x8231,0x8213,0x0216,0x021C,0x8219,0x0208,0x820D,0x8207,0x0202};
S
Stypedef enum {
S	MOTOR_READ_NULL = 0,
S	MOTOR_READ_MCR,
S	MOTOR_READ_MSR,
S	MOTOR_READ_MISS_ZXD_CNT,
S	MOTOR_READ_SCS_ZXD_CNT,
S	MOTOR_READ_LOCATING_DUTY,
S	MOTOR_READ_RAMP_UP_DUTY,
S	MOTOR_READ_TARGET_DUTY,
S	MOTOR_READ_ACTUAL_DUTY,
S	MOTOR_READ_LOCATING_PERIOD,
S	MOTOR_READ_SPEED_ADC,
S	MOTOR_READ_RESERVED_1,
S	MOTOR_READ_RAMP_UP_PERIOD_LOW,
S	MOTOR_READ_RAMP_UP_PERIOD_HIGH,
S	MOTOR_READ_ACTUAL_PERIOD_LOW,
S	MOTOR_READ_ACTUAL_PERIOD_HIGH,
S	MOTOR_READ_PHASE_CHANGE_CNT_LOW,
S	MOTOR_READ_PHASE_CHANGE_CNT_HIGH,
S	MOTOR_READ_RPM,
S	MOTOR_READ_BATTERY,
S	MOTOR_READ_CURRENT,
S	MOTOR_READ_RESERVED_2,
S	MOTOR_READ_COMM_OK_LOW,
S	MOTOR_READ_COMM_OK_HIGH,
S	MOTOR_READ_COMM_ERR_LOW,
S	MOTOR_READ_COMM_ERR_HIGH,
S	MOTOR_READ_MAX
S}ENUM_MOTOR_READ_CMD;
S
Stypedef enum {
S	MOTOR_WRITE_DUMMY = 0,
S	MOTOR_WRITE_MOTOR_NEED_TO_RUN,
S	MOTOR_WRITE_ROTATE_DIRECTION,
S	MOTOR_WRITE_LOCATING_DUTY,
S	MOTOR_WRITE_RAMP_UP_DUTY,
S	MOTOR_WRITE_TARGET_DUTY,
S	MOTOR_WRITE_LOCATING_PERIOD,
S	MOTOR_WRITE_RAMP_UP_PERIOD_LOW,
S	MOTOR_WRITE_RAMP_UP_PERIOD_HIGH,
S	MOTOR_WRITE_CMD_MAX
S}ENUM_MOTOR_WRITE_CMD;
S
Stypedef enum {
S	SPI_RCV_IDLE = 0,
S	SPI_RCV_RD_CMD,
S	SPI_RCV_WR_CMD,
S	SPI_RCV_WR_DATA,
S	SPI_RCV_CRC
S}ENUM_SPI_RECEIVE_STATE;
S
N#else
N#define EXTERNAL_COMM extern
N#endif
N
N#define COMM_PORT					P0
N#define COMM_CLK_PIN				BIT7
N#define COMM_CS_PIN					BIT1
N#define COMM_TX_PIN					BIT6
N#define COMM_RX_PIN					BIT5
N
N#define COMM_FIFO_LENGTH					3
N#define COMM_BIT_LENTH						16	// Because STM32F407 can only configure SPI to be 8bits/16bits width
N// highest bit in first half word is used to indicate command or data
N#define COMM_RD_CMD_CNT						2	// R(0):Address | CRC
N#define COMM_WR_CMD_CNT						4	// W(1):Address | Data Low | Data High | CRC
N
N// If using FIFO, need to use 32 bit
N#define COMM_RD_CMD_CNT_IN_32BIT	1	
N#define COMM_WR_CMD_CNT_IN_32BIT	2	
N
N#define COMM_RW_CMD_MASK					(0x8000)
N#define IS_COMM_RD_CMD(value)			(((value) & COMM_RW_CMD_MASK) == COMM_RW_CMD_MASK)
N#define IS_COMM_WR_CMD(value)			(((value) & COMM_RW_CMD_MASK) == 0)
N#define COMM_DATA_MASK						(0x7FFF)
N#define COMM_GET_DATA(value)			((value) & COMM_DATA_MASK)
N#define COMM_BAUT_RATE						0	// 5MHz
N#define MTR_INVALID_MOTOR_CMD			0xFFFF
N#define MTR_NULL_MOTOR_CMD				0
N//typedef enum{
N//	MOTOR_MCR = 0,	/*!<  Motor Control  */
N//	MOTOR_MSR,		/*!<  Motor Status  */
N//	MOTOR_MISS_ZXD_CNT,
N//	MOTOR_SCS_ZXD_CNT,
N//	MOTOR_LCT_DUTY,		/*!<  PWM Locating Duty  */
N//	MOTOR_RU_DUTY,		/*!<  PWM Ramp Up Start Duty  */
N//	MOTOR_TGT_DUTY,		/*!<  PWM Target (Locked State) Duty  */
N//	MOTOR_ACT_DUTY,		/*!<  PWM Actual Duty  */
N//	MOTOR_LCT_PERIOD,	/*!<  Locating State One Phase Period  */
N//	MOTOR_RU_PERIOD_LOW,	/*!<  Ramp Up Start One Phase Period  */
N//	MOTOR_RU_PERIOD_HIGH,	/*!<  Ramp Up Start One Phase Period  */
N//	MOTOR_ACT_PERIOD_LOW,	/*!<  Actual One Phase Period  */
N//	MOTOR_ACT_PERIOD_HIGH,	/*!<  Actual One Phase Period  */
N//	MOTOR_RPM,			/*!<  Actual RPM  */
N//	MOTOR_RESERVE,		/*!<  Reserve for future use (round up 32bits) */
N//	MOTOR_BATTERY,		/*!<  Battery Voltage  */
N//	MOTOR_CURRENT		/*!<  Current  */
N//} ENUM_COMM_REG;
N
NEXTERNAL_COMM uint16_t unRegisterValue;	// 0 or 0xFFFF means no data
Xextern uint16_t unRegisterValue;	
N//EXTERNAL_COMM ENUM_COMM_REG tRegister;
NEXTERNAL_COMM uint8_t FlagRegisterNeedWrite;
Xextern uint8_t FlagRegisterNeedWrite;
NEXTERNAL_COMM uint16_t unReadValueCRC;
Xextern uint16_t unReadValueCRC;
NEXTERNAL_COMM void COMM_Manager(void);
Xextern void COMM_Manager(void);
N#endif
L 71 "User\global.h" 2
N#include "Error.h"
L 1 "User\Error.h" 1
N#ifndef __ERROR_H__
S#define __ERROR_H__
S
S#include "global.h"
S
S#define LED_PORT					P5
S#define LED_PIN						BIT4
S#define LED_OUTPUT				P54
S
S#define GET_SPECIFIED_EEROR(x)		((unErrorMaster & (1L << (x)) == 0) ? FALSE : TRUE)
S#define IS_ANY_EEROR				((unErrorMaster == 0) ? FALSE : TRUE)
S/*
S ERR_NULL = 0,
S ERR_CURRENT_WARNING,	// Current > 5A
S ERR_LOCATE_FAIL,
S ERR_RAMPUP_FAIL,
S ERR_BATTERY_LOW,
S ERR_INTERNAL,	// Loss lock, single phase duration too long
S ERR_CURRENT_BURNING,	// Current > 15A
S ERR_BRD_FAULT
S */
S#define MOTOR_ERROR_MSK				0xFFFFFFFEul
S#define NO_MOTOR_EEROR				(((unErrorMaster & MOTOR_ERROR_MSK) == 0) ? TRUE : FALSE)
S
S// Max 32 type of error because used uint32_t's bit to mark each error
Stypedef enum {
S	ERR_NULL = 0, ERR_CURRENT_WARNING,	// Current > 5A
S	ERR_COMMUNICATION_FAIL,
S	ERR_LOCATE_FAIL,
S	ERR_RAMPUP_FAIL,
S	ERR_BATTERY_LOW,
S	ERR_INTERNAL,	// Loss lock, single phase duration too long
S	ERR_CURRENT_BURNING,	// Current > 15A
S	ERR_BRD_FAULT
S} ENUM_ERROR_LEVEL;
S
S#define LED_ON					(LED_OUTPUT = 0)
S#define LED_OFF 				(LED_OUTPUT = 1)
S#define LED_TOGGLE 			(GPIO_TOGGLE(LED_OUTPUT))
S
S#ifdef __USED_BY_ERROR_C__
S#define EXTERNAL_ERROR
S
S#define LED_PATTERN_INTERVAL	2000  //2s
S#define LED_BLINK_ON_TIME			200  //0.2s
S#define LED_BLINK_OFF_TIME		200  //0.2s, so 3 times is (0.4x3 = 1.2s)
S#define LED_BLINK_INTERVAL		(LED_BLINK_ON_TIME + LED_BLINK_OFF_TIME)
S// Since LED can not blink to fast (for human watchable), 3 type of blink make sense
S// So this table is introduced. Since ERR_BRD_FAULT is constantly ON, we can use it as array size
Sconst uint32_t unLED_BLINK_PATTERN_TABLE[ERR_BRD_FAULT] = {1 * LED_BLINK_INTERVAL,
S	1 * LED_BLINK_INTERVAL,
S	2 * LED_BLINK_INTERVAL,
S	2 * LED_BLINK_INTERVAL,
S	2 * LED_BLINK_INTERVAL,
S	2 * LED_BLINK_INTERVAL,
S	3 * LED_BLINK_INTERVAL};
S#else 
S#define EXTERNAL_ERROR extern
S#endif
S
SEXTERNAL_ERROR uint32_t unErrorMaster;
SEXTERNAL_ERROR void delay(uint32_t unDelayMs);
SEXTERNAL_ERROR void resetError(ENUM_ERROR_LEVEL enumErrorType);
SEXTERNAL_ERROR void setError(ENUM_ERROR_LEVEL enumErrorType);
SEXTERNAL_ERROR void clearError(void);
SEXTERNAL_ERROR void ERR_Manager(void);
S
N#endif
L 72 "User\global.h" 2
N#include "Protection.h"
L 1 "User\Protection.h" 1
N#ifndef __PROTECTION_H__
N#define __PROTECTION_H__
N
N#include "global.h"
N
N#define BATTERY_V_PORT				P3
N#define BATTERY_V_PIN				((uint32_t)BIT1)
N#define CURRENT_PORT				P5
N#define CURRENT_PIN					((uint32_t)BIT3)
N
N#define ADC_CURRENT_CHN_IDX			0
N#define ADC_BATTERY_CHN_IDX			7
N#define ADC_CURRENT_CHN_MSK			(0x01 << ADC_CURRENT_CHN_IDX)
N#define ADC_BATTERY_CHN_MSK			(0x01 << ADC_BATTERY_CHN_IDX)
N#define ADC_CURRENT_CMP_MSK			ADC_CMP0_INT
N#define ADC_BATTERY_CMP_MSK			ADC_CMP1_INT
N#define ADC_ADF_MSK					ADC_ADF_INT
N
N// 5x50 m ohm R = 10m ohm, 30A*0.01=0.3V, VCC=3V, (0.3/3)*1024=102
N// 5x50 m ohm R = 10m ohm, 30A*0.01=0.3V, VCC=5V, (0.3/5)*1024=61
N#define ADC_CURRENT_HIGH_THRS			68
N#define ADC_CURRENT_HIGH_CNT			12	// 300us*8*2(one current, one battery)=4.8ms
N//16	// 15us*16*2(one current, one battery)=0.48ms interval of measurement
N// 5x50 m ohm R = 10m ohm, 1A*0.01=0.01V, VCC=5V, (0.01/5)*1024=2
N#define ADC_CURRENT_HIGH_THRS_MT		5	// For MOSFET check at start up, but 2 can be noise, so maybe 5 is OK
N// If it is higher than 5 also maybe ADC is wrong
N
N// Set 6.8V as min, (6.8/13.3)*3.3=1.687V, (1.687/3.3)*1024=524	// Actually using 10K and 3.3K R
N// Set 10.2V as min, (10.2/13.3)*3.3=2.53V, (2.53/3)*1024=864	// Actually using 10K and 3.3K R
N// Set 10.2V as min, (10.2/13.3)*3.3=2.53V, (2.53/5)*1024=518	// Actually using 10K and 3.3K R
N// Set 10.2V as min, (10.2/12)*2=1.7V, (1.7/5)*1024=348	// Actually using 10K and 2K R
N#define ADC_BAT_LOW_THRS				348
N#define ADC_BAT_LOW_CNT					16	// Battery may need further filter, 300us*16*2(one current, one battery)=9.6ms
N// Set 11.5V as min, (11.5/12)*2=1.92V, (1.92/5)*1024=393	// Actually using 10K and 2K R
N#define ADC_BAT_LOW_THRS_MT				393
N
N#ifdef __USED_BY_PTC_C__
S#define EXTERNAL_PTC
S
Svolatile uint32_t* unMosfetTestTable[] = {&MOSFET_AS_PIN_ADDR, &MOSFET_BS_PIN_ADDR, &MOSFET_CS_PIN_ADDR,
S	&MOSFET_AD_PIN_ADDR, &MOSFET_BD_PIN_ADDR, &MOSFET_CD_PIN_ADDR};
S#define SET_MOSFET_ON_MANUAL(pinAddr)		(*(pinAddr) = 0)
S#define SET_MOSFET_OFF_MANUAL(pinAddr)		(*(pinAddr) = 1)
S
N#else
N#define EXTERNAL_PTC extern
N#endif
N
NEXTERNAL_PTC void PTC_checkMotor(void);
Xextern void PTC_checkMotor(void);
N
N#endif
L 73 "User\global.h" 2
N#endif 
L 5 "User\Error.h" 2
N
N#define LED_PORT					P5
N#define LED_PIN						BIT4
N#define LED_OUTPUT				P54
N
N#define GET_SPECIFIED_EEROR(x)		((unErrorMaster & (1L << (x)) == 0) ? FALSE : TRUE)
N#define IS_ANY_EEROR				((unErrorMaster == 0) ? FALSE : TRUE)
N/*
N ERR_NULL = 0,
N ERR_CURRENT_WARNING,	// Current > 5A
N ERR_LOCATE_FAIL,
N ERR_RAMPUP_FAIL,
N ERR_BATTERY_LOW,
N ERR_INTERNAL,	// Loss lock, single phase duration too long
N ERR_CURRENT_BURNING,	// Current > 15A
N ERR_BRD_FAULT
N */
N#define MOTOR_ERROR_MSK				0xFFFFFFFEul
N#define NO_MOTOR_EEROR				(((unErrorMaster & MOTOR_ERROR_MSK) == 0) ? TRUE : FALSE)
N
N// Max 32 type of error because used uint32_t's bit to mark each error
Ntypedef enum {
N	ERR_NULL = 0, ERR_CURRENT_WARNING,	// Current > 5A
N	ERR_COMMUNICATION_FAIL,
N	ERR_LOCATE_FAIL,
N	ERR_RAMPUP_FAIL,
N	ERR_BATTERY_LOW,
N	ERR_INTERNAL,	// Loss lock, single phase duration too long
N	ERR_CURRENT_BURNING,	// Current > 15A
N	ERR_BRD_FAULT
N} ENUM_ERROR_LEVEL;
N
N#define LED_ON					(LED_OUTPUT = 0)
N#define LED_OFF 				(LED_OUTPUT = 1)
N#define LED_TOGGLE 			(GPIO_TOGGLE(LED_OUTPUT))
N
N#ifdef __USED_BY_ERROR_C__
N#define EXTERNAL_ERROR
N
N#define LED_PATTERN_INTERVAL	2000  //2s
N#define LED_BLINK_ON_TIME			200  //0.2s
N#define LED_BLINK_OFF_TIME		200  //0.2s, so 3 times is (0.4x3 = 1.2s)
N#define LED_BLINK_INTERVAL		(LED_BLINK_ON_TIME + LED_BLINK_OFF_TIME)
N// Since LED can not blink to fast (for human watchable), 3 type of blink make sense
N// So this table is introduced. Since ERR_BRD_FAULT is constantly ON, we can use it as array size
Nconst uint32_t unLED_BLINK_PATTERN_TABLE[ERR_BRD_FAULT] = {1 * LED_BLINK_INTERVAL,
Xconst uint32_t unLED_BLINK_PATTERN_TABLE[ERR_BRD_FAULT] = {1 * (200 + 200),
N	1 * LED_BLINK_INTERVAL,
X	1 * (200 + 200),
N	2 * LED_BLINK_INTERVAL,
X	2 * (200 + 200),
N	2 * LED_BLINK_INTERVAL,
X	2 * (200 + 200),
N	2 * LED_BLINK_INTERVAL,
X	2 * (200 + 200),
N	2 * LED_BLINK_INTERVAL,
X	2 * (200 + 200),
N	3 * LED_BLINK_INTERVAL};
X	3 * (200 + 200)};
N#else 
S#define EXTERNAL_ERROR extern
N#endif
N
NEXTERNAL_ERROR uint32_t unErrorMaster;
X uint32_t unErrorMaster;
NEXTERNAL_ERROR void delay(uint32_t unDelayMs);
X void delay(uint32_t unDelayMs);
NEXTERNAL_ERROR void resetError(ENUM_ERROR_LEVEL enumErrorType);
X void resetError(ENUM_ERROR_LEVEL enumErrorType);
NEXTERNAL_ERROR void setError(ENUM_ERROR_LEVEL enumErrorType);
X void setError(ENUM_ERROR_LEVEL enumErrorType);
NEXTERNAL_ERROR void clearError(void);
X void clearError(void);
NEXTERNAL_ERROR void ERR_Manager(void);
X void ERR_Manager(void);
N
N#endif
L 14 "User\Error.c" 2
N
Nvoid delay(uint32_t unDelayMs)
N{
N	uint32_t unEntryTime = unSystemTick;
N	while (((uint32_t)(unSystemTick - unEntryTime)) < unDelayMs)
N	{
N		__NOP();
X		__nop();
N	}
N}
N
Nvoid clearError(void)
N{
N	unErrorMaster = 0;
N}
N
Nvoid resetError(ENUM_ERROR_LEVEL enumErrorType)
N{
N	if (ERR_NULL != enumErrorType)
N	{	
N		unErrorMaster &= ~(1UL << (enumErrorType - 1));
N	}
N}
N
Nvoid setError(ENUM_ERROR_LEVEL enumErrorType)
N{
N	if (ERR_NULL == enumErrorType)
N	{
N		unErrorMaster = 0;
N	}
N	else
N	{
N		unErrorMaster |= 1UL << (enumErrorType - 1); 
N	}
N}
N
NENUM_ERROR_LEVEL getPrecedenceError(void)
N{
N	register ENUM_ERROR_LEVEL iVernier = ERR_BRD_FAULT;
N	while (iVernier)
N	{
N		iVernier--; 
N		if (unErrorMaster >> iVernier)
N		{
N			return (iVernier + 1);
N		}		
N	}
N	return iVernier;
N}
N
Nvoid LEDBlinkHandler(ENUM_ERROR_LEVEL tErrorType, uint32_t unErrorStartTime)
N{
N	uint16_t iLEDTime;
N	if (ERR_BRD_FAULT == tErrorType)
N	{
N		// Always ON
N		LED_ON;
X		((*((volatile uint32_t *)(((((uint32_t)0x50000000) + 0x04200)+(0x20*(5))) + ((4)<<2)))) = 0);
N	}
N	else if (ERR_NULL == tErrorType)
N	{
N		// Always off
N		LED_OFF;
X		((*((volatile uint32_t *)(((((uint32_t)0x50000000) + 0x04200)+(0x20*(5))) + ((4)<<2)))) = 1);
N	}
N	else
N	{
N		iLEDTime = (uint16_t)(((uint32_t)(unSystemTick - unErrorStartTime)) % LED_PATTERN_INTERVAL);
X		iLEDTime = (uint16_t)(((uint32_t)(unSystemTick - unErrorStartTime)) % 2000);
N		if (iLEDTime >= unLED_BLINK_PATTERN_TABLE[tErrorType])
N		{
N			LED_OFF;
X			((*((volatile uint32_t *)(((((uint32_t)0x50000000) + 0x04200)+(0x20*(5))) + ((4)<<2)))) = 1);
N		}
N		else
N		{
N			iLEDTime %= LED_BLINK_INTERVAL;
X			iLEDTime %= (200 + 200);
N			if (iLEDTime < LED_BLINK_ON_TIME)
X			if (iLEDTime < 200)
N			{
N				LED_ON;
X				((*((volatile uint32_t *)(((((uint32_t)0x50000000) + 0x04200)+(0x20*(5))) + ((4)<<2)))) = 0);
N			}
N			else
N			{
N				LED_OFF;
X				((*((volatile uint32_t *)(((((uint32_t)0x50000000) + 0x04200)+(0x20*(5))) + ((4)<<2)))) = 1);
N			}
N		}
N	}
N}
N
N// Take charge of all error reporting via LED/UART
N// Shut down all MOSFET was handled as soon as the critical error was found
N// to make sure then responding time will not burn the board
Nvoid ERR_Manager(void)
N{
N	static uint32_t unLastErrorChangeTime;
N	static ENUM_ERROR_LEVEL tLastErrorType = ERR_NULL;
N	ENUM_ERROR_LEVEL tErrorFetched;
N	tErrorFetched = getPrecedenceError();
N
N	if (tLastErrorType != tErrorFetched)
N	{
N		tLastErrorType = tErrorFetched;
N		// error type changed (maybe changed to no error)
N		unLastErrorChangeTime = unSystemTick;
N		// No matter there is error or not, process!!
N		LEDBlinkHandler(tErrorFetched, unLastErrorChangeTime);
N	}
N	else
N	{
N		// Still same error (maybe no error)
N		// Only process when there is some error
N		if (ERR_NULL != tErrorFetched)
N		{
N			LEDBlinkHandler(tErrorFetched, unLastErrorChangeTime);
N		}	
N	}
N	
N}
N
