; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\bldcsensorless.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\bldcsensorless.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\Mini51Series\Include -I..\..\..\Library\StdDriver\inc -I.\StdDriver\inc -I.\CMSIS -I.\RTE\Device\Mini54ZDE -I.\RTE\_BLDC_driver -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.1.0\Device\Mini51\Driver -IC:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.1.0\Device\Mini51\Include -D__MICROLIB -D__UVISION_VERSION=524 -D_RTE_ -DCLK_APBCLK_ACMP_EN_Pos=CLK_APBCLK_CMP_EN_Pos --omf_browse=.\obj\bldcsensorless.crf User\BLDCSensorLess.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  canMotorContinueRunning PROC
;;;75      1-65534: phase time */
;;;76     uint16_t canMotorContinueRunning(void) {
000000  2000              MOVS     r0,#0
;;;77     	uint16_t unPhaseDuration = 0;
;;;78     	static uint32_t unStateEnterTime;
;;;79     // Later implement this when motor can rotate
;;;80     // Then stop it while rotating to measure the waveform
;;;81     // Manually rotate it is too slow 
;;;82     	return 0;
;;;83     
;;;84     	if ((uint32_t) (unSystemTick - unRotateDetectStartTime) > MAX_ALREADY_ROTATING_DETECT_TIME) {
;;;85     		return 0;
;;;86     	}
;;;87     	switch (tRotateDetectState) {
;;;88     	case DETECT_START:
;;;89     		unStateEnterTime = unSystemTick;
;;;90     		tRotateDetectState = DETECT_PHASE_1_P;
;;;91     		break;
;;;92     
;;;93     	case DETECT_PHASE_1_P:
;;;94     		if ((uint32_t) (unSystemTick - unStateEnterTime) > MAX_ROTATING_DETECT_PHASE_TIME) {
;;;95     			return (uint16_t) 0;
;;;96     		} else {
;;;97     
;;;98     		}
;;;99     		break;
;;;100    
;;;101    	case DETECT_PHASE_1_A:
;;;102    
;;;103    		break;
;;;104    
;;;105    	case DETECT_PHASE_2_P:
;;;106    
;;;107    		break;
;;;108    
;;;109    	case DETECT_PHASE_2_A:
;;;110    
;;;111    		break;
;;;112    
;;;113    	case DETECT_PHASE_3_P:
;;;114    
;;;115    		break;
;;;116    
;;;117    	case DETECT_PHASE_3_A:
;;;118    
;;;119    		break;
;;;120    
;;;121    	default:
;;;122    		break;
;;;123    	}
;;;124    
;;;125    	return unPhaseDuration;
;;;126    }
000002  4770              BX       lr
;;;127    
                          ENDP

                  BLDCSpeedManager PROC
;;;128    // Mainly PWM duty increase/decrease
;;;129    void BLDCSpeedManager(void) {
000004  b510              PUSH     {r4,lr}
;;;130    	if (SET == FLAG_PHASE_CHANGED) {
000006  4cb2              LDR      r4,|L1.720|
000008  79a0              LDRB     r0,[r4,#6]  ; FLAG_PHASE_CHANGED
00000a  2801              CMP      r0,#1
00000c  d133              BNE      |L1.118|
;;;131    		PhaseChangedRoutine();
00000e  f7fffffe          BL       PhaseChangedRoutine
;;;132    
;;;133    		if (tMotor.structMotor.unActualDuty != tMotor.structMotor.unTargetDuty) {
000012  49b0              LDR      r1,|L1.724|
000014  8a08              LDRH     r0,[r1,#0x10]  ; tMotor
000016  89ca              LDRH     r2,[r1,#0xe]  ; tMotor
000018  4290              CMP      r0,r2
00001a  d017              BEQ      |L1.76|
;;;134    //				tMotor.structMotor.ACT_DUTY = tMotor.structMotor.TGT_DUTY;
;;;135    			// Change PWM duty after each x phase change
;;;136    			if (unPhaseChangeCNT_AtCurrentDuty > CHANGE_DUTY_AFTER_PHASE_CHANGED_NUM) {
00001c  7920              LDRB     r0,[r4,#4]  ; unPhaseChangeCNT_AtCurrentDuty
00001e  2805              CMP      r0,#5
000020  d911              BLS      |L1.70|
;;;137    				unPhaseChangeCNT_AtCurrentDuty = 0;
000022  2000              MOVS     r0,#0
000024  7120              STRB     r0,[r4,#4]
;;;138    				if (tMotor.structMotor.unActualDuty < tMotor.structMotor.unTargetDuty) {
000026  8a08              LDRH     r0,[r1,#0x10]  ; tMotor
000028  89ca              LDRH     r2,[r1,#0xe]  ; tMotor
00002a  4290              CMP      r0,r2
;;;139    					tMotor.structMotor.unActualDuty++;
;;;140    				} else {
;;;141    					tMotor.structMotor.unActualDuty--;
00002c  8a08              LDRH     r0,[r1,#0x10]  ; tMotor
00002e  d201              BCS      |L1.52|
000030  1c40              ADDS     r0,r0,#1              ;138
000032  e000              B        |L1.54|
                  |L1.52|
000034  1e40              SUBS     r0,r0,#1              ;139
                  |L1.54|
000036  8208              STRH     r0,[r1,#0x10]
;;;142    				}
;;;143    				MOTOR_SET_DUTY(tMotor.structMotor.unActualDuty);
000038  8a0a              LDRH     r2,[r1,#0x10]  ; tMotor
00003a  48a7              LDR      r0,|L1.728|
00003c  6282              STR      r2,[r0,#0x28]
00003e  8a0a              LDRH     r2,[r1,#0x10]  ; tMotor
000040  6302              STR      r2,[r0,#0x30]
000042  8a0a              LDRH     r2,[r1,#0x10]  ; tMotor
000044  6382              STR      r2,[r0,#0x38]
                  |L1.70|
;;;144    			}
;;;145    			unPhaseChangeCNT_AtCurrentDuty++;
000046  7920              LDRB     r0,[r4,#4]  ; unPhaseChangeCNT_AtCurrentDuty
000048  1c40              ADDS     r0,r0,#1
00004a  7120              STRB     r0,[r4,#4]
                  |L1.76|
;;;146    		}
;;;147    
;;;148    		PHASE_INCREASE(unCurrentPhase);
00004c  7960              LDRB     r0,[r4,#5]  ; unCurrentPhase
00004e  2805              CMP      r0,#5
000050  d201              BCS      |L1.86|
000052  1c40              ADDS     r0,r0,#1
000054  e000              B        |L1.88|
                  |L1.86|
000056  2000              MOVS     r0,#0
                  |L1.88|
000058  b2c0              UXTB     r0,r0
00005a  7160              STRB     r0,[r4,#5]
;;;149    		// Modify PWM->PHCHGNXT at last because I don't know how long needed to reload PHCH with PHCHNEXT after TIM0 time-out
;;;150    		PWM->PHCHGNXT = GET_PHASE_VALUE(unCurrentPhase);
00005c  8849              LDRH     r1,[r1,#2]  ; tMotor
00005e  0789              LSLS     r1,r1,#30
000060  d402              BMI      |L1.104|
000062  0080              LSLS     r0,r0,#2
000064  499d              LDR      r1,|L1.732|
000066  e002              B        |L1.110|
                  |L1.104|
000068  499c              LDR      r1,|L1.732|
00006a  0080              LSLS     r0,r0,#2
00006c  3118              ADDS     r1,r1,#0x18
                  |L1.110|
00006e  5808              LDR      r0,[r1,r0]
000070  4999              LDR      r1,|L1.728|
000072  3140              ADDS     r1,r1,#0x40
000074  63c8              STR      r0,[r1,#0x3c]
                  |L1.118|
;;;151    	}
;;;152    }
000076  bd10              POP      {r4,pc}
;;;153    
                          ENDP

                  BLDC_LocatingManager PROC
;;;165    
;;;166    ENUM_STATUS BLDC_LocatingManager(void) {
000078  b5f8              PUSH     {r3-r7,lr}
;;;167    	if ((uint32_t) (unSystemTick - unLastPhaseChangeTime) > tMotor.structMotor.unLocatingPeriod) {
00007a  4899              LDR      r0,|L1.736|
00007c  6800              LDR      r0,[r0,#0]  ; unSystemTick
00007e  4c94              LDR      r4,|L1.720|
000080  4b94              LDR      r3,|L1.724|
000082  6961              LDR      r1,[r4,#0x14]  ; unLastPhaseChangeTime
000084  1a40              SUBS     r0,r0,r1
000086  8a59              LDRH     r1,[r3,#0x12]  ; tMotor
000088  4288              CMP      r0,r1
00008a  d90b              BLS      |L1.164|
;;;168    		if (unLocateIndex < (sizeof(unLocatePhaseSequencyTable) / sizeof(uint8_t))) {
00008c  78a0              LDRB     r0,[r4,#2]  ; unLocateIndex
00008e  2804              CMP      r0,#4
000090  d20a              BCS      |L1.168|
;;;169    			//iLastPhaseChangeTime = unSystemTick; 
;;;170    			setPhaseManually(tMotor.structMotor.unLocatingDuty, unLocatePhaseSequencyTable[unLocateIndex]);
000092  4992              LDR      r1,|L1.732|
000094  1f09              SUBS     r1,r1,#4
000096  5c09              LDRB     r1,[r1,r0]
000098  8958              LDRH     r0,[r3,#0xa]  ; tMotor
00009a  f7fffffe          BL       setPhaseManually
;;;171    			unLocateIndex++;
00009e  78a0              LDRB     r0,[r4,#2]  ; unLocateIndex
0000a0  1c40              ADDS     r0,r0,#1
0000a2  70a0              STRB     r0,[r4,#2]
                  |L1.164|
;;;172    		} else {
;;;173    			MOTOR_SHUT_DOWN;
;;;174    			tMotor.structMotor.MSR.bMotorPowerOn = FALSE;
;;;175    			unCurrentPhase = unLocatePhaseSequencyTable[unLocateIndex - 1];
;;;176    			return STATUS_FINISHED;
;;;177    		}
;;;178    	}
;;;179    	return STATUS_WORKING;
0000a4  488f              LDR      r0,|L1.740|
;;;180    }
0000a6  bdf8              POP      {r3-r7,pc}
                  |L1.168|
0000a8  4a8f              LDR      r2,|L1.744|
0000aa  2100              MOVS     r1,#0                 ;173
0000ac  6211              STR      r1,[r2,#0x20]         ;173
0000ae  4d8a              LDR      r5,|L1.728|
0000b0  3540              ADDS     r5,r5,#0x40           ;173
0000b2  6169              STR      r1,[r5,#0x14]         ;173
0000b4  498d              LDR      r1,|L1.748|
0000b6  680a              LDR      r2,[r1,#0]            ;173
0000b8  038e              LSLS     r6,r1,#14             ;173
0000ba  43b2              BICS     r2,r2,r6              ;173
0000bc  600a              STR      r2,[r1,#0]            ;173
0000be  4a8b              LDR      r2,|L1.748|
0000c0  3220              ADDS     r2,r2,#0x20           ;173
0000c2  6817              LDR      r7,[r2,#0]            ;173
0000c4  43b7              BICS     r7,r7,r6              ;173
0000c6  6017              STR      r7,[r2,#0]            ;173
0000c8  680f              LDR      r7,[r1,#0]            ;173
0000ca  034e              LSLS     r6,r1,#13             ;173
0000cc  43b7              BICS     r7,r7,r6              ;173
0000ce  600f              STR      r7,[r1,#0]            ;173
0000d0  6811              LDR      r1,[r2,#0]            ;173
0000d2  43b1              BICS     r1,r1,r6              ;173
0000d4  6011              STR      r1,[r2,#0]            ;173
0000d6  21ff              MOVS     r1,#0xff              ;173
0000d8  63e9              STR      r1,[r5,#0x3c]         ;173
0000da  63a9              STR      r1,[r5,#0x38]         ;173
0000dc  8899              LDRH     r1,[r3,#4]            ;174  ; tMotor
0000de  0849              LSRS     r1,r1,#1              ;174
0000e0  0049              LSLS     r1,r1,#1              ;174
0000e2  8099              STRH     r1,[r3,#4]            ;174
0000e4  497d              LDR      r1,|L1.732|
0000e6  1f09              SUBS     r1,r1,#4              ;175
0000e8  1808              ADDS     r0,r1,r0              ;175
0000ea  3820              SUBS     r0,r0,#0x20           ;175
0000ec  7fc0              LDRB     r0,[r0,#0x1f]         ;175
0000ee  7160              STRB     r0,[r4,#5]            ;175
0000f0  2001              MOVS     r0,#1                 ;176
0000f2  bdf8              POP      {r3-r7,pc}
;;;181    
                          ENDP

                  BLDC_SensorLessManager PROC
;;;227    // Take charge of all Motot control
;;;228    void BLDC_SensorLessManager(void) {
0000f4  b5f8              PUSH     {r3-r7,lr}
0000f6  4c77              LDR      r4,|L1.724|
0000f8  8a21              LDRH     r1,[r4,#0x10]  ; tMotor
0000fa  487d              LDR      r0,|L1.752|
0000fc  4281              CMP      r1,r0
0000fe  d803              BHI      |L1.264|
000100  4975              LDR      r1,|L1.728|
000102  6a89              LDR      r1,[r1,#0x28]
000104  4281              CMP      r1,r0
000106  d904              BLS      |L1.274|
                  |L1.264|
000108  f7fffffe          BL       BLDC_stopMotor
00010c  2006              MOVS     r0,#6
00010e  f7fffffe          BL       setError
                  |L1.274|
;;;229    	uint16_t unMotorAlreadyRotatingPhaseTime;
;;;230    	static uint32_t iEnterTimeBeforeWait;
;;;231    
;;;232    	dutyProtection();
;;;233    	phaseDurationProtection(unLastPhaseChangeTime);
000112  4d6f              LDR      r5,|L1.720|
000114  88a1              LDRH     r1,[r4,#4]  ; tMotor
000116  6968              LDR      r0,[r5,#0x14]  ; unLastPhaseChangeTime
000118  4e71              LDR      r6,|L1.736|
00011a  07c9              LSLS     r1,r1,#31
00011c  d013              BEQ      |L1.326|
00011e  496e              LDR      r1,|L1.728|
000120  3140              ADDS     r1,r1,#0x40
000122  6b8b              LDR      r3,[r1,#0x38]
000124  4a73              LDR      r2,|L1.756|
000126  6817              LDR      r7,[r2,#0]  ; _ZZ23phaseDurationProtectionE14unCurrentPHCHG
000128  42bb              CMP      r3,r7
00012a  d003              BEQ      |L1.308|
00012c  6b88              LDR      r0,[r1,#0x38]
00012e  6010              STR      r0,[r2,#0]  ; _ZZ23phaseDurationProtectionE14unCurrentPHCHG
000130  6830              LDR      r0,[r6,#0]  ; unSystemTick
000132  e008              B        |L1.326|
                  |L1.308|
000134  6831              LDR      r1,[r6,#0]  ; unSystemTick
000136  1a08              SUBS     r0,r1,r0
000138  2850              CMP      r0,#0x50
00013a  d904              BLS      |L1.326|
00013c  f7fffffe          BL       BLDC_stopMotor
000140  2006              MOVS     r0,#6
000142  f7fffffe          BL       setError
                  |L1.326|
;;;234    
;;;235    	switch (tMotorState) {
000146  782a              LDRB     r2,[r5,#0]  ; tMotorState
;;;236    	case MOTOR_IDLE:
;;;237    		if (tMotor.structMotor.MCR.bMotorNeedToRun && NO_MOTOR_EEROR) {
000148  486b              LDR      r0,|L1.760|
00014a  2700              MOVS     r7,#0
00014c  2101              MOVS     r1,#1                 ;235
00014e  0013              MOVS     r3,r2                 ;235
000150  f7fffffe          BL       __ARM_common_switch8
000154  0705102d          DCB      0x07,0x05,0x10,0x2d
000158  3b7d9eb5          DCB      0x3b,0x7d,0x9e,0xb5
00015c  0f00              DCB      0x0f,0x00
00015e  8862              LDRH     r2,[r4,#2]  ; tMotor
000160  07d2              LSLS     r2,r2,#31
000162  d006              BEQ      |L1.370|
000164  6800              LDR      r0,[r0,#0]  ; unErrorMaster
000166  0840              LSRS     r0,r0,#1
000168  d103              BNE      |L1.370|
;;;238    			unRotateDetectStartTime = unSystemTick;
00016a  6830              LDR      r0,[r6,#0]  ; unSystemTick
;;;239    			tRotateDetectState = DETECT_START;
00016c  61a8              STR      r0,[r5,#0x18]  ; unRotateDetectStartTime
00016e  706f              STRB     r7,[r5,#1]
;;;240    			tMotorState = MOTOR_START;
000170  7029              STRB     r1,[r5,#0]
                  |L1.370|
;;;241    		}
;;;242    		break;
;;;243    
;;;244    	case MOTOR_START:
;;;245    		if (tMotor.structMotor.MCR.bMotorNeedToRun && NO_MOTOR_EEROR) {
;;;246    			// Later implement this when motor can rotate
;;;247    			// Then stop it while rotating to measure the waveform
;;;248    			// Manually rotate it is too slow 
;;;249    			unMotorAlreadyRotatingPhaseTime = canMotorContinueRunning();
;;;250    			if (unMotorAlreadyRotatingPhaseTime != IS_ROTATING_DETECTING) {
;;;251    				if (unMotorAlreadyRotatingPhaseTime > 0) {
;;;252    					// 1 to 65534
;;;253    					tMotorState = MOTOR_LOCKED;
;;;254    				} else {
;;;255    					// When back to Idle state the motor was already shut down
;;;256    					// MOTOR_SHUT_DOWN;
;;;257    					unCurrentPhase = 0;
;;;258    					unLocateIndex = 0;
;;;259    					tMotor.structMotor.unMissedZXD_CNT = 0;
;;;260    					unLastPhaseChangeTime = unSystemTick;
;;;261    					tMotor.structMotor.MSR.bMotorPowerOn = TRUE;
;;;262    					// Clear start detect zero cross flag
;;;263    					tMotor.structMotor.MSR.bZeroCrossDetecting = FALSE;
;;;264    					tMotor.structMotor.MSR.bLocked = FALSE;
;;;265    					//setPhaseManually(tMotor.structMotor.LCT_DUTY, unCurrentPhase);
;;;266    					BRG_ENABLE;
;;;267    					tMotorState = MOTOR_LOCATE;
;;;268    				}
;;;269    			}
;;;270    		} else {
;;;271    			BLDC_stopMotor();
;;;272    		}
;;;273    		break;
;;;274    
;;;275    	case MOTOR_LOCATE:
;;;276    		if (tMotor.structMotor.MCR.bMotorNeedToRun && NO_MOTOR_EEROR) {
;;;277    			if (BLDC_LocatingManager() == STATUS_FINISHED) {
;;;278    				iEnterTimeBeforeWait = unSystemTick;
;;;279    				tMotorState = MOTOR_WAIT_AFTER_LOCATE;
;;;280    			}
;;;281    		} else {
;;;282    			BLDC_stopMotor();
;;;283    		}
;;;284    		break;
;;;285    
;;;286    	case MOTOR_WAIT_AFTER_LOCATE:
;;;287    		if (tMotor.structMotor.MCR.bMotorNeedToRun && NO_MOTOR_EEROR) {
;;;288    			if ((uint32_t) (unSystemTick - iEnterTimeBeforeWait) >= WAIT_AFTER_LOCATE_TIME) {
;;;289    				tMotor.structMotor.unActualDuty = tMotor.structMotor.unRampUpDuty;
;;;290    				tMotor.structMotor.unActualPeriod = tMotor.structMotor.unRampUpPeriod;
;;;291    				tMotor.structMotor.MSR.bMotorPowerOn = TRUE;
;;;292    				PHASE_INCREASE(unCurrentPhase);
;;;293    				setPhaseManually(tMotor.structMotor.unActualDuty, unCurrentPhase);
;;;294    				BRG_ENABLE;
;;;295    				// Set timer 0 valure, use timer 0 to change phase automatically
;;;296    				// ************************************************************************
;;;297    				// ----==== From here current unCurrentPhase is actually next phase ====----
;;;298    				// ----==== Because we want to use the HW auto phase changer (PWM->PHCHGNXT) ====----
;;;299    				// So increase unCurrentPhase again. Want to get real current phase value? Read PWM->PHCHG.
;;;300    				// ************************************************************************
;;;301    				PHASE_INCREASE(unCurrentPhase);
;;;302    				PWM->PHCHGNXT = GET_PHASE_VALUE(unCurrentPhase);
;;;303    				// !!!! Need to make sure CPU runs to here every min tMotor.structMotor.ACT_PERIOD time !!!
;;;304    				// !!!! If not , timer counter may already passed tMotor.structMotor.ACT_PERIOD, !!!!
;;;305    				// !!!! then need to count to max timer counter number (which is 2^24), !!!!
;;;306    				// !!!! go back to 0 and triger interrupt when reach ACT_PERIOD again !!!!
;;;307    				TIMER_SET_CMP_VALUE(TIMER0, tMotor.structMotor.unActualPeriod);
;;;308    				TIMER_Start(TIMER0);				// Once started, running and interrupting until Motor stop
;;;309    				TIMER_EnableInt(TIMER0);
;;;310    				unPeriodChangeCNT_AfterPR_ReachMini = 0;
;;;311    				unPhaseChangeCNT_AtCurrentDuty = 0;
;;;312    				unPhaseChangeCNT_AtCurrentPeriod = 0;
;;;313    				tMotorState = MOTOR_RAMPUP_WO_ZXD;
;;;314    			}
;;;315    		} else {
;;;316    			BLDC_stopMotor();
;;;317    		}
;;;318    		break;
;;;319    
;;;320    	case MOTOR_RAMPUP_WO_ZXD:	// without zero cross detection
;;;321    		if (tMotor.structMotor.MCR.bMotorNeedToRun && NO_MOTOR_EEROR) {
;;;322    			BLDCRampUp_Manager();
;;;323    			if (tMotor.structMotor.unActualPeriod <= MOTOR_START_ZXD_SPEED)	//(iRampUpPeriodMiniCNT > MOTOR_START_ZXD_MINROT_CNT)  //
;;;324    			{
;;;325    				tMotor.structMotor.MSR.bThisPhaseDetectedZX = FALSE;
;;;326    				tMotor.structMotor.MSR.bZeroCrossDetecting = TRUE;
;;;327    				// Speed is enough for zero cross detecting
;;;328    				// Prepare everything
;;;329    				// T0 used to change phase automatically -- already configured
;;;330    				// T1 used to filter ZX
;;;331    
;;;332    //				TIMER_SET_CMP_VALUE(TIMER1, GET_TIM1_CMP_VALUE(TIMER1->TDR + AVOID_ZXD_AFTER_PHCHG));
;;;333    //				FLAG_TIM1_USEAGE = ENUM_TIM1_AVOID_ZXD;
;;;334    				ACMP0_ENABLE;
;;;335    				TIMER_Start(TIMER1);				// Once started, running until Motor stop
;;;336    //				TIMER_EnableInt(TIMER1);
;;;337    						// Suppose last ZX detected time
;;;338    //				unLastZXDetectedTime = MINI51_TIM_CNT_MAX - tMotor.structMotor.ACT_PERIOD / 2;
;;;339    				tMotorState = MOTOR_RAMPUP_W_ZXD;
;;;340    			}
;;;341    		} else {
;;;342    			BLDC_stopMotor();
;;;343    		}
;;;344    		break;
;;;345    
;;;346    	case MOTOR_RAMPUP_W_ZXD:	// with zero cross detection
;;;347    		if (tMotor.structMotor.MCR.bMotorNeedToRun && NO_MOTOR_EEROR) {
;;;348    			if (TRUE == tMotor.structMotor.MSR.bLocked) {
;;;349    				// Finally, everything was prepared:
;;;350    				// T0 used to change phase automatically
;;;351    				// T1 used to filter ZX
;;;352    				tMotorState = MOTOR_LOCKED;
;;;353    			} else {
;;;354    				if (unPeriodChangeCNT_AfterPR_ReachMini < RAMP_UP_MIN_PERIOD_NUM_THRS) {
;;;355    					BLDCRampUp_Manager();
;;;356    				} else {
;;;357    					setError(ERR_RAMPUP_FAIL);
;;;358    				}
;;;359    			}
;;;360    		} else {
;;;361    			BLDC_stopMotor();
;;;362    		}
;;;363    		break;
;;;364    
;;;365    	case MOTOR_LOCKED:
;;;366    		if (tMotor.structMotor.MCR.bMotorNeedToRun && NO_MOTOR_EEROR) {
;;;367    			BLDCSpeedManager();	// Mainly PWM duty increase/decrease
;;;368    		} else {
;;;369    			BLDC_stopMotor();
;;;370    		}
;;;371    		break;
;;;372    
;;;373    	default:
;;;374    		break;
;;;375    	}
;;;376    }
000172  bdf8              POP      {r3-r7,pc}
000174  8862              LDRH     r2,[r4,#2]            ;245  ; tMotor
000176  07d2              LSLS     r2,r2,#31             ;245
000178  d016              BEQ      |L1.424|
00017a  6800              LDR      r0,[r0,#0]            ;245  ; unErrorMaster
00017c  0840              LSRS     r0,r0,#1              ;245
00017e  d113              BNE      |L1.424|
000180  716f              STRB     r7,[r5,#5]            ;257
000182  70af              STRB     r7,[r5,#2]            ;258
000184  80e7              STRH     r7,[r4,#6]            ;259
000186  6830              LDR      r0,[r6,#0]            ;260  ; unSystemTick
000188  6168              STR      r0,[r5,#0x14]         ;261  ; unLastPhaseChangeTime
00018a  88a0              LDRH     r0,[r4,#4]            ;261  ; tMotor
00018c  4308              ORRS     r0,r0,r1              ;261
00018e  80a0              STRH     r0,[r4,#4]            ;261
000190  88a0              LDRH     r0,[r4,#4]            ;263  ; tMotor
000192  2202              MOVS     r2,#2                 ;263
000194  4390              BICS     r0,r0,r2              ;263
000196  80a0              STRH     r0,[r4,#4]            ;263
000198  88a3              LDRH     r3,[r4,#4]            ;264  ; tMotor
00019a  2004              MOVS     r0,#4                 ;264
00019c  4383              BICS     r3,r3,r0              ;264
00019e  80a3              STRH     r3,[r4,#4]            ;264
0001a0  4851              LDR      r0,|L1.744|
0001a2  6201              STR      r1,[r0,#0x20]         ;266
0001a4  702a              STRB     r2,[r5,#0]            ;267
0001a6  bdf8              POP      {r3-r7,pc}
                  |L1.424|
0001a8  f7fffffe          BL       BLDC_stopMotor
                  |L1.428|
0001ac  bdf8              POP      {r3-r7,pc}
0001ae  8861              LDRH     r1,[r4,#2]            ;276  ; tMotor
0001b0  07c9              LSLS     r1,r1,#31             ;276
0001b2  d0f9              BEQ      |L1.424|
0001b4  6800              LDR      r0,[r0,#0]            ;276  ; unErrorMaster
0001b6  0840              LSRS     r0,r0,#1              ;276
0001b8  d1f6              BNE      |L1.424|
0001ba  f7fffffe          BL       BLDC_LocatingManager
0001be  2801              CMP      r0,#1                 ;277
0001c0  d1f4              BNE      |L1.428|
0001c2  6830              LDR      r0,[r6,#0]            ;278  ; unSystemTick
0001c4  6128              STR      r0,[r5,#0x10]         ;279  ; iEnterTimeBeforeWait
0001c6  2003              MOVS     r0,#3                 ;279
0001c8  e03f              B        |L1.586|
0001ca  8862              LDRH     r2,[r4,#2]            ;287  ; tMotor
0001cc  07d2              LSLS     r2,r2,#31             ;287
                  |L1.462|
0001ce  d0eb              BEQ      |L1.424|
0001d0  6800              LDR      r0,[r0,#0]            ;287  ; unErrorMaster
0001d2  0840              LSRS     r0,r0,#1              ;287
                  |L1.468|
0001d4  d1e8              BNE      |L1.424|
0001d6  6830              LDR      r0,[r6,#0]            ;288  ; unSystemTick
0001d8  89a0              LDRH     r0,[r4,#0xc]          ;289  ; tMotor
0001da  8220              STRH     r0,[r4,#0x10]         ;289
0001dc  69a0              LDR      r0,[r4,#0x18]         ;290  ; tMotor
0001de  61e0              STR      r0,[r4,#0x1c]         ;290  ; tMotor
0001e0  88a0              LDRH     r0,[r4,#4]            ;291  ; tMotor
0001e2  460e              MOV      r6,r1                 ;291
0001e4  4330              ORRS     r0,r0,r6              ;291
0001e6  80a0              STRH     r0,[r4,#4]            ;291
0001e8  7968              LDRB     r0,[r5,#5]            ;292  ; unCurrentPhase
0001ea  2805              CMP      r0,#5                 ;292
0001ec  d201              BCS      |L1.498|
0001ee  1c40              ADDS     r0,r0,#1              ;292
0001f0  e000              B        |L1.500|
                  |L1.498|
0001f2  2000              MOVS     r0,#0                 ;292
                  |L1.500|
0001f4  b2c1              UXTB     r1,r0                 ;292
0001f6  7169              STRB     r1,[r5,#5]            ;292
0001f8  8a20              LDRH     r0,[r4,#0x10]         ;293  ; tMotor
0001fa  f7fffffe          BL       setPhaseManually
0001fe  483a              LDR      r0,|L1.744|
000200  6206              STR      r6,[r0,#0x20]         ;294
000202  7968              LDRB     r0,[r5,#5]            ;301  ; unCurrentPhase
000204  2805              CMP      r0,#5                 ;301
000206  d201              BCS      |L1.524|
000208  1c40              ADDS     r0,r0,#1              ;301
00020a  e000              B        |L1.526|
                  |L1.524|
00020c  2000              MOVS     r0,#0                 ;301
                  |L1.526|
00020e  b2c0              UXTB     r0,r0                 ;301
000210  7168              STRB     r0,[r5,#5]            ;301
000212  8861              LDRH     r1,[r4,#2]            ;302  ; tMotor
000214  0789              LSLS     r1,r1,#30             ;302
000216  d402              BMI      |L1.542|
000218  0080              LSLS     r0,r0,#2              ;302
00021a  4930              LDR      r1,|L1.732|
00021c  e002              B        |L1.548|
                  |L1.542|
00021e  492f              LDR      r1,|L1.732|
000220  0080              LSLS     r0,r0,#2              ;302
000222  3118              ADDS     r1,r1,#0x18           ;302
                  |L1.548|
000224  5808              LDR      r0,[r1,r0]            ;302
000226  492c              LDR      r1,|L1.728|
000228  3140              ADDS     r1,r1,#0x40           ;302
00022a  63c8              STR      r0,[r1,#0x3c]         ;302
00022c  69e1              LDR      r1,[r4,#0x1c]         ;307  ; tMotor
00022e  482f              LDR      r0,|L1.748|
000230  6041              STR      r1,[r0,#4]            ;307
000232  6801              LDR      r1,[r0,#0]            ;307
000234  0382              LSLS     r2,r0,#14             ;307
000236  4311              ORRS     r1,r1,r2              ;307
000238  6001              STR      r1,[r0,#0]            ;307
00023a  6801              LDR      r1,[r0,#0]            ;307
00023c  0342              LSLS     r2,r0,#13             ;307
00023e  4311              ORRS     r1,r1,r2              ;307
000240  6001              STR      r1,[r0,#0]            ;307
000242  812f              STRH     r7,[r5,#8]            ;310
000244  712f              STRB     r7,[r5,#4]            ;311
000246  70ef              STRB     r7,[r5,#3]            ;312
000248  2004              MOVS     r0,#4                 ;313
                  |L1.586|
00024a  7028              STRB     r0,[r5,#0]            ;279
                  |L1.588|
00024c  bdf8              POP      {r3-r7,pc}
00024e  8861              LDRH     r1,[r4,#2]            ;321  ; tMotor
000250  07c9              LSLS     r1,r1,#31             ;321
000252  d0a9              BEQ      |L1.424|
000254  6800              LDR      r0,[r0,#0]            ;321  ; unErrorMaster
000256  0840              LSRS     r0,r0,#1              ;321
000258  d1a6              BNE      |L1.424|
00025a  f7fffffe          BL       BLDCRampUp_Manager
00025e  69e0              LDR      r0,[r4,#0x1c]         ;323  ; tMotor
000260  4926              LDR      r1,|L1.764|
000262  4288              CMP      r0,r1                 ;323
000264  d8f2              BHI      |L1.588|
000266  88a0              LDRH     r0,[r4,#4]            ;325  ; tMotor
000268  2108              MOVS     r1,#8                 ;325
00026a  4388              BICS     r0,r0,r1              ;325
00026c  80a0              STRH     r0,[r4,#4]            ;325
00026e  88a0              LDRH     r0,[r4,#4]            ;326  ; tMotor
000270  2102              MOVS     r1,#2                 ;326
000272  4308              ORRS     r0,r0,r1              ;326
000274  80a0              STRH     r0,[r4,#4]            ;326
000276  4822              LDR      r0,|L1.768|
000278  6801              LDR      r1,[r0,#0]            ;334
00027a  2305              MOVS     r3,#5                 ;334
00027c  4319              ORRS     r1,r1,r3              ;334
00027e  6001              STR      r1,[r0,#0]            ;334
000280  481a              LDR      r0,|L1.748|
000282  3020              ADDS     r0,r0,#0x20           ;334
000284  6802              LDR      r2,[r0,#0]            ;334
000286  0641              LSLS     r1,r0,#25             ;334
000288  430a              ORRS     r2,r2,r1              ;334
00028a  6002              STR      r2,[r0,#0]            ;334
00028c  702b              STRB     r3,[r5,#0]            ;339
00028e  bdf8              POP      {r3-r7,pc}
000290  8861              LDRH     r1,[r4,#2]            ;347  ; tMotor
000292  07c9              LSLS     r1,r1,#31             ;347
000294  d088              BEQ      |L1.424|
000296  6800              LDR      r0,[r0,#0]            ;347  ; unErrorMaster
000298  0840              LSRS     r0,r0,#1              ;347
00029a  d185              BNE      |L1.424|
00029c  88a0              LDRH     r0,[r4,#4]            ;348  ; tMotor
00029e  0740              LSLS     r0,r0,#29             ;348
0002a0  d501              BPL      |L1.678|
0002a2  2006              MOVS     r0,#6                 ;352
0002a4  e7d1              B        |L1.586|
                  |L1.678|
0002a6  8928              LDRH     r0,[r5,#8]            ;354  ; unPeriodChangeCNT_AfterPR_ReachMini
0002a8  21ff              MOVS     r1,#0xff              ;354
0002aa  312d              ADDS     r1,r1,#0x2d           ;354
0002ac  4288              CMP      r0,r1                 ;354
0002ae  d202              BCS      |L1.694|
0002b0  f7fffffe          BL       BLDCRampUp_Manager
0002b4  bdf8              POP      {r3-r7,pc}
                  |L1.694|
0002b6  2004              MOVS     r0,#4                 ;357
0002b8  f7fffffe          BL       setError
0002bc  bdf8              POP      {r3-r7,pc}
0002be  8861              LDRH     r1,[r4,#2]            ;366  ; tMotor
0002c0  07c9              LSLS     r1,r1,#31             ;366
0002c2  d084              BEQ      |L1.462|
0002c4  6800              LDR      r0,[r0,#0]            ;366  ; unErrorMaster
0002c6  0840              LSRS     r0,r0,#1              ;366
0002c8  d184              BNE      |L1.468|
0002ca  f7fffffe          BL       BLDCSpeedManager
0002ce  bdf8              POP      {r3-r7,pc}
;;;377    
                          ENDP

                  |L1.720|
                          DCD      ||.data||
                  |L1.724|
                          DCD      ||.bss||
                  |L1.728|
                          DCD      0x40040000
                  |L1.732|
                          DCD      ||.constdata||+0x4
                  |L1.736|
                          DCD      unSystemTick
                  |L1.740|
                          DCD      0x0000ffff
                  |L1.744|
                          DCD      0x50004240
                  |L1.748|
                          DCD      0x40010000
                  |L1.752|
                          DCD      0x000002dd
                  |L1.756|
                          DCD      _ZZ23phaseDurationProtectionE14unCurrentPHCHG
                  |L1.760|
                          DCD      unErrorMaster
                  |L1.764|
                          DCD      0x0000063f
                  |L1.768|
                          DCD      0x400d0000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  tMotor
                          %        52

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  unLocatePhaseSequencyTable
000000  00010201          DCB      0x00,0x01,0x02,0x01
                  PHASE_TAB_CLOCKWISE
                          DCD      0x40000239
                          DCD      0x700002ad
                          DCD      0x50000827
                          DCD      0x400008b6
                          DCD      0x7000201e
                          DCD      0x5000209b
                  PHASE_TAB_ANTICLOCKWISE
                          DCD      0x400002b9
                          DCD      0x5000201b
                          DCD      0x7000209e
                          DCD      0x40000836
                          DCD      0x500008a7
                          DCD      0x7000022d

                          AREA ||.data||, DATA, ALIGN=2

                  tMotorState
000000  00                DCB      0x00
                  tRotateDetectState
000001  00                DCB      0x00
                  unLocateIndex
000002  00                DCB      0x00
                  unPhaseChangeCNT_AtCurrentPeriod
000003  00                DCB      0x00
                  unPhaseChangeCNT_AtCurrentDuty
000004  00                DCB      0x00
                  unCurrentPhase
000005  00                DCB      0x00
                  FLAG_PHASE_CHANGED
000006  0000              DCB      0x00,0x00
                  unPeriodChangeCNT_AfterPR_ReachMini
000008  00000000          DCB      0x00,0x00,0x00,0x00
                  unStateEnterTime
                          DCD      0x00000000
                  iEnterTimeBeforeWait
                          DCD      0x00000000
                  unLastPhaseChangeTime
                          DCD      0x00000000
                  unRotateDetectStartTime
                          DCD      0x00000000
                  unLastZXDetectedTime
                          DCD      0x00000000

                          AREA ||area_number.7||, DATA, ALIGN=0

                          EXPORTAS ||area_number.7||, ||.data||
                  FLAG_TIM1_USEAGE
000000  00                DCB      0x00

                          AREA ||area_number.8||, DATA, ALIGN=2

                          EXPORTAS ||area_number.8||, ||.data||
                  unZXMatchCNT
                          DCD      0x00000000

                          AREA ||i.PhaseChangedRoutine||, COMGROUP=PhaseChangedRoutine, CODE, READONLY, ALIGN=2

                  PhaseChangedRoutine PROC
;;;26     
;;;27     __INLINE void PhaseChangedRoutine(void) {
000000  b5f8              PUSH     {r3-r7,lr}
;;;28     	FLAG_PHASE_CHANGED = RESET;
000002  4e33              LDR      r6,|L20.208|
000004  2500              MOVS     r5,#0
;;;29     	tMotor.structMotor.unPhaseChangeCNT++;
000006  4c33              LDR      r4,|L20.212|
000008  71b5              STRB     r5,[r6,#6]            ;28
00000a  6a20              LDR      r0,[r4,#0x20]  ; tMotor
00000c  1c40              ADDS     r0,r0,#1
00000e  6220              STR      r0,[r4,#0x20]  ; tMotor
;;;30     
;;;31     	if (TRUE == tMotor.structMotor.MSR.bZeroCrossDetecting) {
000010  88a0              LDRH     r0,[r4,#4]  ; tMotor
000012  0780              LSLS     r0,r0,#30
000014  d548              BPL      |L20.168|
;;;32     //		iPhaseChangeTime = TIMER_GetCounter(TIMER1);
;;;33     		// Miss ZXD or ZXD success filter
;;;34     		// If continuously detected more than MIN_SUCC_ZXD_THRESHOLD ZX, OK! GOOD!!
;;;35     		if (TRUE == tMotor.structMotor.MSR.bThisPhaseDetectedZX) {
000016  88a0              LDRH     r0,[r4,#4]  ; tMotor
;;;36     			tMotor.structMotor.unMissedZXD_CNT = 0;
;;;37     
;;;38     			if (tMotor.structMotor.unSuccessZXD_CNT > MIN_SUCC_ZXD_THRESHOLD) {
;;;39     				tMotor.structMotor.MSR.bLocked = TRUE;
000018  2704              MOVS     r7,#4
00001a  0700              LSLS     r0,r0,#28             ;35
00001c  2800              CMP      r0,#0                 ;35
00001e  da0b              BGE      |L20.56|
000020  80e5              STRH     r5,[r4,#6]            ;36
000022  8920              LDRH     r0,[r4,#8]            ;38  ; tMotor
000024  2804              CMP      r0,#4                 ;38
000026  d903              BLS      |L20.48|
000028  88a0              LDRH     r0,[r4,#4]  ; tMotor
00002a  4338              ORRS     r0,r0,r7
00002c  80a0              STRH     r0,[r4,#4]
00002e  e03b              B        |L20.168|
                  |L20.48|
;;;40     			} else {
;;;41     				tMotor.structMotor.unSuccessZXD_CNT++;
000030  8920              LDRH     r0,[r4,#8]  ; tMotor
000032  1c40              ADDS     r0,r0,#1
000034  8120              STRH     r0,[r4,#8]
000036  e037              B        |L20.168|
                  |L20.56|
;;;42     			}
;;;43     		} else		// If continuously missing detected more than MAX_MISS_ZXD_THRESHOLD ZX, loss lock
;;;44     		{
;;;45     			tMotor.structMotor.unSuccessZXD_CNT = 0;
000038  8125              STRH     r5,[r4,#8]
00003a  4827              LDR      r0,|L20.216|
00003c  68c1              LDR      r1,[r0,#0xc]
;;;46     			// If ZX was not detected in last phase, unLastZXDetectedTime was also not updated
;;;47     			// Guess one value
;;;48     			unLastZXDetectedTime = GET_TIMER_DIFF((tMotor.structMotor.unActualPeriod >> 2), TIMER_GetCounter(TIMER1));
00003e  69e2              LDR      r2,[r4,#0x1c]  ; tMotor
000040  0892              LSRS     r2,r2,#2
000042  4291              CMP      r1,r2
000044  68c1              LDR      r1,[r0,#0xc]
000046  69e2              LDR      r2,[r4,#0x1c]  ; tMotor
000048  d902              BLS      |L20.80|
00004a  0892              LSRS     r2,r2,#2
00004c  1a89              SUBS     r1,r1,r2
00004e  e003              B        |L20.88|
                  |L20.80|
000050  4b22              LDR      r3,|L20.220|
000052  0892              LSRS     r2,r2,#2
000054  1a9a              SUBS     r2,r3,r2
000056  1889              ADDS     r1,r1,r2
                  |L20.88|
000058  61f1              STR      r1,[r6,#0x1c]  ; unLastZXDetectedTime
;;;49     			if (tMotor.structMotor.unMissedZXD_CNT > MAX_MISS_ZXD_THRESHOLD) {
00005a  88e1              LDRH     r1,[r4,#6]  ; tMotor
00005c  290c              CMP      r1,#0xc
00005e  d920              BLS      |L20.162|
;;;50     				if (TRUE == tMotor.structMotor.MSR.bLocked) {
000060  88a1              LDRH     r1,[r4,#4]  ; tMotor
000062  0749              LSLS     r1,r1,#29
000064  d520              BPL      |L20.168|
;;;51     					tMotor.structMotor.MSR.bLocked = FALSE;
000066  88a1              LDRH     r1,[r4,#4]  ; tMotor
000068  43b9              BICS     r1,r1,r7
00006a  80a1              STRH     r1,[r4,#4]
;;;52     					MOTOR_SHUT_DOWN;
00006c  491c              LDR      r1,|L20.224|
00006e  620d              STR      r5,[r1,#0x20]
000070  4a1c              LDR      r2,|L20.228|
000072  6155              STR      r5,[r2,#0x14]
000074  4918              LDR      r1,|L20.216|
000076  3920              SUBS     r1,r1,#0x20
000078  680d              LDR      r5,[r1,#0]
00007a  038b              LSLS     r3,r1,#14
00007c  439d              BICS     r5,r5,r3
00007e  600d              STR      r5,[r1,#0]
000080  6805              LDR      r5,[r0,#0]
000082  439d              BICS     r5,r5,r3
000084  6005              STR      r5,[r0,#0]
000086  680d              LDR      r5,[r1,#0]
000088  034b              LSLS     r3,r1,#13
00008a  439d              BICS     r5,r5,r3
00008c  600d              STR      r5,[r1,#0]
00008e  6801              LDR      r1,[r0,#0]
000090  4399              BICS     r1,r1,r3
000092  6001              STR      r1,[r0,#0]
000094  20ff              MOVS     r0,#0xff
000096  63d0              STR      r0,[r2,#0x3c]
000098  6390              STR      r0,[r2,#0x38]
;;;53     					setError(ERR_INTERNAL);
00009a  2006              MOVS     r0,#6
00009c  f7fffffe          BL       setError
0000a0  e002              B        |L20.168|
                  |L20.162|
;;;54     				}
;;;55     			} else {
;;;56     				tMotor.structMotor.unMissedZXD_CNT++;
0000a2  88e0              LDRH     r0,[r4,#6]  ; tMotor
0000a4  1c40              ADDS     r0,r0,#1
0000a6  80e0              STRH     r0,[r4,#6]
                  |L20.168|
;;;57     			}
;;;58     		}
;;;59     
;;;60     	}
;;;61     
;;;62     	if (TRUE == tMotor.structMotor.MSR.bLocked) {
0000a8  88a0              LDRH     r0,[r4,#4]  ; tMotor
0000aa  0740              LSLS     r0,r0,#29
0000ac  d504              BPL      |L20.184|
;;;63     		// Set a rough next phase change time as the same with last phase
;;;64     		// After detected ZX in TIM1 interrupt, next phase change time will be re-configured
;;;65     		TIMER_SET_CMP_VALUE(TIMER0, tMotor.structMotor.unActualPeriod << 1);
0000ae  69e0              LDR      r0,[r4,#0x1c]  ; tMotor
0000b0  0041              LSLS     r1,r0,#1
0000b2  4809              LDR      r0,|L20.216|
0000b4  3820              SUBS     r0,r0,#0x20
0000b6  6041              STR      r1,[r0,#4]
                  |L20.184|
;;;66     	}
;;;67     
;;;68     	tMotor.structMotor.MSR.bThisPhaseDetectedZX = FALSE;
0000b8  88a0              LDRH     r0,[r4,#4]  ; tMotor
0000ba  2108              MOVS     r1,#8
0000bc  4388              BICS     r0,r0,r1
0000be  80a0              STRH     r0,[r4,#4]
;;;69     	// For debug
;;;70     	GPIO_TOGGLE(P50);
0000c0  4807              LDR      r0,|L20.224|
0000c2  3040              ADDS     r0,r0,#0x40
0000c4  6a01              LDR      r1,[r0,#0x20]
0000c6  2201              MOVS     r2,#1
0000c8  4051              EORS     r1,r1,r2
0000ca  6201              STR      r1,[r0,#0x20]
;;;71     }
0000cc  bdf8              POP      {r3-r7,pc}
;;;72     
                          ENDP

0000ce  0000              DCW      0x0000
                  |L20.208|
                          DCD      ||.data||
                  |L20.212|
                          DCD      ||.bss||
                  |L20.216|
                          DCD      0x40010020
                  |L20.220|
                          DCD      0x00ffffff
                  |L20.224|
                          DCD      0x50004240
                  |L20.228|
                          DCD      0x40040040

                          AREA ||i.BLDC_stopMotor||, COMGROUP=BLDC_stopMotor, CODE, READONLY, ALIGN=2

                  BLDC_stopMotor PROC
;;;153    
;;;154    __INLINE void BLDC_stopMotor(void) {
000000  b530              PUSH     {r4,r5,lr}
;;;155    	MOTOR_SHUT_DOWN;
000002  4812              LDR      r0,|L27.76|
000004  2200              MOVS     r2,#0
000006  6202              STR      r2,[r0,#0x20]
000008  4b11              LDR      r3,|L27.80|
00000a  615a              STR      r2,[r3,#0x14]
00000c  4811              LDR      r0,|L27.84|
00000e  6801              LDR      r1,[r0,#0]
000010  0384              LSLS     r4,r0,#14
000012  43a1              BICS     r1,r1,r4
000014  6001              STR      r1,[r0,#0]
000016  490f              LDR      r1,|L27.84|
000018  3120              ADDS     r1,r1,#0x20
00001a  680d              LDR      r5,[r1,#0]
00001c  43a5              BICS     r5,r5,r4
00001e  600d              STR      r5,[r1,#0]
000020  6805              LDR      r5,[r0,#0]
000022  0344              LSLS     r4,r0,#13
000024  43a5              BICS     r5,r5,r4
000026  6005              STR      r5,[r0,#0]
000028  6808              LDR      r0,[r1,#0]
00002a  43a0              BICS     r0,r0,r4
00002c  6008              STR      r0,[r1,#0]
00002e  20ff              MOVS     r0,#0xff
000030  63d8              STR      r0,[r3,#0x3c]
000032  6398              STR      r0,[r3,#0x38]
;;;156    	tMotor.structMotor.MCR.bMotorNeedToRun = FALSE;
000034  4808              LDR      r0,|L27.88|
000036  8841              LDRH     r1,[r0,#2]  ; tMotor
000038  0849              LSRS     r1,r1,#1
00003a  0049              LSLS     r1,r1,#1
00003c  8041              STRH     r1,[r0,#2]
;;;157    	tMotor.structMotor.MSR.bMotorPowerOn = FALSE;
00003e  8881              LDRH     r1,[r0,#4]  ; tMotor
000040  0849              LSRS     r1,r1,#1
000042  0049              LSLS     r1,r1,#1
000044  8081              STRH     r1,[r0,#4]
;;;158    	tMotorState = MOTOR_IDLE;
000046  4805              LDR      r0,|L27.92|
000048  7002              STRB     r2,[r0,#0]
;;;159    }
00004a  bd30              POP      {r4,r5,pc}
;;;160    
                          ENDP

                  |L27.76|
                          DCD      0x50004240
                  |L27.80|
                          DCD      0x40040040
                  |L27.84|
                          DCD      0x40010000
                  |L27.88|
                          DCD      ||.bss||
                  |L27.92|
                          DCD      ||.data||

                          AREA ||i.setPhaseManually||, COMGROUP=setPhaseManually, CODE, READONLY, ALIGN=2

                  setPhaseManually PROC
;;;160    
;;;161    __INLINE void setPhaseManually(uint16_t iPWMDuty, uint8_t iPhase) {
000000  4a09              LDR      r2,|L34.40|
;;;162    	MOTOR_SET_DUTY(iPWMDuty);
000002  6290              STR      r0,[r2,#0x28]
000004  6310              STR      r0,[r2,#0x30]
000006  6390              STR      r0,[r2,#0x38]
;;;163    	PWM->PHCHG = GET_PHASE_VALUE(iPhase);
000008  4808              LDR      r0,|L34.44|
00000a  8840              LDRH     r0,[r0,#2]  ; tMotor
00000c  0782              LSLS     r2,r0,#30
00000e  0088              LSLS     r0,r1,#2
000010  2a00              CMP      r2,#0
000012  db01              BLT      |L34.24|
000014  4906              LDR      r1,|L34.48|
000016  e001              B        |L34.28|
                  |L34.24|
000018  4905              LDR      r1,|L34.48|
00001a  3118              ADDS     r1,r1,#0x18
                  |L34.28|
00001c  5808              LDR      r0,[r1,r0]
00001e  4902              LDR      r1,|L34.40|
000020  3140              ADDS     r1,r1,#0x40
000022  6388              STR      r0,[r1,#0x38]
;;;164    }
000024  4770              BX       lr
;;;165    
                          ENDP

000026  0000              DCW      0x0000
                  |L34.40|
                          DCD      0x40040000
                  |L34.44|
                          DCD      ||.bss||
                  |L34.48|
                          DCD      ||.constdata||+0x4

                          AREA ||i.BLDCRampUp_Manager||, COMGROUP=BLDCRampUp_Manager, CODE, READONLY, ALIGN=2

                  BLDCRampUp_Manager PROC
;;;181    
;;;182    __INLINE void BLDCRampUp_Manager(void) {
000000  b570              PUSH     {r4-r6,lr}
;;;183    	if (SET == FLAG_PHASE_CHANGED) {
000002  4d1e              LDR      r5,|L41.124|
000004  79a8              LDRB     r0,[r5,#6]  ; FLAG_PHASE_CHANGED
000006  2801              CMP      r0,#1
000008  d136              BNE      |L41.120|
;;;184    		PhaseChangedRoutine();
00000a  f7fffffe          BL       PhaseChangedRoutine
;;;185    		if (unPhaseChangeCNT_AtCurrentPeriod > CHANGE_DT_PR_AFTER_PHASE_CHANGED_NUM) {
00000e  78e8              LDRB     r0,[r5,#3]  ; unPhaseChangeCNT_AtCurrentPeriod
;;;186    			unPhaseChangeCNT_AtCurrentPeriod = 0;
;;;187    			// Change duty and period 
;;;188    //			MOTOR_RAMPUP_DT_INCR(tMotor.structMotor.ACT_DUTY);			
;;;189    			MOTOR_RAMPUP_PR_DCR(tMotor.structMotor.unActualPeriod);
000010  4c1b              LDR      r4,|L41.128|
000012  2809              CMP      r0,#9                 ;185
000014  d916              BLS      |L41.68|
000016  2000              MOVS     r0,#0                 ;186
000018  70e8              STRB     r0,[r5,#3]            ;186
00001a  69e0              LDR      r0,[r4,#0x1c]  ; tMotor
00001c  4e19              LDR      r6,|L41.132|
00001e  42b0              CMP      r0,r6
000020  69e0              LDR      r0,[r4,#0x1c]  ; tMotor
000022  d308              BCC      |L41.54|
000024  f7fffffe          BL       __aeabi_ui2d
000028  4a17              LDR      r2,|L41.136|
00002a  4b18              LDR      r3,|L41.140|
00002c  f7fffffe          BL       __aeabi_dmul
000030  f7fffffe          BL       __aeabi_d2uiz
000034  b280              UXTH     r0,r0
                  |L41.54|
000036  61e0              STR      r0,[r4,#0x1c]  ; tMotor
;;;190    			if (tMotor.structMotor.unActualPeriod <= MOTOR_RAMPUP_PR_MIN) {
000038  69e0              LDR      r0,[r4,#0x1c]  ; tMotor
00003a  42b0              CMP      r0,r6
00003c  d802              BHI      |L41.68|
;;;191    				unPeriodChangeCNT_AfterPR_ReachMini++;
00003e  8928              LDRH     r0,[r5,#8]  ; unPeriodChangeCNT_AfterPR_ReachMini
000040  1c40              ADDS     r0,r0,#1
000042  8128              STRH     r0,[r5,#8]
                  |L41.68|
;;;192    			}
;;;193    		}
;;;194    		unPhaseChangeCNT_AtCurrentPeriod++;
000044  78e8              LDRB     r0,[r5,#3]  ; unPhaseChangeCNT_AtCurrentPeriod
000046  1c40              ADDS     r0,r0,#1
000048  70e8              STRB     r0,[r5,#3]
;;;195    //		MOTOR_SET_DUTY(tMotor.structMotor.ACT_DUTY);
;;;196    		TIMER_SET_CMP_VALUE(TIMER0, tMotor.structMotor.unActualPeriod);
00004a  69e0              LDR      r0,[r4,#0x1c]  ; tMotor
00004c  4910              LDR      r1,|L41.144|
00004e  6048              STR      r0,[r1,#4]
;;;197    		PHASE_INCREASE(unCurrentPhase);
000050  7968              LDRB     r0,[r5,#5]  ; unCurrentPhase
000052  2805              CMP      r0,#5
000054  d201              BCS      |L41.90|
000056  1c40              ADDS     r0,r0,#1
000058  e000              B        |L41.92|
                  |L41.90|
00005a  2000              MOVS     r0,#0
                  |L41.92|
00005c  b2c0              UXTB     r0,r0
00005e  7168              STRB     r0,[r5,#5]
;;;198    		// Modify PWM->PHCHGNXT at last because I don't know how long needed to reload PHCH with PHCHNEXT after TIM0 time-out
;;;199    		PWM->PHCHGNXT = GET_PHASE_VALUE(unCurrentPhase);
000060  8861              LDRH     r1,[r4,#2]  ; tMotor
000062  0789              LSLS     r1,r1,#30
000064  d402              BMI      |L41.108|
000066  0080              LSLS     r0,r0,#2
000068  490a              LDR      r1,|L41.148|
00006a  e002              B        |L41.114|
                  |L41.108|
00006c  4909              LDR      r1,|L41.148|
00006e  0080              LSLS     r0,r0,#2
000070  3118              ADDS     r1,r1,#0x18
                  |L41.114|
000072  5808              LDR      r0,[r1,r0]
000074  4908              LDR      r1,|L41.152|
000076  63c8              STR      r0,[r1,#0x3c]
                  |L41.120|
;;;200    	}
;;;201    }
000078  bd70              POP      {r4-r6,pc}
;;;202    
                          ENDP

00007a  0000              DCW      0x0000
                  |L41.124|
                          DCD      ||.data||
                  |L41.128|
                          DCD      ||.bss||
                  |L41.132|
                          DCD      0x000003e7
                  |L41.136|
                          DCD      0xf5c28f5c
                  |L41.140|
                          DCD      0x3fef5c28
                  |L41.144|
                          DCD      0x40010000
                  |L41.148|
                          DCD      ||.constdata||+0x4
                  |L41.152|
                          DCD      0x40040040

                          AREA ||.data__ZZ23phaseDurationProtectionE14unCurrentPHCHG||, COMGROUP=_ZZ23phaseDurationProtectionE14unCurrentPHCHG, DATA, ALIGN=2

                  _ZZ23phaseDurationProtectionE14unCurrentPHCHG
                          DCD      0x00000000

                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d200              BCS      |L50.16|
00000e  461d              MOV      r5,r3
                  |L50.16|
000010  5d63              LDRB     r3,[r4,r5]
000012  005b              LSLS     r3,r3,#1
000014  18e3              ADDS     r3,r4,r3
000016  bc30              POP      {r4,r5}
000018  4718              BX       r3
                          ENDP


;*** Start embedded assembler ***

#line 1 "User\\BLDCSensorLess.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_BLDCSensorLess_c_0df2b5b8____REV16|
#line 464 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.1.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___16_BLDCSensorLess_c_0df2b5b8____REV16| PROC
#line 465

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_BLDCSensorLess_c_0df2b5b8____REVSH|
#line 479
|__asm___16_BLDCSensorLess_c_0df2b5b8____REVSH| PROC
#line 480

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
