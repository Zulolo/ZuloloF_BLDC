; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\bldcsensorless.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\bldcsensorless.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\Mini51Series\Include -I..\..\..\Library\StdDriver\inc -I.\StdDriver\inc -I.\CMSIS -IG:\Geek\Projects\Zulolo_F\Force\Code\Zulolo_F_Force\RTE -ID:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.0.7\Device\Mini51\Include -ID:\Keil_v5\ARM\CMSIS\Include -I\ -D__MICROLIB -D__UVISION_VERSION=518 --omf_browse=.\obj\bldcsensorless.crf User\BLDCSensorLess.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  canMotorContinueRunning PROC
;;;87        1-65534: phase time */
;;;88     uint16_t canMotorContinueRunning(void)
000000  2000              MOVS     r0,#0
;;;89     {
;;;90     	uint16_t unPhaseDuration = 0;
;;;91     	static uint32_t unStateEnterTime;
;;;92     // Later implement this when motor can rotate
;;;93     // Then stop it while rotating to measure the waveform
;;;94     // Manually rotate it is too slow 
;;;95     	return 0;
;;;96     
;;;97     	if ((uint32_t)(unSystemTick - unRotateDetectStartTime) > MAX_ALREADY_ROTATING_DETECT_TIME)
;;;98     	{
;;;99     		return 0;
;;;100    	}
;;;101    	switch (tRotateDetectState)
;;;102    	{
;;;103    	case DETECT_START: 
;;;104    		unStateEnterTime = unSystemTick;
;;;105    		tRotateDetectState = DETECT_PHASE_1_P;
;;;106    		break;
;;;107    
;;;108    	case DETECT_PHASE_1_P:
;;;109    		if ((uint32_t)(unSystemTick - unStateEnterTime) > MAX_ROTATING_DETECT_PHASE_TIME)
;;;110    		{
;;;111    			return (uint16_t)0;
;;;112    		}
;;;113    		else
;;;114    		{
;;;115    
;;;116    		}
;;;117    		break; 
;;;118    
;;;119    	case DETECT_PHASE_1_A:
;;;120    
;;;121    		break;
;;;122    
;;;123    	case DETECT_PHASE_2_P:
;;;124    
;;;125    		break;
;;;126    
;;;127    	case DETECT_PHASE_2_A:
;;;128    
;;;129    		break;
;;;130    
;;;131    	case DETECT_PHASE_3_P:
;;;132    
;;;133    		break;
;;;134    
;;;135    	case DETECT_PHASE_3_A:
;;;136    
;;;137    		break;
;;;138    
;;;139    	default:
;;;140    		break;
;;;141    	}
;;;142    
;;;143    	return unPhaseDuration;
;;;144    }
000002  4770              BX       lr
;;;145    
                          ENDP

                  BLDCSpeedManager PROC
;;;146    // Mainly PWM duty increase/decrease
;;;147    void BLDCSpeedManager(void)
000004  b510              PUSH     {r4,lr}
;;;148    {
;;;149    	if (SET == FLAG_PHASE_CHANGED)
000006  4cb2              LDR      r4,|L1.720|
000008  79a0              LDRB     r0,[r4,#6]  ; FLAG_PHASE_CHANGED
00000a  2801              CMP      r0,#1
00000c  d133              BNE      |L1.118|
;;;150    	{
;;;151    		PhaseChangedRoutine();
00000e  f7fffffe          BL       PhaseChangedRoutine
;;;152    
;;;153    		if (tMotor.structMotor.unActualDuty != tMotor.structMotor.unTargetDuty)
000012  49b0              LDR      r1,|L1.724|
000014  8a08              LDRH     r0,[r1,#0x10]  ; tMotor
000016  89ca              LDRH     r2,[r1,#0xe]  ; tMotor
000018  4290              CMP      r0,r2
00001a  d017              BEQ      |L1.76|
;;;154    		{
;;;155    //				tMotor.structMotor.ACT_DUTY = tMotor.structMotor.TGT_DUTY;
;;;156    				// Change PWM duty after each x phase change
;;;157    			if (unPhaseChangeCNT_AtCurrentDuty > CHANGE_DUTY_AFTER_PHASE_CHANGED_NUM)
00001c  7920              LDRB     r0,[r4,#4]  ; unPhaseChangeCNT_AtCurrentDuty
00001e  2805              CMP      r0,#5
000020  d911              BLS      |L1.70|
;;;158    			{
;;;159    				unPhaseChangeCNT_AtCurrentDuty = 0;
000022  2000              MOVS     r0,#0
000024  7120              STRB     r0,[r4,#4]
;;;160    				if (tMotor.structMotor.unActualDuty < tMotor.structMotor.unTargetDuty)
000026  8a08              LDRH     r0,[r1,#0x10]  ; tMotor
000028  89ca              LDRH     r2,[r1,#0xe]  ; tMotor
00002a  4290              CMP      r0,r2
;;;161    				{
;;;162    					tMotor.structMotor.unActualDuty++;
;;;163    				}
;;;164    				else
;;;165    				{
;;;166    					tMotor.structMotor.unActualDuty--;
00002c  8a08              LDRH     r0,[r1,#0x10]  ; tMotor
00002e  d201              BCS      |L1.52|
000030  1c40              ADDS     r0,r0,#1              ;160
000032  e000              B        |L1.54|
                  |L1.52|
000034  1e40              SUBS     r0,r0,#1              ;162
                  |L1.54|
000036  8208              STRH     r0,[r1,#0x10]
;;;167    				}
;;;168    				MOTOR_SET_DUTY(tMotor.structMotor.unActualDuty);
000038  8a0a              LDRH     r2,[r1,#0x10]  ; tMotor
00003a  48a7              LDR      r0,|L1.728|
00003c  6282              STR      r2,[r0,#0x28]
00003e  8a0a              LDRH     r2,[r1,#0x10]  ; tMotor
000040  6302              STR      r2,[r0,#0x30]
000042  8a0a              LDRH     r2,[r1,#0x10]  ; tMotor
000044  6382              STR      r2,[r0,#0x38]
                  |L1.70|
;;;169    			}
;;;170    			unPhaseChangeCNT_AtCurrentDuty++;
000046  7920              LDRB     r0,[r4,#4]  ; unPhaseChangeCNT_AtCurrentDuty
000048  1c40              ADDS     r0,r0,#1
00004a  7120              STRB     r0,[r4,#4]
                  |L1.76|
;;;171    		}
;;;172    		
;;;173    		PHASE_INCREASE(unCurrentPhase);
00004c  7960              LDRB     r0,[r4,#5]  ; unCurrentPhase
00004e  2805              CMP      r0,#5
000050  d201              BCS      |L1.86|
000052  1c40              ADDS     r0,r0,#1
000054  e000              B        |L1.88|
                  |L1.86|
000056  2000              MOVS     r0,#0
                  |L1.88|
000058  b2c0              UXTB     r0,r0
00005a  7160              STRB     r0,[r4,#5]
;;;174    		// Modify PWM->PHCHGNXT at last because I don't know how long needed to reload PHCH with PHCHNEXT after TIM0 time-out
;;;175    		PWM->PHCHGNXT = GET_PHASE_VALUE(unCurrentPhase);
00005c  8849              LDRH     r1,[r1,#2]  ; tMotor
00005e  0789              LSLS     r1,r1,#30
000060  d402              BMI      |L1.104|
000062  0080              LSLS     r0,r0,#2
000064  499d              LDR      r1,|L1.732|
000066  e002              B        |L1.110|
                  |L1.104|
000068  499c              LDR      r1,|L1.732|
00006a  0080              LSLS     r0,r0,#2
00006c  3118              ADDS     r1,r1,#0x18
                  |L1.110|
00006e  5808              LDR      r0,[r1,r0]
000070  4999              LDR      r1,|L1.728|
000072  3140              ADDS     r1,r1,#0x40
000074  63c8              STR      r0,[r1,#0x3c]
                  |L1.118|
;;;176    	}
;;;177    }
000076  bd10              POP      {r4,pc}
;;;178    
                          ENDP

                  BLDC_LocatingManager PROC
;;;192    
;;;193    ENUM_STATUS BLDC_LocatingManager(void)
000078  b5f8              PUSH     {r3-r7,lr}
;;;194    {
;;;195    	if ((uint32_t)(unSystemTick - unLastPhaseChangeTime) > tMotor.structMotor.unLocatingPeriod)
00007a  4899              LDR      r0,|L1.736|
00007c  6800              LDR      r0,[r0,#0]  ; unSystemTick
00007e  4c94              LDR      r4,|L1.720|
000080  4b94              LDR      r3,|L1.724|
000082  6961              LDR      r1,[r4,#0x14]  ; unLastPhaseChangeTime
000084  1a40              SUBS     r0,r0,r1
000086  8a59              LDRH     r1,[r3,#0x12]  ; tMotor
000088  4288              CMP      r0,r1
00008a  d90b              BLS      |L1.164|
;;;196    	{
;;;197    		if (unLocateIndex < (sizeof(unLocatePhaseSequencyTable)/sizeof(uint8_t)))
00008c  78a0              LDRB     r0,[r4,#2]  ; unLocateIndex
00008e  2804              CMP      r0,#4
000090  d20a              BCS      |L1.168|
;;;198    		{
;;;199    			//iLastPhaseChangeTime = unSystemTick; 
;;;200    			setPhaseManually(tMotor.structMotor.unLocatingDuty, unLocatePhaseSequencyTable[unLocateIndex]);
000092  4992              LDR      r1,|L1.732|
000094  1f09              SUBS     r1,r1,#4
000096  5c09              LDRB     r1,[r1,r0]
000098  8958              LDRH     r0,[r3,#0xa]  ; tMotor
00009a  f7fffffe          BL       setPhaseManually
;;;201    			unLocateIndex++;
00009e  78a0              LDRB     r0,[r4,#2]  ; unLocateIndex
0000a0  1c40              ADDS     r0,r0,#1
0000a2  70a0              STRB     r0,[r4,#2]
                  |L1.164|
;;;202    		}
;;;203    		else
;;;204    		{
;;;205    			MOTOR_SHUT_DOWN;
;;;206    			tMotor.structMotor.MSR.bMotorPowerOn = FALSE;
;;;207    			unCurrentPhase = unLocatePhaseSequencyTable[unLocateIndex - 1];
;;;208    			return STATUS_FINISHED;
;;;209    		}
;;;210    	}
;;;211    	return STATUS_WORKING;
0000a4  488f              LDR      r0,|L1.740|
;;;212    }
0000a6  bdf8              POP      {r3-r7,pc}
                  |L1.168|
0000a8  4a8f              LDR      r2,|L1.744|
0000aa  2100              MOVS     r1,#0                 ;205
0000ac  6211              STR      r1,[r2,#0x20]         ;205
0000ae  4d8a              LDR      r5,|L1.728|
0000b0  3540              ADDS     r5,r5,#0x40           ;205
0000b2  6169              STR      r1,[r5,#0x14]         ;205
0000b4  498d              LDR      r1,|L1.748|
0000b6  680a              LDR      r2,[r1,#0]            ;205
0000b8  038e              LSLS     r6,r1,#14             ;205
0000ba  43b2              BICS     r2,r2,r6              ;205
0000bc  600a              STR      r2,[r1,#0]            ;205
0000be  4a8b              LDR      r2,|L1.748|
0000c0  3220              ADDS     r2,r2,#0x20           ;205
0000c2  6817              LDR      r7,[r2,#0]            ;205
0000c4  43b7              BICS     r7,r7,r6              ;205
0000c6  6017              STR      r7,[r2,#0]            ;205
0000c8  680f              LDR      r7,[r1,#0]            ;205
0000ca  034e              LSLS     r6,r1,#13             ;205
0000cc  43b7              BICS     r7,r7,r6              ;205
0000ce  600f              STR      r7,[r1,#0]            ;205
0000d0  6811              LDR      r1,[r2,#0]            ;205
0000d2  43b1              BICS     r1,r1,r6              ;205
0000d4  6011              STR      r1,[r2,#0]            ;205
0000d6  21ff              MOVS     r1,#0xff              ;205
0000d8  63e9              STR      r1,[r5,#0x3c]         ;205
0000da  63a9              STR      r1,[r5,#0x38]         ;205
0000dc  8899              LDRH     r1,[r3,#4]            ;206  ; tMotor
0000de  0849              LSRS     r1,r1,#1              ;206
0000e0  0049              LSLS     r1,r1,#1              ;206
0000e2  8099              STRH     r1,[r3,#4]            ;206
0000e4  497d              LDR      r1,|L1.732|
0000e6  1f09              SUBS     r1,r1,#4              ;207
0000e8  1808              ADDS     r0,r1,r0              ;207
0000ea  3820              SUBS     r0,r0,#0x20           ;207
0000ec  7fc0              LDRB     r0,[r0,#0x1f]         ;207
0000ee  7160              STRB     r0,[r4,#5]            ;207
0000f0  2001              MOVS     r0,#1                 ;208
0000f2  bdf8              POP      {r3-r7,pc}
;;;213    
                          ENDP

                  BLDC_SensorLessManager PROC
;;;271    // Take charge of all Motot control
;;;272    void BLDC_SensorLessManager(void)
0000f4  b5f8              PUSH     {r3-r7,lr}
0000f6  4c77              LDR      r4,|L1.724|
0000f8  8a21              LDRH     r1,[r4,#0x10]  ; tMotor
0000fa  487d              LDR      r0,|L1.752|
0000fc  4281              CMP      r1,r0
;;;273    {
0000fe  d803              BHI      |L1.264|
000100  4975              LDR      r1,|L1.728|
000102  6a89              LDR      r1,[r1,#0x28]
000104  4281              CMP      r1,r0
000106  d904              BLS      |L1.274|
                  |L1.264|
000108  f7fffffe          BL       BLDC_stopMotor
00010c  2006              MOVS     r0,#6
00010e  f7fffffe          BL       setError
                  |L1.274|
;;;274    	uint16_t unMotorAlreadyRotatingPhaseTime;
;;;275    	static uint32_t iEnterTimeBeforeWait;
;;;276    
;;;277    	dutyProtection();
;;;278    	phaseDurationProtection(unLastPhaseChangeTime);
000112  4d6f              LDR      r5,|L1.720|
000114  88a1              LDRH     r1,[r4,#4]  ; tMotor
000116  6968              LDR      r0,[r5,#0x14]  ; unLastPhaseChangeTime
000118  4e71              LDR      r6,|L1.736|
00011a  07c9              LSLS     r1,r1,#31
00011c  d013              BEQ      |L1.326|
00011e  496e              LDR      r1,|L1.728|
000120  3140              ADDS     r1,r1,#0x40
000122  6b8b              LDR      r3,[r1,#0x38]
000124  4a73              LDR      r2,|L1.756|
000126  6817              LDR      r7,[r2,#0]  ; _ZZ23phaseDurationProtectionE14unCurrentPHCHG
000128  42bb              CMP      r3,r7
00012a  d003              BEQ      |L1.308|
00012c  6b88              LDR      r0,[r1,#0x38]
00012e  6010              STR      r0,[r2,#0]  ; _ZZ23phaseDurationProtectionE14unCurrentPHCHG
000130  6830              LDR      r0,[r6,#0]  ; unSystemTick
000132  e008              B        |L1.326|
                  |L1.308|
000134  6831              LDR      r1,[r6,#0]  ; unSystemTick
000136  1a08              SUBS     r0,r1,r0
000138  2850              CMP      r0,#0x50
00013a  d904              BLS      |L1.326|
00013c  f7fffffe          BL       BLDC_stopMotor
000140  2006              MOVS     r0,#6
000142  f7fffffe          BL       setError
                  |L1.326|
;;;279    
;;;280    	switch (tMotorState)
000146  782a              LDRB     r2,[r5,#0]  ; tMotorState
;;;281    	{
;;;282    	case MOTOR_IDLE:
;;;283    		if (tMotor.structMotor.MCR.bMotorNeedToRun && NO_MOTOR_EEROR)
000148  486b              LDR      r0,|L1.760|
00014a  2700              MOVS     r7,#0
00014c  2101              MOVS     r1,#1                 ;280
00014e  0013              MOVS     r3,r2                 ;280
000150  f7fffffe          BL       __ARM_common_switch8
000154  0705102d          DCB      0x07,0x05,0x10,0x2d
000158  3b7d9eb5          DCB      0x3b,0x7d,0x9e,0xb5
00015c  0f00              DCB      0x0f,0x00
00015e  8862              LDRH     r2,[r4,#2]  ; tMotor
000160  07d2              LSLS     r2,r2,#31
000162  d006              BEQ      |L1.370|
000164  6800              LDR      r0,[r0,#0]  ; unErrorMaster
000166  0840              LSRS     r0,r0,#1
000168  d103              BNE      |L1.370|
;;;284    		{
;;;285    			unRotateDetectStartTime = unSystemTick;
00016a  6830              LDR      r0,[r6,#0]  ; unSystemTick
;;;286    			tRotateDetectState = DETECT_START;
00016c  61a8              STR      r0,[r5,#0x18]  ; unRotateDetectStartTime
00016e  706f              STRB     r7,[r5,#1]
;;;287    			tMotorState = MOTOR_START;
000170  7029              STRB     r1,[r5,#0]
                  |L1.370|
;;;288    		}
;;;289    		break;
;;;290    		
;;;291    	case MOTOR_START:
;;;292    		if (tMotor.structMotor.MCR.bMotorNeedToRun && NO_MOTOR_EEROR)
;;;293    		{
;;;294    			// Later implement this when motor can rotate
;;;295    			// Then stop it while rotating to measure the waveform
;;;296    			// Manually rotate it is too slow 
;;;297    			unMotorAlreadyRotatingPhaseTime = canMotorContinueRunning();
;;;298    			if (unMotorAlreadyRotatingPhaseTime != IS_ROTATING_DETECTING)
;;;299    			{
;;;300    				if (unMotorAlreadyRotatingPhaseTime > 0)
;;;301    				{
;;;302    					// 1 to 65534
;;;303    					tMotorState = MOTOR_LOCKED;
;;;304    				}
;;;305    				else
;;;306    				{
;;;307    					// When back to Idle state the motor was already shut down
;;;308    					// MOTOR_SHUT_DOWN;
;;;309    					unCurrentPhase = 0;
;;;310    					unLocateIndex = 0;
;;;311    					tMotor.structMotor.unMissedZXD_CNT = 0;
;;;312    					unLastPhaseChangeTime = unSystemTick;
;;;313    					tMotor.structMotor.MSR.bMotorPowerOn = TRUE;
;;;314    					// Clear start detect zero cross flag
;;;315    					tMotor.structMotor.MSR.bZeroCrossDetecting = FALSE;
;;;316    					tMotor.structMotor.MSR.bLocked = FALSE;
;;;317    					//setPhaseManually(tMotor.structMotor.LCT_DUTY, unCurrentPhase);
;;;318    					BRG_ENABLE;
;;;319    					tMotorState = MOTOR_LOCATE;
;;;320    				}
;;;321    			}
;;;322    		}
;;;323    		else
;;;324    		{
;;;325    			BLDC_stopMotor();
;;;326    		}
;;;327    		break;
;;;328    
;;;329    	case MOTOR_LOCATE:
;;;330    		if (tMotor.structMotor.MCR.bMotorNeedToRun && NO_MOTOR_EEROR)
;;;331    		{
;;;332    			if (BLDC_LocatingManager() == STATUS_FINISHED)
;;;333    			{
;;;334    				iEnterTimeBeforeWait = unSystemTick;
;;;335    				tMotorState = MOTOR_WAIT_AFTER_LOCATE;
;;;336    			}
;;;337    		}
;;;338    		else
;;;339    		{
;;;340    			BLDC_stopMotor();
;;;341    		}
;;;342    		break;
;;;343    
;;;344    	case MOTOR_WAIT_AFTER_LOCATE:
;;;345    		if (tMotor.structMotor.MCR.bMotorNeedToRun && NO_MOTOR_EEROR)
;;;346    		{
;;;347    			if ((uint32_t)(unSystemTick - iEnterTimeBeforeWait) >= WAIT_AFTER_LOCATE_TIME)
;;;348    			{
;;;349    				tMotor.structMotor.unActualDuty = tMotor.structMotor.unRampUpDuty;
;;;350    				tMotor.structMotor.unActualPeriod = tMotor.structMotor.unRampUpPeriod;
;;;351    				tMotor.structMotor.MSR.bMotorPowerOn = TRUE;
;;;352    				PHASE_INCREASE(unCurrentPhase);
;;;353    				setPhaseManually(tMotor.structMotor.unActualDuty, unCurrentPhase);
;;;354    				BRG_ENABLE;
;;;355    				// Set timer 0 valure, use timer 0 to change phase automatically
;;;356    				// ************************************************************************
;;;357    				// ----==== From here current unCurrentPhase is actually next phase ====----
;;;358    				// ----==== Because we want to use the HW auto phase changer (PWM->PHCHGNXT) ====----
;;;359    				// So increase unCurrentPhase again. Want to get real current phase value? Read PWM->PHCHG.
;;;360    				// ************************************************************************
;;;361    				PHASE_INCREASE(unCurrentPhase);
;;;362    				PWM->PHCHGNXT = GET_PHASE_VALUE(unCurrentPhase);
;;;363    				// !!!! Need to make sure CPU runs to here every min tMotor.structMotor.ACT_PERIOD time !!!
;;;364    				// !!!! If not , timer counter may already passed tMotor.structMotor.ACT_PERIOD, !!!!
;;;365    				// !!!! then need to count to max timer counter number (which is 2^24), !!!!
;;;366    				// !!!! go back to 0 and triger interrupt when reach ACT_PERIOD again !!!!
;;;367    				TIMER_SET_CMP_VALUE(TIMER0, tMotor.structMotor.unActualPeriod);
;;;368    				TIMER_Start(TIMER0);	// Once started, running and interrupting until Motor stop
;;;369    				TIMER_EnableInt(TIMER0);
;;;370    				unPeriodChangeCNT_AfterPR_ReachMini = 0;
;;;371    				unPhaseChangeCNT_AtCurrentDuty = 0;
;;;372    				unPhaseChangeCNT_AtCurrentPeriod = 0;
;;;373    				tMotorState = MOTOR_RAMPUP_WO_ZXD;
;;;374    			}
;;;375    		}
;;;376    		else
;;;377    		{
;;;378    			BLDC_stopMotor();
;;;379    		}
;;;380    		break;
;;;381    
;;;382    	case MOTOR_RAMPUP_WO_ZXD:	// without zero cross detection
;;;383    		if (tMotor.structMotor.MCR.bMotorNeedToRun && NO_MOTOR_EEROR)
;;;384    		{
;;;385    			BLDCRampUp_Manager();
;;;386    			if (tMotor.structMotor.unActualPeriod <= MOTOR_START_ZXD_SPEED)	//(iRampUpPeriodMiniCNT > MOTOR_START_ZXD_MINROT_CNT)  //
;;;387    			{
;;;388    				tMotor.structMotor.MSR.bThisPhaseDetectedZX = FALSE;
;;;389    				tMotor.structMotor.MSR.bZeroCrossDetecting = TRUE;
;;;390    				// Speed is enough for zero cross detecting
;;;391    				// Prepare everything
;;;392    				// T0 used to change phase automatically -- already configured
;;;393    				// T1 used to filter ZX
;;;394    
;;;395    //				TIMER_SET_CMP_VALUE(TIMER1, GET_TIM1_CMP_VALUE(TIMER1->TDR + AVOID_ZXD_AFTER_PHCHG));
;;;396    //				FLAG_TIM1_USEAGE = ENUM_TIM1_AVOID_ZXD;
;;;397    				ACMP0_ENABLE;
;;;398    				TIMER_Start(TIMER1);	// Once started, running until Motor stop
;;;399    //				TIMER_EnableInt(TIMER1);
;;;400    				// Suppose last ZX detected time 
;;;401    //				unLastZXDetectedTime = MINI51_TIM_CNT_MAX - tMotor.structMotor.ACT_PERIOD / 2;
;;;402    				tMotorState = MOTOR_RAMPUP_W_ZXD;
;;;403    			}
;;;404    		}
;;;405    		else
;;;406    		{
;;;407    			BLDC_stopMotor();
;;;408    		}
;;;409    		break;
;;;410    
;;;411    	case MOTOR_RAMPUP_W_ZXD:	// with zero cross detection
;;;412    		if (tMotor.structMotor.MCR.bMotorNeedToRun && NO_MOTOR_EEROR)
;;;413    		{
;;;414    			if (TRUE == tMotor.structMotor.MSR.bLocked)
;;;415    			{
;;;416    				// Finally, everything was prepared:
;;;417    				// T0 used to change phase automatically
;;;418    				// T1 used to filter ZX
;;;419    				tMotorState = MOTOR_LOCKED;
;;;420    			}
;;;421    			else
;;;422    			{
;;;423    				if (unPeriodChangeCNT_AfterPR_ReachMini < RAMP_UP_MIN_PERIOD_NUM_THRS)
;;;424    				{
;;;425    					BLDCRampUp_Manager(); 
;;;426    				}
;;;427    				else
;;;428    				{
;;;429    					setError(ERR_RAMPUP_FAIL);
;;;430    				}
;;;431    			}
;;;432    		}
;;;433    		else
;;;434    		{
;;;435    			BLDC_stopMotor();
;;;436    		}
;;;437    		break;
;;;438    
;;;439    	case MOTOR_LOCKED:
;;;440    		if (tMotor.structMotor.MCR.bMotorNeedToRun && NO_MOTOR_EEROR)
;;;441    		{
;;;442    			BLDCSpeedManager();	// Mainly PWM duty increase/decrease
;;;443    		}
;;;444    		else
;;;445    		{
;;;446    			BLDC_stopMotor();
;;;447    		}
;;;448    		break;
;;;449    
;;;450    	default:
;;;451    		break;
;;;452    	}
;;;453    }
000172  bdf8              POP      {r3-r7,pc}
000174  8862              LDRH     r2,[r4,#2]            ;292  ; tMotor
000176  07d2              LSLS     r2,r2,#31             ;292
000178  d016              BEQ      |L1.424|
00017a  6800              LDR      r0,[r0,#0]            ;292  ; unErrorMaster
00017c  0840              LSRS     r0,r0,#1              ;292
00017e  d113              BNE      |L1.424|
000180  716f              STRB     r7,[r5,#5]            ;309
000182  70af              STRB     r7,[r5,#2]            ;310
000184  80e7              STRH     r7,[r4,#6]            ;311
000186  6830              LDR      r0,[r6,#0]            ;312  ; unSystemTick
000188  6168              STR      r0,[r5,#0x14]         ;313  ; unLastPhaseChangeTime
00018a  88a0              LDRH     r0,[r4,#4]            ;313  ; tMotor
00018c  4308              ORRS     r0,r0,r1              ;313
00018e  80a0              STRH     r0,[r4,#4]            ;313
000190  88a0              LDRH     r0,[r4,#4]            ;315  ; tMotor
000192  2202              MOVS     r2,#2                 ;315
000194  4390              BICS     r0,r0,r2              ;315
000196  80a0              STRH     r0,[r4,#4]            ;315
000198  88a3              LDRH     r3,[r4,#4]            ;316  ; tMotor
00019a  2004              MOVS     r0,#4                 ;316
00019c  4383              BICS     r3,r3,r0              ;316
00019e  80a3              STRH     r3,[r4,#4]            ;316
0001a0  4851              LDR      r0,|L1.744|
0001a2  6201              STR      r1,[r0,#0x20]         ;318
0001a4  702a              STRB     r2,[r5,#0]            ;319
0001a6  bdf8              POP      {r3-r7,pc}
                  |L1.424|
0001a8  f7fffffe          BL       BLDC_stopMotor
                  |L1.428|
0001ac  bdf8              POP      {r3-r7,pc}
0001ae  8861              LDRH     r1,[r4,#2]            ;330  ; tMotor
0001b0  07c9              LSLS     r1,r1,#31             ;330
0001b2  d0f9              BEQ      |L1.424|
0001b4  6800              LDR      r0,[r0,#0]            ;330  ; unErrorMaster
0001b6  0840              LSRS     r0,r0,#1              ;330
0001b8  d1f6              BNE      |L1.424|
0001ba  f7fffffe          BL       BLDC_LocatingManager
0001be  2801              CMP      r0,#1                 ;332
0001c0  d1f4              BNE      |L1.428|
0001c2  6830              LDR      r0,[r6,#0]            ;334  ; unSystemTick
0001c4  6128              STR      r0,[r5,#0x10]         ;335  ; iEnterTimeBeforeWait
0001c6  2003              MOVS     r0,#3                 ;335
0001c8  e03f              B        |L1.586|
0001ca  8862              LDRH     r2,[r4,#2]            ;345  ; tMotor
0001cc  07d2              LSLS     r2,r2,#31             ;345
                  |L1.462|
0001ce  d0eb              BEQ      |L1.424|
0001d0  6800              LDR      r0,[r0,#0]            ;345  ; unErrorMaster
0001d2  0840              LSRS     r0,r0,#1              ;345
                  |L1.468|
0001d4  d1e8              BNE      |L1.424|
0001d6  6830              LDR      r0,[r6,#0]            ;347  ; unSystemTick
0001d8  89a0              LDRH     r0,[r4,#0xc]          ;349  ; tMotor
0001da  8220              STRH     r0,[r4,#0x10]         ;349
0001dc  69a0              LDR      r0,[r4,#0x18]         ;350  ; tMotor
0001de  61e0              STR      r0,[r4,#0x1c]         ;350  ; tMotor
0001e0  88a0              LDRH     r0,[r4,#4]            ;351  ; tMotor
0001e2  460e              MOV      r6,r1                 ;351
0001e4  4330              ORRS     r0,r0,r6              ;351
0001e6  80a0              STRH     r0,[r4,#4]            ;351
0001e8  7968              LDRB     r0,[r5,#5]            ;352  ; unCurrentPhase
0001ea  2805              CMP      r0,#5                 ;352
0001ec  d201              BCS      |L1.498|
0001ee  1c40              ADDS     r0,r0,#1              ;352
0001f0  e000              B        |L1.500|
                  |L1.498|
0001f2  2000              MOVS     r0,#0                 ;352
                  |L1.500|
0001f4  b2c1              UXTB     r1,r0                 ;352
0001f6  7169              STRB     r1,[r5,#5]            ;352
0001f8  8a20              LDRH     r0,[r4,#0x10]         ;353  ; tMotor
0001fa  f7fffffe          BL       setPhaseManually
0001fe  483a              LDR      r0,|L1.744|
000200  6206              STR      r6,[r0,#0x20]         ;354
000202  7968              LDRB     r0,[r5,#5]            ;361  ; unCurrentPhase
000204  2805              CMP      r0,#5                 ;361
000206  d201              BCS      |L1.524|
000208  1c40              ADDS     r0,r0,#1              ;361
00020a  e000              B        |L1.526|
                  |L1.524|
00020c  2000              MOVS     r0,#0                 ;361
                  |L1.526|
00020e  b2c0              UXTB     r0,r0                 ;361
000210  7168              STRB     r0,[r5,#5]            ;361
000212  8861              LDRH     r1,[r4,#2]            ;362  ; tMotor
000214  0789              LSLS     r1,r1,#30             ;362
000216  d402              BMI      |L1.542|
000218  0080              LSLS     r0,r0,#2              ;362
00021a  4930              LDR      r1,|L1.732|
00021c  e002              B        |L1.548|
                  |L1.542|
00021e  492f              LDR      r1,|L1.732|
000220  0080              LSLS     r0,r0,#2              ;362
000222  3118              ADDS     r1,r1,#0x18           ;362
                  |L1.548|
000224  5808              LDR      r0,[r1,r0]            ;362
000226  492c              LDR      r1,|L1.728|
000228  3140              ADDS     r1,r1,#0x40           ;362
00022a  63c8              STR      r0,[r1,#0x3c]         ;362
00022c  69e1              LDR      r1,[r4,#0x1c]         ;367  ; tMotor
00022e  482f              LDR      r0,|L1.748|
000230  6041              STR      r1,[r0,#4]            ;367
000232  6801              LDR      r1,[r0,#0]            ;367
000234  0382              LSLS     r2,r0,#14             ;367
000236  4311              ORRS     r1,r1,r2              ;367
000238  6001              STR      r1,[r0,#0]            ;367
00023a  6801              LDR      r1,[r0,#0]            ;367
00023c  0342              LSLS     r2,r0,#13             ;367
00023e  4311              ORRS     r1,r1,r2              ;367
000240  6001              STR      r1,[r0,#0]            ;367
000242  812f              STRH     r7,[r5,#8]            ;370
000244  712f              STRB     r7,[r5,#4]            ;371
000246  70ef              STRB     r7,[r5,#3]            ;372
000248  2004              MOVS     r0,#4                 ;373
                  |L1.586|
00024a  7028              STRB     r0,[r5,#0]            ;335
                  |L1.588|
00024c  bdf8              POP      {r3-r7,pc}
00024e  8861              LDRH     r1,[r4,#2]            ;383  ; tMotor
000250  07c9              LSLS     r1,r1,#31             ;383
000252  d0a9              BEQ      |L1.424|
000254  6800              LDR      r0,[r0,#0]            ;383  ; unErrorMaster
000256  0840              LSRS     r0,r0,#1              ;383
000258  d1a6              BNE      |L1.424|
00025a  f7fffffe          BL       BLDCRampUp_Manager
00025e  69e0              LDR      r0,[r4,#0x1c]         ;386  ; tMotor
000260  4926              LDR      r1,|L1.764|
000262  4288              CMP      r0,r1                 ;386
000264  d8f2              BHI      |L1.588|
000266  88a0              LDRH     r0,[r4,#4]            ;388  ; tMotor
000268  2108              MOVS     r1,#8                 ;388
00026a  4388              BICS     r0,r0,r1              ;388
00026c  80a0              STRH     r0,[r4,#4]            ;388
00026e  88a0              LDRH     r0,[r4,#4]            ;389  ; tMotor
000270  2102              MOVS     r1,#2                 ;389
000272  4308              ORRS     r0,r0,r1              ;389
000274  80a0              STRH     r0,[r4,#4]            ;389
000276  4822              LDR      r0,|L1.768|
000278  6801              LDR      r1,[r0,#0]            ;397
00027a  2305              MOVS     r3,#5                 ;397
00027c  4319              ORRS     r1,r1,r3              ;397
00027e  6001              STR      r1,[r0,#0]            ;397
000280  481a              LDR      r0,|L1.748|
000282  3020              ADDS     r0,r0,#0x20           ;397
000284  6802              LDR      r2,[r0,#0]            ;397
000286  0641              LSLS     r1,r0,#25             ;397
000288  430a              ORRS     r2,r2,r1              ;397
00028a  6002              STR      r2,[r0,#0]            ;397
00028c  702b              STRB     r3,[r5,#0]            ;402
00028e  bdf8              POP      {r3-r7,pc}
000290  8861              LDRH     r1,[r4,#2]            ;412  ; tMotor
000292  07c9              LSLS     r1,r1,#31             ;412
000294  d088              BEQ      |L1.424|
000296  6800              LDR      r0,[r0,#0]            ;412  ; unErrorMaster
000298  0840              LSRS     r0,r0,#1              ;412
00029a  d185              BNE      |L1.424|
00029c  88a0              LDRH     r0,[r4,#4]            ;414  ; tMotor
00029e  0740              LSLS     r0,r0,#29             ;414
0002a0  d501              BPL      |L1.678|
0002a2  2006              MOVS     r0,#6                 ;419
0002a4  e7d1              B        |L1.586|
                  |L1.678|
0002a6  8928              LDRH     r0,[r5,#8]            ;423  ; unPeriodChangeCNT_AfterPR_ReachMini
0002a8  21ff              MOVS     r1,#0xff              ;423
0002aa  312d              ADDS     r1,r1,#0x2d           ;423
0002ac  4288              CMP      r0,r1                 ;423
0002ae  d202              BCS      |L1.694|
0002b0  f7fffffe          BL       BLDCRampUp_Manager
0002b4  bdf8              POP      {r3-r7,pc}
                  |L1.694|
0002b6  2004              MOVS     r0,#4                 ;429
0002b8  f7fffffe          BL       setError
0002bc  bdf8              POP      {r3-r7,pc}
0002be  8861              LDRH     r1,[r4,#2]            ;440  ; tMotor
0002c0  07c9              LSLS     r1,r1,#31             ;440
0002c2  d084              BEQ      |L1.462|
0002c4  6800              LDR      r0,[r0,#0]            ;440  ; unErrorMaster
0002c6  0840              LSRS     r0,r0,#1              ;440
0002c8  d184              BNE      |L1.468|
0002ca  f7fffffe          BL       BLDCSpeedManager
0002ce  bdf8              POP      {r3-r7,pc}
;;;454    
                          ENDP

                  |L1.720|
                          DCD      ||.data||
                  |L1.724|
                          DCD      ||.bss||
                  |L1.728|
                          DCD      0x40040000
                  |L1.732|
                          DCD      ||.constdata||+0x4
                  |L1.736|
                          DCD      unSystemTick
                  |L1.740|
                          DCD      0x0000ffff
                  |L1.744|
                          DCD      0x50004240
                  |L1.748|
                          DCD      0x40010000
                  |L1.752|
                          DCD      0x000002dd
                  |L1.756|
                          DCD      _ZZ23phaseDurationProtectionE14unCurrentPHCHG
                  |L1.760|
                          DCD      unErrorMaster
                  |L1.764|
                          DCD      0x0000063f
                  |L1.768|
                          DCD      0x400d0000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  tMotor
                          %        52

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  unLocatePhaseSequencyTable
000000  00010201          DCB      0x00,0x01,0x02,0x01
                  PHASE_TAB_CLOCKWISE
                          DCD      0x40000239
                          DCD      0x700002ad
                          DCD      0x50000827
                          DCD      0x400008b6
                          DCD      0x7000201e
                          DCD      0x5000209b
                  PHASE_TAB_ANTICLOCKWISE
                          DCD      0x400002b9
                          DCD      0x5000201b
                          DCD      0x7000209e
                          DCD      0x40000836
                          DCD      0x500008a7
                          DCD      0x7000022d

                          AREA ||.data||, DATA, ALIGN=2

                  tMotorState
000000  00                DCB      0x00
                  tRotateDetectState
000001  00                DCB      0x00
                  unLocateIndex
000002  00                DCB      0x00
                  unPhaseChangeCNT_AtCurrentPeriod
000003  00                DCB      0x00
                  unPhaseChangeCNT_AtCurrentDuty
000004  00                DCB      0x00
                  unCurrentPhase
000005  00                DCB      0x00
                  FLAG_PHASE_CHANGED
000006  0000              DCB      0x00,0x00
                  unPeriodChangeCNT_AfterPR_ReachMini
000008  00000000          DCB      0x00,0x00,0x00,0x00
                  unStateEnterTime
                          DCD      0x00000000
                  iEnterTimeBeforeWait
                          DCD      0x00000000
                  unLastPhaseChangeTime
                          DCD      0x00000000
                  unRotateDetectStartTime
                          DCD      0x00000000
                  unLastZXDetectedTime
                          DCD      0x00000000

                          AREA ||area_number.7||, DATA, ALIGN=0

                          EXPORTAS ||area_number.7||, ||.data||
                  FLAG_TIM1_USEAGE
000000  00                DCB      0x00

                          AREA ||area_number.8||, DATA, ALIGN=2

                          EXPORTAS ||area_number.8||, ||.data||
                  unZXMatchCNT
                          DCD      0x00000000

                          AREA ||i.PhaseChangedRoutine||, COMGROUP=PhaseChangedRoutine, CODE, READONLY, ALIGN=2

                  PhaseChangedRoutine PROC
;;;26     
;;;27     __INLINE void PhaseChangedRoutine(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;28     {
;;;29     	FLAG_PHASE_CHANGED = RESET;
000002  4e33              LDR      r6,|L20.208|
000004  2500              MOVS     r5,#0
;;;30     	tMotor.structMotor.unPhaseChangeCNT++;
000006  4c33              LDR      r4,|L20.212|
000008  71b5              STRB     r5,[r6,#6]            ;29
00000a  6a20              LDR      r0,[r4,#0x20]  ; tMotor
00000c  1c40              ADDS     r0,r0,#1
00000e  6220              STR      r0,[r4,#0x20]  ; tMotor
;;;31     	
;;;32     	if (TRUE == tMotor.structMotor.MSR.bZeroCrossDetecting)
000010  88a0              LDRH     r0,[r4,#4]  ; tMotor
000012  0780              LSLS     r0,r0,#30
000014  d548              BPL      |L20.168|
;;;33     	{
;;;34     //		iPhaseChangeTime = TIMER_GetCounter(TIMER1);
;;;35     		// Miss ZXD or ZXD success filter
;;;36     		// If continuously detected more than MIN_SUCC_ZXD_THRESHOLD ZX, OK! GOOD!!
;;;37     		if (TRUE == tMotor.structMotor.MSR.bThisPhaseDetectedZX)
000016  88a0              LDRH     r0,[r4,#4]  ; tMotor
;;;38     		{
;;;39     			tMotor.structMotor.unMissedZXD_CNT = 0;
;;;40     
;;;41     			if (tMotor.structMotor.unSuccessZXD_CNT > MIN_SUCC_ZXD_THRESHOLD)
;;;42     			{
;;;43     				tMotor.structMotor.MSR.bLocked = TRUE;
000018  2704              MOVS     r7,#4
00001a  0700              LSLS     r0,r0,#28             ;37
00001c  2800              CMP      r0,#0                 ;37
00001e  da0b              BGE      |L20.56|
000020  80e5              STRH     r5,[r4,#6]            ;39
000022  8920              LDRH     r0,[r4,#8]            ;41  ; tMotor
000024  2804              CMP      r0,#4                 ;41
000026  d903              BLS      |L20.48|
000028  88a0              LDRH     r0,[r4,#4]  ; tMotor
00002a  4338              ORRS     r0,r0,r7
00002c  80a0              STRH     r0,[r4,#4]
00002e  e03b              B        |L20.168|
                  |L20.48|
;;;44     			}
;;;45     			else
;;;46     			{
;;;47     				tMotor.structMotor.unSuccessZXD_CNT++;
000030  8920              LDRH     r0,[r4,#8]  ; tMotor
000032  1c40              ADDS     r0,r0,#1
000034  8120              STRH     r0,[r4,#8]
000036  e037              B        |L20.168|
                  |L20.56|
;;;48     			}
;;;49     		}
;;;50     		else	// If continuously missing detected more than MAX_MISS_ZXD_THRESHOLD ZX, loss lock
;;;51     		{
;;;52     			tMotor.structMotor.unSuccessZXD_CNT = 0;
000038  8125              STRH     r5,[r4,#8]
00003a  4827              LDR      r0,|L20.216|
00003c  68c1              LDR      r1,[r0,#0xc]
;;;53     			// If ZX was not detected in last phase, unLastZXDetectedTime was also not updated
;;;54     			// Guess one value
;;;55     			unLastZXDetectedTime = GET_TIMER_DIFF((tMotor.structMotor.unActualPeriod >> 2), TIMER_GetCounter(TIMER1));
00003e  69e2              LDR      r2,[r4,#0x1c]  ; tMotor
000040  0892              LSRS     r2,r2,#2
000042  4291              CMP      r1,r2
000044  68c1              LDR      r1,[r0,#0xc]
000046  69e2              LDR      r2,[r4,#0x1c]  ; tMotor
000048  d902              BLS      |L20.80|
00004a  0892              LSRS     r2,r2,#2
00004c  1a89              SUBS     r1,r1,r2
00004e  e003              B        |L20.88|
                  |L20.80|
000050  4b22              LDR      r3,|L20.220|
000052  0892              LSRS     r2,r2,#2
000054  1a9a              SUBS     r2,r3,r2
000056  1889              ADDS     r1,r1,r2
                  |L20.88|
000058  61f1              STR      r1,[r6,#0x1c]  ; unLastZXDetectedTime
;;;56     			if (tMotor.structMotor.unMissedZXD_CNT > MAX_MISS_ZXD_THRESHOLD)
00005a  88e1              LDRH     r1,[r4,#6]  ; tMotor
00005c  290c              CMP      r1,#0xc
00005e  d920              BLS      |L20.162|
;;;57     			{
;;;58     				if (TRUE == tMotor.structMotor.MSR.bLocked)
000060  88a1              LDRH     r1,[r4,#4]  ; tMotor
000062  0749              LSLS     r1,r1,#29
000064  d520              BPL      |L20.168|
;;;59     				{	
;;;60     					tMotor.structMotor.MSR.bLocked = FALSE;
000066  88a1              LDRH     r1,[r4,#4]  ; tMotor
000068  43b9              BICS     r1,r1,r7
00006a  80a1              STRH     r1,[r4,#4]
;;;61     					MOTOR_SHUT_DOWN;
00006c  491c              LDR      r1,|L20.224|
00006e  620d              STR      r5,[r1,#0x20]
000070  4a1c              LDR      r2,|L20.228|
000072  6155              STR      r5,[r2,#0x14]
000074  4918              LDR      r1,|L20.216|
000076  3920              SUBS     r1,r1,#0x20
000078  680d              LDR      r5,[r1,#0]
00007a  038b              LSLS     r3,r1,#14
00007c  439d              BICS     r5,r5,r3
00007e  600d              STR      r5,[r1,#0]
000080  6805              LDR      r5,[r0,#0]
000082  439d              BICS     r5,r5,r3
000084  6005              STR      r5,[r0,#0]
000086  680d              LDR      r5,[r1,#0]
000088  034b              LSLS     r3,r1,#13
00008a  439d              BICS     r5,r5,r3
00008c  600d              STR      r5,[r1,#0]
00008e  6801              LDR      r1,[r0,#0]
000090  4399              BICS     r1,r1,r3
000092  6001              STR      r1,[r0,#0]
000094  20ff              MOVS     r0,#0xff
000096  63d0              STR      r0,[r2,#0x3c]
000098  6390              STR      r0,[r2,#0x38]
;;;62     					setError(ERR_INTERNAL);
00009a  2006              MOVS     r0,#6
00009c  f7fffffe          BL       setError
0000a0  e002              B        |L20.168|
                  |L20.162|
;;;63     				}
;;;64     			}
;;;65     			else
;;;66     			{
;;;67     				tMotor.structMotor.unMissedZXD_CNT++;
0000a2  88e0              LDRH     r0,[r4,#6]  ; tMotor
0000a4  1c40              ADDS     r0,r0,#1
0000a6  80e0              STRH     r0,[r4,#6]
                  |L20.168|
;;;68     			}
;;;69     		}
;;;70     
;;;71     	}
;;;72     
;;;73     	if (TRUE == tMotor.structMotor.MSR.bLocked)
0000a8  88a0              LDRH     r0,[r4,#4]  ; tMotor
0000aa  0740              LSLS     r0,r0,#29
0000ac  d504              BPL      |L20.184|
;;;74     	{
;;;75     		// Set a rough next phase change time as the same with last phase
;;;76     		// After detected ZX in TIM1 interrupt, next phase change time will be re-configured
;;;77     		TIMER_SET_CMP_VALUE(TIMER0, tMotor.structMotor.unActualPeriod << 1);
0000ae  69e0              LDR      r0,[r4,#0x1c]  ; tMotor
0000b0  0041              LSLS     r1,r0,#1
0000b2  4809              LDR      r0,|L20.216|
0000b4  3820              SUBS     r0,r0,#0x20
0000b6  6041              STR      r1,[r0,#4]
                  |L20.184|
;;;78     	}
;;;79     
;;;80     	tMotor.structMotor.MSR.bThisPhaseDetectedZX = FALSE;
0000b8  88a0              LDRH     r0,[r4,#4]  ; tMotor
0000ba  2108              MOVS     r1,#8
0000bc  4388              BICS     r0,r0,r1
0000be  80a0              STRH     r0,[r4,#4]
;;;81     	// For debug
;;;82     	GPIO_TOGGLE(P50);
0000c0  4807              LDR      r0,|L20.224|
0000c2  3040              ADDS     r0,r0,#0x40
0000c4  6a01              LDR      r1,[r0,#0x20]
0000c6  2201              MOVS     r2,#1
0000c8  4051              EORS     r1,r1,r2
0000ca  6201              STR      r1,[r0,#0x20]
;;;83     }
0000cc  bdf8              POP      {r3-r7,pc}
;;;84     
                          ENDP

0000ce  0000              DCW      0x0000
                  |L20.208|
                          DCD      ||.data||
                  |L20.212|
                          DCD      ||.bss||
                  |L20.216|
                          DCD      0x40010020
                  |L20.220|
                          DCD      0x00ffffff
                  |L20.224|
                          DCD      0x50004240
                  |L20.228|
                          DCD      0x40040040

                          AREA ||i.BLDC_stopMotor||, COMGROUP=BLDC_stopMotor, CODE, READONLY, ALIGN=2

                  BLDC_stopMotor PROC
;;;178    
;;;179    __INLINE void BLDC_stopMotor(void)
000000  b530              PUSH     {r4,r5,lr}
;;;180    {
;;;181    	MOTOR_SHUT_DOWN;
000002  4812              LDR      r0,|L27.76|
000004  2200              MOVS     r2,#0
000006  6202              STR      r2,[r0,#0x20]
000008  4b11              LDR      r3,|L27.80|
00000a  615a              STR      r2,[r3,#0x14]
00000c  4811              LDR      r0,|L27.84|
00000e  6801              LDR      r1,[r0,#0]
000010  0384              LSLS     r4,r0,#14
000012  43a1              BICS     r1,r1,r4
000014  6001              STR      r1,[r0,#0]
000016  490f              LDR      r1,|L27.84|
000018  3120              ADDS     r1,r1,#0x20
00001a  680d              LDR      r5,[r1,#0]
00001c  43a5              BICS     r5,r5,r4
00001e  600d              STR      r5,[r1,#0]
000020  6805              LDR      r5,[r0,#0]
000022  0344              LSLS     r4,r0,#13
000024  43a5              BICS     r5,r5,r4
000026  6005              STR      r5,[r0,#0]
000028  6808              LDR      r0,[r1,#0]
00002a  43a0              BICS     r0,r0,r4
00002c  6008              STR      r0,[r1,#0]
00002e  20ff              MOVS     r0,#0xff
000030  63d8              STR      r0,[r3,#0x3c]
000032  6398              STR      r0,[r3,#0x38]
;;;182    	tMotor.structMotor.MCR.bMotorNeedToRun = FALSE;
000034  4808              LDR      r0,|L27.88|
000036  8841              LDRH     r1,[r0,#2]  ; tMotor
000038  0849              LSRS     r1,r1,#1
00003a  0049              LSLS     r1,r1,#1
00003c  8041              STRH     r1,[r0,#2]
;;;183    	tMotor.structMotor.MSR.bMotorPowerOn = FALSE;
00003e  8881              LDRH     r1,[r0,#4]  ; tMotor
000040  0849              LSRS     r1,r1,#1
000042  0049              LSLS     r1,r1,#1
000044  8081              STRH     r1,[r0,#4]
;;;184    	tMotorState = MOTOR_IDLE;
000046  4805              LDR      r0,|L27.92|
000048  7002              STRB     r2,[r0,#0]
;;;185    }
00004a  bd30              POP      {r4,r5,pc}
;;;186    
                          ENDP

                  |L27.76|
                          DCD      0x50004240
                  |L27.80|
                          DCD      0x40040040
                  |L27.84|
                          DCD      0x40010000
                  |L27.88|
                          DCD      ||.bss||
                  |L27.92|
                          DCD      ||.data||

                          AREA ||i.setPhaseManually||, COMGROUP=setPhaseManually, CODE, READONLY, ALIGN=2

                  setPhaseManually PROC
;;;186    
;;;187    __INLINE void setPhaseManually(uint16_t iPWMDuty, uint8_t iPhase)
000000  4a09              LDR      r2,|L34.40|
;;;188    {
;;;189        MOTOR_SET_DUTY(iPWMDuty);
000002  6290              STR      r0,[r2,#0x28]
000004  6310              STR      r0,[r2,#0x30]
000006  6390              STR      r0,[r2,#0x38]
;;;190    	PWM->PHCHG = GET_PHASE_VALUE(iPhase);
000008  4808              LDR      r0,|L34.44|
00000a  8840              LDRH     r0,[r0,#2]  ; tMotor
00000c  0782              LSLS     r2,r0,#30
00000e  0088              LSLS     r0,r1,#2
000010  2a00              CMP      r2,#0
000012  db01              BLT      |L34.24|
000014  4906              LDR      r1,|L34.48|
000016  e001              B        |L34.28|
                  |L34.24|
000018  4905              LDR      r1,|L34.48|
00001a  3118              ADDS     r1,r1,#0x18
                  |L34.28|
00001c  5808              LDR      r0,[r1,r0]
00001e  4902              LDR      r1,|L34.40|
000020  3140              ADDS     r1,r1,#0x40
000022  6388              STR      r0,[r1,#0x38]
;;;191    }
000024  4770              BX       lr
;;;192    
                          ENDP

000026  0000              DCW      0x0000
                  |L34.40|
                          DCD      0x40040000
                  |L34.44|
                          DCD      ||.bss||
                  |L34.48|
                          DCD      ||.constdata||+0x4

                          AREA ||i.BLDCRampUp_Manager||, COMGROUP=BLDCRampUp_Manager, CODE, READONLY, ALIGN=2

                  BLDCRampUp_Manager PROC
;;;213    
;;;214    __INLINE void BLDCRampUp_Manager(void)
000000  b570              PUSH     {r4-r6,lr}
;;;215    {
;;;216    	if (SET == FLAG_PHASE_CHANGED)
000002  4d1e              LDR      r5,|L41.124|
000004  79a8              LDRB     r0,[r5,#6]  ; FLAG_PHASE_CHANGED
000006  2801              CMP      r0,#1
000008  d136              BNE      |L41.120|
;;;217    	{
;;;218    		PhaseChangedRoutine();
00000a  f7fffffe          BL       PhaseChangedRoutine
;;;219    		if (unPhaseChangeCNT_AtCurrentPeriod > CHANGE_DT_PR_AFTER_PHASE_CHANGED_NUM)
00000e  78e8              LDRB     r0,[r5,#3]  ; unPhaseChangeCNT_AtCurrentPeriod
;;;220    		{
;;;221    			unPhaseChangeCNT_AtCurrentPeriod = 0;
;;;222    			// Change duty and period 
;;;223    //			MOTOR_RAMPUP_DT_INCR(tMotor.structMotor.ACT_DUTY);			
;;;224    			MOTOR_RAMPUP_PR_DCR(tMotor.structMotor.unActualPeriod);	
000010  4c1b              LDR      r4,|L41.128|
000012  2809              CMP      r0,#9                 ;219
000014  d916              BLS      |L41.68|
000016  2000              MOVS     r0,#0                 ;221
000018  70e8              STRB     r0,[r5,#3]            ;221
00001a  69e0              LDR      r0,[r4,#0x1c]  ; tMotor
00001c  4e19              LDR      r6,|L41.132|
00001e  42b0              CMP      r0,r6
000020  69e0              LDR      r0,[r4,#0x1c]  ; tMotor
000022  d308              BCC      |L41.54|
000024  f7fffffe          BL       __aeabi_ui2d
000028  4a17              LDR      r2,|L41.136|
00002a  4b18              LDR      r3,|L41.140|
00002c  f7fffffe          BL       __aeabi_dmul
000030  f7fffffe          BL       __aeabi_d2uiz
000034  b280              UXTH     r0,r0
                  |L41.54|
000036  61e0              STR      r0,[r4,#0x1c]  ; tMotor
;;;225    			if (tMotor.structMotor.unActualPeriod <= MOTOR_RAMPUP_PR_MIN)
000038  69e0              LDR      r0,[r4,#0x1c]  ; tMotor
00003a  42b0              CMP      r0,r6
00003c  d802              BHI      |L41.68|
;;;226    			{
;;;227    				unPeriodChangeCNT_AfterPR_ReachMini++;
00003e  8928              LDRH     r0,[r5,#8]  ; unPeriodChangeCNT_AfterPR_ReachMini
000040  1c40              ADDS     r0,r0,#1
000042  8128              STRH     r0,[r5,#8]
                  |L41.68|
;;;228    			}
;;;229    		}
;;;230    		unPhaseChangeCNT_AtCurrentPeriod++;
000044  78e8              LDRB     r0,[r5,#3]  ; unPhaseChangeCNT_AtCurrentPeriod
000046  1c40              ADDS     r0,r0,#1
000048  70e8              STRB     r0,[r5,#3]
;;;231    //		MOTOR_SET_DUTY(tMotor.structMotor.ACT_DUTY);
;;;232    		TIMER_SET_CMP_VALUE(TIMER0, tMotor.structMotor.unActualPeriod);
00004a  69e0              LDR      r0,[r4,#0x1c]  ; tMotor
00004c  4910              LDR      r1,|L41.144|
00004e  6048              STR      r0,[r1,#4]
;;;233    		PHASE_INCREASE(unCurrentPhase);
000050  7968              LDRB     r0,[r5,#5]  ; unCurrentPhase
000052  2805              CMP      r0,#5
000054  d201              BCS      |L41.90|
000056  1c40              ADDS     r0,r0,#1
000058  e000              B        |L41.92|
                  |L41.90|
00005a  2000              MOVS     r0,#0
                  |L41.92|
00005c  b2c0              UXTB     r0,r0
00005e  7168              STRB     r0,[r5,#5]
;;;234    		// Modify PWM->PHCHGNXT at last because I don't know how long needed to reload PHCH with PHCHNEXT after TIM0 time-out
;;;235    		PWM->PHCHGNXT = GET_PHASE_VALUE(unCurrentPhase);
000060  8861              LDRH     r1,[r4,#2]  ; tMotor
000062  0789              LSLS     r1,r1,#30
000064  d402              BMI      |L41.108|
000066  0080              LSLS     r0,r0,#2
000068  490a              LDR      r1,|L41.148|
00006a  e002              B        |L41.114|
                  |L41.108|
00006c  4909              LDR      r1,|L41.148|
00006e  0080              LSLS     r0,r0,#2
000070  3118              ADDS     r1,r1,#0x18
                  |L41.114|
000072  5808              LDR      r0,[r1,r0]
000074  4908              LDR      r1,|L41.152|
000076  63c8              STR      r0,[r1,#0x3c]
                  |L41.120|
;;;236    	}
;;;237    }
000078  bd70              POP      {r4-r6,pc}
;;;238    
                          ENDP

00007a  0000              DCW      0x0000
                  |L41.124|
                          DCD      ||.data||
                  |L41.128|
                          DCD      ||.bss||
                  |L41.132|
                          DCD      0x000003e7
                  |L41.136|
                          DCD      0xf5c28f5c
                  |L41.140|
                          DCD      0x3fef5c28
                  |L41.144|
                          DCD      0x40010000
                  |L41.148|
                          DCD      ||.constdata||+0x4
                  |L41.152|
                          DCD      0x40040040

                          AREA ||.data__ZZ23phaseDurationProtectionE14unCurrentPHCHG||, COMGROUP=_ZZ23phaseDurationProtectionE14unCurrentPHCHG, DATA, ALIGN=2

                  _ZZ23phaseDurationProtectionE14unCurrentPHCHG
                          DCD      0x00000000

                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d200              BCS      |L50.16|
00000e  461d              MOV      r5,r3
                  |L50.16|
000010  5d63              LDRB     r3,[r4,r5]
000012  005b              LSLS     r3,r3,#1
000014  18e3              ADDS     r3,r4,r3
000016  bc30              POP      {r4,r5}
000018  4718              BX       r3
                          ENDP


;*** Start embedded assembler ***

#line 1 "User\\BLDCSensorLess.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_BLDCSensorLess_c_0df2b5b8____REV16|
#line 118 ".\\CMSIS\\core_cmInstr.h"
|__asm___16_BLDCSensorLess_c_0df2b5b8____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_BLDCSensorLess_c_0df2b5b8____REVSH|
#line 132
|__asm___16_BLDCSensorLess_c_0df2b5b8____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
