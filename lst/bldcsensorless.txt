; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\bldcsensorless.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\bldcsensorless.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\Mini51Series\Include -I..\..\..\Library\StdDriver\inc -I.\StdDriver\inc -I.\CMSIS -I.\RTE\Device\Mini54ZDE -I.\RTE\_BLDC_driver -ID:\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.0\CMSIS\Include -ID:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.1.0\Device\Mini51\Driver -ID:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.1.0\Device\Mini51\Include -D__MICROLIB -D__UVISION_VERSION=524 -D_RTE_ -DCLK_APBCLK_ACMP_EN_Pos=CLK_APBCLK_CMP_EN_Pos -DFOR_CAR --omf_browse=.\obj\bldcsensorless.crf User\BLDCSensorLess.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  canMotorContinueRunning PROC
;;;75      1-65534: phase time */
;;;76     uint16_t canMotorContinueRunning(void) {
000000  2000              MOVS     r0,#0
;;;77     // Later implement this when motor can rotate
;;;78     // Then stop it while rotating to measure the waveform
;;;79     // Manually rotate it is too slow 
;;;80     #ifdef FOR_CAR
;;;81     	return 0;
;;;82     #else
;;;83     	uint16_t unPhaseDuration = 0;
;;;84     	static uint32_t unStateEnterTime;
;;;85     	if ((uint32_t) (unSystemTick - unRotateDetectStartTime) > MAX_ALREADY_ROTATING_DETECT_TIME) {
;;;86     		return 0;
;;;87     	}
;;;88     	switch (tRotateDetectState) {
;;;89     	case DETECT_START:
;;;90     		unStateEnterTime = unSystemTick;
;;;91     		tRotateDetectState = DETECT_PHASE_1_P;
;;;92     		break;
;;;93     
;;;94     	case DETECT_PHASE_1_P:
;;;95     		if ((uint32_t) (unSystemTick - unStateEnterTime) > MAX_ROTATING_DETECT_PHASE_TIME) {
;;;96     			return (uint16_t) 0;
;;;97     		} else {
;;;98     
;;;99     		}
;;;100    		break;
;;;101    
;;;102    	case DETECT_PHASE_1_A:
;;;103    
;;;104    		break;
;;;105    
;;;106    	case DETECT_PHASE_2_P:
;;;107    
;;;108    		break;
;;;109    
;;;110    	case DETECT_PHASE_2_A:
;;;111    
;;;112    		break;
;;;113    
;;;114    	case DETECT_PHASE_3_P:
;;;115    
;;;116    		break;
;;;117    
;;;118    	case DETECT_PHASE_3_A:
;;;119    
;;;120    		break;
;;;121    
;;;122    	default:
;;;123    		break;
;;;124    	}
;;;125    
;;;126    	return unPhaseDuration;
;;;127    #endif
;;;128    }
000002  4770              BX       lr
;;;129    
                          ENDP

                  BLDCSpeedManager PROC
;;;130    // Mainly PWM duty increase/decrease
;;;131    void BLDCSpeedManager(void) {
000004  b510              PUSH     {r4,lr}
;;;132    	if (SET == FLAG_PHASE_CHANGED) {
000006  4cb1              LDR      r4,|L1.716|
000008  79a0              LDRB     r0,[r4,#6]  ; FLAG_PHASE_CHANGED
00000a  2801              CMP      r0,#1
00000c  d133              BNE      |L1.118|
;;;133    		PhaseChangedRoutine();
00000e  f7fffffe          BL       PhaseChangedRoutine
;;;134    
;;;135    		if (tMotor.structMotor.unActualDuty != tMotor.structMotor.unTargetDuty) {
000012  49af              LDR      r1,|L1.720|
000014  8a08              LDRH     r0,[r1,#0x10]  ; tMotor
000016  89ca              LDRH     r2,[r1,#0xe]  ; tMotor
000018  4290              CMP      r0,r2
00001a  d017              BEQ      |L1.76|
;;;136    //				tMotor.structMotor.ACT_DUTY = tMotor.structMotor.TGT_DUTY;
;;;137    			// Change PWM duty after each x phase change
;;;138    			if (unPhaseChangeCNT_AtCurrentDuty > CHANGE_DUTY_AFTER_PHASE_CHANGED_NUM) {
00001c  7920              LDRB     r0,[r4,#4]  ; unPhaseChangeCNT_AtCurrentDuty
00001e  2805              CMP      r0,#5
000020  d911              BLS      |L1.70|
;;;139    				unPhaseChangeCNT_AtCurrentDuty = 0;
000022  2000              MOVS     r0,#0
000024  7120              STRB     r0,[r4,#4]
;;;140    				if (tMotor.structMotor.unActualDuty < tMotor.structMotor.unTargetDuty) {
000026  8a08              LDRH     r0,[r1,#0x10]  ; tMotor
000028  89ca              LDRH     r2,[r1,#0xe]  ; tMotor
00002a  4290              CMP      r0,r2
;;;141    					tMotor.structMotor.unActualDuty++;
;;;142    				} else {
;;;143    					tMotor.structMotor.unActualDuty--;
00002c  8a08              LDRH     r0,[r1,#0x10]  ; tMotor
00002e  d201              BCS      |L1.52|
000030  1c40              ADDS     r0,r0,#1              ;140
000032  e000              B        |L1.54|
                  |L1.52|
000034  1e40              SUBS     r0,r0,#1              ;141
                  |L1.54|
000036  8208              STRH     r0,[r1,#0x10]
;;;144    				}
;;;145    				MOTOR_SET_DUTY(tMotor.structMotor.unActualDuty);
000038  8a0a              LDRH     r2,[r1,#0x10]  ; tMotor
00003a  48a6              LDR      r0,|L1.724|
00003c  6282              STR      r2,[r0,#0x28]
00003e  8a0a              LDRH     r2,[r1,#0x10]  ; tMotor
000040  6302              STR      r2,[r0,#0x30]
000042  8a0a              LDRH     r2,[r1,#0x10]  ; tMotor
000044  6382              STR      r2,[r0,#0x38]
                  |L1.70|
;;;146    			}
;;;147    			unPhaseChangeCNT_AtCurrentDuty++;
000046  7920              LDRB     r0,[r4,#4]  ; unPhaseChangeCNT_AtCurrentDuty
000048  1c40              ADDS     r0,r0,#1
00004a  7120              STRB     r0,[r4,#4]
                  |L1.76|
;;;148    		}
;;;149    
;;;150    		PHASE_INCREASE(unCurrentPhase);
00004c  7960              LDRB     r0,[r4,#5]  ; unCurrentPhase
00004e  2805              CMP      r0,#5
000050  d201              BCS      |L1.86|
000052  1c40              ADDS     r0,r0,#1
000054  e000              B        |L1.88|
                  |L1.86|
000056  2000              MOVS     r0,#0
                  |L1.88|
000058  b2c0              UXTB     r0,r0
00005a  7160              STRB     r0,[r4,#5]
;;;151    		// Modify PWM->PHCHGNXT at last because I don't know how long needed to reload PHCH with PHCHNEXT after TIM0 time-out
;;;152    		PWM->PHCHGNXT = GET_PHASE_VALUE(unCurrentPhase);
00005c  8849              LDRH     r1,[r1,#2]  ; tMotor
00005e  0789              LSLS     r1,r1,#30
000060  d402              BMI      |L1.104|
000062  0080              LSLS     r0,r0,#2
000064  499c              LDR      r1,|L1.728|
000066  e002              B        |L1.110|
                  |L1.104|
000068  499b              LDR      r1,|L1.728|
00006a  0080              LSLS     r0,r0,#2
00006c  3118              ADDS     r1,r1,#0x18
                  |L1.110|
00006e  5808              LDR      r0,[r1,r0]
000070  4998              LDR      r1,|L1.724|
000072  3140              ADDS     r1,r1,#0x40
000074  63c8              STR      r0,[r1,#0x3c]
                  |L1.118|
;;;153    	}
;;;154    }
000076  bd10              POP      {r4,pc}
;;;155    
                          ENDP

                  BLDC_LocatingManager PROC
;;;167    
;;;168    ENUM_STATUS BLDC_LocatingManager(void) {
000078  b5f8              PUSH     {r3-r7,lr}
;;;169    	if ((uint32_t) (unSystemTick - unLastPhaseChangeTime) > tMotor.structMotor.unLocatingPeriod) {
00007a  4898              LDR      r0,|L1.732|
00007c  6800              LDR      r0,[r0,#0]  ; unSystemTick
00007e  4c93              LDR      r4,|L1.716|
000080  4b93              LDR      r3,|L1.720|
000082  68e1              LDR      r1,[r4,#0xc]  ; unLastPhaseChangeTime
000084  1a40              SUBS     r0,r0,r1
000086  8a59              LDRH     r1,[r3,#0x12]  ; tMotor
000088  4288              CMP      r0,r1
00008a  d90b              BLS      |L1.164|
;;;170    		if (unLocateIndex < (sizeof(unLocatePhaseSequencyTable) / sizeof(uint8_t))) {
00008c  78a0              LDRB     r0,[r4,#2]  ; unLocateIndex
00008e  2804              CMP      r0,#4
000090  d20a              BCS      |L1.168|
;;;171    			//iLastPhaseChangeTime = unSystemTick; 
;;;172    			setPhaseManually(tMotor.structMotor.unLocatingDuty, unLocatePhaseSequencyTable[unLocateIndex]);
000092  4991              LDR      r1,|L1.728|
000094  1f09              SUBS     r1,r1,#4
000096  5c09              LDRB     r1,[r1,r0]
000098  8958              LDRH     r0,[r3,#0xa]  ; tMotor
00009a  f7fffffe          BL       setPhaseManually
;;;173    			unLocateIndex++;
00009e  78a0              LDRB     r0,[r4,#2]  ; unLocateIndex
0000a0  1c40              ADDS     r0,r0,#1
0000a2  70a0              STRB     r0,[r4,#2]
                  |L1.164|
;;;174    		} else {
;;;175    			MOTOR_SHUT_DOWN;
;;;176    			tMotor.structMotor.MSR.bMotorPowerOn = FALSE;
;;;177    			unCurrentPhase = unLocatePhaseSequencyTable[unLocateIndex - 1];
;;;178    			return STATUS_FINISHED;
;;;179    		}
;;;180    	}
;;;181    	return STATUS_WORKING;
0000a4  488e              LDR      r0,|L1.736|
;;;182    }
0000a6  bdf8              POP      {r3-r7,pc}
                  |L1.168|
0000a8  4a8e              LDR      r2,|L1.740|
0000aa  2100              MOVS     r1,#0                 ;175
0000ac  6211              STR      r1,[r2,#0x20]         ;175
0000ae  4d89              LDR      r5,|L1.724|
0000b0  3540              ADDS     r5,r5,#0x40           ;175
0000b2  6169              STR      r1,[r5,#0x14]         ;175
0000b4  498c              LDR      r1,|L1.744|
0000b6  680a              LDR      r2,[r1,#0]            ;175
0000b8  038e              LSLS     r6,r1,#14             ;175
0000ba  43b2              BICS     r2,r2,r6              ;175
0000bc  600a              STR      r2,[r1,#0]            ;175
0000be  4a8a              LDR      r2,|L1.744|
0000c0  3220              ADDS     r2,r2,#0x20           ;175
0000c2  6817              LDR      r7,[r2,#0]            ;175
0000c4  43b7              BICS     r7,r7,r6              ;175
0000c6  6017              STR      r7,[r2,#0]            ;175
0000c8  680f              LDR      r7,[r1,#0]            ;175
0000ca  034e              LSLS     r6,r1,#13             ;175
0000cc  43b7              BICS     r7,r7,r6              ;175
0000ce  600f              STR      r7,[r1,#0]            ;175
0000d0  6811              LDR      r1,[r2,#0]            ;175
0000d2  43b1              BICS     r1,r1,r6              ;175
0000d4  6011              STR      r1,[r2,#0]            ;175
0000d6  21ff              MOVS     r1,#0xff              ;175
0000d8  63e9              STR      r1,[r5,#0x3c]         ;175
0000da  63a9              STR      r1,[r5,#0x38]         ;175
0000dc  8899              LDRH     r1,[r3,#4]            ;176  ; tMotor
0000de  0849              LSRS     r1,r1,#1              ;176
0000e0  0049              LSLS     r1,r1,#1              ;176
0000e2  8099              STRH     r1,[r3,#4]            ;176
0000e4  497c              LDR      r1,|L1.728|
0000e6  1f09              SUBS     r1,r1,#4              ;177
0000e8  1808              ADDS     r0,r1,r0              ;177
0000ea  3820              SUBS     r0,r0,#0x20           ;177
0000ec  7fc0              LDRB     r0,[r0,#0x1f]         ;177
0000ee  7160              STRB     r0,[r4,#5]            ;177
0000f0  2001              MOVS     r0,#1                 ;178
0000f2  bdf8              POP      {r3-r7,pc}
;;;183    
                          ENDP

                  BLDC_SensorLessManager PROC
;;;229    // Take charge of all Motot control
;;;230    void BLDC_SensorLessManager(void) {
0000f4  b5f8              PUSH     {r3-r7,lr}
0000f6  4c76              LDR      r4,|L1.720|
0000f8  8a21              LDRH     r1,[r4,#0x10]  ; tMotor
0000fa  487c              LDR      r0,|L1.748|
0000fc  4281              CMP      r1,r0
0000fe  d803              BHI      |L1.264|
000100  4974              LDR      r1,|L1.724|
000102  6a89              LDR      r1,[r1,#0x28]
000104  4281              CMP      r1,r0
000106  d904              BLS      |L1.274|
                  |L1.264|
000108  f7fffffe          BL       BLDC_stopMotor
00010c  2006              MOVS     r0,#6
00010e  f7fffffe          BL       setError
                  |L1.274|
;;;231    	uint16_t unMotorAlreadyRotatingPhaseTime;
;;;232    #ifdef WAIT_AFTER_LOCATE
;;;233    	static uint32_t iEnterTimeBeforeWait;
;;;234    #endif
;;;235    	dutyProtection();
;;;236    	phaseDurationProtection(unLastPhaseChangeTime);
000112  4d6e              LDR      r5,|L1.716|
000114  88a1              LDRH     r1,[r4,#4]  ; tMotor
000116  68e8              LDR      r0,[r5,#0xc]  ; unLastPhaseChangeTime
000118  4e70              LDR      r6,|L1.732|
00011a  07c9              LSLS     r1,r1,#31
00011c  d013              BEQ      |L1.326|
00011e  496d              LDR      r1,|L1.724|
000120  3140              ADDS     r1,r1,#0x40
000122  6b8b              LDR      r3,[r1,#0x38]
000124  4a72              LDR      r2,|L1.752|
000126  6817              LDR      r7,[r2,#0]  ; _ZZ23phaseDurationProtectionE14unCurrentPHCHG
000128  42bb              CMP      r3,r7
00012a  d003              BEQ      |L1.308|
00012c  6b88              LDR      r0,[r1,#0x38]
00012e  6010              STR      r0,[r2,#0]  ; _ZZ23phaseDurationProtectionE14unCurrentPHCHG
000130  6830              LDR      r0,[r6,#0]  ; unSystemTick
000132  e008              B        |L1.326|
                  |L1.308|
000134  6831              LDR      r1,[r6,#0]  ; unSystemTick
000136  1a08              SUBS     r0,r1,r0
000138  2850              CMP      r0,#0x50
00013a  d904              BLS      |L1.326|
00013c  f7fffffe          BL       BLDC_stopMotor
000140  2006              MOVS     r0,#6
000142  f7fffffe          BL       setError
                  |L1.326|
;;;237    
;;;238    	switch (tMotorState) {
000146  782a              LDRB     r2,[r5,#0]  ; tMotorState
000148  2700              MOVS     r7,#0
;;;239    	case MOTOR_IDLE:
;;;240    		if (tMotor.structMotor.MCR.bMotorNeedToRun && NO_MOTOR_EEROR) {
00014a  486a              LDR      r0,|L1.756|
00014c  2101              MOVS     r1,#1                 ;238
00014e  0013              MOVS     r3,r2                 ;238
000150  f7fffffe          BL       __ARM_common_switch8
000154  0705102c          DCB      0x07,0x05,0x10,0x2c
000158  387a9bb2          DCB      0x38,0x7a,0x9b,0xb2
00015c  0f00              DCB      0x0f,0x00
00015e  8862              LDRH     r2,[r4,#2]  ; tMotor
000160  07d2              LSLS     r2,r2,#31
000162  d006              BEQ      |L1.370|
000164  6800              LDR      r0,[r0,#0]  ; unErrorMaster
000166  0840              LSRS     r0,r0,#1
000168  d103              BNE      |L1.370|
;;;241    			unRotateDetectStartTime = unSystemTick;
00016a  6830              LDR      r0,[r6,#0]  ; unSystemTick
;;;242    			tRotateDetectState = DETECT_START;
00016c  6128              STR      r0,[r5,#0x10]  ; unRotateDetectStartTime
00016e  706f              STRB     r7,[r5,#1]
;;;243    			tMotorState = MOTOR_START;
000170  7029              STRB     r1,[r5,#0]
                  |L1.370|
;;;244    		}
;;;245    		break;
;;;246    
;;;247    	case MOTOR_START:
;;;248    		if (tMotor.structMotor.MCR.bMotorNeedToRun && NO_MOTOR_EEROR) {
;;;249    			// Later implement this when motor can rotate
;;;250    			// Then stop it while rotating to measure the waveform
;;;251    			// Manually rotate it is too slow 
;;;252    			unMotorAlreadyRotatingPhaseTime = canMotorContinueRunning();
;;;253    			if (unMotorAlreadyRotatingPhaseTime != IS_ROTATING_DETECTING) {
;;;254    				if (unMotorAlreadyRotatingPhaseTime > 0) {
;;;255    					// 1 to 65534
;;;256    					tMotorState = MOTOR_LOCKED;
;;;257    				} else {
;;;258    					// When back to Idle state the motor was already shut down
;;;259    					// MOTOR_SHUT_DOWN;
;;;260    					unCurrentPhase = 0;
;;;261    					unLocateIndex = 0;
;;;262    					tMotor.structMotor.unMissedZXD_CNT = 0;
;;;263    					unLastPhaseChangeTime = unSystemTick;
;;;264    					tMotor.structMotor.MSR.bMotorPowerOn = TRUE;
;;;265    					// Clear start detect zero cross flag
;;;266    					tMotor.structMotor.MSR.bZeroCrossDetecting = FALSE;
;;;267    					tMotor.structMotor.MSR.bLocked = FALSE;
;;;268    					//setPhaseManually(tMotor.structMotor.LCT_DUTY, unCurrentPhase);
;;;269    					BRG_ENABLE;
;;;270    					tMotorState = MOTOR_LOCATE;
;;;271    				}
;;;272    			}
;;;273    		} else {
;;;274    			BLDC_stopMotor();
;;;275    		}
;;;276    		break;
;;;277    
;;;278    	case MOTOR_LOCATE:
;;;279    		if (tMotor.structMotor.MCR.bMotorNeedToRun && NO_MOTOR_EEROR) {
;;;280    			if (BLDC_LocatingManager() == STATUS_FINISHED) {
;;;281    #ifdef WAIT_AFTER_LOCATE
;;;282    				iEnterTimeBeforeWait = unSystemTick;
;;;283    #endif
;;;284    				tMotorState = MOTOR_WAIT_AFTER_LOCATE;
;;;285    			}
;;;286    		} else {
;;;287    			BLDC_stopMotor();
;;;288    		}
;;;289    		break;
;;;290    
;;;291    	case MOTOR_WAIT_AFTER_LOCATE:
;;;292    		if (tMotor.structMotor.MCR.bMotorNeedToRun && NO_MOTOR_EEROR) {
;;;293    #ifdef WAIT_AFTER_LOCATE
;;;294    			if ((uint32_t) (unSystemTick - iEnterTimeBeforeWait) >= WAIT_AFTER_LOCATE_TIME) {
;;;295    #endif					
;;;296    				tMotor.structMotor.unActualDuty = tMotor.structMotor.unRampUpDuty;
;;;297    				tMotor.structMotor.unActualPeriod = tMotor.structMotor.unRampUpPeriod;
;;;298    				tMotor.structMotor.MSR.bMotorPowerOn = TRUE;
;;;299    				PHASE_INCREASE(unCurrentPhase);
;;;300    				setPhaseManually(tMotor.structMotor.unActualDuty, unCurrentPhase);
;;;301    				BRG_ENABLE;
;;;302    				// Set timer 0 valure, use timer 0 to change phase automatically
;;;303    				// ************************************************************************
;;;304    				// ----==== From here current unCurrentPhase is actually next phase ====----
;;;305    				// ----==== Because we want to use the HW auto phase changer (PWM->PHCHGNXT) ====----
;;;306    				// So increase unCurrentPhase again. Want to get real current phase value? Read PWM->PHCHG.
;;;307    				// ************************************************************************
;;;308    				PHASE_INCREASE(unCurrentPhase);
;;;309    				PWM->PHCHGNXT = GET_PHASE_VALUE(unCurrentPhase);
;;;310    				// !!!! Need to make sure CPU runs to here every min tMotor.structMotor.ACT_PERIOD time !!!
;;;311    				// !!!! If not , timer counter may already passed tMotor.structMotor.ACT_PERIOD, !!!!
;;;312    				// !!!! then need to count to max timer counter number (which is 2^24), !!!!
;;;313    				// !!!! go back to 0 and triger interrupt when reach ACT_PERIOD again !!!!
;;;314    				TIMER_SET_CMP_VALUE(TIMER0, tMotor.structMotor.unActualPeriod);
;;;315    				TIMER_Start(TIMER0);				// Once started, running and interrupting until Motor stop
;;;316    				TIMER_EnableInt(TIMER0);
;;;317    				unPeriodChangeCNT_AfterPR_ReachMini = 0;
;;;318    				unPhaseChangeCNT_AtCurrentDuty = 0;
;;;319    				unPhaseChangeCNT_AtCurrentPeriod = 0;
;;;320    				tMotorState = MOTOR_RAMPUP_WO_ZXD;
;;;321    #ifdef WAIT_AFTER_LOCATE
;;;322    			}
;;;323    #endif
;;;324    		} else {
;;;325    			BLDC_stopMotor();
;;;326    		}
;;;327    		break;
;;;328    
;;;329    	case MOTOR_RAMPUP_WO_ZXD:	// without zero cross detection
;;;330    		if (tMotor.structMotor.MCR.bMotorNeedToRun && NO_MOTOR_EEROR) {
;;;331    			BLDCRampUp_Manager();
;;;332    			if (tMotor.structMotor.unActualPeriod <= MOTOR_START_ZXD_SPEED)	//(iRampUpPeriodMiniCNT > MOTOR_START_ZXD_MINROT_CNT)  //
;;;333    			{
;;;334    				tMotor.structMotor.MSR.bThisPhaseDetectedZX = FALSE;
;;;335    				tMotor.structMotor.MSR.bZeroCrossDetecting = TRUE;
;;;336    				// Speed is enough for zero cross detecting
;;;337    				// Prepare everything
;;;338    				// T0 used to change phase automatically -- already configured
;;;339    				// T1 used to filter ZX
;;;340    
;;;341    //				TIMER_SET_CMP_VALUE(TIMER1, GET_TIM1_CMP_VALUE(TIMER1->TDR + AVOID_ZXD_AFTER_PHCHG));
;;;342    //				FLAG_TIM1_USEAGE = ENUM_TIM1_AVOID_ZXD;
;;;343    				ACMP0_ENABLE;
;;;344    				TIMER_Start(TIMER1);				// Once started, running until Motor stop
;;;345    //				TIMER_EnableInt(TIMER1);
;;;346    						// Suppose last ZX detected time
;;;347    //				unLastZXDetectedTime = MINI51_TIM_CNT_MAX - tMotor.structMotor.ACT_PERIOD / 2;
;;;348    				tMotorState = MOTOR_RAMPUP_W_ZXD;
;;;349    			}
;;;350    		} else {
;;;351    			BLDC_stopMotor();
;;;352    		}
;;;353    		break;
;;;354    
;;;355    	case MOTOR_RAMPUP_W_ZXD:	// with zero cross detection
;;;356    		if (tMotor.structMotor.MCR.bMotorNeedToRun && NO_MOTOR_EEROR) {
;;;357    			if (TRUE == tMotor.structMotor.MSR.bLocked) {
;;;358    				// Finally, everything was prepared:
;;;359    				// T0 used to change phase automatically
;;;360    				// T1 used to filter ZX
;;;361    				tMotorState = MOTOR_LOCKED;
;;;362    			} else {
;;;363    				if (unPeriodChangeCNT_AfterPR_ReachMini < RAMP_UP_MIN_PERIOD_NUM_THRS) {
;;;364    					BLDCRampUp_Manager();
;;;365    				} else {
;;;366    					setError(ERR_RAMPUP_FAIL);
;;;367    				}
;;;368    			}
;;;369    		} else {
;;;370    			BLDC_stopMotor();
;;;371    		}
;;;372    		break;
;;;373    
;;;374    	case MOTOR_LOCKED:
;;;375    		if (tMotor.structMotor.MCR.bMotorNeedToRun && NO_MOTOR_EEROR) {
;;;376    			BLDCSpeedManager();	// Mainly PWM duty increase/decrease
;;;377    		} else {
;;;378    			BLDC_stopMotor();
;;;379    		}
;;;380    		break;
;;;381    
;;;382    	default:
;;;383    		break;
;;;384    	}
;;;385    }
000172  bdf8              POP      {r3-r7,pc}
000174  8862              LDRH     r2,[r4,#2]            ;248  ; tMotor
000176  07d2              LSLS     r2,r2,#31             ;248
000178  d015              BEQ      |L1.422|
00017a  6800              LDR      r0,[r0,#0]            ;248  ; unErrorMaster
00017c  0840              LSRS     r0,r0,#1              ;248
00017e  d112              BNE      |L1.422|
000180  716f              STRB     r7,[r5,#5]            ;260
000182  70af              STRB     r7,[r5,#2]            ;261
000184  80e7              STRH     r7,[r4,#6]            ;262
000186  6830              LDR      r0,[r6,#0]            ;263  ; unSystemTick
000188  60e8              STR      r0,[r5,#0xc]          ;264  ; unLastPhaseChangeTime
00018a  88a0              LDRH     r0,[r4,#4]            ;264  ; tMotor
00018c  4308              ORRS     r0,r0,r1              ;264
00018e  80a0              STRH     r0,[r4,#4]            ;264
000190  88a2              LDRH     r2,[r4,#4]            ;266  ; tMotor
000192  2002              MOVS     r0,#2                 ;266
000194  4382              BICS     r2,r2,r0              ;266
000196  80a2              STRH     r2,[r4,#4]            ;266
000198  88a3              LDRH     r3,[r4,#4]            ;267  ; tMotor
00019a  2204              MOVS     r2,#4                 ;267
00019c  4393              BICS     r3,r3,r2              ;267
00019e  80a3              STRH     r3,[r4,#4]            ;267
0001a0  4a50              LDR      r2,|L1.740|
0001a2  6211              STR      r1,[r2,#0x20]         ;269
0001a4  e04e              B        |L1.580|
                  |L1.422|
0001a6  f7fffffe          BL       BLDC_stopMotor
                  |L1.426|
0001aa  bdf8              POP      {r3-r7,pc}
0001ac  8861              LDRH     r1,[r4,#2]            ;279  ; tMotor
0001ae  07c9              LSLS     r1,r1,#31             ;279
0001b0  d0f9              BEQ      |L1.422|
0001b2  6800              LDR      r0,[r0,#0]            ;279  ; unErrorMaster
0001b4  0840              LSRS     r0,r0,#1              ;279
0001b6  d1f6              BNE      |L1.422|
0001b8  f7fffffe          BL       BLDC_LocatingManager
0001bc  2801              CMP      r0,#1                 ;280
0001be  d1f4              BNE      |L1.426|
0001c0  2003              MOVS     r0,#3                 ;284
0001c2  e03f              B        |L1.580|
0001c4  8862              LDRH     r2,[r4,#2]            ;292  ; tMotor
0001c6  07d2              LSLS     r2,r2,#31             ;292
                  |L1.456|
0001c8  d0ed              BEQ      |L1.422|
0001ca  6800              LDR      r0,[r0,#0]            ;292  ; unErrorMaster
0001cc  0840              LSRS     r0,r0,#1              ;292
                  |L1.462|
0001ce  d1ea              BNE      |L1.422|
0001d0  89a0              LDRH     r0,[r4,#0xc]          ;296  ; tMotor
0001d2  4626              MOV      r6,r4                 ;296
0001d4  8220              STRH     r0,[r4,#0x10]         ;296
0001d6  69a0              LDR      r0,[r4,#0x18]         ;297  ; tMotor
0001d8  61e0              STR      r0,[r4,#0x1c]         ;297  ; tMotor
0001da  88a0              LDRH     r0,[r4,#4]            ;298  ; tMotor
0001dc  460c              MOV      r4,r1                 ;298
0001de  4320              ORRS     r0,r0,r4              ;298
0001e0  80b0              STRH     r0,[r6,#4]            ;298
0001e2  7968              LDRB     r0,[r5,#5]            ;299  ; unCurrentPhase
0001e4  2805              CMP      r0,#5                 ;299
0001e6  d201              BCS      |L1.492|
0001e8  1c40              ADDS     r0,r0,#1              ;299
0001ea  e000              B        |L1.494|
                  |L1.492|
0001ec  2000              MOVS     r0,#0                 ;299
                  |L1.494|
0001ee  b2c1              UXTB     r1,r0                 ;299
0001f0  7169              STRB     r1,[r5,#5]            ;299
0001f2  8a30              LDRH     r0,[r6,#0x10]         ;300  ; tMotor
0001f4  f7fffffe          BL       setPhaseManually
0001f8  483a              LDR      r0,|L1.740|
0001fa  6204              STR      r4,[r0,#0x20]         ;301
0001fc  7968              LDRB     r0,[r5,#5]            ;308  ; unCurrentPhase
0001fe  2805              CMP      r0,#5                 ;308
000200  d201              BCS      |L1.518|
000202  1c40              ADDS     r0,r0,#1              ;308
000204  e000              B        |L1.520|
                  |L1.518|
000206  2000              MOVS     r0,#0                 ;308
                  |L1.520|
000208  b2c0              UXTB     r0,r0                 ;308
00020a  7168              STRB     r0,[r5,#5]            ;308
00020c  8871              LDRH     r1,[r6,#2]            ;309  ; tMotor
00020e  0789              LSLS     r1,r1,#30             ;309
000210  d402              BMI      |L1.536|
000212  0080              LSLS     r0,r0,#2              ;309
000214  4930              LDR      r1,|L1.728|
000216  e002              B        |L1.542|
                  |L1.536|
000218  492f              LDR      r1,|L1.728|
00021a  0080              LSLS     r0,r0,#2              ;309
00021c  3118              ADDS     r1,r1,#0x18           ;309
                  |L1.542|
00021e  5808              LDR      r0,[r1,r0]            ;309
000220  492c              LDR      r1,|L1.724|
000222  3140              ADDS     r1,r1,#0x40           ;309
000224  63c8              STR      r0,[r1,#0x3c]         ;309
000226  69f1              LDR      r1,[r6,#0x1c]         ;314  ; tMotor
000228  482f              LDR      r0,|L1.744|
00022a  6041              STR      r1,[r0,#4]            ;314
00022c  6801              LDR      r1,[r0,#0]            ;314
00022e  0382              LSLS     r2,r0,#14             ;314
000230  4311              ORRS     r1,r1,r2              ;314
000232  6001              STR      r1,[r0,#0]            ;314
000234  6801              LDR      r1,[r0,#0]            ;314
000236  0342              LSLS     r2,r0,#13             ;314
000238  4311              ORRS     r1,r1,r2              ;314
00023a  6001              STR      r1,[r0,#0]            ;314
00023c  812f              STRH     r7,[r5,#8]            ;317
00023e  712f              STRB     r7,[r5,#4]            ;318
000240  70ef              STRB     r7,[r5,#3]            ;319
000242  2004              MOVS     r0,#4                 ;320
                  |L1.580|
000244  7028              STRB     r0,[r5,#0]            ;284
                  |L1.582|
000246  bdf8              POP      {r3-r7,pc}
000248  8861              LDRH     r1,[r4,#2]            ;330  ; tMotor
00024a  07c9              LSLS     r1,r1,#31             ;330
00024c  d0ab              BEQ      |L1.422|
00024e  6800              LDR      r0,[r0,#0]            ;330  ; unErrorMaster
000250  0840              LSRS     r0,r0,#1              ;330
000252  d1a8              BNE      |L1.422|
000254  f7fffffe          BL       BLDCRampUp_Manager
000258  69e0              LDR      r0,[r4,#0x1c]         ;332  ; tMotor
00025a  4927              LDR      r1,|L1.760|
00025c  4288              CMP      r0,r1                 ;332
00025e  d8f2              BHI      |L1.582|
000260  88a0              LDRH     r0,[r4,#4]            ;334  ; tMotor
000262  2108              MOVS     r1,#8                 ;334
000264  4388              BICS     r0,r0,r1              ;334
000266  80a0              STRH     r0,[r4,#4]            ;334
000268  88a0              LDRH     r0,[r4,#4]            ;335  ; tMotor
00026a  2102              MOVS     r1,#2                 ;335
00026c  4308              ORRS     r0,r0,r1              ;335
00026e  80a0              STRH     r0,[r4,#4]            ;335
000270  4822              LDR      r0,|L1.764|
000272  6801              LDR      r1,[r0,#0]            ;343
000274  2205              MOVS     r2,#5                 ;343
000276  4311              ORRS     r1,r1,r2              ;343
000278  6001              STR      r1,[r0,#0]            ;343
00027a  481b              LDR      r0,|L1.744|
00027c  3020              ADDS     r0,r0,#0x20           ;343
00027e  6801              LDR      r1,[r0,#0]            ;343
000280  0643              LSLS     r3,r0,#25             ;343
000282  4319              ORRS     r1,r1,r3              ;343
000284  6001              STR      r1,[r0,#0]            ;343
000286  702a              STRB     r2,[r5,#0]            ;348
000288  bdf8              POP      {r3-r7,pc}
00028a  8861              LDRH     r1,[r4,#2]            ;356  ; tMotor
00028c  07c9              LSLS     r1,r1,#31             ;356
00028e  d08a              BEQ      |L1.422|
000290  6800              LDR      r0,[r0,#0]            ;356  ; unErrorMaster
000292  0840              LSRS     r0,r0,#1              ;356
000294  d187              BNE      |L1.422|
000296  88a0              LDRH     r0,[r4,#4]            ;357  ; tMotor
000298  0740              LSLS     r0,r0,#29             ;357
00029a  d501              BPL      |L1.672|
00029c  2006              MOVS     r0,#6                 ;361
00029e  e7d1              B        |L1.580|
                  |L1.672|
0002a0  8928              LDRH     r0,[r5,#8]            ;363  ; unPeriodChangeCNT_AfterPR_ReachMini
0002a2  21ff              MOVS     r1,#0xff              ;363
0002a4  312d              ADDS     r1,r1,#0x2d           ;363
0002a6  4288              CMP      r0,r1                 ;363
0002a8  d202              BCS      |L1.688|
0002aa  f7fffffe          BL       BLDCRampUp_Manager
0002ae  bdf8              POP      {r3-r7,pc}
                  |L1.688|
0002b0  2004              MOVS     r0,#4                 ;366
0002b2  f7fffffe          BL       setError
0002b6  bdf8              POP      {r3-r7,pc}
0002b8  8861              LDRH     r1,[r4,#2]            ;375  ; tMotor
0002ba  07c9              LSLS     r1,r1,#31             ;375
0002bc  d084              BEQ      |L1.456|
0002be  6800              LDR      r0,[r0,#0]            ;375  ; unErrorMaster
0002c0  0840              LSRS     r0,r0,#1              ;375
0002c2  d184              BNE      |L1.462|
0002c4  f7fffffe          BL       BLDCSpeedManager
0002c8  bdf8              POP      {r3-r7,pc}
;;;386    
                          ENDP

0002ca  0000              DCW      0x0000
                  |L1.716|
                          DCD      ||.data||
                  |L1.720|
                          DCD      ||.bss||
                  |L1.724|
                          DCD      0x40040000
                  |L1.728|
                          DCD      ||.constdata||+0x4
                  |L1.732|
                          DCD      unSystemTick
                  |L1.736|
                          DCD      0x0000ffff
                  |L1.740|
                          DCD      0x50004240
                  |L1.744|
                          DCD      0x40010000
                  |L1.748|
                          DCD      0x000002dd
                  |L1.752|
                          DCD      _ZZ23phaseDurationProtectionE14unCurrentPHCHG
                  |L1.756|
                          DCD      unErrorMaster
                  |L1.760|
                          DCD      0x0000063f
                  |L1.764|
                          DCD      0x400d0000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  tMotor
                          %        52

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  unLocatePhaseSequencyTable
000000  00010201          DCB      0x00,0x01,0x02,0x01
                  PHASE_TAB_CLOCKWISE
                          DCD      0x40000239
                          DCD      0x700002ad
                          DCD      0x50000827
                          DCD      0x400008b6
                          DCD      0x7000201e
                          DCD      0x5000209b
                  PHASE_TAB_ANTICLOCKWISE
                          DCD      0x400002b9
                          DCD      0x5000201b
                          DCD      0x7000209e
                          DCD      0x40000836
                          DCD      0x500008a7
                          DCD      0x7000022d

                          AREA ||.data||, DATA, ALIGN=2

                  tMotorState
000000  00                DCB      0x00
                  tRotateDetectState
000001  00                DCB      0x00
                  unLocateIndex
000002  00                DCB      0x00
                  unPhaseChangeCNT_AtCurrentPeriod
000003  00                DCB      0x00
                  unPhaseChangeCNT_AtCurrentDuty
000004  00                DCB      0x00
                  unCurrentPhase
000005  00                DCB      0x00
                  FLAG_PHASE_CHANGED
000006  0000              DCB      0x00,0x00
                  unPeriodChangeCNT_AfterPR_ReachMini
000008  00000000          DCB      0x00,0x00,0x00,0x00
                  unLastPhaseChangeTime
                          DCD      0x00000000
                  unRotateDetectStartTime
                          DCD      0x00000000
                  unLastZXDetectedTime
                          DCD      0x00000000

                          AREA ||area_number.7||, DATA, ALIGN=0

                          EXPORTAS ||area_number.7||, ||.data||
                  FLAG_TIM1_USEAGE
000000  00                DCB      0x00

                          AREA ||area_number.8||, DATA, ALIGN=2

                          EXPORTAS ||area_number.8||, ||.data||
                  unZXMatchCNT
                          DCD      0x00000000

                          AREA ||i.PhaseChangedRoutine||, COMGROUP=PhaseChangedRoutine, CODE, READONLY, ALIGN=2

                  PhaseChangedRoutine PROC
;;;26     
;;;27     __INLINE void PhaseChangedRoutine(void) {
000000  b5f8              PUSH     {r3-r7,lr}
;;;28     	FLAG_PHASE_CHANGED = RESET;
000002  4e33              LDR      r6,|L20.208|
000004  2500              MOVS     r5,#0
;;;29     	tMotor.structMotor.unPhaseChangeCNT++;
000006  4c33              LDR      r4,|L20.212|
000008  71b5              STRB     r5,[r6,#6]            ;28
00000a  6a20              LDR      r0,[r4,#0x20]  ; tMotor
00000c  1c40              ADDS     r0,r0,#1
00000e  6220              STR      r0,[r4,#0x20]  ; tMotor
;;;30     
;;;31     	if (TRUE == tMotor.structMotor.MSR.bZeroCrossDetecting) {
000010  88a0              LDRH     r0,[r4,#4]  ; tMotor
000012  0780              LSLS     r0,r0,#30
000014  d548              BPL      |L20.168|
;;;32     //		iPhaseChangeTime = TIMER_GetCounter(TIMER1);
;;;33     		// Miss ZXD or ZXD success filter
;;;34     		// If continuously detected more than MIN_SUCC_ZXD_THRESHOLD ZX, OK! GOOD!!
;;;35     		if (TRUE == tMotor.structMotor.MSR.bThisPhaseDetectedZX) {
000016  88a0              LDRH     r0,[r4,#4]  ; tMotor
;;;36     			tMotor.structMotor.unMissedZXD_CNT = 0;
;;;37     
;;;38     			if (tMotor.structMotor.unSuccessZXD_CNT > MIN_SUCC_ZXD_THRESHOLD) {
;;;39     				tMotor.structMotor.MSR.bLocked = TRUE;
000018  2704              MOVS     r7,#4
00001a  0700              LSLS     r0,r0,#28             ;35
00001c  2800              CMP      r0,#0                 ;35
00001e  da0b              BGE      |L20.56|
000020  80e5              STRH     r5,[r4,#6]            ;36
000022  8920              LDRH     r0,[r4,#8]            ;38  ; tMotor
000024  2804              CMP      r0,#4                 ;38
000026  d903              BLS      |L20.48|
000028  88a0              LDRH     r0,[r4,#4]  ; tMotor
00002a  4338              ORRS     r0,r0,r7
00002c  80a0              STRH     r0,[r4,#4]
00002e  e03b              B        |L20.168|
                  |L20.48|
;;;40     			} else {
;;;41     				tMotor.structMotor.unSuccessZXD_CNT++;
000030  8920              LDRH     r0,[r4,#8]  ; tMotor
000032  1c40              ADDS     r0,r0,#1
000034  8120              STRH     r0,[r4,#8]
000036  e037              B        |L20.168|
                  |L20.56|
;;;42     			}
;;;43     		} else		// If continuously missing detected more than MAX_MISS_ZXD_THRESHOLD ZX, loss lock
;;;44     		{
;;;45     			tMotor.structMotor.unSuccessZXD_CNT = 0;
000038  8125              STRH     r5,[r4,#8]
00003a  4827              LDR      r0,|L20.216|
00003c  68c1              LDR      r1,[r0,#0xc]
;;;46     			// If ZX was not detected in last phase, unLastZXDetectedTime was also not updated
;;;47     			// Guess one value
;;;48     			unLastZXDetectedTime = GET_TIMER_DIFF((tMotor.structMotor.unActualPeriod >> 2), TIMER_GetCounter(TIMER1));
00003e  69e2              LDR      r2,[r4,#0x1c]  ; tMotor
000040  0892              LSRS     r2,r2,#2
000042  4291              CMP      r1,r2
000044  68c1              LDR      r1,[r0,#0xc]
000046  69e2              LDR      r2,[r4,#0x1c]  ; tMotor
000048  d902              BLS      |L20.80|
00004a  0892              LSRS     r2,r2,#2
00004c  1a89              SUBS     r1,r1,r2
00004e  e003              B        |L20.88|
                  |L20.80|
000050  4b22              LDR      r3,|L20.220|
000052  0892              LSRS     r2,r2,#2
000054  1a9a              SUBS     r2,r3,r2
000056  1889              ADDS     r1,r1,r2
                  |L20.88|
000058  6171              STR      r1,[r6,#0x14]  ; unLastZXDetectedTime
;;;49     			if (tMotor.structMotor.unMissedZXD_CNT > MAX_MISS_ZXD_THRESHOLD) {
00005a  88e1              LDRH     r1,[r4,#6]  ; tMotor
00005c  290c              CMP      r1,#0xc
00005e  d920              BLS      |L20.162|
;;;50     				if (TRUE == tMotor.structMotor.MSR.bLocked) {
000060  88a1              LDRH     r1,[r4,#4]  ; tMotor
000062  0749              LSLS     r1,r1,#29
000064  d520              BPL      |L20.168|
;;;51     					tMotor.structMotor.MSR.bLocked = FALSE;
000066  88a1              LDRH     r1,[r4,#4]  ; tMotor
000068  43b9              BICS     r1,r1,r7
00006a  80a1              STRH     r1,[r4,#4]
;;;52     					MOTOR_SHUT_DOWN;
00006c  491c              LDR      r1,|L20.224|
00006e  620d              STR      r5,[r1,#0x20]
000070  4a1c              LDR      r2,|L20.228|
000072  6155              STR      r5,[r2,#0x14]
000074  4918              LDR      r1,|L20.216|
000076  3920              SUBS     r1,r1,#0x20
000078  680d              LDR      r5,[r1,#0]
00007a  038b              LSLS     r3,r1,#14
00007c  439d              BICS     r5,r5,r3
00007e  600d              STR      r5,[r1,#0]
000080  6805              LDR      r5,[r0,#0]
000082  439d              BICS     r5,r5,r3
000084  6005              STR      r5,[r0,#0]
000086  680d              LDR      r5,[r1,#0]
000088  034b              LSLS     r3,r1,#13
00008a  439d              BICS     r5,r5,r3
00008c  600d              STR      r5,[r1,#0]
00008e  6801              LDR      r1,[r0,#0]
000090  4399              BICS     r1,r1,r3
000092  6001              STR      r1,[r0,#0]
000094  20ff              MOVS     r0,#0xff
000096  63d0              STR      r0,[r2,#0x3c]
000098  6390              STR      r0,[r2,#0x38]
;;;53     					setError(ERR_INTERNAL);
00009a  2006              MOVS     r0,#6
00009c  f7fffffe          BL       setError
0000a0  e002              B        |L20.168|
                  |L20.162|
;;;54     				}
;;;55     			} else {
;;;56     				tMotor.structMotor.unMissedZXD_CNT++;
0000a2  88e0              LDRH     r0,[r4,#6]  ; tMotor
0000a4  1c40              ADDS     r0,r0,#1
0000a6  80e0              STRH     r0,[r4,#6]
                  |L20.168|
;;;57     			}
;;;58     		}
;;;59     
;;;60     	}
;;;61     
;;;62     	if (TRUE == tMotor.structMotor.MSR.bLocked) {
0000a8  88a0              LDRH     r0,[r4,#4]  ; tMotor
0000aa  0740              LSLS     r0,r0,#29
0000ac  d504              BPL      |L20.184|
;;;63     		// Set a rough next phase change time as the same with last phase
;;;64     		// After detected ZX in TIM1 interrupt, next phase change time will be re-configured
;;;65     		TIMER_SET_CMP_VALUE(TIMER0, tMotor.structMotor.unActualPeriod << 1);
0000ae  69e0              LDR      r0,[r4,#0x1c]  ; tMotor
0000b0  0041              LSLS     r1,r0,#1
0000b2  4809              LDR      r0,|L20.216|
0000b4  3820              SUBS     r0,r0,#0x20
0000b6  6041              STR      r1,[r0,#4]
                  |L20.184|
;;;66     	}
;;;67     
;;;68     	tMotor.structMotor.MSR.bThisPhaseDetectedZX = FALSE;
0000b8  88a0              LDRH     r0,[r4,#4]  ; tMotor
0000ba  2108              MOVS     r1,#8
0000bc  4388              BICS     r0,r0,r1
0000be  80a0              STRH     r0,[r4,#4]
;;;69     	// For debug
;;;70     	GPIO_TOGGLE(P50);
0000c0  4807              LDR      r0,|L20.224|
0000c2  3040              ADDS     r0,r0,#0x40
0000c4  6a01              LDR      r1,[r0,#0x20]
0000c6  2201              MOVS     r2,#1
0000c8  4051              EORS     r1,r1,r2
0000ca  6201              STR      r1,[r0,#0x20]
;;;71     }
0000cc  bdf8              POP      {r3-r7,pc}
;;;72     
                          ENDP

0000ce  0000              DCW      0x0000
                  |L20.208|
                          DCD      ||.data||
                  |L20.212|
                          DCD      ||.bss||
                  |L20.216|
                          DCD      0x40010020
                  |L20.220|
                          DCD      0x00ffffff
                  |L20.224|
                          DCD      0x50004240
                  |L20.228|
                          DCD      0x40040040

                          AREA ||i.BLDC_stopMotor||, COMGROUP=BLDC_stopMotor, CODE, READONLY, ALIGN=2

                  BLDC_stopMotor PROC
;;;155    
;;;156    __INLINE void BLDC_stopMotor(void) {
000000  b530              PUSH     {r4,r5,lr}
;;;157    	MOTOR_SHUT_DOWN;
000002  4812              LDR      r0,|L27.76|
000004  2200              MOVS     r2,#0
000006  6202              STR      r2,[r0,#0x20]
000008  4b11              LDR      r3,|L27.80|
00000a  615a              STR      r2,[r3,#0x14]
00000c  4811              LDR      r0,|L27.84|
00000e  6801              LDR      r1,[r0,#0]
000010  0384              LSLS     r4,r0,#14
000012  43a1              BICS     r1,r1,r4
000014  6001              STR      r1,[r0,#0]
000016  490f              LDR      r1,|L27.84|
000018  3120              ADDS     r1,r1,#0x20
00001a  680d              LDR      r5,[r1,#0]
00001c  43a5              BICS     r5,r5,r4
00001e  600d              STR      r5,[r1,#0]
000020  6805              LDR      r5,[r0,#0]
000022  0344              LSLS     r4,r0,#13
000024  43a5              BICS     r5,r5,r4
000026  6005              STR      r5,[r0,#0]
000028  6808              LDR      r0,[r1,#0]
00002a  43a0              BICS     r0,r0,r4
00002c  6008              STR      r0,[r1,#0]
00002e  20ff              MOVS     r0,#0xff
000030  63d8              STR      r0,[r3,#0x3c]
000032  6398              STR      r0,[r3,#0x38]
;;;158    	tMotor.structMotor.MCR.bMotorNeedToRun = FALSE;
000034  4808              LDR      r0,|L27.88|
000036  8841              LDRH     r1,[r0,#2]  ; tMotor
000038  0849              LSRS     r1,r1,#1
00003a  0049              LSLS     r1,r1,#1
00003c  8041              STRH     r1,[r0,#2]
;;;159    	tMotor.structMotor.MSR.bMotorPowerOn = FALSE;
00003e  8881              LDRH     r1,[r0,#4]  ; tMotor
000040  0849              LSRS     r1,r1,#1
000042  0049              LSLS     r1,r1,#1
000044  8081              STRH     r1,[r0,#4]
;;;160    	tMotorState = MOTOR_IDLE;
000046  4805              LDR      r0,|L27.92|
000048  7002              STRB     r2,[r0,#0]
;;;161    }
00004a  bd30              POP      {r4,r5,pc}
;;;162    
                          ENDP

                  |L27.76|
                          DCD      0x50004240
                  |L27.80|
                          DCD      0x40040040
                  |L27.84|
                          DCD      0x40010000
                  |L27.88|
                          DCD      ||.bss||
                  |L27.92|
                          DCD      ||.data||

                          AREA ||i.setPhaseManually||, COMGROUP=setPhaseManually, CODE, READONLY, ALIGN=2

                  setPhaseManually PROC
;;;162    
;;;163    __INLINE void setPhaseManually(uint16_t iPWMDuty, uint8_t iPhase) {
000000  4a09              LDR      r2,|L34.40|
;;;164    	MOTOR_SET_DUTY(iPWMDuty);
000002  6290              STR      r0,[r2,#0x28]
000004  6310              STR      r0,[r2,#0x30]
000006  6390              STR      r0,[r2,#0x38]
;;;165    	PWM->PHCHG = GET_PHASE_VALUE(iPhase);
000008  4808              LDR      r0,|L34.44|
00000a  8840              LDRH     r0,[r0,#2]  ; tMotor
00000c  0782              LSLS     r2,r0,#30
00000e  0088              LSLS     r0,r1,#2
000010  2a00              CMP      r2,#0
000012  db01              BLT      |L34.24|
000014  4906              LDR      r1,|L34.48|
000016  e001              B        |L34.28|
                  |L34.24|
000018  4905              LDR      r1,|L34.48|
00001a  3118              ADDS     r1,r1,#0x18
                  |L34.28|
00001c  5808              LDR      r0,[r1,r0]
00001e  4902              LDR      r1,|L34.40|
000020  3140              ADDS     r1,r1,#0x40
000022  6388              STR      r0,[r1,#0x38]
;;;166    }
000024  4770              BX       lr
;;;167    
                          ENDP

000026  0000              DCW      0x0000
                  |L34.40|
                          DCD      0x40040000
                  |L34.44|
                          DCD      ||.bss||
                  |L34.48|
                          DCD      ||.constdata||+0x4

                          AREA ||i.BLDCRampUp_Manager||, COMGROUP=BLDCRampUp_Manager, CODE, READONLY, ALIGN=2

                  BLDCRampUp_Manager PROC
;;;183    
;;;184    __INLINE void BLDCRampUp_Manager(void) {
000000  b570              PUSH     {r4-r6,lr}
;;;185    	if (SET == FLAG_PHASE_CHANGED) {
000002  4d1e              LDR      r5,|L41.124|
000004  79a8              LDRB     r0,[r5,#6]  ; FLAG_PHASE_CHANGED
000006  2801              CMP      r0,#1
000008  d136              BNE      |L41.120|
;;;186    		PhaseChangedRoutine();
00000a  f7fffffe          BL       PhaseChangedRoutine
;;;187    		if (unPhaseChangeCNT_AtCurrentPeriod > CHANGE_DT_PR_AFTER_PHASE_CHANGED_NUM) {
00000e  78e8              LDRB     r0,[r5,#3]  ; unPhaseChangeCNT_AtCurrentPeriod
;;;188    			unPhaseChangeCNT_AtCurrentPeriod = 0;
;;;189    			// Change duty and period 
;;;190    //			MOTOR_RAMPUP_DT_INCR(tMotor.structMotor.ACT_DUTY);			
;;;191    			MOTOR_RAMPUP_PR_DCR(tMotor.structMotor.unActualPeriod);
000010  4c1b              LDR      r4,|L41.128|
000012  2809              CMP      r0,#9                 ;187
000014  d916              BLS      |L41.68|
000016  2000              MOVS     r0,#0                 ;188
000018  70e8              STRB     r0,[r5,#3]            ;188
00001a  69e0              LDR      r0,[r4,#0x1c]  ; tMotor
00001c  4e19              LDR      r6,|L41.132|
00001e  42b0              CMP      r0,r6
000020  69e0              LDR      r0,[r4,#0x1c]  ; tMotor
000022  d308              BCC      |L41.54|
000024  f7fffffe          BL       __aeabi_ui2d
000028  4a17              LDR      r2,|L41.136|
00002a  4b18              LDR      r3,|L41.140|
00002c  f7fffffe          BL       __aeabi_dmul
000030  f7fffffe          BL       __aeabi_d2uiz
000034  b280              UXTH     r0,r0
                  |L41.54|
000036  61e0              STR      r0,[r4,#0x1c]  ; tMotor
;;;192    			if (tMotor.structMotor.unActualPeriod <= MOTOR_RAMPUP_PR_MIN) {
000038  69e0              LDR      r0,[r4,#0x1c]  ; tMotor
00003a  42b0              CMP      r0,r6
00003c  d802              BHI      |L41.68|
;;;193    				unPeriodChangeCNT_AfterPR_ReachMini++;
00003e  8928              LDRH     r0,[r5,#8]  ; unPeriodChangeCNT_AfterPR_ReachMini
000040  1c40              ADDS     r0,r0,#1
000042  8128              STRH     r0,[r5,#8]
                  |L41.68|
;;;194    			}
;;;195    		}
;;;196    		unPhaseChangeCNT_AtCurrentPeriod++;
000044  78e8              LDRB     r0,[r5,#3]  ; unPhaseChangeCNT_AtCurrentPeriod
000046  1c40              ADDS     r0,r0,#1
000048  70e8              STRB     r0,[r5,#3]
;;;197    //		MOTOR_SET_DUTY(tMotor.structMotor.ACT_DUTY);
;;;198    		TIMER_SET_CMP_VALUE(TIMER0, tMotor.structMotor.unActualPeriod);
00004a  69e0              LDR      r0,[r4,#0x1c]  ; tMotor
00004c  4910              LDR      r1,|L41.144|
00004e  6048              STR      r0,[r1,#4]
;;;199    		PHASE_INCREASE(unCurrentPhase);
000050  7968              LDRB     r0,[r5,#5]  ; unCurrentPhase
000052  2805              CMP      r0,#5
000054  d201              BCS      |L41.90|
000056  1c40              ADDS     r0,r0,#1
000058  e000              B        |L41.92|
                  |L41.90|
00005a  2000              MOVS     r0,#0
                  |L41.92|
00005c  b2c0              UXTB     r0,r0
00005e  7168              STRB     r0,[r5,#5]
;;;200    		// Modify PWM->PHCHGNXT at last because I don't know how long needed to reload PHCH with PHCHNEXT after TIM0 time-out
;;;201    		PWM->PHCHGNXT = GET_PHASE_VALUE(unCurrentPhase);
000060  8861              LDRH     r1,[r4,#2]  ; tMotor
000062  0789              LSLS     r1,r1,#30
000064  d402              BMI      |L41.108|
000066  0080              LSLS     r0,r0,#2
000068  490a              LDR      r1,|L41.148|
00006a  e002              B        |L41.114|
                  |L41.108|
00006c  4909              LDR      r1,|L41.148|
00006e  0080              LSLS     r0,r0,#2
000070  3118              ADDS     r1,r1,#0x18
                  |L41.114|
000072  5808              LDR      r0,[r1,r0]
000074  4908              LDR      r1,|L41.152|
000076  63c8              STR      r0,[r1,#0x3c]
                  |L41.120|
;;;202    	}
;;;203    }
000078  bd70              POP      {r4-r6,pc}
;;;204    
                          ENDP

00007a  0000              DCW      0x0000
                  |L41.124|
                          DCD      ||.data||
                  |L41.128|
                          DCD      ||.bss||
                  |L41.132|
                          DCD      0x000003e7
                  |L41.136|
                          DCD      0xf5c28f5c
                  |L41.140|
                          DCD      0x3fef5c28
                  |L41.144|
                          DCD      0x40010000
                  |L41.148|
                          DCD      ||.constdata||+0x4
                  |L41.152|
                          DCD      0x40040040

                          AREA ||.data__ZZ23phaseDurationProtectionE14unCurrentPHCHG||, COMGROUP=_ZZ23phaseDurationProtectionE14unCurrentPHCHG, DATA, ALIGN=2

                  _ZZ23phaseDurationProtectionE14unCurrentPHCHG
                          DCD      0x00000000

                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d200              BCS      |L50.16|
00000e  461d              MOV      r5,r3
                  |L50.16|
000010  5d63              LDRB     r3,[r4,r5]
000012  005b              LSLS     r3,r3,#1
000014  18e3              ADDS     r3,r4,r3
000016  bc30              POP      {r4,r5}
000018  4718              BX       r3
                          ENDP


;*** Start embedded assembler ***

#line 1 "User\\BLDCSensorLess.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_BLDCSensorLess_c_0df2b5b8____REV16|
#line 464 "D:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.1.0\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___16_BLDCSensorLess_c_0df2b5b8____REV16| PROC
#line 465

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_BLDCSensorLess_c_0df2b5b8____REVSH|
#line 479
|__asm___16_BLDCSensorLess_c_0df2b5b8____REVSH| PROC
#line 480

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
