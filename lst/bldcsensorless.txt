; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\bldcsensorless.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\bldcsensorless.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\Mini51Series\Include -I..\..\..\Library\StdDriver\inc -I.\StdDriver\inc -I.\CMSIS -IG:\Geek\Projects\Zulolo_F\Force\Code\Zulolo_F_Force\RTE -ID:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.0.2\Device\Mini51\Include -ID:\Keil_v5\ARM\CMSIS\Include -I\ -D__MICROLIB -D__UVISION_VERSION=518 --omf_browse=.\obj\bldcsensorless.crf User\BLDCSensorLess.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  canMotorContinueRunning PROC
;;;93        1-65534: phase time */
;;;94     uint16_t canMotorContinueRunning(void)
000000  2000              MOVS     r0,#0
;;;95     {
;;;96     	uint16_t unPhaseDuration = 0;
;;;97     	static uint32_t unStateEnterTime;
;;;98     // Later implement this when motor can rotate
;;;99     // Then stop it while rotating to measure the waveform
;;;100    // Manually rotate it is too slow 
;;;101    	return 0;
;;;102    
;;;103    	if ((uint32_t)(unSystemTick - unRotateDetectStartTime) > MAX_ALREADY_ROTATING_DETECT_TIME)
;;;104    	{
;;;105    		return 0;
;;;106    	}
;;;107    	switch (tRotateDetectState)
;;;108    	{
;;;109    	case DETECT_START: 
;;;110    		unStateEnterTime = unSystemTick;
;;;111    		tRotateDetectState = DETECT_PHASE_1_P;
;;;112    		break;
;;;113    
;;;114    	case DETECT_PHASE_1_P:
;;;115    		if ((uint32_t)(unSystemTick - unStateEnterTime) > MAX_ROTATING_DETECT_PHASE_TIME)
;;;116    		{
;;;117    			return (uint16_t)0;
;;;118    		}
;;;119    		else
;;;120    		{
;;;121    
;;;122    		}
;;;123    		break; 
;;;124    
;;;125    	case DETECT_PHASE_1_A:
;;;126    
;;;127    		break;
;;;128    
;;;129    	case DETECT_PHASE_2_P:
;;;130    
;;;131    		break;
;;;132    
;;;133    	case DETECT_PHASE_2_A:
;;;134    
;;;135    		break;
;;;136    
;;;137    	case DETECT_PHASE_3_P:
;;;138    
;;;139    		break;
;;;140    
;;;141    	case DETECT_PHASE_3_A:
;;;142    
;;;143    		break;
;;;144    
;;;145    	default:
;;;146    		break;
;;;147    	}
;;;148    
;;;149    	return unPhaseDuration;
;;;150    }
000002  4770              BX       lr
;;;151    
                          ENDP

                  BLDCSpeedManager PROC
;;;152    // Mainly PWM duty increase/decrease
;;;153    void BLDCSpeedManager(void)
000004  b510              PUSH     {r4,lr}
;;;154    {
;;;155    	if (SET == FLAG_PHASE_CHANGED)
000006  4cb4              LDR      r4,|L1.728|
000008  79a0              LDRB     r0,[r4,#6]  ; FLAG_PHASE_CHANGED
00000a  2801              CMP      r0,#1
00000c  d133              BNE      |L1.118|
;;;156    	{
;;;157    		PhaseChangedRoutine();
00000e  f7fffffe          BL       PhaseChangedRoutine
;;;158    
;;;159    		if (tMotor.structMotor.unActualDuty != tMotor.structMotor.unTargetDuty)
000012  49b2              LDR      r1,|L1.732|
000014  8988              LDRH     r0,[r1,#0xc]  ; tMotor
000016  894a              LDRH     r2,[r1,#0xa]  ; tMotor
000018  4290              CMP      r0,r2
00001a  d017              BEQ      |L1.76|
;;;160    		{
;;;161    //				tMotor.structMotor.ACT_DUTY = tMotor.structMotor.TGT_DUTY;
;;;162    				// Change PWM duty after each x phase change
;;;163    			if (unPhaseChangeCNT4Duty > CHANGE_DUTY_CNT_THR)
00001c  7920              LDRB     r0,[r4,#4]  ; unPhaseChangeCNT4Duty
00001e  2805              CMP      r0,#5
000020  d911              BLS      |L1.70|
;;;164    			{
;;;165    				unPhaseChangeCNT4Duty = 0;
000022  2000              MOVS     r0,#0
000024  7120              STRB     r0,[r4,#4]
;;;166    				if (tMotor.structMotor.unActualDuty < tMotor.structMotor.unTargetDuty)
000026  8988              LDRH     r0,[r1,#0xc]  ; tMotor
000028  894a              LDRH     r2,[r1,#0xa]  ; tMotor
00002a  4290              CMP      r0,r2
;;;167    				{
;;;168    					tMotor.structMotor.unActualDuty++;
;;;169    				}
;;;170    				else
;;;171    				{
;;;172    					tMotor.structMotor.unActualDuty--;
00002c  8988              LDRH     r0,[r1,#0xc]  ; tMotor
00002e  d201              BCS      |L1.52|
000030  1c40              ADDS     r0,r0,#1              ;166
000032  e000              B        |L1.54|
                  |L1.52|
000034  1e40              SUBS     r0,r0,#1              ;168
                  |L1.54|
000036  8188              STRH     r0,[r1,#0xc]
;;;173    				}
;;;174    				MOTOR_SET_DUTY(tMotor.structMotor.unActualDuty);
000038  898a              LDRH     r2,[r1,#0xc]  ; tMotor
00003a  48a9              LDR      r0,|L1.736|
00003c  6282              STR      r2,[r0,#0x28]
00003e  898a              LDRH     r2,[r1,#0xc]  ; tMotor
000040  6302              STR      r2,[r0,#0x30]
000042  898a              LDRH     r2,[r1,#0xc]  ; tMotor
000044  6382              STR      r2,[r0,#0x38]
                  |L1.70|
;;;175    			}
;;;176    			unPhaseChangeCNT4Duty++;
000046  7920              LDRB     r0,[r4,#4]  ; unPhaseChangeCNT4Duty
000048  1c40              ADDS     r0,r0,#1
00004a  7120              STRB     r0,[r4,#4]
                  |L1.76|
;;;177    		}
;;;178    		
;;;179    		PHASE_INCREASE(unCurrentPhase);
00004c  7960              LDRB     r0,[r4,#5]  ; unCurrentPhase
00004e  2805              CMP      r0,#5
000050  d201              BCS      |L1.86|
000052  1c40              ADDS     r0,r0,#1
000054  e000              B        |L1.88|
                  |L1.86|
000056  2000              MOVS     r0,#0
                  |L1.88|
000058  b2c0              UXTB     r0,r0
00005a  7160              STRB     r0,[r4,#5]
;;;180    		// Modify PWM->PHCHGNXT at last because I don't know how long needed to reload PHCH with PHCHNEXT after TIM0 time-out
;;;181    		PWM->PHCHGNXT = GET_PHASE_VALUE(unCurrentPhase);
00005c  8809              LDRH     r1,[r1,#0]  ; tMotor
00005e  0789              LSLS     r1,r1,#30
000060  d402              BMI      |L1.104|
000062  0080              LSLS     r0,r0,#2
000064  499f              LDR      r1,|L1.740|
000066  e002              B        |L1.110|
                  |L1.104|
000068  499e              LDR      r1,|L1.740|
00006a  0080              LSLS     r0,r0,#2
00006c  3118              ADDS     r1,r1,#0x18
                  |L1.110|
00006e  5808              LDR      r0,[r1,r0]
000070  499b              LDR      r1,|L1.736|
000072  3140              ADDS     r1,r1,#0x40
000074  63c8              STR      r0,[r1,#0x3c]
                  |L1.118|
;;;182    	}
;;;183    }
000076  bd10              POP      {r4,pc}
;;;184    //
                          ENDP

                  BLDC_LocatingManager PROC
;;;207    
;;;208    ENUM_STATUS BLDC_LocatingManager(void)
000078  b5f8              PUSH     {r3-r7,lr}
;;;209    {
;;;210    	if ((uint32_t)(unSystemTick - unLastPhaseChangeTime) > tMotor.structMotor.unLocatingPeriod)
00007a  489b              LDR      r0,|L1.744|
00007c  6800              LDR      r0,[r0,#0]  ; unSystemTick
00007e  4c96              LDR      r4,|L1.728|
000080  4b96              LDR      r3,|L1.732|
000082  6961              LDR      r1,[r4,#0x14]  ; unLastPhaseChangeTime
000084  1a40              SUBS     r0,r0,r1
000086  89d9              LDRH     r1,[r3,#0xe]  ; tMotor
000088  4288              CMP      r0,r1
00008a  d90b              BLS      |L1.164|
;;;211    	{
;;;212    		if (unLocateIndex < (sizeof(unLocatePhaseSequencyTable)/sizeof(uint8_t)))
00008c  78a0              LDRB     r0,[r4,#2]  ; unLocateIndex
00008e  2804              CMP      r0,#4
000090  d20a              BCS      |L1.168|
;;;213    		{
;;;214    			//iLastPhaseChangeTime = unSystemTick; 
;;;215    			setPhaseManually(tMotor.structMotor.unLocatingDuty, unLocatePhaseSequencyTable[unLocateIndex]);
000092  4994              LDR      r1,|L1.740|
000094  1f09              SUBS     r1,r1,#4
000096  5c09              LDRB     r1,[r1,r0]
000098  88d8              LDRH     r0,[r3,#6]  ; tMotor
00009a  f7fffffe          BL       setPhaseManually
;;;216    			unLocateIndex++;
00009e  78a0              LDRB     r0,[r4,#2]  ; unLocateIndex
0000a0  1c40              ADDS     r0,r0,#1
0000a2  70a0              STRB     r0,[r4,#2]
                  |L1.164|
;;;217    		}
;;;218    		else
;;;219    		{
;;;220    			MOTOR_SHUT_DOWN;
;;;221    			tMotor.structMotor.MSR.bMotorPowerOn = FALSE;
;;;222    			unCurrentPhase = unLocatePhaseSequencyTable[unLocateIndex - 1];
;;;223    			return STATUS_FINISHED;
;;;224    		}
;;;225    	}
;;;226    	return STATUS_WORKING;
0000a4  4891              LDR      r0,|L1.748|
;;;227    }
0000a6  bdf8              POP      {r3-r7,pc}
                  |L1.168|
0000a8  4a91              LDR      r2,|L1.752|
0000aa  2100              MOVS     r1,#0                 ;220
0000ac  6211              STR      r1,[r2,#0x20]         ;220
0000ae  4d8c              LDR      r5,|L1.736|
0000b0  3540              ADDS     r5,r5,#0x40           ;220
0000b2  6169              STR      r1,[r5,#0x14]         ;220
0000b4  498f              LDR      r1,|L1.756|
0000b6  680a              LDR      r2,[r1,#0]            ;220
0000b8  038e              LSLS     r6,r1,#14             ;220
0000ba  43b2              BICS     r2,r2,r6              ;220
0000bc  600a              STR      r2,[r1,#0]            ;220
0000be  4a8d              LDR      r2,|L1.756|
0000c0  3220              ADDS     r2,r2,#0x20           ;220
0000c2  6817              LDR      r7,[r2,#0]            ;220
0000c4  43b7              BICS     r7,r7,r6              ;220
0000c6  6017              STR      r7,[r2,#0]            ;220
0000c8  680f              LDR      r7,[r1,#0]            ;220
0000ca  034e              LSLS     r6,r1,#13             ;220
0000cc  43b7              BICS     r7,r7,r6              ;220
0000ce  600f              STR      r7,[r1,#0]            ;220
0000d0  6811              LDR      r1,[r2,#0]            ;220
0000d2  43b1              BICS     r1,r1,r6              ;220
0000d4  6011              STR      r1,[r2,#0]            ;220
0000d6  21ff              MOVS     r1,#0xff              ;220
0000d8  63e9              STR      r1,[r5,#0x3c]         ;220
0000da  63a9              STR      r1,[r5,#0x38]         ;220
0000dc  8859              LDRH     r1,[r3,#2]            ;221  ; tMotor
0000de  0849              LSRS     r1,r1,#1              ;221
0000e0  0049              LSLS     r1,r1,#1              ;221
0000e2  8059              STRH     r1,[r3,#2]            ;221
0000e4  497f              LDR      r1,|L1.740|
0000e6  1f09              SUBS     r1,r1,#4              ;222
0000e8  1808              ADDS     r0,r1,r0              ;222
0000ea  3820              SUBS     r0,r0,#0x20           ;222
0000ec  7fc0              LDRB     r0,[r0,#0x1f]         ;222
0000ee  7160              STRB     r0,[r4,#5]            ;222
0000f0  2001              MOVS     r0,#1                 ;223
0000f2  bdf8              POP      {r3-r7,pc}
;;;228    
                          ENDP

                  BLDC_SensorLessManager PROC
;;;286    // Take charge of all Motot control
;;;287    void BLDC_SensorLessManager(void)
0000f4  b5f8              PUSH     {r3-r7,lr}
0000f6  4c79              LDR      r4,|L1.732|
0000f8  89a1              LDRH     r1,[r4,#0xc]  ; tMotor
0000fa  487f              LDR      r0,|L1.760|
0000fc  4281              CMP      r1,r0
;;;288    {
0000fe  d803              BHI      |L1.264|
000100  4977              LDR      r1,|L1.736|
000102  6a89              LDR      r1,[r1,#0x28]
000104  4281              CMP      r1,r0
000106  d904              BLS      |L1.274|
                  |L1.264|
000108  f7fffffe          BL       BLDC_stopMotor
00010c  2006              MOVS     r0,#6
00010e  f7fffffe          BL       setError
                  |L1.274|
;;;289    	uint16_t iMotorAlreadyRotatingPhaseTime;
;;;290    	static uint32_t iEnterTimeBeforeWait;
;;;291    
;;;292    	dutyProtection();
;;;293    	phaseDurationProtection(unLastPhaseChangeTime);
000112  4d71              LDR      r5,|L1.728|
000114  8861              LDRH     r1,[r4,#2]  ; tMotor
000116  6968              LDR      r0,[r5,#0x14]  ; unLastPhaseChangeTime
000118  4e73              LDR      r6,|L1.744|
00011a  07c9              LSLS     r1,r1,#31
00011c  d013              BEQ      |L1.326|
00011e  4970              LDR      r1,|L1.736|
000120  3140              ADDS     r1,r1,#0x40
000122  6b8b              LDR      r3,[r1,#0x38]
000124  4a75              LDR      r2,|L1.764|
000126  6817              LDR      r7,[r2,#0]  ; _ZZ23phaseDurationProtectionE14unCurrentPHCHG
000128  42bb              CMP      r3,r7
00012a  d003              BEQ      |L1.308|
00012c  6b88              LDR      r0,[r1,#0x38]
00012e  6010              STR      r0,[r2,#0]  ; _ZZ23phaseDurationProtectionE14unCurrentPHCHG
000130  6830              LDR      r0,[r6,#0]  ; unSystemTick
000132  e008              B        |L1.326|
                  |L1.308|
000134  6831              LDR      r1,[r6,#0]  ; unSystemTick
000136  1a08              SUBS     r0,r1,r0
000138  2850              CMP      r0,#0x50
00013a  d904              BLS      |L1.326|
00013c  f7fffffe          BL       BLDC_stopMotor
000140  2006              MOVS     r0,#6
000142  f7fffffe          BL       setError
                  |L1.326|
;;;294    
;;;295    	switch (tMotorState)
000146  782a              LDRB     r2,[r5,#0]  ; tMotorState
;;;296    	{
;;;297    	case MOTOR_IDLE:
;;;298    		if (tMotor.structMotor.MCR.bMotorNeedToRun && NO_MOTOR_EEROR)
000148  486d              LDR      r0,|L1.768|
00014a  2700              MOVS     r7,#0
00014c  2101              MOVS     r1,#1                 ;295
00014e  0013              MOVS     r3,r2                 ;295
000150  f7fffffe          BL       __ARM_common_switch8
000154  07051031          DCB      0x07,0x05,0x10,0x31
000158  3f81a1b8          DCB      0x3f,0x81,0xa1,0xb8
00015c  0f00              DCB      0x0f,0x00
00015e  8822              LDRH     r2,[r4,#0]  ; tMotor
000160  07d2              LSLS     r2,r2,#31
000162  d006              BEQ      |L1.370|
000164  6800              LDR      r0,[r0,#0]  ; unErrorMaster
000166  0840              LSRS     r0,r0,#1
000168  d103              BNE      |L1.370|
;;;299    		{
;;;300    			unRotateDetectStartTime = unSystemTick;
00016a  6830              LDR      r0,[r6,#0]  ; unSystemTick
;;;301    			tRotateDetectState = DETECT_START;
00016c  61a8              STR      r0,[r5,#0x18]  ; unRotateDetectStartTime
00016e  706f              STRB     r7,[r5,#1]
;;;302    			tMotorState = MOTOR_START;
000170  7029              STRB     r1,[r5,#0]
                  |L1.370|
;;;303    		}
;;;304    		break;
;;;305    		
;;;306    	case MOTOR_START:
;;;307    		if (tMotor.structMotor.MCR.bMotorNeedToRun && NO_MOTOR_EEROR)
;;;308    		{
;;;309    			// Later implement this when motor can rotate
;;;310    			// Then stop it while rotating to measure the waveform
;;;311    			// Manually rotate it is too slow 
;;;312    			iMotorAlreadyRotatingPhaseTime = canMotorContinueRunning();
;;;313    			if (iMotorAlreadyRotatingPhaseTime != IS_ROTATING_DETECTING)
;;;314    			{
;;;315    				if (iMotorAlreadyRotatingPhaseTime > 0)
;;;316    				{
;;;317    					// 1 to 65534
;;;318    					tMotorState = MOTOR_LOCKED;
;;;319    				}
;;;320    				else
;;;321    				{
;;;322    					// When back to Idle state the motor was already shut down
;;;323    					// MOTOR_SHUT_DOWN;
;;;324    					unCurrentPhase = 0;
;;;325    					unLocateIndex = 0;
;;;326    					tMotor.structMotor.MSR.unMissedZXD_CNT = 0;
;;;327    					unLastPhaseChangeTime = unSystemTick;
;;;328    					tMotor.structMotor.MSR.bMotorPowerOn = TRUE;
;;;329    					// Clear start detect zero cross flag
;;;330    					tMotor.structMotor.MSR.bZeroCrossDetecting = FALSE;
;;;331    					tMotor.structMotor.MSR.bLocked = FALSE;
;;;332    					//setPhaseManually(tMotor.structMotor.LCT_DUTY, unCurrentPhase);
;;;333    					BRG_ENABLE;
;;;334    					tMotorState = MOTOR_LOCATE;
;;;335    				}
;;;336    			}
;;;337    		}
;;;338    		else
;;;339    		{
;;;340    			BLDC_stopMotor();
;;;341    		}
;;;342    		break;
;;;343    
;;;344    	case MOTOR_LOCATE:
;;;345    		if (tMotor.structMotor.MCR.bMotorNeedToRun && NO_MOTOR_EEROR)
;;;346    		{
;;;347    			if (BLDC_LocatingManager() == STATUS_FINISHED)
;;;348    			{
;;;349    				iEnterTimeBeforeWait = unSystemTick;
;;;350    				tMotorState = MOTOR_WAIT_AFTER_LOCATE;
;;;351    			}
;;;352    		}
;;;353    		else
;;;354    		{
;;;355    			BLDC_stopMotor();
;;;356    		}
;;;357    		break;
;;;358    
;;;359    	case MOTOR_WAIT_AFTER_LOCATE:
;;;360    		if (tMotor.structMotor.MCR.bMotorNeedToRun && NO_MOTOR_EEROR)
;;;361    		{
;;;362    			if ((uint32_t)(unSystemTick - iEnterTimeBeforeWait) >= WAIT_AFTER_LOCATE_TIME)
;;;363    			{
;;;364    				tMotor.structMotor.unActualDuty = tMotor.structMotor.unRampUpDuty;
;;;365    				tMotor.structMotor.unActualPeriod = tMotor.structMotor.unRampUpPeriod;
;;;366    				tMotor.structMotor.MSR.bMotorPowerOn = TRUE;
;;;367    				PHASE_INCREASE(unCurrentPhase);
;;;368    				setPhaseManually(tMotor.structMotor.unActualDuty, unCurrentPhase);
;;;369    				BRG_ENABLE;
;;;370    				// Set timer 0 valure, use timer 0 to change phase automatically
;;;371    				// ************************************************************************
;;;372    				// ----==== From here current unCurrentPhase is actually next phase ====----
;;;373    				// ----==== Because we want to use the HW auto phase changer (PWM->PHCHGNXT) ====----
;;;374    				// So increase unCurrentPhase again. Want to get real current phase value? Read PWM->PHCHG.
;;;375    				// ************************************************************************
;;;376    				PHASE_INCREASE(unCurrentPhase);
;;;377    				PWM->PHCHGNXT = GET_PHASE_VALUE(unCurrentPhase);
;;;378    				// !!!! Need to make sure CPU runs to here every min tMotor.structMotor.ACT_PERIOD time !!!
;;;379    				// !!!! If not , timer counter may already passed tMotor.structMotor.ACT_PERIOD, !!!!
;;;380    				// !!!! then need to count to max timer counter number (which is 2^24), !!!!
;;;381    				// !!!! go back to 0 and triger interrupt when reach ACT_PERIOD again !!!!
;;;382    				TIMER_SET_CMP_VALUE(TIMER0, tMotor.structMotor.unActualPeriod);
;;;383    				TIMER_Start(TIMER0);	// Once started, running and interrupting until Motor stop
;;;384    				TIMER_EnableInt(TIMER0);
;;;385    				unRampUpPeriodMiniCNT = 0;
;;;386    				unPhaseChangeCNT4Duty = 0;
;;;387    				unPhaseChangeCNT4Period = 0;
;;;388    				tMotorState = MOTOR_RAMPUP_WO_ZXD;
;;;389    			}
;;;390    		}
;;;391    		else
;;;392    		{
;;;393    			BLDC_stopMotor();
;;;394    		}
;;;395    		break;
;;;396    
;;;397    	case MOTOR_RAMPUP_WO_ZXD:	// without zero cross detection
;;;398    		if (tMotor.structMotor.MCR.bMotorNeedToRun && NO_MOTOR_EEROR)
;;;399    		{
;;;400    			BLDCRampUp_Manager();
;;;401    			if (tMotor.structMotor.unActualPeriod <= MOTOR_START_ZXD_SPEED)	//(iRampUpPeriodMiniCNT > MOTOR_START_ZXD_MINROT_CNT)  //
;;;402    			{
;;;403    				tMotor.structMotor.MSR.bThisPhaseDetectedZX = FALSE;
;;;404    				tMotor.structMotor.MSR.bZeroCrossDetecting = TRUE;
;;;405    				// Speed is enough for zero cross detecting
;;;406    				// Prepare everything
;;;407    				// T0 used to change phase automatically -- already configured
;;;408    				// T1 used to filter ZX
;;;409    				//ACMP->CMPCR[0]
;;;410    
;;;411    //				TIMER_SET_CMP_VALUE(TIMER1, GET_TIM1_CMP_VALUE(TIMER1->TDR + AVOID_ZXD_AFTER_PHCHG));
;;;412    //				FLAG_TIM1_USEAGE = ENUM_TIM1_AVOID_ZXD;
;;;413    				ACMP0_ENABLE;
;;;414    				TIMER_Start(TIMER1);	// Once started, running until Motor stop
;;;415    //				TIMER_EnableInt(TIMER1);
;;;416    				// Suppose last ZX detected time 
;;;417    //				unLastZXDetectedTime = MINI51_TIM_CNT_MAX - tMotor.structMotor.ACT_PERIOD / 2;
;;;418    				tMotorState = MOTOR_RAMPUP_W_ZXD;
;;;419    			}
;;;420    		}
;;;421    		else
;;;422    		{
;;;423    			BLDC_stopMotor();
;;;424    		}
;;;425    		break;
;;;426    
;;;427    	case MOTOR_RAMPUP_W_ZXD:	// with zero cross detection
;;;428    		if (tMotor.structMotor.MCR.bMotorNeedToRun && NO_MOTOR_EEROR)
;;;429    		{
;;;430    			if (TRUE == tMotor.structMotor.MSR.bLocked)
;;;431    			{
;;;432    				// Finally, everything was prepared:
;;;433    				// T0 used to change phase automatically
;;;434    				// T1 used to filter ZX
;;;435    				tMotorState = MOTOR_LOCKED;
;;;436    			}
;;;437    			else
;;;438    			{
;;;439    				if (unRampUpPeriodMiniCNT < RAMP_UP_MIN_PERIOD_NUM_THRS)
;;;440    				{
;;;441    					BLDCRampUp_Manager(); 
;;;442    				}
;;;443    				else
;;;444    				{
;;;445    					setError(ERR_RAMPUP_FAIL);
;;;446    				}
;;;447    			}
;;;448    		}
;;;449    		else
;;;450    		{
;;;451    			BLDC_stopMotor();
;;;452    		}
;;;453    		break;
;;;454    
;;;455    	case MOTOR_LOCKED:
;;;456    		if (tMotor.structMotor.MCR.bMotorNeedToRun && NO_MOTOR_EEROR)
;;;457    		{
;;;458    			BLDCSpeedManager();	// Mainly PWM duty increase/decrease
;;;459    		}
;;;460    		else
;;;461    		{
;;;462    			BLDC_stopMotor();
;;;463    		}
;;;464    		break;
;;;465    
;;;466    	default:
;;;467    		break;
;;;468    	}
;;;469    }
000172  bdf8              POP      {r3-r7,pc}
000174  8822              LDRH     r2,[r4,#0]            ;307  ; tMotor
000176  07d2              LSLS     r2,r2,#31             ;307
000178  d01a              BEQ      |L1.432|
00017a  6800              LDR      r0,[r0,#0]            ;307  ; unErrorMaster
00017c  0840              LSRS     r0,r0,#1              ;307
00017e  d117              BNE      |L1.432|
000180  716f              STRB     r7,[r5,#5]            ;324
000182  70af              STRB     r7,[r5,#2]            ;325
000184  8860              LDRH     r0,[r4,#2]            ;326  ; tMotor
000186  22ff              MOVS     r2,#0xff              ;326
000188  0152              LSLS     r2,r2,#5              ;326
00018a  4390              BICS     r0,r0,r2              ;326
00018c  8060              STRH     r0,[r4,#2]            ;326
00018e  6830              LDR      r0,[r6,#0]            ;327  ; unSystemTick
000190  6168              STR      r0,[r5,#0x14]         ;328  ; unLastPhaseChangeTime
000192  8860              LDRH     r0,[r4,#2]            ;328  ; tMotor
000194  4308              ORRS     r0,r0,r1              ;328
000196  8060              STRH     r0,[r4,#2]            ;328
000198  8860              LDRH     r0,[r4,#2]            ;330  ; tMotor
00019a  2302              MOVS     r3,#2                 ;330
00019c  4398              BICS     r0,r0,r3              ;330
00019e  8060              STRH     r0,[r4,#2]            ;330
0001a0  8862              LDRH     r2,[r4,#2]            ;331  ; tMotor
0001a2  2004              MOVS     r0,#4                 ;331
0001a4  4382              BICS     r2,r2,r0              ;331
0001a6  8062              STRH     r2,[r4,#2]            ;331
0001a8  4851              LDR      r0,|L1.752|
0001aa  6201              STR      r1,[r0,#0x20]         ;333
0001ac  702b              STRB     r3,[r5,#0]            ;334
0001ae  bdf8              POP      {r3-r7,pc}
                  |L1.432|
0001b0  f7fffffe          BL       BLDC_stopMotor
                  |L1.436|
0001b4  bdf8              POP      {r3-r7,pc}
0001b6  8821              LDRH     r1,[r4,#0]            ;345  ; tMotor
0001b8  07c9              LSLS     r1,r1,#31             ;345
0001ba  d0f9              BEQ      |L1.432|
0001bc  6800              LDR      r0,[r0,#0]            ;345  ; unErrorMaster
0001be  0840              LSRS     r0,r0,#1              ;345
0001c0  d1f6              BNE      |L1.432|
0001c2  f7fffffe          BL       BLDC_LocatingManager
0001c6  2801              CMP      r0,#1                 ;347
0001c8  d1f4              BNE      |L1.436|
0001ca  6830              LDR      r0,[r6,#0]            ;349  ; unSystemTick
0001cc  6128              STR      r0,[r5,#0x10]         ;350  ; iEnterTimeBeforeWait
0001ce  2003              MOVS     r0,#3                 ;350
0001d0  e03f              B        |L1.594|
0001d2  8822              LDRH     r2,[r4,#0]            ;360  ; tMotor
0001d4  07d2              LSLS     r2,r2,#31             ;360
                  |L1.470|
0001d6  d0eb              BEQ      |L1.432|
0001d8  6800              LDR      r0,[r0,#0]            ;360  ; unErrorMaster
0001da  0840              LSRS     r0,r0,#1              ;360
                  |L1.476|
0001dc  d1e8              BNE      |L1.432|
0001de  6830              LDR      r0,[r6,#0]            ;362  ; unSystemTick
0001e0  8920              LDRH     r0,[r4,#8]            ;364  ; tMotor
0001e2  81a0              STRH     r0,[r4,#0xc]          ;364
0001e4  6960              LDR      r0,[r4,#0x14]         ;365  ; tMotor
0001e6  61a0              STR      r0,[r4,#0x18]         ;365  ; tMotor
0001e8  8860              LDRH     r0,[r4,#2]            ;366  ; tMotor
0001ea  460e              MOV      r6,r1                 ;366
0001ec  4330              ORRS     r0,r0,r6              ;366
0001ee  8060              STRH     r0,[r4,#2]            ;366
0001f0  7968              LDRB     r0,[r5,#5]            ;367  ; unCurrentPhase
0001f2  2805              CMP      r0,#5                 ;367
0001f4  d201              BCS      |L1.506|
0001f6  1c40              ADDS     r0,r0,#1              ;367
0001f8  e000              B        |L1.508|
                  |L1.506|
0001fa  2000              MOVS     r0,#0                 ;367
                  |L1.508|
0001fc  b2c1              UXTB     r1,r0                 ;367
0001fe  7169              STRB     r1,[r5,#5]            ;367
000200  89a0              LDRH     r0,[r4,#0xc]          ;368  ; tMotor
000202  f7fffffe          BL       setPhaseManually
000206  483a              LDR      r0,|L1.752|
000208  6206              STR      r6,[r0,#0x20]         ;369
00020a  7968              LDRB     r0,[r5,#5]            ;376  ; unCurrentPhase
00020c  2805              CMP      r0,#5                 ;376
00020e  d201              BCS      |L1.532|
000210  1c40              ADDS     r0,r0,#1              ;376
000212  e000              B        |L1.534|
                  |L1.532|
000214  2000              MOVS     r0,#0                 ;376
                  |L1.534|
000216  b2c0              UXTB     r0,r0                 ;376
000218  7168              STRB     r0,[r5,#5]            ;376
00021a  8821              LDRH     r1,[r4,#0]            ;377  ; tMotor
00021c  0789              LSLS     r1,r1,#30             ;377
00021e  d402              BMI      |L1.550|
000220  0080              LSLS     r0,r0,#2              ;377
000222  4930              LDR      r1,|L1.740|
000224  e002              B        |L1.556|
                  |L1.550|
000226  492f              LDR      r1,|L1.740|
000228  0080              LSLS     r0,r0,#2              ;377
00022a  3118              ADDS     r1,r1,#0x18           ;377
                  |L1.556|
00022c  5808              LDR      r0,[r1,r0]            ;377
00022e  492c              LDR      r1,|L1.736|
000230  3140              ADDS     r1,r1,#0x40           ;377
000232  63c8              STR      r0,[r1,#0x3c]         ;377
000234  69a1              LDR      r1,[r4,#0x18]         ;382  ; tMotor
000236  482f              LDR      r0,|L1.756|
000238  6041              STR      r1,[r0,#4]            ;382
00023a  6801              LDR      r1,[r0,#0]            ;382
00023c  0382              LSLS     r2,r0,#14             ;382
00023e  4311              ORRS     r1,r1,r2              ;382
000240  6001              STR      r1,[r0,#0]            ;382
000242  6801              LDR      r1,[r0,#0]            ;382
000244  0342              LSLS     r2,r0,#13             ;382
000246  4311              ORRS     r1,r1,r2              ;382
000248  6001              STR      r1,[r0,#0]            ;382
00024a  812f              STRH     r7,[r5,#8]            ;385
00024c  712f              STRB     r7,[r5,#4]            ;386
00024e  70ef              STRB     r7,[r5,#3]            ;387
000250  2004              MOVS     r0,#4                 ;388
                  |L1.594|
000252  7028              STRB     r0,[r5,#0]            ;350
                  |L1.596|
000254  bdf8              POP      {r3-r7,pc}
000256  8821              LDRH     r1,[r4,#0]            ;398  ; tMotor
000258  07c9              LSLS     r1,r1,#31             ;398
00025a  d0a9              BEQ      |L1.432|
00025c  6800              LDR      r0,[r0,#0]            ;398  ; unErrorMaster
00025e  0840              LSRS     r0,r0,#1              ;398
000260  d1a6              BNE      |L1.432|
000262  f7fffffe          BL       BLDCRampUp_Manager
000266  69a0              LDR      r0,[r4,#0x18]         ;401  ; tMotor
000268  4926              LDR      r1,|L1.772|
00026a  4288              CMP      r0,r1                 ;401
00026c  d8f2              BHI      |L1.596|
00026e  8860              LDRH     r0,[r4,#2]            ;403  ; tMotor
000270  2108              MOVS     r1,#8                 ;403
000272  4388              BICS     r0,r0,r1              ;403
000274  8060              STRH     r0,[r4,#2]            ;403
000276  8860              LDRH     r0,[r4,#2]            ;404  ; tMotor
000278  2102              MOVS     r1,#2                 ;404
00027a  4308              ORRS     r0,r0,r1              ;404
00027c  8060              STRH     r0,[r4,#2]            ;404
00027e  4922              LDR      r1,|L1.776|
000280  680a              LDR      r2,[r1,#0]            ;413
000282  2005              MOVS     r0,#5                 ;413
000284  4302              ORRS     r2,r2,r0              ;413
000286  600a              STR      r2,[r1,#0]            ;413
000288  491a              LDR      r1,|L1.756|
00028a  3120              ADDS     r1,r1,#0x20           ;413
00028c  680a              LDR      r2,[r1,#0]            ;413
00028e  0783              LSLS     r3,r0,#30             ;413
000290  431a              ORRS     r2,r2,r3              ;413
000292  600a              STR      r2,[r1,#0]            ;413
000294  e7dd              B        |L1.594|
000296  8821              LDRH     r1,[r4,#0]            ;428  ; tMotor
000298  07c9              LSLS     r1,r1,#31             ;428
00029a  d089              BEQ      |L1.432|
00029c  6800              LDR      r0,[r0,#0]            ;428  ; unErrorMaster
00029e  0840              LSRS     r0,r0,#1              ;428
0002a0  d186              BNE      |L1.432|
0002a2  8860              LDRH     r0,[r4,#2]            ;430  ; tMotor
0002a4  0740              LSLS     r0,r0,#29             ;430
0002a6  d501              BPL      |L1.684|
0002a8  2006              MOVS     r0,#6                 ;435
0002aa  e7d2              B        |L1.594|
                  |L1.684|
0002ac  8928              LDRH     r0,[r5,#8]            ;439  ; unRampUpPeriodMiniCNT
0002ae  21ff              MOVS     r1,#0xff              ;439
0002b0  312d              ADDS     r1,r1,#0x2d           ;439
0002b2  4288              CMP      r0,r1                 ;439
0002b4  d202              BCS      |L1.700|
0002b6  f7fffffe          BL       BLDCRampUp_Manager
0002ba  bdf8              POP      {r3-r7,pc}
                  |L1.700|
0002bc  2004              MOVS     r0,#4                 ;445
0002be  f7fffffe          BL       setError
0002c2  bdf8              POP      {r3-r7,pc}
0002c4  8821              LDRH     r1,[r4,#0]            ;456  ; tMotor
0002c6  07c9              LSLS     r1,r1,#31             ;456
0002c8  d085              BEQ      |L1.470|
0002ca  6800              LDR      r0,[r0,#0]            ;456  ; unErrorMaster
0002cc  0840              LSRS     r0,r0,#1              ;456
0002ce  d185              BNE      |L1.476|
0002d0  f7fffffe          BL       BLDCSpeedManager
0002d4  bdf8              POP      {r3-r7,pc}
;;;470    
                          ENDP

0002d6  0000              DCW      0x0000
                  |L1.728|
                          DCD      ||.data||
                  |L1.732|
                          DCD      ||.bss||
                  |L1.736|
                          DCD      0x40040000
                  |L1.740|
                          DCD      ||.constdata||+0x4
                  |L1.744|
                          DCD      unSystemTick
                  |L1.748|
                          DCD      0x0000ffff
                  |L1.752|
                          DCD      0x50004240
                  |L1.756|
                          DCD      0x40010000
                  |L1.760|
                          DCD      0x000002dd
                  |L1.764|
                          DCD      _ZZ23phaseDurationProtectionE14unCurrentPHCHG
                  |L1.768|
                          DCD      unErrorMaster
                  |L1.772|
                          DCD      0x0000063f
                  |L1.776|
                          DCD      0x400d0000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  tMotor
                          %        40

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  unLocatePhaseSequencyTable
000000  00010201          DCB      0x00,0x01,0x02,0x01
                  PHASE_TAB_CLOCKWISE
                          DCD      0x40000239
                          DCD      0x700002ad
                          DCD      0x50000827
                          DCD      0x400008b6
                          DCD      0x7000201e
                          DCD      0x5000209b
                  PHASE_TAB_ANTICLOCKWISE
                          DCD      0x400002b9
                          DCD      0x5000201b
                          DCD      0x7000209e
                          DCD      0x40000836
                          DCD      0x500008a7
                          DCD      0x7000022d

                          AREA ||.data||, DATA, ALIGN=2

                  tMotorState
000000  00                DCB      0x00
                  tRotateDetectState
000001  00                DCB      0x00
                  unLocateIndex
000002  00                DCB      0x00
                  unPhaseChangeCNT4Period
000003  00                DCB      0x00
                  unPhaseChangeCNT4Duty
000004  00                DCB      0x00
                  unCurrentPhase
000005  00                DCB      0x00
                  FLAG_PHASE_CHANGED
000006  0000              DCB      0x00,0x00
                  unRampUpPeriodMiniCNT
000008  00000000          DCB      0x00,0x00,0x00,0x00
                  unStateEnterTime
                          DCD      0x00000000
                  iEnterTimeBeforeWait
                          DCD      0x00000000
                  unLastPhaseChangeTime
                          DCD      0x00000000
                  unRotateDetectStartTime
                          DCD      0x00000000
                  unLastZXDetectedTime
                          DCD      0x00000000

                          AREA ||area_number.7||, DATA, ALIGN=0

                          EXPORTAS ||area_number.7||, ||.data||
                  FLAG_TIM1_USEAGE
000000  00                DCB      0x00

                          AREA ||area_number.8||, DATA, ALIGN=2

                          EXPORTAS ||area_number.8||, ||.data||
                  unZXMatchCNT
                          DCD      0x00000000

                          AREA ||i.PhaseChangedRoutine||, COMGROUP=PhaseChangedRoutine, CODE, READONLY, ALIGN=2

                  PhaseChangedRoutine PROC
;;;26     
;;;27     __INLINE void PhaseChangedRoutine(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;28     {
;;;29     	FLAG_PHASE_CHANGED = RESET;
000002  4e3d              LDR      r6,|L20.248|
000004  2500              MOVS     r5,#0
;;;30     	tMotor.structMotor.unPhaseChangeCNT++;
000006  4c3d              LDR      r4,|L20.252|
000008  71b5              STRB     r5,[r6,#6]            ;29
00000a  69e0              LDR      r0,[r4,#0x1c]  ; tMotor
00000c  1c40              ADDS     r0,r0,#1
00000e  61e0              STR      r0,[r4,#0x1c]  ; tMotor
;;;31     	
;;;32     	if (TRUE == tMotor.structMotor.MSR.bZeroCrossDetecting)
000010  8860              LDRH     r0,[r4,#2]  ; tMotor
000012  0780              LSLS     r0,r0,#30
000014  d55d              BPL      |L20.210|
;;;33     	{
;;;34     //		iPhaseChangeTime = TIMER_GetCounter(TIMER1);
;;;35     		// Miss ZXD or ZXD success filter
;;;36     		// If continuously detected more than MIN_SUCC_ZXD_THRESHOLD ZX, OK! GOOD!!
;;;37     		if (TRUE == tMotor.structMotor.MSR.bThisPhaseDetectedZX)
000016  8860              LDRH     r0,[r4,#2]  ; tMotor
;;;38     		{
;;;39     			tMotor.structMotor.MSR.unMissedZXD_CNT = 0;
000018  4f39              LDR      r7,|L20.256|
00001a  0700              LSLS     r0,r0,#28             ;37
00001c  d514              BPL      |L20.72|
00001e  8860              LDRH     r0,[r4,#2]  ; tMotor
000020  43b8              BICS     r0,r0,r7
000022  8060              STRH     r0,[r4,#2]
;;;40     
;;;41     			if (tMotor.structMotor.MSR.unSuccessZXD_CNT > MIN_SUCC_ZXD_THRESHOLD)
000024  88a0              LDRH     r0,[r4,#4]  ; tMotor
000026  b2c0              UXTB     r0,r0
000028  2804              CMP      r0,#4
00002a  d904              BLS      |L20.54|
;;;42     			{
;;;43     				tMotor.structMotor.MSR.bLocked = TRUE;
00002c  8860              LDRH     r0,[r4,#2]  ; tMotor
00002e  2104              MOVS     r1,#4
000030  4308              ORRS     r0,r0,r1
000032  8060              STRH     r0,[r4,#2]
000034  e04d              B        |L20.210|
                  |L20.54|
;;;44     //				BRG_DISABLE;
;;;45     //				P50 = 1;
;;;46     //				BLDC_stopMotor();
;;;47     
;;;48     //				iTestZXContinueCNT++;
;;;49     //				iTestZXDPeriod = tMotor.structMotor.ACT_PERIOD;
;;;50     			}
;;;51     			else
;;;52     			{
;;;53     				tMotor.structMotor.MSR.unSuccessZXD_CNT++;
000036  88a0              LDRH     r0,[r4,#4]  ; tMotor
000038  88a1              LDRH     r1,[r4,#4]  ; tMotor
00003a  1c40              ADDS     r0,r0,#1
00003c  b2c0              UXTB     r0,r0
00003e  0a09              LSRS     r1,r1,#8
000040  0209              LSLS     r1,r1,#8
000042  4301              ORRS     r1,r1,r0
000044  80a1              STRH     r1,[r4,#4]
000046  e044              B        |L20.210|
                  |L20.72|
;;;54     			}
;;;55     		}
;;;56     		else	// If continuously missing detected more than MAX_MISS_ZXD_THRESHOLD ZX, loss lock
;;;57     		{
;;;58     			tMotor.structMotor.MSR.unSuccessZXD_CNT = 0;
000048  88a0              LDRH     r0,[r4,#4]  ; tMotor
00004a  0a00              LSRS     r0,r0,#8
00004c  0200              LSLS     r0,r0,#8
00004e  80a0              STRH     r0,[r4,#4]
000050  482c              LDR      r0,|L20.260|
000052  68c1              LDR      r1,[r0,#0xc]
;;;59     			// If ZX was not detected in last phase, unLastZXDetectedTime was also not updated
;;;60     			// Guess one value
;;;61     			unLastZXDetectedTime = GET_TIMER_DIFF((tMotor.structMotor.unActualPeriod >> 2), TIMER_GetCounter(TIMER1));
000054  69a2              LDR      r2,[r4,#0x18]  ; tMotor
000056  0892              LSRS     r2,r2,#2
000058  4291              CMP      r1,r2
00005a  68c1              LDR      r1,[r0,#0xc]
00005c  69a2              LDR      r2,[r4,#0x18]  ; tMotor
00005e  d902              BLS      |L20.102|
000060  0892              LSRS     r2,r2,#2
000062  1a89              SUBS     r1,r1,r2
000064  e003              B        |L20.110|
                  |L20.102|
000066  4b28              LDR      r3,|L20.264|
000068  0892              LSRS     r2,r2,#2
00006a  1a9a              SUBS     r2,r3,r2
00006c  1889              ADDS     r1,r1,r2
                  |L20.110|
00006e  61f1              STR      r1,[r6,#0x1c]  ; unLastZXDetectedTime
;;;62     			if (tMotor.structMotor.MSR.unMissedZXD_CNT > MAX_MISS_ZXD_THRESHOLD)
000070  8861              LDRH     r1,[r4,#2]  ; tMotor
000072  04c9              LSLS     r1,r1,#19
000074  0e09              LSRS     r1,r1,#24
000076  290c              CMP      r1,#0xc
000078  d921              BLS      |L20.190|
;;;63     			{
;;;64     				if (TRUE == tMotor.structMotor.MSR.bLocked)
00007a  8861              LDRH     r1,[r4,#2]  ; tMotor
00007c  0749              LSLS     r1,r1,#29
00007e  d528              BPL      |L20.210|
;;;65     				{	
;;;66     					tMotor.structMotor.MSR.bLocked = FALSE;
000080  8861              LDRH     r1,[r4,#2]  ; tMotor
000082  2204              MOVS     r2,#4
000084  4391              BICS     r1,r1,r2
000086  8061              STRH     r1,[r4,#2]
;;;67     					MOTOR_SHUT_DOWN;
000088  4920              LDR      r1,|L20.268|
00008a  620d              STR      r5,[r1,#0x20]
00008c  4a20              LDR      r2,|L20.272|
00008e  6155              STR      r5,[r2,#0x14]
000090  491c              LDR      r1,|L20.260|
000092  3920              SUBS     r1,r1,#0x20
000094  680d              LDR      r5,[r1,#0]
000096  038b              LSLS     r3,r1,#14
000098  439d              BICS     r5,r5,r3
00009a  600d              STR      r5,[r1,#0]
00009c  6805              LDR      r5,[r0,#0]
00009e  439d              BICS     r5,r5,r3
0000a0  6005              STR      r5,[r0,#0]
0000a2  680d              LDR      r5,[r1,#0]
0000a4  034b              LSLS     r3,r1,#13
0000a6  439d              BICS     r5,r5,r3
0000a8  600d              STR      r5,[r1,#0]
0000aa  6801              LDR      r1,[r0,#0]
0000ac  4399              BICS     r1,r1,r3
0000ae  6001              STR      r1,[r0,#0]
0000b0  20ff              MOVS     r0,#0xff
0000b2  63d0              STR      r0,[r2,#0x3c]
0000b4  6390              STR      r0,[r2,#0x38]
;;;68     					setError(ERR_INTERNAL);
0000b6  2006              MOVS     r0,#6
0000b8  f7fffffe          BL       setError
0000bc  e009              B        |L20.210|
                  |L20.190|
;;;69     				}
;;;70     			}
;;;71     			else
;;;72     			{
;;;73     				tMotor.structMotor.MSR.unMissedZXD_CNT++;
0000be  8860              LDRH     r0,[r4,#2]  ; tMotor
0000c0  8861              LDRH     r1,[r4,#2]  ; tMotor
0000c2  04c0              LSLS     r0,r0,#19
0000c4  0e00              LSRS     r0,r0,#24
0000c6  1c40              ADDS     r0,r0,#1
0000c8  0600              LSLS     r0,r0,#24
0000ca  0cc0              LSRS     r0,r0,#19
0000cc  43b9              BICS     r1,r1,r7
0000ce  4301              ORRS     r1,r1,r0
0000d0  8061              STRH     r1,[r4,#2]
                  |L20.210|
;;;74     			}
;;;75     		}
;;;76     
;;;77     	}
;;;78     
;;;79     	if (TRUE == tMotor.structMotor.MSR.bLocked)
0000d2  8860              LDRH     r0,[r4,#2]  ; tMotor
0000d4  0740              LSLS     r0,r0,#29
0000d6  d504              BPL      |L20.226|
;;;80     	{
;;;81     		// Set a rough next phase change time as the same with last phase
;;;82     		// After detected ZX in TIM1 interrupt, next phase change time will be re-configured
;;;83     		TIMER_SET_CMP_VALUE(TIMER0, tMotor.structMotor.unActualPeriod << 1);
0000d8  69a0              LDR      r0,[r4,#0x18]  ; tMotor
0000da  0041              LSLS     r1,r0,#1
0000dc  4809              LDR      r0,|L20.260|
0000de  3820              SUBS     r0,r0,#0x20
0000e0  6041              STR      r1,[r0,#4]
                  |L20.226|
;;;84     	}
;;;85     
;;;86     	tMotor.structMotor.MSR.bThisPhaseDetectedZX = FALSE;
0000e2  8860              LDRH     r0,[r4,#2]  ; tMotor
0000e4  2108              MOVS     r1,#8
0000e6  4388              BICS     r0,r0,r1
0000e8  8060              STRH     r0,[r4,#2]
;;;87     	// For debug
;;;88     	GPIO_TOGGLE(P50);
0000ea  4808              LDR      r0,|L20.268|
0000ec  3040              ADDS     r0,r0,#0x40
0000ee  6a01              LDR      r1,[r0,#0x20]
0000f0  2201              MOVS     r2,#1
0000f2  4051              EORS     r1,r1,r2
0000f4  6201              STR      r1,[r0,#0x20]
;;;89     }
0000f6  bdf8              POP      {r3-r7,pc}
;;;90     
                          ENDP

                  |L20.248|
                          DCD      ||.data||
                  |L20.252|
                          DCD      ||.bss||
                  |L20.256|
                          DCD      0x00001fe0
                  |L20.260|
                          DCD      0x40010020
                  |L20.264|
                          DCD      0x00ffffff
                  |L20.268|
                          DCD      0x50004240
                  |L20.272|
                          DCD      0x40040040

                          AREA ||i.BLDC_stopMotor||, COMGROUP=BLDC_stopMotor, CODE, READONLY, ALIGN=2

                  BLDC_stopMotor PROC
;;;193    //}
;;;194    __INLINE void BLDC_stopMotor(void)
000000  b530              PUSH     {r4,r5,lr}
;;;195    {
;;;196    	MOTOR_SHUT_DOWN;
000002  4812              LDR      r0,|L27.76|
000004  2200              MOVS     r2,#0
000006  6202              STR      r2,[r0,#0x20]
000008  4b11              LDR      r3,|L27.80|
00000a  615a              STR      r2,[r3,#0x14]
00000c  4811              LDR      r0,|L27.84|
00000e  6801              LDR      r1,[r0,#0]
000010  0384              LSLS     r4,r0,#14
000012  43a1              BICS     r1,r1,r4
000014  6001              STR      r1,[r0,#0]
000016  490f              LDR      r1,|L27.84|
000018  3120              ADDS     r1,r1,#0x20
00001a  680d              LDR      r5,[r1,#0]
00001c  43a5              BICS     r5,r5,r4
00001e  600d              STR      r5,[r1,#0]
000020  6805              LDR      r5,[r0,#0]
000022  0344              LSLS     r4,r0,#13
000024  43a5              BICS     r5,r5,r4
000026  6005              STR      r5,[r0,#0]
000028  6808              LDR      r0,[r1,#0]
00002a  43a0              BICS     r0,r0,r4
00002c  6008              STR      r0,[r1,#0]
00002e  20ff              MOVS     r0,#0xff
000030  63d8              STR      r0,[r3,#0x3c]
000032  6398              STR      r0,[r3,#0x38]
;;;197    	tMotor.structMotor.MCR.bMotorNeedToRun = FALSE;
000034  4808              LDR      r0,|L27.88|
000036  8801              LDRH     r1,[r0,#0]  ; tMotor
000038  0849              LSRS     r1,r1,#1
00003a  0049              LSLS     r1,r1,#1
00003c  8001              STRH     r1,[r0,#0]
;;;198    	tMotor.structMotor.MSR.bMotorPowerOn = FALSE;
00003e  8841              LDRH     r1,[r0,#2]  ; tMotor
000040  0849              LSRS     r1,r1,#1
000042  0049              LSLS     r1,r1,#1
000044  8041              STRH     r1,[r0,#2]
;;;199    	tMotorState = MOTOR_IDLE;
000046  4805              LDR      r0,|L27.92|
000048  7002              STRB     r2,[r0,#0]
;;;200    }
00004a  bd30              POP      {r4,r5,pc}
;;;201    
                          ENDP

                  |L27.76|
                          DCD      0x50004240
                  |L27.80|
                          DCD      0x40040040
                  |L27.84|
                          DCD      0x40010000
                  |L27.88|
                          DCD      ||.bss||
                  |L27.92|
                          DCD      ||.data||

                          AREA ||i.setPhaseManually||, COMGROUP=setPhaseManually, CODE, READONLY, ALIGN=2

                  setPhaseManually PROC
;;;201    
;;;202    __INLINE void setPhaseManually(uint16_t iPWMDuty, uint8_t iPhase)
000000  4a09              LDR      r2,|L34.40|
;;;203    {
;;;204        MOTOR_SET_DUTY(iPWMDuty);
000002  6290              STR      r0,[r2,#0x28]
000004  6310              STR      r0,[r2,#0x30]
000006  6390              STR      r0,[r2,#0x38]
;;;205    	PWM->PHCHG = GET_PHASE_VALUE(iPhase);
000008  4808              LDR      r0,|L34.44|
00000a  8800              LDRH     r0,[r0,#0]  ; tMotor
00000c  0782              LSLS     r2,r0,#30
00000e  0088              LSLS     r0,r1,#2
000010  2a00              CMP      r2,#0
000012  db01              BLT      |L34.24|
000014  4906              LDR      r1,|L34.48|
000016  e001              B        |L34.28|
                  |L34.24|
000018  4905              LDR      r1,|L34.48|
00001a  3118              ADDS     r1,r1,#0x18
                  |L34.28|
00001c  5808              LDR      r0,[r1,r0]
00001e  4902              LDR      r1,|L34.40|
000020  3140              ADDS     r1,r1,#0x40
000022  6388              STR      r0,[r1,#0x38]
;;;206    }
000024  4770              BX       lr
;;;207    
                          ENDP

000026  0000              DCW      0x0000
                  |L34.40|
                          DCD      0x40040000
                  |L34.44|
                          DCD      ||.bss||
                  |L34.48|
                          DCD      ||.constdata||+0x4

                          AREA ||i.BLDCRampUp_Manager||, COMGROUP=BLDCRampUp_Manager, CODE, READONLY, ALIGN=2

                  BLDCRampUp_Manager PROC
;;;228    
;;;229    __INLINE void BLDCRampUp_Manager(void)
000000  b570              PUSH     {r4-r6,lr}
;;;230    {
;;;231    	if (SET == FLAG_PHASE_CHANGED)
000002  4d1e              LDR      r5,|L41.124|
000004  79a8              LDRB     r0,[r5,#6]  ; FLAG_PHASE_CHANGED
000006  2801              CMP      r0,#1
000008  d136              BNE      |L41.120|
;;;232    	{
;;;233    		PhaseChangedRoutine();
00000a  f7fffffe          BL       PhaseChangedRoutine
;;;234    		if (unPhaseChangeCNT4Period > CHANGE_DUTY_PERIOD_THR)
00000e  78e8              LDRB     r0,[r5,#3]  ; unPhaseChangeCNT4Period
;;;235    		{
;;;236    			unPhaseChangeCNT4Period = 0;
;;;237    			// Change duty and period 
;;;238    //			MOTOR_RAMPUP_DT_INCR(tMotor.structMotor.ACT_DUTY);			
;;;239    			MOTOR_RAMPUP_PR_DCR(tMotor.structMotor.unActualPeriod);	
000010  4c1b              LDR      r4,|L41.128|
000012  2809              CMP      r0,#9                 ;234
000014  d916              BLS      |L41.68|
000016  2000              MOVS     r0,#0                 ;236
000018  70e8              STRB     r0,[r5,#3]            ;236
00001a  69a0              LDR      r0,[r4,#0x18]  ; tMotor
00001c  4e19              LDR      r6,|L41.132|
00001e  42b0              CMP      r0,r6
000020  69a0              LDR      r0,[r4,#0x18]  ; tMotor
000022  d308              BCC      |L41.54|
000024  f7fffffe          BL       __aeabi_ui2d
000028  4a17              LDR      r2,|L41.136|
00002a  4b18              LDR      r3,|L41.140|
00002c  f7fffffe          BL       __aeabi_dmul
000030  f7fffffe          BL       __aeabi_d2uiz
000034  b280              UXTH     r0,r0
                  |L41.54|
000036  61a0              STR      r0,[r4,#0x18]  ; tMotor
;;;240    			if (tMotor.structMotor.unActualPeriod <= MOTOR_RAMPUP_PR_MIN)
000038  69a0              LDR      r0,[r4,#0x18]  ; tMotor
00003a  42b0              CMP      r0,r6
00003c  d802              BHI      |L41.68|
;;;241    			{
;;;242    				unRampUpPeriodMiniCNT++;
00003e  8928              LDRH     r0,[r5,#8]  ; unRampUpPeriodMiniCNT
000040  1c40              ADDS     r0,r0,#1
000042  8128              STRH     r0,[r5,#8]
                  |L41.68|
;;;243    			}
;;;244    		}
;;;245    		unPhaseChangeCNT4Period++;
000044  78e8              LDRB     r0,[r5,#3]  ; unPhaseChangeCNT4Period
000046  1c40              ADDS     r0,r0,#1
000048  70e8              STRB     r0,[r5,#3]
;;;246    //		MOTOR_SET_DUTY(tMotor.structMotor.ACT_DUTY);
;;;247    		TIMER_SET_CMP_VALUE(TIMER0, tMotor.structMotor.unActualPeriod);
00004a  69a0              LDR      r0,[r4,#0x18]  ; tMotor
00004c  4910              LDR      r1,|L41.144|
00004e  6048              STR      r0,[r1,#4]
;;;248    		PHASE_INCREASE(unCurrentPhase);
000050  7968              LDRB     r0,[r5,#5]  ; unCurrentPhase
000052  2805              CMP      r0,#5
000054  d201              BCS      |L41.90|
000056  1c40              ADDS     r0,r0,#1
000058  e000              B        |L41.92|
                  |L41.90|
00005a  2000              MOVS     r0,#0
                  |L41.92|
00005c  b2c0              UXTB     r0,r0
00005e  7168              STRB     r0,[r5,#5]
;;;249    		// Modify PWM->PHCHGNXT at last because I don't know how long needed to reload PHCH with PHCHNEXT after TIM0 time-out
;;;250    		PWM->PHCHGNXT = GET_PHASE_VALUE(unCurrentPhase);
000060  8821              LDRH     r1,[r4,#0]  ; tMotor
000062  0789              LSLS     r1,r1,#30
000064  d402              BMI      |L41.108|
000066  0080              LSLS     r0,r0,#2
000068  490a              LDR      r1,|L41.148|
00006a  e002              B        |L41.114|
                  |L41.108|
00006c  4909              LDR      r1,|L41.148|
00006e  0080              LSLS     r0,r0,#2
000070  3118              ADDS     r1,r1,#0x18
                  |L41.114|
000072  5808              LDR      r0,[r1,r0]
000074  4908              LDR      r1,|L41.152|
000076  63c8              STR      r0,[r1,#0x3c]
                  |L41.120|
;;;251    	}
;;;252    }
000078  bd70              POP      {r4-r6,pc}
;;;253    
                          ENDP

00007a  0000              DCW      0x0000
                  |L41.124|
                          DCD      ||.data||
                  |L41.128|
                          DCD      ||.bss||
                  |L41.132|
                          DCD      0x000003e7
                  |L41.136|
                          DCD      0xf5c28f5c
                  |L41.140|
                          DCD      0x3fef5c28
                  |L41.144|
                          DCD      0x40010000
                  |L41.148|
                          DCD      ||.constdata||+0x4
                  |L41.152|
                          DCD      0x40040040

                          AREA ||.data__ZZ23phaseDurationProtectionE14unCurrentPHCHG||, COMGROUP=_ZZ23phaseDurationProtectionE14unCurrentPHCHG, DATA, ALIGN=2

                  _ZZ23phaseDurationProtectionE14unCurrentPHCHG
                          DCD      0x00000000

                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d200              BCS      |L50.16|
00000e  461d              MOV      r5,r3
                  |L50.16|
000010  5d63              LDRB     r3,[r4,r5]
000012  005b              LSLS     r3,r3,#1
000014  18e3              ADDS     r3,r4,r3
000016  bc30              POP      {r4,r5}
000018  4718              BX       r3
                          ENDP


;*** Start embedded assembler ***

#line 1 "User\\BLDCSensorLess.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_BLDCSensorLess_c_0df2b5b8____REV16|
#line 118 ".\\CMSIS\\core_cmInstr.h"
|__asm___16_BLDCSensorLess_c_0df2b5b8____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_BLDCSensorLess_c_0df2b5b8____REVSH|
#line 132
|__asm___16_BLDCSensorLess_c_0df2b5b8____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
