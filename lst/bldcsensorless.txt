; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\bldcsensorless.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\bldcsensorless.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\Mini51Series\Include -I..\..\..\Library\StdDriver\inc -I.\StdDriver\inc -I.\CMSIS -I.\RTE\Device\Mini54ZDE -I.\RTE\_BLDC_driver -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.1.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.1.0\Device\Mini51\Driver -IC:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.1.0\Device\Mini51\Include -D__MICROLIB -D__UVISION_VERSION=524 -D_RTE_ -DCLK_APBCLK_ACMP_EN_Pos=CLK_APBCLK_CMP_EN_Pos -DFOR_CAR --omf_browse=.\obj\bldcsensorless.crf User\BLDCSensorLess.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  canMotorContinueRunning PROC
;;;75      1-65534: phase time */
;;;76     uint16_t canMotorContinueRunning(void) {
000000  2000              MOVS     r0,#0
;;;77     // Later implement this when motor can rotate
;;;78     // Then stop it while rotating to measure the waveform
;;;79     // Manually rotate it is too slow 
;;;80     #ifdef FOR_CAR
;;;81     	return 0;
;;;82     #else
;;;83     	uint16_t unPhaseDuration = 0;
;;;84     	static uint32_t unStateEnterTime;
;;;85     	if ((uint32_t) (unSystemTick - unRotateDetectStartTime) > MAX_ALREADY_ROTATING_DETECT_TIME) {
;;;86     		return 0;
;;;87     	}
;;;88     	switch (tRotateDetectState) {
;;;89     	case DETECT_START:
;;;90     		unStateEnterTime = unSystemTick;
;;;91     		tRotateDetectState = DETECT_PHASE_1_P;
;;;92     		break;
;;;93     
;;;94     	case DETECT_PHASE_1_P:
;;;95     		if ((uint32_t) (unSystemTick - unStateEnterTime) > MAX_ROTATING_DETECT_PHASE_TIME) {
;;;96     			return (uint16_t) 0;
;;;97     		} else {
;;;98     
;;;99     		}
;;;100    		break;
;;;101    
;;;102    	case DETECT_PHASE_1_A:
;;;103    
;;;104    		break;
;;;105    
;;;106    	case DETECT_PHASE_2_P:
;;;107    
;;;108    		break;
;;;109    
;;;110    	case DETECT_PHASE_2_A:
;;;111    
;;;112    		break;
;;;113    
;;;114    	case DETECT_PHASE_3_P:
;;;115    
;;;116    		break;
;;;117    
;;;118    	case DETECT_PHASE_3_A:
;;;119    
;;;120    		break;
;;;121    
;;;122    	default:
;;;123    		break;
;;;124    	}
;;;125    
;;;126    	return unPhaseDuration;
;;;127    #endif
;;;128    }
000002  4770              BX       lr
;;;129    
                          ENDP

                  BLDCSpeedManager PROC
;;;130    // Mainly PWM duty increase/decrease
;;;131    void BLDCSpeedManager(void) {
000004  b510              PUSH     {r4,lr}
;;;132    	if (SET == FLAG_PHASE_CHANGED) {
000006  4cb2              LDR      r4,|L1.720|
000008  79a0              LDRB     r0,[r4,#6]  ; FLAG_PHASE_CHANGED
00000a  2801              CMP      r0,#1
00000c  d133              BNE      |L1.118|
;;;133    		PhaseChangedRoutine();
00000e  f7fffffe          BL       PhaseChangedRoutine
;;;134    
;;;135    		if (tMotor.structMotor.unActualDuty != tMotor.structMotor.unTargetDuty) {
000012  49b0              LDR      r1,|L1.724|
000014  8a08              LDRH     r0,[r1,#0x10]  ; tMotor
000016  89ca              LDRH     r2,[r1,#0xe]  ; tMotor
000018  4290              CMP      r0,r2
00001a  d017              BEQ      |L1.76|
;;;136    //				tMotor.structMotor.ACT_DUTY = tMotor.structMotor.TGT_DUTY;
;;;137    			// Change PWM duty after each x phase change
;;;138    			if (unPhaseChangeCNT_AtCurrentDuty > CHANGE_DUTY_AFTER_PHASE_CHANGED_NUM) {
00001c  7920              LDRB     r0,[r4,#4]  ; unPhaseChangeCNT_AtCurrentDuty
00001e  2805              CMP      r0,#5
000020  d911              BLS      |L1.70|
;;;139    				unPhaseChangeCNT_AtCurrentDuty = 0;
000022  2000              MOVS     r0,#0
000024  7120              STRB     r0,[r4,#4]
;;;140    				if (tMotor.structMotor.unActualDuty < tMotor.structMotor.unTargetDuty) {
000026  8a08              LDRH     r0,[r1,#0x10]  ; tMotor
000028  89ca              LDRH     r2,[r1,#0xe]  ; tMotor
00002a  4290              CMP      r0,r2
;;;141    					tMotor.structMotor.unActualDuty++;
;;;142    				} else {
;;;143    					tMotor.structMotor.unActualDuty--;
00002c  8a08              LDRH     r0,[r1,#0x10]  ; tMotor
00002e  d201              BCS      |L1.52|
000030  1c40              ADDS     r0,r0,#1              ;140
000032  e000              B        |L1.54|
                  |L1.52|
000034  1e40              SUBS     r0,r0,#1              ;141
                  |L1.54|
000036  8208              STRH     r0,[r1,#0x10]
;;;144    				}
;;;145    				MOTOR_SET_DUTY(tMotor.structMotor.unActualDuty);
000038  8a0a              LDRH     r2,[r1,#0x10]  ; tMotor
00003a  48a7              LDR      r0,|L1.728|
00003c  6282              STR      r2,[r0,#0x28]
00003e  8a0a              LDRH     r2,[r1,#0x10]  ; tMotor
000040  6302              STR      r2,[r0,#0x30]
000042  8a0a              LDRH     r2,[r1,#0x10]  ; tMotor
000044  6382              STR      r2,[r0,#0x38]
                  |L1.70|
;;;146    			}
;;;147    			unPhaseChangeCNT_AtCurrentDuty++;
000046  7920              LDRB     r0,[r4,#4]  ; unPhaseChangeCNT_AtCurrentDuty
000048  1c40              ADDS     r0,r0,#1
00004a  7120              STRB     r0,[r4,#4]
                  |L1.76|
;;;148    		}
;;;149    
;;;150    		PHASE_INCREASE(unCurrentPhase);
00004c  7960              LDRB     r0,[r4,#5]  ; unCurrentPhase
00004e  2805              CMP      r0,#5
000050  d201              BCS      |L1.86|
000052  1c40              ADDS     r0,r0,#1
000054  e000              B        |L1.88|
                  |L1.86|
000056  2000              MOVS     r0,#0
                  |L1.88|
000058  b2c0              UXTB     r0,r0
00005a  7160              STRB     r0,[r4,#5]
;;;151    		// Modify PWM->PHCHGNXT at last because I don't know how long needed to reload PHCH with PHCHNEXT after TIM0 time-out
;;;152    		PWM->PHCHGNXT = GET_PHASE_VALUE(unCurrentPhase);
00005c  8849              LDRH     r1,[r1,#2]  ; tMotor
00005e  0789              LSLS     r1,r1,#30
000060  d402              BMI      |L1.104|
000062  0080              LSLS     r0,r0,#2
000064  499d              LDR      r1,|L1.732|
000066  e002              B        |L1.110|
                  |L1.104|
000068  499c              LDR      r1,|L1.732|
00006a  0080              LSLS     r0,r0,#2
00006c  3118              ADDS     r1,r1,#0x18
                  |L1.110|
00006e  5808              LDR      r0,[r1,r0]
000070  4999              LDR      r1,|L1.728|
000072  3140              ADDS     r1,r1,#0x40
000074  63c8              STR      r0,[r1,#0x3c]
                  |L1.118|
;;;153    	}
;;;154    }
000076  bd10              POP      {r4,pc}
;;;155    
                          ENDP

                  BLDC_LocatingManager PROC
;;;167    
;;;168    ENUM_STATUS BLDC_LocatingManager(void) {
000078  b5f8              PUSH     {r3-r7,lr}
;;;169    	if ((uint32_t) (unSystemTick - unLastPhaseChangeTime) > tMotor.structMotor.unLocatingPeriod) {
00007a  4899              LDR      r0,|L1.736|
00007c  6800              LDR      r0,[r0,#0]  ; unSystemTick
00007e  4c94              LDR      r4,|L1.720|
000080  4b94              LDR      r3,|L1.724|
000082  6921              LDR      r1,[r4,#0x10]  ; unLastPhaseChangeTime
000084  1a40              SUBS     r0,r0,r1
000086  8a59              LDRH     r1,[r3,#0x12]  ; tMotor
000088  4288              CMP      r0,r1
00008a  d90b              BLS      |L1.164|
;;;170    		if (unLocateIndex < (sizeof(unLocatePhaseSequencyTable) / sizeof(uint8_t))) {
00008c  78a0              LDRB     r0,[r4,#2]  ; unLocateIndex
00008e  2804              CMP      r0,#4
000090  d20a              BCS      |L1.168|
;;;171    			//iLastPhaseChangeTime = unSystemTick; 
;;;172    			setPhaseManually(tMotor.structMotor.unLocatingDuty, unLocatePhaseSequencyTable[unLocateIndex]);
000092  4992              LDR      r1,|L1.732|
000094  1f09              SUBS     r1,r1,#4
000096  5c09              LDRB     r1,[r1,r0]
000098  8958              LDRH     r0,[r3,#0xa]  ; tMotor
00009a  f7fffffe          BL       setPhaseManually
;;;173    			unLocateIndex++;
00009e  78a0              LDRB     r0,[r4,#2]  ; unLocateIndex
0000a0  1c40              ADDS     r0,r0,#1
0000a2  70a0              STRB     r0,[r4,#2]
                  |L1.164|
;;;174    		} else {
;;;175    			MOTOR_SHUT_DOWN;
;;;176    			tMotor.structMotor.MSR.bMotorPowerOn = FALSE;
;;;177    			unCurrentPhase = unLocatePhaseSequencyTable[unLocateIndex - 1];
;;;178    			return STATUS_FINISHED;
;;;179    		}
;;;180    	}
;;;181    	return STATUS_WORKING;
0000a4  488f              LDR      r0,|L1.740|
;;;182    }
0000a6  bdf8              POP      {r3-r7,pc}
                  |L1.168|
0000a8  4a8f              LDR      r2,|L1.744|
0000aa  2100              MOVS     r1,#0                 ;175
0000ac  6211              STR      r1,[r2,#0x20]         ;175
0000ae  4d8a              LDR      r5,|L1.728|
0000b0  3540              ADDS     r5,r5,#0x40           ;175
0000b2  6169              STR      r1,[r5,#0x14]         ;175
0000b4  498d              LDR      r1,|L1.748|
0000b6  680a              LDR      r2,[r1,#0]            ;175
0000b8  038e              LSLS     r6,r1,#14             ;175
0000ba  43b2              BICS     r2,r2,r6              ;175
0000bc  600a              STR      r2,[r1,#0]            ;175
0000be  4a8b              LDR      r2,|L1.748|
0000c0  3220              ADDS     r2,r2,#0x20           ;175
0000c2  6817              LDR      r7,[r2,#0]            ;175
0000c4  43b7              BICS     r7,r7,r6              ;175
0000c6  6017              STR      r7,[r2,#0]            ;175
0000c8  680f              LDR      r7,[r1,#0]            ;175
0000ca  034e              LSLS     r6,r1,#13             ;175
0000cc  43b7              BICS     r7,r7,r6              ;175
0000ce  600f              STR      r7,[r1,#0]            ;175
0000d0  6811              LDR      r1,[r2,#0]            ;175
0000d2  43b1              BICS     r1,r1,r6              ;175
0000d4  6011              STR      r1,[r2,#0]            ;175
0000d6  21ff              MOVS     r1,#0xff              ;175
0000d8  63e9              STR      r1,[r5,#0x3c]         ;175
0000da  63a9              STR      r1,[r5,#0x38]         ;175
0000dc  8899              LDRH     r1,[r3,#4]            ;176  ; tMotor
0000de  0849              LSRS     r1,r1,#1              ;176
0000e0  0049              LSLS     r1,r1,#1              ;176
0000e2  8099              STRH     r1,[r3,#4]            ;176
0000e4  497d              LDR      r1,|L1.732|
0000e6  1f09              SUBS     r1,r1,#4              ;177
0000e8  1808              ADDS     r0,r1,r0              ;177
0000ea  3820              SUBS     r0,r0,#0x20           ;177
0000ec  7fc0              LDRB     r0,[r0,#0x1f]         ;177
0000ee  7160              STRB     r0,[r4,#5]            ;177
0000f0  2001              MOVS     r0,#1                 ;178
0000f2  bdf8              POP      {r3-r7,pc}
;;;183    
                          ENDP

                  BLDC_SensorLessManager PROC
;;;229    // Take charge of all Motot control
;;;230    void BLDC_SensorLessManager(void) {
0000f4  b5f8              PUSH     {r3-r7,lr}
0000f6  4c77              LDR      r4,|L1.724|
0000f8  8a21              LDRH     r1,[r4,#0x10]  ; tMotor
0000fa  487d              LDR      r0,|L1.752|
0000fc  4281              CMP      r1,r0
0000fe  d803              BHI      |L1.264|
000100  4975              LDR      r1,|L1.728|
000102  6a89              LDR      r1,[r1,#0x28]
000104  4281              CMP      r1,r0
000106  d904              BLS      |L1.274|
                  |L1.264|
000108  f7fffffe          BL       BLDC_stopMotor
00010c  2006              MOVS     r0,#6
00010e  f7fffffe          BL       setError
                  |L1.274|
;;;231    	uint16_t unMotorAlreadyRotatingPhaseTime;
;;;232    	static uint32_t iEnterTimeBeforeWait;
;;;233    
;;;234    	dutyProtection();
;;;235    	phaseDurationProtection(unLastPhaseChangeTime);
000112  4d6f              LDR      r5,|L1.720|
000114  88a1              LDRH     r1,[r4,#4]  ; tMotor
000116  6928              LDR      r0,[r5,#0x10]  ; unLastPhaseChangeTime
000118  4e71              LDR      r6,|L1.736|
00011a  07c9              LSLS     r1,r1,#31
00011c  d013              BEQ      |L1.326|
00011e  496e              LDR      r1,|L1.728|
000120  3140              ADDS     r1,r1,#0x40
000122  6b8b              LDR      r3,[r1,#0x38]
000124  4a73              LDR      r2,|L1.756|
000126  6817              LDR      r7,[r2,#0]  ; _ZZ23phaseDurationProtectionE14unCurrentPHCHG
000128  42bb              CMP      r3,r7
00012a  d003              BEQ      |L1.308|
00012c  6b88              LDR      r0,[r1,#0x38]
00012e  6010              STR      r0,[r2,#0]  ; _ZZ23phaseDurationProtectionE14unCurrentPHCHG
000130  6830              LDR      r0,[r6,#0]  ; unSystemTick
000132  e008              B        |L1.326|
                  |L1.308|
000134  6831              LDR      r1,[r6,#0]  ; unSystemTick
000136  1a08              SUBS     r0,r1,r0
000138  2850              CMP      r0,#0x50
00013a  d904              BLS      |L1.326|
00013c  f7fffffe          BL       BLDC_stopMotor
000140  2006              MOVS     r0,#6
000142  f7fffffe          BL       setError
                  |L1.326|
;;;236    
;;;237    	switch (tMotorState) {
000146  782a              LDRB     r2,[r5,#0]  ; tMotorState
000148  2700              MOVS     r7,#0
;;;238    	case MOTOR_IDLE:
;;;239    		if (tMotor.structMotor.MCR.bMotorNeedToRun && NO_MOTOR_EEROR) {
00014a  486b              LDR      r0,|L1.760|
00014c  2101              MOVS     r1,#1                 ;237
00014e  0013              MOVS     r3,r2                 ;237
000150  f7fffffe          BL       __ARM_common_switch8
000154  0705102c          DCB      0x07,0x05,0x10,0x2c
000158  3a7c9db4          DCB      0x3a,0x7c,0x9d,0xb4
00015c  0f00              DCB      0x0f,0x00
00015e  8862              LDRH     r2,[r4,#2]  ; tMotor
000160  07d2              LSLS     r2,r2,#31
000162  d006              BEQ      |L1.370|
000164  6800              LDR      r0,[r0,#0]  ; unErrorMaster
000166  0840              LSRS     r0,r0,#1
000168  d103              BNE      |L1.370|
;;;240    			unRotateDetectStartTime = unSystemTick;
00016a  6830              LDR      r0,[r6,#0]  ; unSystemTick
;;;241    			tRotateDetectState = DETECT_START;
00016c  6168              STR      r0,[r5,#0x14]  ; unRotateDetectStartTime
00016e  706f              STRB     r7,[r5,#1]
;;;242    			tMotorState = MOTOR_START;
000170  7029              STRB     r1,[r5,#0]
                  |L1.370|
;;;243    		}
;;;244    		break;
;;;245    
;;;246    	case MOTOR_START:
;;;247    		if (tMotor.structMotor.MCR.bMotorNeedToRun && NO_MOTOR_EEROR) {
;;;248    			// Later implement this when motor can rotate
;;;249    			// Then stop it while rotating to measure the waveform
;;;250    			// Manually rotate it is too slow 
;;;251    			unMotorAlreadyRotatingPhaseTime = canMotorContinueRunning();
;;;252    			if (unMotorAlreadyRotatingPhaseTime != IS_ROTATING_DETECTING) {
;;;253    				if (unMotorAlreadyRotatingPhaseTime > 0) {
;;;254    					// 1 to 65534
;;;255    					tMotorState = MOTOR_LOCKED;
;;;256    				} else {
;;;257    					// When back to Idle state the motor was already shut down
;;;258    					// MOTOR_SHUT_DOWN;
;;;259    					unCurrentPhase = 0;
;;;260    					unLocateIndex = 0;
;;;261    					tMotor.structMotor.unMissedZXD_CNT = 0;
;;;262    					unLastPhaseChangeTime = unSystemTick;
;;;263    					tMotor.structMotor.MSR.bMotorPowerOn = TRUE;
;;;264    					// Clear start detect zero cross flag
;;;265    					tMotor.structMotor.MSR.bZeroCrossDetecting = FALSE;
;;;266    					tMotor.structMotor.MSR.bLocked = FALSE;
;;;267    					//setPhaseManually(tMotor.structMotor.LCT_DUTY, unCurrentPhase);
;;;268    					BRG_ENABLE;
;;;269    					tMotorState = MOTOR_LOCATE;
;;;270    				}
;;;271    			}
;;;272    		} else {
;;;273    			BLDC_stopMotor();
;;;274    		}
;;;275    		break;
;;;276    
;;;277    	case MOTOR_LOCATE:
;;;278    		if (tMotor.structMotor.MCR.bMotorNeedToRun && NO_MOTOR_EEROR) {
;;;279    			if (BLDC_LocatingManager() == STATUS_FINISHED) {
;;;280    				iEnterTimeBeforeWait = unSystemTick;
;;;281    				tMotorState = MOTOR_WAIT_AFTER_LOCATE;
;;;282    			}
;;;283    		} else {
;;;284    			BLDC_stopMotor();
;;;285    		}
;;;286    		break;
;;;287    
;;;288    	case MOTOR_WAIT_AFTER_LOCATE:
;;;289    		if (tMotor.structMotor.MCR.bMotorNeedToRun && NO_MOTOR_EEROR) {
;;;290    #ifdef WAIT_AFTER_LOCATE
;;;291    			if ((uint32_t) (unSystemTick - iEnterTimeBeforeWait) >= WAIT_AFTER_LOCATE_TIME) {
;;;292    #endif					
;;;293    				tMotor.structMotor.unActualDuty = tMotor.structMotor.unRampUpDuty;
;;;294    				tMotor.structMotor.unActualPeriod = tMotor.structMotor.unRampUpPeriod;
;;;295    				tMotor.structMotor.MSR.bMotorPowerOn = TRUE;
;;;296    				PHASE_INCREASE(unCurrentPhase);
;;;297    				setPhaseManually(tMotor.structMotor.unActualDuty, unCurrentPhase);
;;;298    				BRG_ENABLE;
;;;299    				// Set timer 0 valure, use timer 0 to change phase automatically
;;;300    				// ************************************************************************
;;;301    				// ----==== From here current unCurrentPhase is actually next phase ====----
;;;302    				// ----==== Because we want to use the HW auto phase changer (PWM->PHCHGNXT) ====----
;;;303    				// So increase unCurrentPhase again. Want to get real current phase value? Read PWM->PHCHG.
;;;304    				// ************************************************************************
;;;305    				PHASE_INCREASE(unCurrentPhase);
;;;306    				PWM->PHCHGNXT = GET_PHASE_VALUE(unCurrentPhase);
;;;307    				// !!!! Need to make sure CPU runs to here every min tMotor.structMotor.ACT_PERIOD time !!!
;;;308    				// !!!! If not , timer counter may already passed tMotor.structMotor.ACT_PERIOD, !!!!
;;;309    				// !!!! then need to count to max timer counter number (which is 2^24), !!!!
;;;310    				// !!!! go back to 0 and triger interrupt when reach ACT_PERIOD again !!!!
;;;311    				TIMER_SET_CMP_VALUE(TIMER0, tMotor.structMotor.unActualPeriod);
;;;312    				TIMER_Start(TIMER0);				// Once started, running and interrupting until Motor stop
;;;313    				TIMER_EnableInt(TIMER0);
;;;314    				unPeriodChangeCNT_AfterPR_ReachMini = 0;
;;;315    				unPhaseChangeCNT_AtCurrentDuty = 0;
;;;316    				unPhaseChangeCNT_AtCurrentPeriod = 0;
;;;317    				tMotorState = MOTOR_RAMPUP_WO_ZXD;
;;;318    #ifdef WAIT_AFTER_LOCATE
;;;319    			}
;;;320    #endif
;;;321    		} else {
;;;322    			BLDC_stopMotor();
;;;323    		}
;;;324    		break;
;;;325    
;;;326    	case MOTOR_RAMPUP_WO_ZXD:	// without zero cross detection
;;;327    		if (tMotor.structMotor.MCR.bMotorNeedToRun && NO_MOTOR_EEROR) {
;;;328    			BLDCRampUp_Manager();
;;;329    			if (tMotor.structMotor.unActualPeriod <= MOTOR_START_ZXD_SPEED)	//(iRampUpPeriodMiniCNT > MOTOR_START_ZXD_MINROT_CNT)  //
;;;330    			{
;;;331    				tMotor.structMotor.MSR.bThisPhaseDetectedZX = FALSE;
;;;332    				tMotor.structMotor.MSR.bZeroCrossDetecting = TRUE;
;;;333    				// Speed is enough for zero cross detecting
;;;334    				// Prepare everything
;;;335    				// T0 used to change phase automatically -- already configured
;;;336    				// T1 used to filter ZX
;;;337    
;;;338    //				TIMER_SET_CMP_VALUE(TIMER1, GET_TIM1_CMP_VALUE(TIMER1->TDR + AVOID_ZXD_AFTER_PHCHG));
;;;339    //				FLAG_TIM1_USEAGE = ENUM_TIM1_AVOID_ZXD;
;;;340    				ACMP0_ENABLE;
;;;341    				TIMER_Start(TIMER1);				// Once started, running until Motor stop
;;;342    //				TIMER_EnableInt(TIMER1);
;;;343    						// Suppose last ZX detected time
;;;344    //				unLastZXDetectedTime = MINI51_TIM_CNT_MAX - tMotor.structMotor.ACT_PERIOD / 2;
;;;345    				tMotorState = MOTOR_RAMPUP_W_ZXD;
;;;346    			}
;;;347    		} else {
;;;348    			BLDC_stopMotor();
;;;349    		}
;;;350    		break;
;;;351    
;;;352    	case MOTOR_RAMPUP_W_ZXD:	// with zero cross detection
;;;353    		if (tMotor.structMotor.MCR.bMotorNeedToRun && NO_MOTOR_EEROR) {
;;;354    			if (TRUE == tMotor.structMotor.MSR.bLocked) {
;;;355    				// Finally, everything was prepared:
;;;356    				// T0 used to change phase automatically
;;;357    				// T1 used to filter ZX
;;;358    				tMotorState = MOTOR_LOCKED;
;;;359    			} else {
;;;360    				if (unPeriodChangeCNT_AfterPR_ReachMini < RAMP_UP_MIN_PERIOD_NUM_THRS) {
;;;361    					BLDCRampUp_Manager();
;;;362    				} else {
;;;363    					setError(ERR_RAMPUP_FAIL);
;;;364    				}
;;;365    			}
;;;366    		} else {
;;;367    			BLDC_stopMotor();
;;;368    		}
;;;369    		break;
;;;370    
;;;371    	case MOTOR_LOCKED:
;;;372    		if (tMotor.structMotor.MCR.bMotorNeedToRun && NO_MOTOR_EEROR) {
;;;373    			BLDCSpeedManager();	// Mainly PWM duty increase/decrease
;;;374    		} else {
;;;375    			BLDC_stopMotor();
;;;376    		}
;;;377    		break;
;;;378    
;;;379    	default:
;;;380    		break;
;;;381    	}
;;;382    }
000172  bdf8              POP      {r3-r7,pc}
000174  8862              LDRH     r2,[r4,#2]            ;247  ; tMotor
000176  07d2              LSLS     r2,r2,#31             ;247
000178  d015              BEQ      |L1.422|
00017a  6800              LDR      r0,[r0,#0]            ;247  ; unErrorMaster
00017c  0840              LSRS     r0,r0,#1              ;247
00017e  d112              BNE      |L1.422|
000180  716f              STRB     r7,[r5,#5]            ;259
000182  70af              STRB     r7,[r5,#2]            ;260
000184  80e7              STRH     r7,[r4,#6]            ;261
000186  6830              LDR      r0,[r6,#0]            ;262  ; unSystemTick
000188  6128              STR      r0,[r5,#0x10]         ;263  ; unLastPhaseChangeTime
00018a  88a0              LDRH     r0,[r4,#4]            ;263  ; tMotor
00018c  4308              ORRS     r0,r0,r1              ;263
00018e  80a0              STRH     r0,[r4,#4]            ;263
000190  88a2              LDRH     r2,[r4,#4]            ;265  ; tMotor
000192  2002              MOVS     r0,#2                 ;265
000194  4382              BICS     r2,r2,r0              ;265
000196  80a2              STRH     r2,[r4,#4]            ;265
000198  88a3              LDRH     r3,[r4,#4]            ;266  ; tMotor
00019a  2204              MOVS     r2,#4                 ;266
00019c  4393              BICS     r3,r3,r2              ;266
00019e  80a3              STRH     r3,[r4,#4]            ;266
0001a0  4a51              LDR      r2,|L1.744|
0001a2  6211              STR      r1,[r2,#0x20]         ;268
0001a4  e050              B        |L1.584|
                  |L1.422|
0001a6  f7fffffe          BL       BLDC_stopMotor
                  |L1.426|
0001aa  bdf8              POP      {r3-r7,pc}
0001ac  8861              LDRH     r1,[r4,#2]            ;278  ; tMotor
0001ae  07c9              LSLS     r1,r1,#31             ;278
0001b0  d0f9              BEQ      |L1.422|
0001b2  6800              LDR      r0,[r0,#0]            ;278  ; unErrorMaster
0001b4  0840              LSRS     r0,r0,#1              ;278
0001b6  d1f6              BNE      |L1.422|
0001b8  f7fffffe          BL       BLDC_LocatingManager
0001bc  2801              CMP      r0,#1                 ;279
0001be  d1f4              BNE      |L1.426|
0001c0  6830              LDR      r0,[r6,#0]            ;280  ; unSystemTick
0001c2  60e8              STR      r0,[r5,#0xc]          ;281  ; iEnterTimeBeforeWait
0001c4  2003              MOVS     r0,#3                 ;281
0001c6  e03f              B        |L1.584|
0001c8  8862              LDRH     r2,[r4,#2]            ;289  ; tMotor
0001ca  07d2              LSLS     r2,r2,#31             ;289
                  |L1.460|
0001cc  d0eb              BEQ      |L1.422|
0001ce  6800              LDR      r0,[r0,#0]            ;289  ; unErrorMaster
0001d0  0840              LSRS     r0,r0,#1              ;289
                  |L1.466|
0001d2  d1e8              BNE      |L1.422|
0001d4  89a0              LDRH     r0,[r4,#0xc]          ;293  ; tMotor
0001d6  4626              MOV      r6,r4                 ;293
0001d8  8220              STRH     r0,[r4,#0x10]         ;293
0001da  69a0              LDR      r0,[r4,#0x18]         ;294  ; tMotor
0001dc  61e0              STR      r0,[r4,#0x1c]         ;294  ; tMotor
0001de  88a0              LDRH     r0,[r4,#4]            ;295  ; tMotor
0001e0  460c              MOV      r4,r1                 ;295
0001e2  4320              ORRS     r0,r0,r4              ;295
0001e4  80b0              STRH     r0,[r6,#4]            ;295
0001e6  7968              LDRB     r0,[r5,#5]            ;296  ; unCurrentPhase
0001e8  2805              CMP      r0,#5                 ;296
0001ea  d201              BCS      |L1.496|
0001ec  1c40              ADDS     r0,r0,#1              ;296
0001ee  e000              B        |L1.498|
                  |L1.496|
0001f0  2000              MOVS     r0,#0                 ;296
                  |L1.498|
0001f2  b2c1              UXTB     r1,r0                 ;296
0001f4  7169              STRB     r1,[r5,#5]            ;296
0001f6  8a30              LDRH     r0,[r6,#0x10]         ;297  ; tMotor
0001f8  f7fffffe          BL       setPhaseManually
0001fc  483a              LDR      r0,|L1.744|
0001fe  6204              STR      r4,[r0,#0x20]         ;298
000200  7968              LDRB     r0,[r5,#5]            ;305  ; unCurrentPhase
000202  2805              CMP      r0,#5                 ;305
000204  d201              BCS      |L1.522|
000206  1c40              ADDS     r0,r0,#1              ;305
000208  e000              B        |L1.524|
                  |L1.522|
00020a  2000              MOVS     r0,#0                 ;305
                  |L1.524|
00020c  b2c0              UXTB     r0,r0                 ;305
00020e  7168              STRB     r0,[r5,#5]            ;305
000210  8871              LDRH     r1,[r6,#2]            ;306  ; tMotor
000212  0789              LSLS     r1,r1,#30             ;306
000214  d402              BMI      |L1.540|
000216  0080              LSLS     r0,r0,#2              ;306
000218  4930              LDR      r1,|L1.732|
00021a  e002              B        |L1.546|
                  |L1.540|
00021c  492f              LDR      r1,|L1.732|
00021e  0080              LSLS     r0,r0,#2              ;306
000220  3118              ADDS     r1,r1,#0x18           ;306
                  |L1.546|
000222  5808              LDR      r0,[r1,r0]            ;306
000224  492c              LDR      r1,|L1.728|
000226  3140              ADDS     r1,r1,#0x40           ;306
000228  63c8              STR      r0,[r1,#0x3c]         ;306
00022a  69f1              LDR      r1,[r6,#0x1c]         ;311  ; tMotor
00022c  482f              LDR      r0,|L1.748|
00022e  6041              STR      r1,[r0,#4]            ;311
000230  6801              LDR      r1,[r0,#0]            ;311
000232  0382              LSLS     r2,r0,#14             ;311
000234  4311              ORRS     r1,r1,r2              ;311
000236  6001              STR      r1,[r0,#0]            ;311
000238  6801              LDR      r1,[r0,#0]            ;311
00023a  0342              LSLS     r2,r0,#13             ;311
00023c  4311              ORRS     r1,r1,r2              ;311
00023e  6001              STR      r1,[r0,#0]            ;311
000240  812f              STRH     r7,[r5,#8]            ;314
000242  712f              STRB     r7,[r5,#4]            ;315
000244  70ef              STRB     r7,[r5,#3]            ;316
000246  2004              MOVS     r0,#4                 ;317
                  |L1.584|
000248  7028              STRB     r0,[r5,#0]            ;281
                  |L1.586|
00024a  bdf8              POP      {r3-r7,pc}
00024c  8861              LDRH     r1,[r4,#2]            ;327  ; tMotor
00024e  07c9              LSLS     r1,r1,#31             ;327
000250  d0a9              BEQ      |L1.422|
000252  6800              LDR      r0,[r0,#0]            ;327  ; unErrorMaster
000254  0840              LSRS     r0,r0,#1              ;327
000256  d1a6              BNE      |L1.422|
000258  f7fffffe          BL       BLDCRampUp_Manager
00025c  69e0              LDR      r0,[r4,#0x1c]         ;329  ; tMotor
00025e  4927              LDR      r1,|L1.764|
000260  4288              CMP      r0,r1                 ;329
000262  d8f2              BHI      |L1.586|
000264  88a0              LDRH     r0,[r4,#4]            ;331  ; tMotor
000266  2108              MOVS     r1,#8                 ;331
000268  4388              BICS     r0,r0,r1              ;331
00026a  80a0              STRH     r0,[r4,#4]            ;331
00026c  88a0              LDRH     r0,[r4,#4]            ;332  ; tMotor
00026e  2102              MOVS     r1,#2                 ;332
000270  4308              ORRS     r0,r0,r1              ;332
000272  80a0              STRH     r0,[r4,#4]            ;332
000274  4822              LDR      r0,|L1.768|
000276  6801              LDR      r1,[r0,#0]            ;340
000278  2305              MOVS     r3,#5                 ;340
00027a  4319              ORRS     r1,r1,r3              ;340
00027c  6001              STR      r1,[r0,#0]            ;340
00027e  491b              LDR      r1,|L1.748|
000280  3120              ADDS     r1,r1,#0x20           ;340
000282  680a              LDR      r2,[r1,#0]            ;340
000284  0380              LSLS     r0,r0,#14             ;340
000286  4302              ORRS     r2,r2,r0              ;340
000288  600a              STR      r2,[r1,#0]            ;340
00028a  702b              STRB     r3,[r5,#0]            ;345
00028c  bdf8              POP      {r3-r7,pc}
00028e  8861              LDRH     r1,[r4,#2]            ;353  ; tMotor
000290  07c9              LSLS     r1,r1,#31             ;353
000292  d088              BEQ      |L1.422|
000294  6800              LDR      r0,[r0,#0]            ;353  ; unErrorMaster
000296  0840              LSRS     r0,r0,#1              ;353
000298  d185              BNE      |L1.422|
00029a  88a0              LDRH     r0,[r4,#4]            ;354  ; tMotor
00029c  0740              LSLS     r0,r0,#29             ;354
00029e  d501              BPL      |L1.676|
0002a0  2006              MOVS     r0,#6                 ;358
0002a2  e7d1              B        |L1.584|
                  |L1.676|
0002a4  8928              LDRH     r0,[r5,#8]            ;360  ; unPeriodChangeCNT_AfterPR_ReachMini
0002a6  21ff              MOVS     r1,#0xff              ;360
0002a8  312d              ADDS     r1,r1,#0x2d           ;360
0002aa  4288              CMP      r0,r1                 ;360
0002ac  d202              BCS      |L1.692|
0002ae  f7fffffe          BL       BLDCRampUp_Manager
0002b2  bdf8              POP      {r3-r7,pc}
                  |L1.692|
0002b4  2004              MOVS     r0,#4                 ;363
0002b6  f7fffffe          BL       setError
0002ba  bdf8              POP      {r3-r7,pc}
0002bc  8861              LDRH     r1,[r4,#2]            ;372  ; tMotor
0002be  07c9              LSLS     r1,r1,#31             ;372
0002c0  d084              BEQ      |L1.460|
0002c2  6800              LDR      r0,[r0,#0]            ;372  ; unErrorMaster
0002c4  0840              LSRS     r0,r0,#1              ;372
0002c6  d184              BNE      |L1.466|
0002c8  f7fffffe          BL       BLDCSpeedManager
0002cc  bdf8              POP      {r3-r7,pc}
;;;383    
                          ENDP

0002ce  0000              DCW      0x0000
                  |L1.720|
                          DCD      ||.data||
                  |L1.724|
                          DCD      ||.bss||
                  |L1.728|
                          DCD      0x40040000
                  |L1.732|
                          DCD      ||.constdata||+0x4
                  |L1.736|
                          DCD      unSystemTick
                  |L1.740|
                          DCD      0x0000ffff
                  |L1.744|
                          DCD      0x50004240
                  |L1.748|
                          DCD      0x40010000
                  |L1.752|
                          DCD      0x000002dd
                  |L1.756|
                          DCD      _ZZ23phaseDurationProtectionE14unCurrentPHCHG
                  |L1.760|
                          DCD      unErrorMaster
                  |L1.764|
                          DCD      0x0000063f
                  |L1.768|
                          DCD      0x400d0000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  tMotor
                          %        52

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  unLocatePhaseSequencyTable
000000  00010201          DCB      0x00,0x01,0x02,0x01
                  PHASE_TAB_CLOCKWISE
                          DCD      0x40000239
                          DCD      0x700002ad
                          DCD      0x50000827
                          DCD      0x400008b6
                          DCD      0x7000201e
                          DCD      0x5000209b
                  PHASE_TAB_ANTICLOCKWISE
                          DCD      0x400002b9
                          DCD      0x5000201b
                          DCD      0x7000209e
                          DCD      0x40000836
                          DCD      0x500008a7
                          DCD      0x7000022d

                          AREA ||.data||, DATA, ALIGN=2

                  tMotorState
000000  00                DCB      0x00
                  tRotateDetectState
000001  00                DCB      0x00
                  unLocateIndex
000002  00                DCB      0x00
                  unPhaseChangeCNT_AtCurrentPeriod
000003  00                DCB      0x00
                  unPhaseChangeCNT_AtCurrentDuty
000004  00                DCB      0x00
                  unCurrentPhase
000005  00                DCB      0x00
                  FLAG_PHASE_CHANGED
000006  0000              DCB      0x00,0x00
                  unPeriodChangeCNT_AfterPR_ReachMini
000008  00000000          DCB      0x00,0x00,0x00,0x00
                  iEnterTimeBeforeWait
                          DCD      0x00000000
                  unLastPhaseChangeTime
                          DCD      0x00000000
                  unRotateDetectStartTime
                          DCD      0x00000000
                  unLastZXDetectedTime
                          DCD      0x00000000

                          AREA ||area_number.7||, DATA, ALIGN=0

                          EXPORTAS ||area_number.7||, ||.data||
                  FLAG_TIM1_USEAGE
000000  00                DCB      0x00

                          AREA ||area_number.8||, DATA, ALIGN=2

                          EXPORTAS ||area_number.8||, ||.data||
                  unZXMatchCNT
                          DCD      0x00000000

                          AREA ||i.PhaseChangedRoutine||, COMGROUP=PhaseChangedRoutine, CODE, READONLY, ALIGN=2

                  PhaseChangedRoutine PROC
;;;26     
;;;27     __INLINE void PhaseChangedRoutine(void) {
000000  b5f8              PUSH     {r3-r7,lr}
;;;28     	FLAG_PHASE_CHANGED = RESET;
000002  4e33              LDR      r6,|L20.208|
000004  2500              MOVS     r5,#0
;;;29     	tMotor.structMotor.unPhaseChangeCNT++;
000006  4c33              LDR      r4,|L20.212|
000008  71b5              STRB     r5,[r6,#6]            ;28
00000a  6a20              LDR      r0,[r4,#0x20]  ; tMotor
00000c  1c40              ADDS     r0,r0,#1
00000e  6220              STR      r0,[r4,#0x20]  ; tMotor
;;;30     
;;;31     	if (TRUE == tMotor.structMotor.MSR.bZeroCrossDetecting) {
000010  88a0              LDRH     r0,[r4,#4]  ; tMotor
000012  0780              LSLS     r0,r0,#30
000014  d548              BPL      |L20.168|
;;;32     //		iPhaseChangeTime = TIMER_GetCounter(TIMER1);
;;;33     		// Miss ZXD or ZXD success filter
;;;34     		// If continuously detected more than MIN_SUCC_ZXD_THRESHOLD ZX, OK! GOOD!!
;;;35     		if (TRUE == tMotor.structMotor.MSR.bThisPhaseDetectedZX) {
000016  88a0              LDRH     r0,[r4,#4]  ; tMotor
;;;36     			tMotor.structMotor.unMissedZXD_CNT = 0;
;;;37     
;;;38     			if (tMotor.structMotor.unSuccessZXD_CNT > MIN_SUCC_ZXD_THRESHOLD) {
;;;39     				tMotor.structMotor.MSR.bLocked = TRUE;
000018  2704              MOVS     r7,#4
00001a  0700              LSLS     r0,r0,#28             ;35
00001c  2800              CMP      r0,#0                 ;35
00001e  da0b              BGE      |L20.56|
000020  80e5              STRH     r5,[r4,#6]            ;36
000022  8920              LDRH     r0,[r4,#8]            ;38  ; tMotor
000024  2804              CMP      r0,#4                 ;38
000026  d903              BLS      |L20.48|
000028  88a0              LDRH     r0,[r4,#4]  ; tMotor
00002a  4338              ORRS     r0,r0,r7
00002c  80a0              STRH     r0,[r4,#4]
00002e  e03b              B        |L20.168|
                  |L20.48|
;;;40     			} else {
;;;41     				tMotor.structMotor.unSuccessZXD_CNT++;
000030  8920              LDRH     r0,[r4,#8]  ; tMotor
000032  1c40              ADDS     r0,r0,#1
000034  8120              STRH     r0,[r4,#8]
000036  e037              B        |L20.168|
                  |L20.56|
;;;42     			}
;;;43     		} else		// If continuously missing detected more than MAX_MISS_ZXD_THRESHOLD ZX, loss lock
;;;44     		{
;;;45     			tMotor.structMotor.unSuccessZXD_CNT = 0;
000038  8125              STRH     r5,[r4,#8]
00003a  4827              LDR      r0,|L20.216|
00003c  68c1              LDR      r1,[r0,#0xc]
;;;46     			// If ZX was not detected in last phase, unLastZXDetectedTime was also not updated
;;;47     			// Guess one value
;;;48     			unLastZXDetectedTime = GET_TIMER_DIFF((tMotor.structMotor.unActualPeriod >> 2), TIMER_GetCounter(TIMER1));
00003e  69e2              LDR      r2,[r4,#0x1c]  ; tMotor
000040  0892              LSRS     r2,r2,#2
000042  4291              CMP      r1,r2
000044  68c1              LDR      r1,[r0,#0xc]
000046  69e2              LDR      r2,[r4,#0x1c]  ; tMotor
000048  d902              BLS      |L20.80|
00004a  0892              LSRS     r2,r2,#2
00004c  1a89              SUBS     r1,r1,r2
00004e  e003              B        |L20.88|
                  |L20.80|
000050  4b22              LDR      r3,|L20.220|
000052  0892              LSRS     r2,r2,#2
000054  1a9a              SUBS     r2,r3,r2
000056  1889              ADDS     r1,r1,r2
                  |L20.88|
000058  61b1              STR      r1,[r6,#0x18]  ; unLastZXDetectedTime
;;;49     			if (tMotor.structMotor.unMissedZXD_CNT > MAX_MISS_ZXD_THRESHOLD) {
00005a  88e1              LDRH     r1,[r4,#6]  ; tMotor
00005c  290c              CMP      r1,#0xc
00005e  d920              BLS      |L20.162|
;;;50     				if (TRUE == tMotor.structMotor.MSR.bLocked) {
000060  88a1              LDRH     r1,[r4,#4]  ; tMotor
000062  0749              LSLS     r1,r1,#29
000064  d520              BPL      |L20.168|
;;;51     					tMotor.structMotor.MSR.bLocked = FALSE;
000066  88a1              LDRH     r1,[r4,#4]  ; tMotor
000068  43b9              BICS     r1,r1,r7
00006a  80a1              STRH     r1,[r4,#4]
;;;52     					MOTOR_SHUT_DOWN;
00006c  491c              LDR      r1,|L20.224|
00006e  620d              STR      r5,[r1,#0x20]
000070  4a1c              LDR      r2,|L20.228|
000072  6155              STR      r5,[r2,#0x14]
000074  4918              LDR      r1,|L20.216|
000076  3920              SUBS     r1,r1,#0x20
000078  680d              LDR      r5,[r1,#0]
00007a  038b              LSLS     r3,r1,#14
00007c  439d              BICS     r5,r5,r3
00007e  600d              STR      r5,[r1,#0]
000080  6805              LDR      r5,[r0,#0]
000082  439d              BICS     r5,r5,r3
000084  6005              STR      r5,[r0,#0]
000086  680d              LDR      r5,[r1,#0]
000088  034b              LSLS     r3,r1,#13
00008a  439d              BICS     r5,r5,r3
00008c  600d              STR      r5,[r1,#0]
00008e  6801              LDR      r1,[r0,#0]
000090  4399              BICS     r1,r1,r3
000092  6001              STR      r1,[r0,#0]
000094  20ff              MOVS     r0,#0xff
000096  63d0              STR      r0,[r2,#0x3c]
000098  6390              STR      r0,[r2,#0x38]
;;;53     					setError(ERR_INTERNAL);
00009a  2006              MOVS     r0,#6
00009c  f7fffffe          BL       setError
0000a0  e002              B        |L20.168|
                  |L20.162|
;;;54     				}
;;;55     			} else {
;;;56     				tMotor.structMotor.unMissedZXD_CNT++;
0000a2  88e0              LDRH     r0,[r4,#6]  ; tMotor
0000a4  1c40              ADDS     r0,r0,#1
0000a6  80e0              STRH     r0,[r4,#6]
                  |L20.168|
;;;57     			}
;;;58     		}
;;;59     
;;;60     	}
;;;61     
;;;62     	if (TRUE == tMotor.structMotor.MSR.bLocked) {
0000a8  88a0              LDRH     r0,[r4,#4]  ; tMotor
0000aa  0740              LSLS     r0,r0,#29
0000ac  d504              BPL      |L20.184|
;;;63     		// Set a rough next phase change time as the same with last phase
;;;64     		// After detected ZX in TIM1 interrupt, next phase change time will be re-configured
;;;65     		TIMER_SET_CMP_VALUE(TIMER0, tMotor.structMotor.unActualPeriod << 1);
0000ae  69e0              LDR      r0,[r4,#0x1c]  ; tMotor
0000b0  0041              LSLS     r1,r0,#1
0000b2  4809              LDR      r0,|L20.216|
0000b4  3820              SUBS     r0,r0,#0x20
0000b6  6041              STR      r1,[r0,#4]
                  |L20.184|
;;;66     	}
;;;67     
;;;68     	tMotor.structMotor.MSR.bThisPhaseDetectedZX = FALSE;
0000b8  88a0              LDRH     r0,[r4,#4]  ; tMotor
0000ba  2108              MOVS     r1,#8
0000bc  4388              BICS     r0,r0,r1
0000be  80a0              STRH     r0,[r4,#4]
;;;69     	// For debug
;;;70     	GPIO_TOGGLE(P50);
0000c0  4807              LDR      r0,|L20.224|
0000c2  3040              ADDS     r0,r0,#0x40
0000c4  6a01              LDR      r1,[r0,#0x20]
0000c6  2201              MOVS     r2,#1
0000c8  4051              EORS     r1,r1,r2
0000ca  6201              STR      r1,[r0,#0x20]
;;;71     }
0000cc  bdf8              POP      {r3-r7,pc}
;;;72     
                          ENDP

0000ce  0000              DCW      0x0000
                  |L20.208|
                          DCD      ||.data||
                  |L20.212|
                          DCD      ||.bss||
                  |L20.216|
                          DCD      0x40010020
                  |L20.220|
                          DCD      0x00ffffff
                  |L20.224|
                          DCD      0x50004240
                  |L20.228|
                          DCD      0x40040040

                          AREA ||i.BLDC_stopMotor||, COMGROUP=BLDC_stopMotor, CODE, READONLY, ALIGN=2

                  BLDC_stopMotor PROC
;;;155    
;;;156    __INLINE void BLDC_stopMotor(void) {
000000  b530              PUSH     {r4,r5,lr}
;;;157    	MOTOR_SHUT_DOWN;
000002  4812              LDR      r0,|L27.76|
000004  2200              MOVS     r2,#0
000006  6202              STR      r2,[r0,#0x20]
000008  4b11              LDR      r3,|L27.80|
00000a  615a              STR      r2,[r3,#0x14]
00000c  4811              LDR      r0,|L27.84|
00000e  6801              LDR      r1,[r0,#0]
000010  0384              LSLS     r4,r0,#14
000012  43a1              BICS     r1,r1,r4
000014  6001              STR      r1,[r0,#0]
000016  490f              LDR      r1,|L27.84|
000018  3120              ADDS     r1,r1,#0x20
00001a  680d              LDR      r5,[r1,#0]
00001c  43a5              BICS     r5,r5,r4
00001e  600d              STR      r5,[r1,#0]
000020  6805              LDR      r5,[r0,#0]
000022  0344              LSLS     r4,r0,#13
000024  43a5              BICS     r5,r5,r4
000026  6005              STR      r5,[r0,#0]
000028  6808              LDR      r0,[r1,#0]
00002a  43a0              BICS     r0,r0,r4
00002c  6008              STR      r0,[r1,#0]
00002e  20ff              MOVS     r0,#0xff
000030  63d8              STR      r0,[r3,#0x3c]
000032  6398              STR      r0,[r3,#0x38]
;;;158    	tMotor.structMotor.MCR.bMotorNeedToRun = FALSE;
000034  4808              LDR      r0,|L27.88|
000036  8841              LDRH     r1,[r0,#2]  ; tMotor
000038  0849              LSRS     r1,r1,#1
00003a  0049              LSLS     r1,r1,#1
00003c  8041              STRH     r1,[r0,#2]
;;;159    	tMotor.structMotor.MSR.bMotorPowerOn = FALSE;
00003e  8881              LDRH     r1,[r0,#4]  ; tMotor
000040  0849              LSRS     r1,r1,#1
000042  0049              LSLS     r1,r1,#1
000044  8081              STRH     r1,[r0,#4]
;;;160    	tMotorState = MOTOR_IDLE;
000046  4805              LDR      r0,|L27.92|
000048  7002              STRB     r2,[r0,#0]
;;;161    }
00004a  bd30              POP      {r4,r5,pc}
;;;162    
                          ENDP

                  |L27.76|
                          DCD      0x50004240
                  |L27.80|
                          DCD      0x40040040
                  |L27.84|
                          DCD      0x40010000
                  |L27.88|
                          DCD      ||.bss||
                  |L27.92|
                          DCD      ||.data||

                          AREA ||i.setPhaseManually||, COMGROUP=setPhaseManually, CODE, READONLY, ALIGN=2

                  setPhaseManually PROC
;;;162    
;;;163    __INLINE void setPhaseManually(uint16_t iPWMDuty, uint8_t iPhase) {
000000  4a09              LDR      r2,|L34.40|
;;;164    	MOTOR_SET_DUTY(iPWMDuty);
000002  6290              STR      r0,[r2,#0x28]
000004  6310              STR      r0,[r2,#0x30]
000006  6390              STR      r0,[r2,#0x38]
;;;165    	PWM->PHCHG = GET_PHASE_VALUE(iPhase);
000008  4808              LDR      r0,|L34.44|
00000a  8840              LDRH     r0,[r0,#2]  ; tMotor
00000c  0782              LSLS     r2,r0,#30
00000e  0088              LSLS     r0,r1,#2
000010  2a00              CMP      r2,#0
000012  db01              BLT      |L34.24|
000014  4906              LDR      r1,|L34.48|
000016  e001              B        |L34.28|
                  |L34.24|
000018  4905              LDR      r1,|L34.48|
00001a  3118              ADDS     r1,r1,#0x18
                  |L34.28|
00001c  5808              LDR      r0,[r1,r0]
00001e  4902              LDR      r1,|L34.40|
000020  3140              ADDS     r1,r1,#0x40
000022  6388              STR      r0,[r1,#0x38]
;;;166    }
000024  4770              BX       lr
;;;167    
                          ENDP

000026  0000              DCW      0x0000
                  |L34.40|
                          DCD      0x40040000
                  |L34.44|
                          DCD      ||.bss||
                  |L34.48|
                          DCD      ||.constdata||+0x4

                          AREA ||i.BLDCRampUp_Manager||, COMGROUP=BLDCRampUp_Manager, CODE, READONLY, ALIGN=2

                  BLDCRampUp_Manager PROC
;;;183    
;;;184    __INLINE void BLDCRampUp_Manager(void) {
000000  b570              PUSH     {r4-r6,lr}
;;;185    	if (SET == FLAG_PHASE_CHANGED) {
000002  4d1e              LDR      r5,|L41.124|
000004  79a8              LDRB     r0,[r5,#6]  ; FLAG_PHASE_CHANGED
000006  2801              CMP      r0,#1
000008  d136              BNE      |L41.120|
;;;186    		PhaseChangedRoutine();
00000a  f7fffffe          BL       PhaseChangedRoutine
;;;187    		if (unPhaseChangeCNT_AtCurrentPeriod > CHANGE_DT_PR_AFTER_PHASE_CHANGED_NUM) {
00000e  78e8              LDRB     r0,[r5,#3]  ; unPhaseChangeCNT_AtCurrentPeriod
;;;188    			unPhaseChangeCNT_AtCurrentPeriod = 0;
;;;189    			// Change duty and period 
;;;190    //			MOTOR_RAMPUP_DT_INCR(tMotor.structMotor.ACT_DUTY);			
;;;191    			MOTOR_RAMPUP_PR_DCR(tMotor.structMotor.unActualPeriod);
000010  4c1b              LDR      r4,|L41.128|
000012  2809              CMP      r0,#9                 ;187
000014  d916              BLS      |L41.68|
000016  2000              MOVS     r0,#0                 ;188
000018  70e8              STRB     r0,[r5,#3]            ;188
00001a  69e0              LDR      r0,[r4,#0x1c]  ; tMotor
00001c  4e19              LDR      r6,|L41.132|
00001e  42b0              CMP      r0,r6
000020  69e0              LDR      r0,[r4,#0x1c]  ; tMotor
000022  d308              BCC      |L41.54|
000024  f7fffffe          BL       __aeabi_ui2d
000028  4a17              LDR      r2,|L41.136|
00002a  4b18              LDR      r3,|L41.140|
00002c  f7fffffe          BL       __aeabi_dmul
000030  f7fffffe          BL       __aeabi_d2uiz
000034  b280              UXTH     r0,r0
                  |L41.54|
000036  61e0              STR      r0,[r4,#0x1c]  ; tMotor
;;;192    			if (tMotor.structMotor.unActualPeriod <= MOTOR_RAMPUP_PR_MIN) {
000038  69e0              LDR      r0,[r4,#0x1c]  ; tMotor
00003a  42b0              CMP      r0,r6
00003c  d802              BHI      |L41.68|
;;;193    				unPeriodChangeCNT_AfterPR_ReachMini++;
00003e  8928              LDRH     r0,[r5,#8]  ; unPeriodChangeCNT_AfterPR_ReachMini
000040  1c40              ADDS     r0,r0,#1
000042  8128              STRH     r0,[r5,#8]
                  |L41.68|
;;;194    			}
;;;195    		}
;;;196    		unPhaseChangeCNT_AtCurrentPeriod++;
000044  78e8              LDRB     r0,[r5,#3]  ; unPhaseChangeCNT_AtCurrentPeriod
000046  1c40              ADDS     r0,r0,#1
000048  70e8              STRB     r0,[r5,#3]
;;;197    //		MOTOR_SET_DUTY(tMotor.structMotor.ACT_DUTY);
;;;198    		TIMER_SET_CMP_VALUE(TIMER0, tMotor.structMotor.unActualPeriod);
00004a  69e0              LDR      r0,[r4,#0x1c]  ; tMotor
00004c  4910              LDR      r1,|L41.144|
00004e  6048              STR      r0,[r1,#4]
;;;199    		PHASE_INCREASE(unCurrentPhase);
000050  7968              LDRB     r0,[r5,#5]  ; unCurrentPhase
000052  2805              CMP      r0,#5
000054  d201              BCS      |L41.90|
000056  1c40              ADDS     r0,r0,#1
000058  e000              B        |L41.92|
                  |L41.90|
00005a  2000              MOVS     r0,#0
                  |L41.92|
00005c  b2c0              UXTB     r0,r0
00005e  7168              STRB     r0,[r5,#5]
;;;200    		// Modify PWM->PHCHGNXT at last because I don't know how long needed to reload PHCH with PHCHNEXT after TIM0 time-out
;;;201    		PWM->PHCHGNXT = GET_PHASE_VALUE(unCurrentPhase);
000060  8861              LDRH     r1,[r4,#2]  ; tMotor
000062  0789              LSLS     r1,r1,#30
000064  d402              BMI      |L41.108|
000066  0080              LSLS     r0,r0,#2
000068  490a              LDR      r1,|L41.148|
00006a  e002              B        |L41.114|
                  |L41.108|
00006c  4909              LDR      r1,|L41.148|
00006e  0080              LSLS     r0,r0,#2
000070  3118              ADDS     r1,r1,#0x18
                  |L41.114|
000072  5808              LDR      r0,[r1,r0]
000074  4908              LDR      r1,|L41.152|
000076  63c8              STR      r0,[r1,#0x3c]
                  |L41.120|
;;;202    	}
;;;203    }
000078  bd70              POP      {r4-r6,pc}
;;;204    
                          ENDP

00007a  0000              DCW      0x0000
                  |L41.124|
                          DCD      ||.data||
                  |L41.128|
                          DCD      ||.bss||
                  |L41.132|
                          DCD      0x000003e7
                  |L41.136|
                          DCD      0xf5c28f5c
                  |L41.140|
                          DCD      0x3fef5c28
                  |L41.144|
                          DCD      0x40010000
                  |L41.148|
                          DCD      ||.constdata||+0x4
                  |L41.152|
                          DCD      0x40040040

                          AREA ||.data__ZZ23phaseDurationProtectionE14unCurrentPHCHG||, COMGROUP=_ZZ23phaseDurationProtectionE14unCurrentPHCHG, DATA, ALIGN=2

                  _ZZ23phaseDurationProtectionE14unCurrentPHCHG
                          DCD      0x00000000

                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d200              BCS      |L50.16|
00000e  461d              MOV      r5,r3
                  |L50.16|
000010  5d63              LDRB     r3,[r4,r5]
000012  005b              LSLS     r3,r3,#1
000014  18e3              ADDS     r3,r4,r3
000016  bc30              POP      {r4,r5}
000018  4718              BX       r3
                          ENDP


;*** Start embedded assembler ***

#line 1 "User\\BLDCSensorLess.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_BLDCSensorLess_c_0df2b5b8____REV16|
#line 464 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.1.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___16_BLDCSensorLess_c_0df2b5b8____REV16| PROC
#line 465

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_BLDCSensorLess_c_0df2b5b8____REVSH|
#line 479
|__asm___16_BLDCSensorLess_c_0df2b5b8____REVSH| PROC
#line 480

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
