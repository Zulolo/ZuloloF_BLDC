; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\bldcsensorless.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\bldcsensorless.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\Mini51Series\Include -I..\..\..\Library\StdDriver\inc -I.\StdDriver\inc -I.\CMSIS -IG:\Geek\Projects\Zulolo_F\Force\Code\Zulolo_F_Force\RTE -ID:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.0.2\Device\Mini51\Include -ID:\Keil_v5\ARM\CMSIS\Include -I\ -D__MICROLIB -D__UVISION_VERSION=518 --omf_browse=.\obj\bldcsensorless.crf User\BLDCSensorLess.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  checkMotor PROC
;;;90     
;;;91     void checkMotor(void)
000000  4770              BX       lr
;;;92     {
;;;93     	// Battery check
;;;94     
;;;95     	// LED check
;;;96     
;;;97     	// MOSFET check
;;;98     }
;;;99     
                          ENDP

                  canMotorContinueRunning PROC
;;;102       1-65534: phase time */
;;;103    uint16_t canMotorContinueRunning(void)
000002  2000              MOVS     r0,#0
;;;104    {
;;;105    	uint16_t iPhaseDuration = 0;
;;;106    	static uint32_t iStateEnterTime;
;;;107    // Later implement this when motor can rotate
;;;108    // Then stop it while rotating to measure the waveform
;;;109    // Manually rotate it is too slow 
;;;110    	return 0;
;;;111    
;;;112    	if ((uint32_t)(iSystemTick - iRotateDetectStartTime) > MAX_ALREADY_ROTATING_DETECT_TIME)
;;;113    	{
;;;114    		return 0;
;;;115    	}
;;;116    	switch (enumRotateDetectState)
;;;117    	{
;;;118    	case DETECT_START: 
;;;119    		iStateEnterTime = iSystemTick;
;;;120    		enumRotateDetectState = DETECT_PHASE_1_P;
;;;121    		break;
;;;122    
;;;123    	case DETECT_PHASE_1_P:
;;;124    		if ((uint32_t)(iSystemTick - iStateEnterTime) > MAX_ROTATING_DETECT_PHASE_TIME)
;;;125    		{
;;;126    			return (uint16_t)0;
;;;127    		}
;;;128    		else
;;;129    		{
;;;130    
;;;131    		}
;;;132    		break; 
;;;133    
;;;134    	case DETECT_PHASE_1_A:
;;;135    
;;;136    		break;
;;;137    
;;;138    	case DETECT_PHASE_2_P:
;;;139    
;;;140    		break;
;;;141    
;;;142    	case DETECT_PHASE_2_A:
;;;143    
;;;144    		break;
;;;145    
;;;146    	case DETECT_PHASE_3_P:
;;;147    
;;;148    		break;
;;;149    
;;;150    	case DETECT_PHASE_3_A:
;;;151    
;;;152    		break;
;;;153    
;;;154    	default:
;;;155    		break;
;;;156    	}
;;;157    
;;;158    	return iPhaseDuration;
;;;159    }
000004  4770              BX       lr
;;;160    
                          ENDP

                  BLDCSpeedManager PROC
;;;161    // Mainly PWM duty increase/decrease
;;;162    void BLDCSpeedManager(void)
000006  b510              PUSH     {r4,lr}
;;;163    {
;;;164    	if (SET == FLAG_PHASE_CHANGED)
000008  4cb4              LDR      r4,|L1.732|
00000a  79a0              LDRB     r0,[r4,#6]  ; FLAG_PHASE_CHANGED
00000c  2801              CMP      r0,#1
00000e  d133              BNE      |L1.120|
;;;165    	{
;;;166    		PhaseChangedRoutine();
000010  f7fffffe          BL       PhaseChangedRoutine
;;;167    
;;;168    		if (mMotor.structMotor.ACT_DUTY != mMotor.structMotor.TGT_DUTY)
000014  49b2              LDR      r1,|L1.736|
000016  8988              LDRH     r0,[r1,#0xc]  ; mMotor
000018  894a              LDRH     r2,[r1,#0xa]  ; mMotor
00001a  4290              CMP      r0,r2
00001c  d017              BEQ      |L1.78|
;;;169    		{
;;;170    //				mMotor.structMotor.ACT_DUTY = mMotor.structMotor.TGT_DUTY;
;;;171    				// Change PWM duty after each x phase change
;;;172    			if (iPhaseChangeCNT4Duty > CHANGE_DUTY_CNT_THR)
00001e  7920              LDRB     r0,[r4,#4]  ; iPhaseChangeCNT4Duty
000020  2805              CMP      r0,#5
000022  d911              BLS      |L1.72|
;;;173    			{
;;;174    				iPhaseChangeCNT4Duty = 0;
000024  2000              MOVS     r0,#0
000026  7120              STRB     r0,[r4,#4]
;;;175    				if (mMotor.structMotor.ACT_DUTY < mMotor.structMotor.TGT_DUTY)
000028  8988              LDRH     r0,[r1,#0xc]  ; mMotor
00002a  894a              LDRH     r2,[r1,#0xa]  ; mMotor
00002c  4290              CMP      r0,r2
;;;176    				{
;;;177    					mMotor.structMotor.ACT_DUTY++;
;;;178    				}
;;;179    				else
;;;180    				{
;;;181    					mMotor.structMotor.ACT_DUTY--;
00002e  8988              LDRH     r0,[r1,#0xc]  ; mMotor
000030  d201              BCS      |L1.54|
000032  1c40              ADDS     r0,r0,#1              ;175
000034  e000              B        |L1.56|
                  |L1.54|
000036  1e40              SUBS     r0,r0,#1              ;177
                  |L1.56|
000038  8188              STRH     r0,[r1,#0xc]
;;;182    				}
;;;183    				MOTOR_SET_DUTY(mMotor.structMotor.ACT_DUTY);
00003a  898a              LDRH     r2,[r1,#0xc]  ; mMotor
00003c  48a9              LDR      r0,|L1.740|
00003e  6282              STR      r2,[r0,#0x28]
000040  898a              LDRH     r2,[r1,#0xc]  ; mMotor
000042  6302              STR      r2,[r0,#0x30]
000044  898a              LDRH     r2,[r1,#0xc]  ; mMotor
000046  6382              STR      r2,[r0,#0x38]
                  |L1.72|
;;;184    			}
;;;185    			iPhaseChangeCNT4Duty++;
000048  7920              LDRB     r0,[r4,#4]  ; iPhaseChangeCNT4Duty
00004a  1c40              ADDS     r0,r0,#1
00004c  7120              STRB     r0,[r4,#4]
                  |L1.78|
;;;186    		}
;;;187    		
;;;188    		PHASE_INCREASE(iCurrentPhase);
00004e  7960              LDRB     r0,[r4,#5]  ; iCurrentPhase
000050  2805              CMP      r0,#5
000052  d201              BCS      |L1.88|
000054  1c40              ADDS     r0,r0,#1
000056  e000              B        |L1.90|
                  |L1.88|
000058  2000              MOVS     r0,#0
                  |L1.90|
00005a  b2c0              UXTB     r0,r0
00005c  7160              STRB     r0,[r4,#5]
;;;189    		// Modify PWM->PHCHGNXT at last because I don't know how long needed to reload PHCH with PHCHNEXT after TIM0 time-out
;;;190    		PWM->PHCHGNXT = GET_PHASE_VALUE(iCurrentPhase);
00005e  8809              LDRH     r1,[r1,#0]  ; mMotor
000060  0789              LSLS     r1,r1,#30
000062  d402              BMI      |L1.106|
000064  0080              LSLS     r0,r0,#2
000066  49a0              LDR      r1,|L1.744|
000068  e002              B        |L1.112|
                  |L1.106|
00006a  499f              LDR      r1,|L1.744|
00006c  0080              LSLS     r0,r0,#2
00006e  3118              ADDS     r1,r1,#0x18
                  |L1.112|
000070  5808              LDR      r0,[r1,r0]
000072  499c              LDR      r1,|L1.740|
000074  3140              ADDS     r1,r1,#0x40
000076  63c8              STR      r0,[r1,#0x3c]
                  |L1.120|
;;;191    	}
;;;192    }
000078  bd10              POP      {r4,pc}
;;;193    //
                          ENDP

                  BLDCLocatingManager PROC
;;;216    
;;;217    ENUM_STATUS BLDCLocatingManager(void)
00007a  b5f8              PUSH     {r3-r7,lr}
;;;218    {
;;;219    	if ((uint32_t)(iSystemTick - iLastPhaseChangeTime) > mMotor.structMotor.LCT_PERIOD)
00007c  489b              LDR      r0,|L1.748|
00007e  6800              LDR      r0,[r0,#0]  ; iSystemTick
000080  4c96              LDR      r4,|L1.732|
000082  4b97              LDR      r3,|L1.736|
000084  69a1              LDR      r1,[r4,#0x18]  ; iLastPhaseChangeTime
000086  1a40              SUBS     r0,r0,r1
000088  89d9              LDRH     r1,[r3,#0xe]  ; mMotor
00008a  4288              CMP      r0,r1
00008c  d90b              BLS      |L1.166|
;;;220    	{
;;;221    		if (iLocateIndex < (sizeof(iLocatePhaseSequencyTable)/sizeof(uint8_t)))
00008e  78a0              LDRB     r0,[r4,#2]  ; iLocateIndex
000090  2804              CMP      r0,#4
000092  d20a              BCS      |L1.170|
;;;222    		{
;;;223    			//iLastPhaseChangeTime = iSystemTick; 
;;;224    			setPhaseManually(mMotor.structMotor.LCT_DUTY, iLocatePhaseSequencyTable[iLocateIndex]);
000094  4994              LDR      r1,|L1.744|
000096  1f09              SUBS     r1,r1,#4
000098  5c09              LDRB     r1,[r1,r0]
00009a  88d8              LDRH     r0,[r3,#6]  ; mMotor
00009c  f7fffffe          BL       setPhaseManually
;;;225    			iLocateIndex++;
0000a0  78a0              LDRB     r0,[r4,#2]  ; iLocateIndex
0000a2  1c40              ADDS     r0,r0,#1
0000a4  70a0              STRB     r0,[r4,#2]
                  |L1.166|
;;;226    		}
;;;227    		else
;;;228    		{
;;;229    			MOTOR_SHUT_DOWN;
;;;230    			mMotor.structMotor.MSR.MotorPowerOn = FALSE;
;;;231    			iCurrentPhase = iLocatePhaseSequencyTable[iLocateIndex - 1];
;;;232    			return STATUS_FINISHED;
;;;233    		}
;;;234    	}
;;;235    	return STATUS_WORKING;
0000a6  4892              LDR      r0,|L1.752|
;;;236    }
0000a8  bdf8              POP      {r3-r7,pc}
                  |L1.170|
0000aa  4a92              LDR      r2,|L1.756|
0000ac  2100              MOVS     r1,#0                 ;229
0000ae  6211              STR      r1,[r2,#0x20]         ;229
0000b0  4d8c              LDR      r5,|L1.740|
0000b2  3540              ADDS     r5,r5,#0x40           ;229
0000b4  6169              STR      r1,[r5,#0x14]         ;229
0000b6  4990              LDR      r1,|L1.760|
0000b8  680a              LDR      r2,[r1,#0]            ;229
0000ba  038e              LSLS     r6,r1,#14             ;229
0000bc  43b2              BICS     r2,r2,r6              ;229
0000be  600a              STR      r2,[r1,#0]            ;229
0000c0  4a8d              LDR      r2,|L1.760|
0000c2  3220              ADDS     r2,r2,#0x20           ;229
0000c4  6817              LDR      r7,[r2,#0]            ;229
0000c6  43b7              BICS     r7,r7,r6              ;229
0000c8  6017              STR      r7,[r2,#0]            ;229
0000ca  680f              LDR      r7,[r1,#0]            ;229
0000cc  034e              LSLS     r6,r1,#13             ;229
0000ce  43b7              BICS     r7,r7,r6              ;229
0000d0  600f              STR      r7,[r1,#0]            ;229
0000d2  6811              LDR      r1,[r2,#0]            ;229
0000d4  43b1              BICS     r1,r1,r6              ;229
0000d6  6011              STR      r1,[r2,#0]            ;229
0000d8  21ff              MOVS     r1,#0xff              ;229
0000da  63e9              STR      r1,[r5,#0x3c]         ;229
0000dc  63a9              STR      r1,[r5,#0x38]         ;229
0000de  8859              LDRH     r1,[r3,#2]            ;230  ; mMotor
0000e0  0849              LSRS     r1,r1,#1              ;230
0000e2  0049              LSLS     r1,r1,#1              ;230
0000e4  8059              STRH     r1,[r3,#2]            ;230
0000e6  4980              LDR      r1,|L1.744|
0000e8  1f09              SUBS     r1,r1,#4              ;231
0000ea  1808              ADDS     r0,r1,r0              ;231
0000ec  3820              SUBS     r0,r0,#0x20           ;231
0000ee  7fc0              LDRB     r0,[r0,#0x1f]         ;231
0000f0  7160              STRB     r0,[r4,#5]            ;231
0000f2  2001              MOVS     r0,#1                 ;232
0000f4  bdf8              POP      {r3-r7,pc}
;;;237    
                          ENDP

                  BLDCSensorLessManager PROC
;;;263    // Take charge of all Motot control
;;;264    void BLDCSensorLessManager(void)
0000f6  b5f8              PUSH     {r3-r7,lr}
;;;265    {
;;;266    	uint16_t iMotorAlreadyRotatingPhaseTime;
;;;267    	static uint32_t iEnterTimeBeforeWait;
;;;268    
;;;269    	// Duty too big protection
;;;270    	if ((mMotor.structMotor.ACT_DUTY > MAX_MOTOR_PWR_DUTY) || (PWM->CMR[1] > MAX_MOTOR_PWR_DUTY))
0000f8  4c79              LDR      r4,|L1.736|
0000fa  89a1              LDRH     r1,[r4,#0xc]  ; mMotor
0000fc  487f              LDR      r0,|L1.764|
0000fe  4281              CMP      r1,r0
000100  d803              BHI      |L1.266|
000102  4978              LDR      r1,|L1.740|
000104  6a89              LDR      r1,[r1,#0x28]
000106  4281              CMP      r1,r0
000108  d904              BLS      |L1.276|
                  |L1.266|
;;;271    	{
;;;272    		stopMotor();
00010a  f7fffffe          BL       stopMotor
;;;273    		setError(ERR_INTERNAL);
00010e  2005              MOVS     r0,#5
000110  f7fffffe          BL       setError
                  |L1.276|
;;;274    	}
;;;275    
;;;276    	// Single phase duration too long protection 
;;;277    	if (TRUE == mMotor.structMotor.MSR.MotorPowerOn)
000114  8860              LDRH     r0,[r4,#2]  ; mMotor
;;;278    	{
;;;279    		if (iCurrentPHCHG != PWM->PHCHG)
;;;280    		{
;;;281    			iCurrentPHCHG = PWM->PHCHG;
;;;282    			iLastPhaseChangeTime = iSystemTick;
000116  4e75              LDR      r6,|L1.748|
000118  4d70              LDR      r5,|L1.732|
00011a  07c0              LSLS     r0,r0,#31             ;277
00011c  d014              BEQ      |L1.328|
00011e  4871              LDR      r0,|L1.740|
000120  3040              ADDS     r0,r0,#0x40           ;279
000122  6b81              LDR      r1,[r0,#0x38]         ;279
000124  696a              LDR      r2,[r5,#0x14]         ;279  ; iCurrentPHCHG
000126  4291              CMP      r1,r2                 ;279
000128  d004              BEQ      |L1.308|
00012a  6b80              LDR      r0,[r0,#0x38]         ;281
00012c  6168              STR      r0,[r5,#0x14]  ; iCurrentPHCHG
00012e  6830              LDR      r0,[r6,#0]  ; iSystemTick
000130  61a8              STR      r0,[r5,#0x18]  ; iLastPhaseChangeTime
000132  e009              B        |L1.328|
                  |L1.308|
;;;283    		}
;;;284    		else
;;;285    		{
;;;286    			if ((uint32_t)(iSystemTick - iLastPhaseChangeTime) > MAX_SINGLE_PHASE_DURATION) 
000134  6830              LDR      r0,[r6,#0]  ; iSystemTick
000136  69a9              LDR      r1,[r5,#0x18]  ; iLastPhaseChangeTime
000138  1a40              SUBS     r0,r0,r1
00013a  2850              CMP      r0,#0x50
00013c  d904              BLS      |L1.328|
;;;287    			{
;;;288    				stopMotor();
00013e  f7fffffe          BL       stopMotor
;;;289    				setError(ERR_INTERNAL);
000142  2005              MOVS     r0,#5
000144  f7fffffe          BL       setError
                  |L1.328|
;;;290    			}
;;;291    		}
;;;292    	}
;;;293    
;;;294    	switch (enumMotorState)
000148  782a              LDRB     r2,[r5,#0]  ; enumMotorState
;;;295    	{
;;;296    	case MOTOR_IDLE:
;;;297    		if (mMotor.structMotor.MCR.MotorNeedToRun && NO_MOTOR_EEROR)
00014a  486d              LDR      r0,|L1.768|
00014c  2700              MOVS     r7,#0
00014e  2101              MOVS     r1,#1                 ;294
000150  0013              MOVS     r3,r2                 ;294
000152  f7fffffe          BL       __ARM_common_switch8
000156  0705              DCB      0x07,0x05
000158  10313f81          DCB      0x10,0x31,0x3f,0x81
00015c  a2b90f00          DCB      0xa2,0xb9,0x0f,0x00
000160  8822              LDRH     r2,[r4,#0]  ; mMotor
000162  07d2              LSLS     r2,r2,#31
000164  d006              BEQ      |L1.372|
000166  6800              LDR      r0,[r0,#0]  ; iErrorMaster
000168  0840              LSRS     r0,r0,#1
00016a  d103              BNE      |L1.372|
;;;298    		{
;;;299    			iRotateDetectStartTime = iSystemTick;
00016c  6830              LDR      r0,[r6,#0]  ; iSystemTick
;;;300    			enumRotateDetectState = DETECT_START;
00016e  61e8              STR      r0,[r5,#0x1c]  ; iRotateDetectStartTime
000170  706f              STRB     r7,[r5,#1]
;;;301    			enumMotorState = MOTOR_START;
000172  7029              STRB     r1,[r5,#0]
                  |L1.372|
;;;302    		}
;;;303    		break;
;;;304    		
;;;305    	case MOTOR_START:
;;;306    		if (mMotor.structMotor.MCR.MotorNeedToRun && NO_MOTOR_EEROR)
;;;307    		{
;;;308    			// Later implement this when motor can rotate
;;;309    			// Then stop it while rotating to measure the waveform
;;;310    			// Manually rotate it is too slow 
;;;311    			iMotorAlreadyRotatingPhaseTime = canMotorContinueRunning();
;;;312    			if (iMotorAlreadyRotatingPhaseTime != ALREADY_ROTATING_DETECTING)
;;;313    			{
;;;314    				if (iMotorAlreadyRotatingPhaseTime)
;;;315    				{
;;;316    					// 1 to 65534
;;;317    					enumMotorState = MOTOR_LOCKED;
;;;318    				}
;;;319    				else
;;;320    				{
;;;321    					// When back to Idle state the motor was already shut down
;;;322    					// MOTOR_SHUT_DOWN;
;;;323    					iCurrentPhase = 0;
;;;324    					iLocateIndex = 0;
;;;325    					mMotor.structMotor.MSR.MissedZXD_CNT = 0;
;;;326    					iLastPhaseChangeTime = iSystemTick;
;;;327    					mMotor.structMotor.MSR.MotorPowerOn = TRUE;
;;;328    					// Clear start detect zero cross flag
;;;329    					mMotor.structMotor.MSR.ZeroCrossDetecting = FALSE;
;;;330    					mMotor.structMotor.MSR.Locked = FALSE;
;;;331    					//setPhaseManually(mMotor.structMotor.LCT_DUTY, iCurrentPhase);
;;;332    					BRG_ENABLE;
;;;333    					enumMotorState = MOTOR_LOCATE;
;;;334    				}
;;;335    			}
;;;336    		}
;;;337    		else
;;;338    		{
;;;339    			stopMotor();
;;;340    		}
;;;341    		break;
;;;342    
;;;343    	case MOTOR_LOCATE:
;;;344    		if (mMotor.structMotor.MCR.MotorNeedToRun && NO_MOTOR_EEROR)
;;;345    		{
;;;346    			if (BLDCLocatingManager() == STATUS_FINISHED)
;;;347    			{
;;;348    				iEnterTimeBeforeWait = iSystemTick;
;;;349    				enumMotorState = MOTOR_WAIT_AFTER_LOCATE;
;;;350    			}
;;;351    		}
;;;352    		else
;;;353    		{
;;;354    			stopMotor();
;;;355    		}
;;;356    		break;
;;;357    
;;;358    	case MOTOR_WAIT_AFTER_LOCATE:
;;;359    		if (mMotor.structMotor.MCR.MotorNeedToRun && NO_MOTOR_EEROR)
;;;360    		{
;;;361    			if ((uint32_t)(iSystemTick - iEnterTimeBeforeWait) >= WAIT_AFTER_LOCATE_TIME)
;;;362    			{
;;;363    				mMotor.structMotor.ACT_DUTY = mMotor.structMotor.RU_DUTY;
;;;364    				mMotor.structMotor.ACT_PERIOD = mMotor.structMotor.RU_PERIOD;
;;;365    				mMotor.structMotor.MSR.MotorPowerOn = TRUE;
;;;366    				PHASE_INCREASE(iCurrentPhase);
;;;367    				setPhaseManually(mMotor.structMotor.ACT_DUTY, iCurrentPhase);
;;;368    				BRG_ENABLE;
;;;369    				// Set timer 0 valure, use timer 0 to change phase automatically
;;;370    				// ************************************************************************
;;;371    				// ----==== From here current iCurrentPhase is actually next phase ====----
;;;372    				// What to get real current phase value? Read PWM->PHCHG.
;;;373    				// ************************************************************************
;;;374    				PHASE_INCREASE(iCurrentPhase);
;;;375    				PWM->PHCHGNXT = GET_PHASE_VALUE(iCurrentPhase);
;;;376    				// !!!! Need to make sure CPU run to here every min mMotor.structMotor.ACT_PERIOD time !!!
;;;377    				// !!!! If not , timer counter may already passed mMotor.structMotor.ACT_PERIOD, !!!!
;;;378    				// !!!! then need to count to 2^24, go back to 0 and triger interrupt when reach ACT_PERIOD !!!!
;;;379    				TIMER_SET_CMP_VALUE(TIMER0, mMotor.structMotor.ACT_PERIOD);
;;;380    				TIMER_Start(TIMER0);	// Once started, running and interrupting until Motor stop
;;;381    				TIMER_EnableInt(TIMER0);
;;;382    				iRampUpPeriodMiniCNT = 0;
;;;383    				iPhaseChangeCNT4Duty = 0;
;;;384    				iPhaseChangeCNT4Period = 0;
;;;385    				enumMotorState = MOTOR_RAMPUP_WO_ZXD;
;;;386    			}
;;;387    		}
;;;388    		else
;;;389    		{
;;;390    			stopMotor();
;;;391    		}
;;;392    		break;
;;;393    
;;;394    	case MOTOR_RAMPUP_WO_ZXD:	// without zero cross detection
;;;395    		if (mMotor.structMotor.MCR.MotorNeedToRun && NO_MOTOR_EEROR)
;;;396    		{
;;;397    			BLDCRampUp_Manager();
;;;398    			if (mMotor.structMotor.ACT_PERIOD <= MOTOR_START_ZXD_SPEED)	//(iRampUpPeriodMiniCNT > MOTOR_START_ZXD_MINROT_CNT)  //
;;;399    			{
;;;400    				mMotor.structMotor.MSR.ThisPhaseDetectedZX = FALSE;
;;;401    				mMotor.structMotor.MSR.ZeroCrossDetecting = TRUE;
;;;402    				// Speed is enough for zero cross detecting
;;;403    				// Prepare everything
;;;404    				// T0 used to change phase automatically -- already configured
;;;405    				// T1 used to filter ZX
;;;406    				//ACMP->CMPCR[0]
;;;407    
;;;408    //				TIMER_SET_CMP_VALUE(TIMER1, GET_TIM1_CMP_VALUE(TIMER1->TDR + AVOID_ZXD_AFTER_PHCHG));
;;;409    //				FLAG_TIM1_USEAGE = ENUM_TIM1_AVOID_ZXD;
;;;410    				ACMP0_ENABLE;
;;;411    				TIMER_Start(TIMER1);	// Once started, running until Motor stop
;;;412    //				TIMER_EnableInt(TIMER1);
;;;413    				// Suppose last ZX detected time 
;;;414    //				iLastZXDetectedTime = MINI51_TIM_CNT_MAX - mMotor.structMotor.ACT_PERIOD / 2;
;;;415    				enumMotorState = MOTOR_RAMPUP_W_ZXD;
;;;416    			}
;;;417    		}
;;;418    		else
;;;419    		{
;;;420    			stopMotor();
;;;421    		}
;;;422    		break;
;;;423    
;;;424    	case MOTOR_RAMPUP_W_ZXD:	// with zero cross detection
;;;425    		if (mMotor.structMotor.MCR.MotorNeedToRun && NO_MOTOR_EEROR)
;;;426    		{
;;;427    			if (TRUE == mMotor.structMotor.MSR.Locked)
;;;428    			{
;;;429    				// Finally, everything was prepared:
;;;430    				// T0 used to change phase automatically
;;;431    				// T1 used to filter ZX
;;;432    				enumMotorState = MOTOR_LOCKED;
;;;433    			}
;;;434    			else
;;;435    			{
;;;436    				if (iRampUpPeriodMiniCNT < RAMP_UP_MIN_PERIOD_NUM_THRS)
;;;437    				{
;;;438    					BLDCRampUp_Manager(); 
;;;439    				}
;;;440    				else
;;;441    				{
;;;442    					setError(ERR_RAMPUP_FAIL);
;;;443    				}
;;;444    			}
;;;445    		}
;;;446    		else
;;;447    		{
;;;448    			stopMotor();
;;;449    		}
;;;450    		break;
;;;451    
;;;452    	case MOTOR_LOCKED:
;;;453    		if (mMotor.structMotor.MCR.MotorNeedToRun && NO_MOTOR_EEROR)
;;;454    		{
;;;455    			BLDCSpeedManager();	// Mainly PWM duty increase/decrease
;;;456    		}
;;;457    		else
;;;458    		{
;;;459    			stopMotor();
;;;460    		}
;;;461    		break;
;;;462    
;;;463    	default:
;;;464    		break;
;;;465    	}
;;;466    }
000174  bdf8              POP      {r3-r7,pc}
000176  8822              LDRH     r2,[r4,#0]            ;306  ; mMotor
000178  07d2              LSLS     r2,r2,#31             ;306
00017a  d01a              BEQ      |L1.434|
00017c  6800              LDR      r0,[r0,#0]            ;306  ; iErrorMaster
00017e  0840              LSRS     r0,r0,#1              ;306
000180  d117              BNE      |L1.434|
000182  716f              STRB     r7,[r5,#5]            ;323
000184  70af              STRB     r7,[r5,#2]            ;324
000186  8860              LDRH     r0,[r4,#2]            ;325  ; mMotor
000188  22ff              MOVS     r2,#0xff              ;325
00018a  0112              LSLS     r2,r2,#4              ;325
00018c  4390              BICS     r0,r0,r2              ;325
00018e  8060              STRH     r0,[r4,#2]            ;325
000190  6830              LDR      r0,[r6,#0]            ;326  ; iSystemTick
000192  61a8              STR      r0,[r5,#0x18]         ;327  ; iLastPhaseChangeTime
000194  8860              LDRH     r0,[r4,#2]            ;327  ; mMotor
000196  4308              ORRS     r0,r0,r1              ;327
000198  8060              STRH     r0,[r4,#2]            ;327
00019a  8860              LDRH     r0,[r4,#2]            ;329  ; mMotor
00019c  2302              MOVS     r3,#2                 ;329
00019e  4398              BICS     r0,r0,r3              ;329
0001a0  8060              STRH     r0,[r4,#2]            ;329
0001a2  8860              LDRH     r0,[r4,#2]            ;330  ; mMotor
0001a4  2204              MOVS     r2,#4                 ;330
0001a6  4390              BICS     r0,r0,r2              ;330
0001a8  8060              STRH     r0,[r4,#2]            ;330
0001aa  4852              LDR      r0,|L1.756|
0001ac  6201              STR      r1,[r0,#0x20]         ;332
0001ae  702b              STRB     r3,[r5,#0]            ;333
0001b0  bdf8              POP      {r3-r7,pc}
                  |L1.434|
0001b2  f7fffffe          BL       stopMotor
                  |L1.438|
0001b6  bdf8              POP      {r3-r7,pc}
0001b8  8821              LDRH     r1,[r4,#0]            ;344  ; mMotor
0001ba  07c9              LSLS     r1,r1,#31             ;344
0001bc  d0f9              BEQ      |L1.434|
0001be  6800              LDR      r0,[r0,#0]            ;344  ; iErrorMaster
0001c0  0840              LSRS     r0,r0,#1              ;344
0001c2  d1f6              BNE      |L1.434|
0001c4  f7fffffe          BL       BLDCLocatingManager
0001c8  2801              CMP      r0,#1                 ;346
0001ca  d1f4              BNE      |L1.438|
0001cc  6830              LDR      r0,[r6,#0]            ;348  ; iSystemTick
0001ce  6128              STR      r0,[r5,#0x10]         ;349  ; iEnterTimeBeforeWait
0001d0  2003              MOVS     r0,#3                 ;349
0001d2  e03f              B        |L1.596|
0001d4  8822              LDRH     r2,[r4,#0]            ;359  ; mMotor
0001d6  07d2              LSLS     r2,r2,#31             ;359
                  |L1.472|
0001d8  d0eb              BEQ      |L1.434|
0001da  6800              LDR      r0,[r0,#0]            ;359  ; iErrorMaster
0001dc  0840              LSRS     r0,r0,#1              ;359
                  |L1.478|
0001de  d1e8              BNE      |L1.434|
0001e0  6830              LDR      r0,[r6,#0]            ;361  ; iSystemTick
0001e2  8920              LDRH     r0,[r4,#8]            ;363  ; mMotor
0001e4  81a0              STRH     r0,[r4,#0xc]          ;363
0001e6  6920              LDR      r0,[r4,#0x10]         ;364  ; mMotor
0001e8  6160              STR      r0,[r4,#0x14]         ;364  ; mMotor
0001ea  8860              LDRH     r0,[r4,#2]            ;365  ; mMotor
0001ec  460e              MOV      r6,r1                 ;365
0001ee  4330              ORRS     r0,r0,r6              ;365
0001f0  8060              STRH     r0,[r4,#2]            ;365
0001f2  7968              LDRB     r0,[r5,#5]            ;366  ; iCurrentPhase
0001f4  2805              CMP      r0,#5                 ;366
0001f6  d201              BCS      |L1.508|
0001f8  1c40              ADDS     r0,r0,#1              ;366
0001fa  e000              B        |L1.510|
                  |L1.508|
0001fc  2000              MOVS     r0,#0                 ;366
                  |L1.510|
0001fe  b2c1              UXTB     r1,r0                 ;366
000200  7169              STRB     r1,[r5,#5]            ;366
000202  89a0              LDRH     r0,[r4,#0xc]          ;367  ; mMotor
000204  f7fffffe          BL       setPhaseManually
000208  483a              LDR      r0,|L1.756|
00020a  6206              STR      r6,[r0,#0x20]         ;368
00020c  7968              LDRB     r0,[r5,#5]            ;374  ; iCurrentPhase
00020e  2805              CMP      r0,#5                 ;374
000210  d201              BCS      |L1.534|
000212  1c40              ADDS     r0,r0,#1              ;374
000214  e000              B        |L1.536|
                  |L1.534|
000216  2000              MOVS     r0,#0                 ;374
                  |L1.536|
000218  b2c0              UXTB     r0,r0                 ;374
00021a  7168              STRB     r0,[r5,#5]            ;374
00021c  8821              LDRH     r1,[r4,#0]            ;375  ; mMotor
00021e  0789              LSLS     r1,r1,#30             ;375
000220  d402              BMI      |L1.552|
000222  0080              LSLS     r0,r0,#2              ;375
000224  4930              LDR      r1,|L1.744|
000226  e002              B        |L1.558|
                  |L1.552|
000228  492f              LDR      r1,|L1.744|
00022a  0080              LSLS     r0,r0,#2              ;375
00022c  3118              ADDS     r1,r1,#0x18           ;375
                  |L1.558|
00022e  5808              LDR      r0,[r1,r0]            ;375
000230  492c              LDR      r1,|L1.740|
000232  3140              ADDS     r1,r1,#0x40           ;375
000234  63c8              STR      r0,[r1,#0x3c]         ;375
000236  6961              LDR      r1,[r4,#0x14]         ;379  ; mMotor
000238  482f              LDR      r0,|L1.760|
00023a  6041              STR      r1,[r0,#4]            ;379
00023c  6801              LDR      r1,[r0,#0]            ;379
00023e  0382              LSLS     r2,r0,#14             ;379
000240  4311              ORRS     r1,r1,r2              ;379
000242  6001              STR      r1,[r0,#0]            ;379
000244  6801              LDR      r1,[r0,#0]            ;379
000246  0342              LSLS     r2,r0,#13             ;379
000248  4311              ORRS     r1,r1,r2              ;379
00024a  6001              STR      r1,[r0,#0]            ;379
00024c  812f              STRH     r7,[r5,#8]            ;382
00024e  712f              STRB     r7,[r5,#4]            ;383
000250  70ef              STRB     r7,[r5,#3]            ;384
000252  2004              MOVS     r0,#4                 ;385
                  |L1.596|
000254  7028              STRB     r0,[r5,#0]            ;349
                  |L1.598|
000256  bdf8              POP      {r3-r7,pc}
000258  8821              LDRH     r1,[r4,#0]            ;395  ; mMotor
00025a  07c9              LSLS     r1,r1,#31             ;395
00025c  d0a9              BEQ      |L1.434|
00025e  6800              LDR      r0,[r0,#0]            ;395  ; iErrorMaster
000260  0840              LSRS     r0,r0,#1              ;395
000262  d1a6              BNE      |L1.434|
000264  f7fffffe          BL       BLDCRampUp_Manager
000268  6960              LDR      r0,[r4,#0x14]         ;398  ; mMotor
00026a  4926              LDR      r1,|L1.772|
00026c  4288              CMP      r0,r1                 ;398
00026e  d8f2              BHI      |L1.598|
000270  8860              LDRH     r0,[r4,#2]            ;400  ; mMotor
000272  2108              MOVS     r1,#8                 ;400
000274  4388              BICS     r0,r0,r1              ;400
000276  8060              STRH     r0,[r4,#2]            ;400
000278  8860              LDRH     r0,[r4,#2]            ;401  ; mMotor
00027a  2102              MOVS     r1,#2                 ;401
00027c  4308              ORRS     r0,r0,r1              ;401
00027e  8060              STRH     r0,[r4,#2]            ;401
000280  4821              LDR      r0,|L1.776|
000282  6801              LDR      r1,[r0,#0]            ;410
000284  2205              MOVS     r2,#5                 ;410
000286  4311              ORRS     r1,r1,r2              ;410
000288  6001              STR      r1,[r0,#0]            ;410
00028a  481b              LDR      r0,|L1.760|
00028c  3020              ADDS     r0,r0,#0x20           ;410
00028e  6801              LDR      r1,[r0,#0]            ;410
000290  0643              LSLS     r3,r0,#25             ;410
000292  4319              ORRS     r1,r1,r3              ;410
000294  6001              STR      r1,[r0,#0]            ;410
000296  702a              STRB     r2,[r5,#0]            ;415
000298  bdf8              POP      {r3-r7,pc}
00029a  8821              LDRH     r1,[r4,#0]            ;425  ; mMotor
00029c  07c9              LSLS     r1,r1,#31             ;425
00029e  d088              BEQ      |L1.434|
0002a0  6800              LDR      r0,[r0,#0]            ;425  ; iErrorMaster
0002a2  0840              LSRS     r0,r0,#1              ;425
0002a4  d185              BNE      |L1.434|
0002a6  8860              LDRH     r0,[r4,#2]            ;427  ; mMotor
0002a8  0740              LSLS     r0,r0,#29             ;427
0002aa  d501              BPL      |L1.688|
0002ac  2006              MOVS     r0,#6                 ;432
0002ae  e7d1              B        |L1.596|
                  |L1.688|
0002b0  8928              LDRH     r0,[r5,#8]            ;436  ; iRampUpPeriodMiniCNT
0002b2  21ff              MOVS     r1,#0xff              ;436
0002b4  312d              ADDS     r1,r1,#0x2d           ;436
0002b6  4288              CMP      r0,r1                 ;436
0002b8  d202              BCS      |L1.704|
0002ba  f7fffffe          BL       BLDCRampUp_Manager
0002be  bdf8              POP      {r3-r7,pc}
                  |L1.704|
0002c0  2003              MOVS     r0,#3                 ;442
0002c2  f7fffffe          BL       setError
0002c6  bdf8              POP      {r3-r7,pc}
0002c8  8821              LDRH     r1,[r4,#0]            ;453  ; mMotor
0002ca  07c9              LSLS     r1,r1,#31             ;453
0002cc  d084              BEQ      |L1.472|
0002ce  6800              LDR      r0,[r0,#0]            ;453  ; iErrorMaster
0002d0  0840              LSRS     r0,r0,#1              ;453
0002d2  d184              BNE      |L1.478|
0002d4  f7fffffe          BL       BLDCSpeedManager
0002d8  bdf8              POP      {r3-r7,pc}
;;;467    
                          ENDP

0002da  0000              DCW      0x0000
                  |L1.732|
                          DCD      ||.data||
                  |L1.736|
                          DCD      ||.bss||
                  |L1.740|
                          DCD      0x40040000
                  |L1.744|
                          DCD      ||.constdata||+0x4
                  |L1.748|
                          DCD      iSystemTick
                  |L1.752|
                          DCD      0x0000ffff
                  |L1.756|
                          DCD      0x50004240
                  |L1.760|
                          DCD      0x40010000
                  |L1.764|
                          DCD      0x000002dd
                  |L1.768|
                          DCD      iErrorMaster
                  |L1.772|
                          DCD      0x0000063f
                  |L1.776|
                          DCD      0x400d0000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  mMotor
                          %        36

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  iLocatePhaseSequencyTable
000000  00010201          DCB      0x00,0x01,0x02,0x01
                  PHASE_TAB_CLOCKWISE
                          DCD      0x40000239
                          DCD      0x700002ad
                          DCD      0x50000827
                          DCD      0x400008b6
                          DCD      0x7000201e
                          DCD      0x5000209b
                  PHASE_TAB_ANTICLOCKWISE
                          DCD      0x400002b9
                          DCD      0x5000201b
                          DCD      0x7000209e
                          DCD      0x40000836
                          DCD      0x500008a7
                          DCD      0x7000022d

                          AREA ||.data||, DATA, ALIGN=2

                  enumMotorState
000000  00                DCB      0x00
                  enumRotateDetectState
000001  00                DCB      0x00
                  iLocateIndex
000002  00                DCB      0x00
                  iPhaseChangeCNT4Period
000003  00                DCB      0x00
                  iPhaseChangeCNT4Duty
000004  00                DCB      0x00
                  iCurrentPhase
000005  00                DCB      0x00
                  FLAG_PHASE_CHANGED
000006  0000              DCB      0x00,0x00
                  iRampUpPeriodMiniCNT
000008  00000000          DCB      0x00,0x00,0x00,0x00
                  iStateEnterTime
                          DCD      0x00000000
                  iEnterTimeBeforeWait
                          DCD      0x00000000
                  iCurrentPHCHG
                          DCD      0x00000000
                  iLastPhaseChangeTime
                          DCD      0x00000000
                  iRotateDetectStartTime
                          DCD      0x00000000
                  iLastZXDetectedTime
                          DCD      0x00000000

                          AREA ||area_number.7||, DATA, ALIGN=0

                          EXPORTAS ||area_number.7||, ||.data||
                  FLAG_TIM1_USEAGE
000000  00                DCB      0x00

                          AREA ||i.PhaseChangedRoutine||, COMGROUP=PhaseChangedRoutine, CODE, READONLY, ALIGN=2

                  PhaseChangedRoutine PROC
;;;26     
;;;27     __INLINE PhaseChangedRoutine(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;28     {
;;;29     	FLAG_PHASE_CHANGED = RESET;
000002  4e3d              LDR      r6,|L19.248|
000004  2500              MOVS     r5,#0
;;;30     	mMotor.structMotor.PHASE_CHANGE_CNT++;
000006  4c3d              LDR      r4,|L19.252|
000008  71b5              STRB     r5,[r6,#6]            ;29
00000a  69a0              LDR      r0,[r4,#0x18]  ; mMotor
00000c  1c40              ADDS     r0,r0,#1
00000e  61a0              STR      r0,[r4,#0x18]  ; mMotor
;;;31     	
;;;32     	if (TRUE == mMotor.structMotor.MSR.ZeroCrossDetecting)
000010  8860              LDRH     r0,[r4,#2]  ; mMotor
000012  0780              LSLS     r0,r0,#30
000014  d55d              BPL      |L19.210|
;;;33     	{
;;;34     //		iPhaseChangeTime = TIMER_GetCounter(TIMER1);
;;;35     		// Miss ZXD or ZXD success filter
;;;36     		// If continuously detected more than MIN_SUCC_ZXD_THRESHOLD ZX, OK! GOOD!!
;;;37     		if (TRUE == mMotor.structMotor.MSR.ThisPhaseDetectedZX)
000016  8860              LDRH     r0,[r4,#2]  ; mMotor
;;;38     		{
;;;39     			mMotor.structMotor.MSR.MissedZXD_CNT = 0;
000018  4f39              LDR      r7,|L19.256|
00001a  0700              LSLS     r0,r0,#28             ;37
00001c  d514              BPL      |L19.72|
00001e  8860              LDRH     r0,[r4,#2]  ; mMotor
000020  43b8              BICS     r0,r0,r7
000022  8060              STRH     r0,[r4,#2]
;;;40     
;;;41     			if (mMotor.structMotor.MSR.SuccessZXD_CNT > MIN_SUCC_ZXD_THRESHOLD)
000024  88a0              LDRH     r0,[r4,#4]  ; mMotor
000026  b2c0              UXTB     r0,r0
000028  2804              CMP      r0,#4
00002a  d904              BLS      |L19.54|
;;;42     			{
;;;43     				mMotor.structMotor.MSR.Locked = TRUE;
00002c  8860              LDRH     r0,[r4,#2]  ; mMotor
00002e  2104              MOVS     r1,#4
000030  4308              ORRS     r0,r0,r1
000032  8060              STRH     r0,[r4,#2]
000034  e04d              B        |L19.210|
                  |L19.54|
;;;44     //				BRG_DISABLE;
;;;45     //				P50 = 1;
;;;46     //				stopMotor();
;;;47     
;;;48     //				iTestZXContinueCNT++;
;;;49     //				iTestZXDPeriod = mMotor.structMotor.ACT_PERIOD;
;;;50     			}
;;;51     			else
;;;52     			{
;;;53     				mMotor.structMotor.MSR.SuccessZXD_CNT++;
000036  88a0              LDRH     r0,[r4,#4]  ; mMotor
000038  88a1              LDRH     r1,[r4,#4]  ; mMotor
00003a  1c40              ADDS     r0,r0,#1
00003c  b2c0              UXTB     r0,r0
00003e  0a09              LSRS     r1,r1,#8
000040  0209              LSLS     r1,r1,#8
000042  4301              ORRS     r1,r1,r0
000044  80a1              STRH     r1,[r4,#4]
000046  e044              B        |L19.210|
                  |L19.72|
;;;54     			}
;;;55     		}
;;;56     		else	// If continuously missing detected more than MAX_MISS_ZXD_THRESHOLD ZX, loss lock
;;;57     		{
;;;58     			mMotor.structMotor.MSR.SuccessZXD_CNT = 0;
000048  88a0              LDRH     r0,[r4,#4]  ; mMotor
00004a  0a00              LSRS     r0,r0,#8
00004c  0200              LSLS     r0,r0,#8
00004e  80a0              STRH     r0,[r4,#4]
000050  482c              LDR      r0,|L19.260|
000052  68c1              LDR      r1,[r0,#0xc]
;;;59     			// If ZX was not detected in last phase, iLastZXDetectedTime was also not updated
;;;60     			// Guess one value
;;;61     			iLastZXDetectedTime = GET_TIMER_DIFF((mMotor.structMotor.ACT_PERIOD >> 2), TIMER_GetCounter(TIMER1));
000054  6962              LDR      r2,[r4,#0x14]  ; mMotor
000056  0892              LSRS     r2,r2,#2
000058  4291              CMP      r1,r2
00005a  68c1              LDR      r1,[r0,#0xc]
00005c  6962              LDR      r2,[r4,#0x14]  ; mMotor
00005e  d902              BLS      |L19.102|
000060  0892              LSRS     r2,r2,#2
000062  1a89              SUBS     r1,r1,r2
000064  e003              B        |L19.110|
                  |L19.102|
000066  4b28              LDR      r3,|L19.264|
000068  0892              LSRS     r2,r2,#2
00006a  1a9a              SUBS     r2,r3,r2
00006c  1889              ADDS     r1,r1,r2
                  |L19.110|
;;;62     			if (mMotor.structMotor.MSR.MissedZXD_CNT > MAX_MISS_ZXD_THRESHOLD)
00006e  6231              STR      r1,[r6,#0x20]  ; iLastZXDetectedTime
000070  8861              LDRH     r1,[r4,#2]  ; mMotor
000072  0509              LSLS     r1,r1,#20
000074  0e09              LSRS     r1,r1,#24
000076  290c              CMP      r1,#0xc
000078  d921              BLS      |L19.190|
;;;63     			{
;;;64     				if (TRUE == mMotor.structMotor.MSR.Locked)
00007a  8861              LDRH     r1,[r4,#2]  ; mMotor
00007c  0749              LSLS     r1,r1,#29
00007e  d528              BPL      |L19.210|
;;;65     				{	
;;;66     					mMotor.structMotor.MSR.Locked = FALSE;
000080  8861              LDRH     r1,[r4,#2]  ; mMotor
000082  2204              MOVS     r2,#4
000084  4391              BICS     r1,r1,r2
000086  8061              STRH     r1,[r4,#2]
;;;67     					MOTOR_SHUT_DOWN;
000088  4920              LDR      r1,|L19.268|
00008a  620d              STR      r5,[r1,#0x20]
00008c  4a20              LDR      r2,|L19.272|
00008e  6155              STR      r5,[r2,#0x14]
000090  491c              LDR      r1,|L19.260|
000092  3920              SUBS     r1,r1,#0x20
000094  680b              LDR      r3,[r1,#0]
000096  038d              LSLS     r5,r1,#14
000098  43ab              BICS     r3,r3,r5
00009a  600b              STR      r3,[r1,#0]
00009c  6803              LDR      r3,[r0,#0]
00009e  43ab              BICS     r3,r3,r5
0000a0  6003              STR      r3,[r0,#0]
0000a2  680d              LDR      r5,[r1,#0]
0000a4  034b              LSLS     r3,r1,#13
0000a6  439d              BICS     r5,r5,r3
0000a8  600d              STR      r5,[r1,#0]
0000aa  6801              LDR      r1,[r0,#0]
0000ac  4399              BICS     r1,r1,r3
0000ae  6001              STR      r1,[r0,#0]
0000b0  20ff              MOVS     r0,#0xff
0000b2  63d0              STR      r0,[r2,#0x3c]
0000b4  6390              STR      r0,[r2,#0x38]
;;;68     					setError(ERR_INTERNAL);
0000b6  2005              MOVS     r0,#5
0000b8  f7fffffe          BL       setError
0000bc  e009              B        |L19.210|
                  |L19.190|
;;;69     				}
;;;70     			}
;;;71     			else
;;;72     			{
;;;73     				mMotor.structMotor.MSR.MissedZXD_CNT++;
0000be  8860              LDRH     r0,[r4,#2]  ; mMotor
0000c0  8861              LDRH     r1,[r4,#2]  ; mMotor
0000c2  0500              LSLS     r0,r0,#20
0000c4  0e00              LSRS     r0,r0,#24
0000c6  1c40              ADDS     r0,r0,#1
0000c8  0600              LSLS     r0,r0,#24
0000ca  0d00              LSRS     r0,r0,#20
0000cc  43b9              BICS     r1,r1,r7
0000ce  4301              ORRS     r1,r1,r0
0000d0  8061              STRH     r1,[r4,#2]
                  |L19.210|
;;;74     			}
;;;75     		}
;;;76     
;;;77     	}
;;;78     
;;;79     	if (TRUE == mMotor.structMotor.MSR.Locked)
0000d2  8860              LDRH     r0,[r4,#2]  ; mMotor
0000d4  0740              LSLS     r0,r0,#29
0000d6  d504              BPL      |L19.226|
;;;80     	{
;;;81     		// Set a rough next phase change time as the same with last phase
;;;82     		// After detected ZX in TIM1 interrupt, next phase change time will be re-configured
;;;83     		TIMER_SET_CMP_VALUE(TIMER0, mMotor.structMotor.ACT_PERIOD << 1);
0000d8  6960              LDR      r0,[r4,#0x14]  ; mMotor
0000da  0041              LSLS     r1,r0,#1
0000dc  4809              LDR      r0,|L19.260|
0000de  3820              SUBS     r0,r0,#0x20
0000e0  6041              STR      r1,[r0,#4]
                  |L19.226|
;;;84     	}
;;;85     
;;;86     	mMotor.structMotor.MSR.ThisPhaseDetectedZX = FALSE;
0000e2  8860              LDRH     r0,[r4,#2]  ; mMotor
0000e4  2108              MOVS     r1,#8
0000e6  4388              BICS     r0,r0,r1
0000e8  8060              STRH     r0,[r4,#2]
;;;87     	// For debug
;;;88     	GPIO_TOGGLE(P50);
0000ea  4808              LDR      r0,|L19.268|
0000ec  3040              ADDS     r0,r0,#0x40
0000ee  6a01              LDR      r1,[r0,#0x20]
0000f0  2201              MOVS     r2,#1
0000f2  4051              EORS     r1,r1,r2
0000f4  6201              STR      r1,[r0,#0x20]
;;;89     }
0000f6  bdf8              POP      {r3-r7,pc}
;;;90     
                          ENDP

                  |L19.248|
                          DCD      ||.data||
                  |L19.252|
                          DCD      ||.bss||
                  |L19.256|
                          DCD      0x00000ff0
                  |L19.260|
                          DCD      0x40010020
                  |L19.264|
                          DCD      0x00ffffff
                  |L19.268|
                          DCD      0x50004240
                  |L19.272|
                          DCD      0x40040040

                          AREA ||i.stopMotor||, COMGROUP=stopMotor, CODE, READONLY, ALIGN=2

                  stopMotor PROC
;;;202    //}
;;;203    __INLINE void stopMotor(void)
000000  b530              PUSH     {r4,r5,lr}
;;;204    {
;;;205    	MOTOR_SHUT_DOWN;
000002  4812              LDR      r0,|L26.76|
000004  2200              MOVS     r2,#0
000006  6202              STR      r2,[r0,#0x20]
000008  4b11              LDR      r3,|L26.80|
00000a  615a              STR      r2,[r3,#0x14]
00000c  4811              LDR      r0,|L26.84|
00000e  6801              LDR      r1,[r0,#0]
000010  0384              LSLS     r4,r0,#14
000012  43a1              BICS     r1,r1,r4
000014  6001              STR      r1,[r0,#0]
000016  490f              LDR      r1,|L26.84|
000018  3120              ADDS     r1,r1,#0x20
00001a  680d              LDR      r5,[r1,#0]
00001c  43a5              BICS     r5,r5,r4
00001e  600d              STR      r5,[r1,#0]
000020  6805              LDR      r5,[r0,#0]
000022  0344              LSLS     r4,r0,#13
000024  43a5              BICS     r5,r5,r4
000026  6005              STR      r5,[r0,#0]
000028  6808              LDR      r0,[r1,#0]
00002a  43a0              BICS     r0,r0,r4
00002c  6008              STR      r0,[r1,#0]
00002e  20ff              MOVS     r0,#0xff
000030  63d8              STR      r0,[r3,#0x3c]
000032  6398              STR      r0,[r3,#0x38]
;;;206    	mMotor.structMotor.MCR.MotorNeedToRun = FALSE;
000034  4808              LDR      r0,|L26.88|
000036  8801              LDRH     r1,[r0,#0]  ; mMotor
000038  0849              LSRS     r1,r1,#1
00003a  0049              LSLS     r1,r1,#1
00003c  8001              STRH     r1,[r0,#0]
;;;207    	mMotor.structMotor.MSR.MotorPowerOn = FALSE;
00003e  8841              LDRH     r1,[r0,#2]  ; mMotor
000040  0849              LSRS     r1,r1,#1
000042  0049              LSLS     r1,r1,#1
000044  8041              STRH     r1,[r0,#2]
;;;208    	enumMotorState = MOTOR_IDLE;
000046  4805              LDR      r0,|L26.92|
000048  7002              STRB     r2,[r0,#0]
;;;209    }
00004a  bd30              POP      {r4,r5,pc}
;;;210    
                          ENDP

                  |L26.76|
                          DCD      0x50004240
                  |L26.80|
                          DCD      0x40040040
                  |L26.84|
                          DCD      0x40010000
                  |L26.88|
                          DCD      ||.bss||
                  |L26.92|
                          DCD      ||.data||

                          AREA ||i.setPhaseManually||, COMGROUP=setPhaseManually, CODE, READONLY, ALIGN=2

                  setPhaseManually PROC
;;;210    
;;;211    __INLINE void setPhaseManually(uint16_t iPWMDuty, uint8_t iPhase)
000000  4a09              LDR      r2,|L33.40|
;;;212    {
;;;213        MOTOR_SET_DUTY(iPWMDuty);
000002  6290              STR      r0,[r2,#0x28]
000004  6310              STR      r0,[r2,#0x30]
000006  6390              STR      r0,[r2,#0x38]
;;;214    	PWM->PHCHG = GET_PHASE_VALUE(iPhase);
000008  4808              LDR      r0,|L33.44|
00000a  8800              LDRH     r0,[r0,#0]  ; mMotor
00000c  0782              LSLS     r2,r0,#30
00000e  0088              LSLS     r0,r1,#2
000010  2a00              CMP      r2,#0
000012  db01              BLT      |L33.24|
000014  4906              LDR      r1,|L33.48|
000016  e001              B        |L33.28|
                  |L33.24|
000018  4905              LDR      r1,|L33.48|
00001a  3118              ADDS     r1,r1,#0x18
                  |L33.28|
00001c  5808              LDR      r0,[r1,r0]
00001e  4902              LDR      r1,|L33.40|
000020  3140              ADDS     r1,r1,#0x40
000022  6388              STR      r0,[r1,#0x38]
;;;215    }
000024  4770              BX       lr
;;;216    
                          ENDP

000026  0000              DCW      0x0000
                  |L33.40|
                          DCD      0x40040000
                  |L33.44|
                          DCD      ||.bss||
                  |L33.48|
                          DCD      ||.constdata||+0x4

                          AREA ||i.BLDCRampUp_Manager||, COMGROUP=BLDCRampUp_Manager, CODE, READONLY, ALIGN=2

                  BLDCRampUp_Manager PROC
;;;237    
;;;238    __INLINE void BLDCRampUp_Manager(void)
000000  b570              PUSH     {r4-r6,lr}
;;;239    {
;;;240    	if (SET == FLAG_PHASE_CHANGED)
000002  4d1e              LDR      r5,|L40.124|
000004  79a8              LDRB     r0,[r5,#6]  ; FLAG_PHASE_CHANGED
000006  2801              CMP      r0,#1
000008  d136              BNE      |L40.120|
;;;241    	{
;;;242    		PhaseChangedRoutine();
00000a  f7fffffe          BL       PhaseChangedRoutine
;;;243    		if (iPhaseChangeCNT4Period > CHANGE_DUTY_PERIOD_THR)
00000e  78e8              LDRB     r0,[r5,#3]  ; iPhaseChangeCNT4Period
;;;244    		{
;;;245    			iPhaseChangeCNT4Period = 0;
;;;246    			// Change duty and period 
;;;247    //			MOTOR_RAMPUP_DT_INCR(mMotor.structMotor.ACT_DUTY);			
;;;248    			MOTOR_RAMPUP_PR_DCR(mMotor.structMotor.ACT_PERIOD);	
000010  4c1b              LDR      r4,|L40.128|
000012  2809              CMP      r0,#9                 ;243
000014  d916              BLS      |L40.68|
000016  2000              MOVS     r0,#0                 ;245
000018  70e8              STRB     r0,[r5,#3]            ;245
00001a  6960              LDR      r0,[r4,#0x14]  ; mMotor
00001c  4e19              LDR      r6,|L40.132|
00001e  42b0              CMP      r0,r6
000020  6960              LDR      r0,[r4,#0x14]  ; mMotor
000022  d308              BCC      |L40.54|
000024  f7fffffe          BL       __aeabi_ui2d
000028  4a17              LDR      r2,|L40.136|
00002a  4b18              LDR      r3,|L40.140|
00002c  f7fffffe          BL       __aeabi_dmul
000030  f7fffffe          BL       __aeabi_d2uiz
000034  b280              UXTH     r0,r0
                  |L40.54|
000036  6160              STR      r0,[r4,#0x14]  ; mMotor
;;;249    			if (mMotor.structMotor.ACT_PERIOD <= MOTOR_RAMPUP_PR_MIN)
000038  6960              LDR      r0,[r4,#0x14]  ; mMotor
00003a  42b0              CMP      r0,r6
00003c  d802              BHI      |L40.68|
;;;250    			{
;;;251    				iRampUpPeriodMiniCNT++;
00003e  8928              LDRH     r0,[r5,#8]  ; iRampUpPeriodMiniCNT
000040  1c40              ADDS     r0,r0,#1
000042  8128              STRH     r0,[r5,#8]
                  |L40.68|
;;;252    			}
;;;253    		}
;;;254    		iPhaseChangeCNT4Period++;
000044  78e8              LDRB     r0,[r5,#3]  ; iPhaseChangeCNT4Period
000046  1c40              ADDS     r0,r0,#1
000048  70e8              STRB     r0,[r5,#3]
;;;255    //		MOTOR_SET_DUTY(mMotor.structMotor.ACT_DUTY);
;;;256    		TIMER_SET_CMP_VALUE(TIMER0, mMotor.structMotor.ACT_PERIOD);
00004a  6960              LDR      r0,[r4,#0x14]  ; mMotor
00004c  4910              LDR      r1,|L40.144|
00004e  6048              STR      r0,[r1,#4]
;;;257    		PHASE_INCREASE(iCurrentPhase);
000050  7968              LDRB     r0,[r5,#5]  ; iCurrentPhase
000052  2805              CMP      r0,#5
000054  d201              BCS      |L40.90|
000056  1c40              ADDS     r0,r0,#1
000058  e000              B        |L40.92|
                  |L40.90|
00005a  2000              MOVS     r0,#0
                  |L40.92|
00005c  b2c0              UXTB     r0,r0
00005e  7168              STRB     r0,[r5,#5]
;;;258    		// Modify PWM->PHCHGNXT at last because I don't know how long needed to reload PHCH with PHCHNEXT after TIM0 time-out
;;;259    		PWM->PHCHGNXT = GET_PHASE_VALUE(iCurrentPhase);
000060  8821              LDRH     r1,[r4,#0]  ; mMotor
000062  0789              LSLS     r1,r1,#30
000064  d402              BMI      |L40.108|
000066  0080              LSLS     r0,r0,#2
000068  490a              LDR      r1,|L40.148|
00006a  e002              B        |L40.114|
                  |L40.108|
00006c  4909              LDR      r1,|L40.148|
00006e  0080              LSLS     r0,r0,#2
000070  3118              ADDS     r1,r1,#0x18
                  |L40.114|
000072  5808              LDR      r0,[r1,r0]
000074  4908              LDR      r1,|L40.152|
000076  63c8              STR      r0,[r1,#0x3c]
                  |L40.120|
;;;260    	}
;;;261    }
000078  bd70              POP      {r4-r6,pc}
;;;262    
                          ENDP

00007a  0000              DCW      0x0000
                  |L40.124|
                          DCD      ||.data||
                  |L40.128|
                          DCD      ||.bss||
                  |L40.132|
                          DCD      0x000003e7
                  |L40.136|
                          DCD      0xf5c28f5c
                  |L40.140|
                          DCD      0x3fef5c28
                  |L40.144|
                          DCD      0x40010000
                  |L40.148|
                          DCD      ||.constdata||+0x4
                  |L40.152|
                          DCD      0x40040040

                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d200              BCS      |L47.16|
00000e  461d              MOV      r5,r3
                  |L47.16|
000010  5d63              LDRB     r3,[r4,r5]
000012  005b              LSLS     r3,r3,#1
000014  18e3              ADDS     r3,r4,r3
000016  bc30              POP      {r4,r5}
000018  4718              BX       r3
                          ENDP


;*** Start embedded assembler ***

#line 1 "User\\BLDCSensorLess.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_BLDCSensorLess_c_0df2b5b8____REV16|
#line 118 ".\\CMSIS\\core_cmInstr.h"
|__asm___16_BLDCSensorLess_c_0df2b5b8____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_BLDCSensorLess_c_0df2b5b8____REVSH|
#line 132
|__asm___16_BLDCSensorLess_c_0df2b5b8____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
