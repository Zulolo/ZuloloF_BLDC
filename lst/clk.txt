; generated by Component: ARM Compiler 5.06 update 1 (build 61) Tool: ArmCC [4d35ad]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\clk.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\clk.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\Mini51Series\Include -I..\..\..\Library\StdDriver\inc -I.\StdDriver\inc -I.\CMSIS -IG:\Geek\Projects\Zulolo_F\Force\Code\ZuloloF_BLDC\RTE -ID:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.0.7\Device\Mini51\Include -ID:\Keil_v5\ARM\CMSIS\Include -I\ -D__MICROLIB -D__UVISION_VERSION=518 --omf_browse=.\obj\clk.crf StdDriver\src\clk.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  CLK_DisableCKO PROC
;;;28       */
;;;29     void CLK_DisableCKO(void)
000000  485c              LDR      r0,|L1.372|
;;;30     { 
;;;31       /* Disable CKO clock source */
;;;32       CLK->APBCLK &= (~CLK_APBCLK_FDIV_EN_Msk); 
000002  6881              LDR      r1,[r0,#8]
000004  2240              MOVS     r2,#0x40
000006  4391              BICS     r1,r1,r2
000008  6081              STR      r1,[r0,#8]
;;;33     }
00000a  4770              BX       lr
;;;34     
                          ENDP

                  CLK_EnableCKO PROC
;;;51       */
;;;52     void CLK_EnableCKO(uint32_t u32ClkSrc, uint32_t u32ClkDiv, uint32_t u32ClkDivBy1En)
00000c  0152              LSLS     r2,r2,#5
;;;53     {
;;;54       /* CKO = clock source / 2^(u32ClkDiv + 1) */
;;;55       CLK->FRQDIV = CLK_FRQDIV_DIVIDER_EN_Msk | u32ClkDiv | u32ClkDivBy1En<<CLK_FRQDIV_DIVIDER1_Pos;
00000e  430a              ORRS     r2,r2,r1
000010  2110              MOVS     r1,#0x10
000012  430a              ORRS     r2,r2,r1
000014  4957              LDR      r1,|L1.372|
000016  624a              STR      r2,[r1,#0x24]
;;;56     
;;;57       /* Enable CKO clock source */
;;;58       CLK->APBCLK |= CLK_APBCLK_FDIV_EN_Msk;
000018  688a              LDR      r2,[r1,#8]
00001a  2340              MOVS     r3,#0x40
00001c  431a              ORRS     r2,r2,r3
00001e  608a              STR      r2,[r1,#8]
;;;59     
;;;60       /* Select CKO clock source */
;;;61       CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_FRQDIV_S_Msk)) | u32ClkSrc;  
000020  69ca              LDR      r2,[r1,#0x1c]
000022  230c              MOVS     r3,#0xc
000024  439a              BICS     r2,r2,r3
000026  4302              ORRS     r2,r2,r0
000028  61ca              STR      r2,[r1,#0x1c]
;;;62     }
00002a  4770              BX       lr
;;;63     
                          ENDP

                  CLK_PowerDown PROC
;;;67       */
;;;68     void CLK_PowerDown(void)
00002c  4952              LDR      r1,|L1.376|
;;;69     {
;;;70       SCB->SCR = SCB_SCR_SLEEPDEEP_Msk;
00002e  2004              MOVS     r0,#4
000030  6108              STR      r0,[r1,#0x10]
;;;71       CLK->PWRCON |= (CLK_PWRCON_PWR_DOWN_EN_Msk | CLK_PWRCON_PD_WU_STS_Msk);
000032  4850              LDR      r0,|L1.372|
000034  6801              LDR      r1,[r0,#0]
000036  22c0              MOVS     r2,#0xc0
000038  4311              ORRS     r1,r1,r2
00003a  6001              STR      r1,[r0,#0]
;;;72       __WFI();
00003c  bf30              WFI      
;;;73     }
00003e  4770              BX       lr
;;;74     
                          ENDP

                  CLK_Idle PROC
;;;78       */
;;;79     void CLK_Idle(void)
000040  484c              LDR      r0,|L1.372|
;;;80     {
;;;81       CLK->PWRCON |= (CLK_PWRCON_PWR_DOWN_EN_Msk | CLK_PWRCON_PD_WU_STS_Msk);
000042  6801              LDR      r1,[r0,#0]
000044  22c0              MOVS     r2,#0xc0
000046  4311              ORRS     r1,r1,r2
000048  6001              STR      r1,[r0,#0]
;;;82       __WFI();
00004a  bf30              WFI      
;;;83     }
00004c  4770              BX       lr
;;;84     
                          ENDP

                  CLK_GetHXTFreq PROC
;;;88       */
;;;89     uint32_t CLK_GetHXTFreq(void)
00004e  4849              LDR      r0,|L1.372|
;;;90     {  
;;;91       if(CLK->PWRCON & CLK_PWRCON_XTL12M )
000050  6800              LDR      r0,[r0,#0]
000052  07c0              LSLS     r0,r0,#31
000054  d000              BEQ      |L1.88|
;;;92         return __XTAL12M;
000056  4849              LDR      r0,|L1.380|
                  |L1.88|
;;;93       else 
;;;94         return 0;
;;;95     }
000058  4770              BX       lr
;;;96     
                          ENDP

                  CLK_GetLXTFreq PROC
;;;100      */
;;;101    uint32_t CLK_GetLXTFreq(void)
00005a  4846              LDR      r0,|L1.372|
;;;102    {
;;;103      if(CLK->PWRCON & CLK_PWRCON_XTL32K )
00005c  6800              LDR      r0,[r0,#0]
00005e  0780              LSLS     r0,r0,#30
000060  d502              BPL      |L1.104|
;;;104        return __XTAL32K;
000062  2001              MOVS     r0,#1
000064  03c0              LSLS     r0,r0,#15
;;;105      else 
;;;106        return 0;
;;;107    }
000066  4770              BX       lr
                  |L1.104|
000068  2000              MOVS     r0,#0                 ;106
00006a  4770              BX       lr
;;;108    
                          ENDP

                  CLK_GetHCLKFreq PROC
;;;112      */
;;;113    uint32_t CLK_GetHCLKFreq(void)
00006c  b510              PUSH     {r4,lr}
;;;114    {
;;;115      SystemCoreClockUpdate();
00006e  f7fffffe          BL       SystemCoreClockUpdate
;;;116      return SystemCoreClock;
000072  4843              LDR      r0,|L1.384|
000074  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;117    }
000076  bd10              POP      {r4,pc}
;;;118    
                          ENDP

                  CLK_GetCPUFreq PROC
;;;123      */
;;;124    uint32_t CLK_GetCPUFreq(void)
000078  b510              PUSH     {r4,lr}
;;;125    {
;;;126      SystemCoreClockUpdate();
00007a  f7fffffe          BL       SystemCoreClockUpdate
;;;127      return SystemCoreClock;
00007e  4840              LDR      r0,|L1.384|
000080  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;128    }
000082  bd10              POP      {r4,pc}
;;;129    
                          ENDP

                  CLK_SetHCLK PROC
;;;139      */
;;;140    void CLK_SetHCLK(uint32_t u32ClkSrc, uint32_t u32ClkDiv)
000084  4a3b              LDR      r2,|L1.372|
;;;141    {
;;;142      CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_HCLK_S_Msk) | u32ClkSrc; 
000086  6913              LDR      r3,[r2,#0x10]
000088  08db              LSRS     r3,r3,#3
00008a  00db              LSLS     r3,r3,#3
00008c  4303              ORRS     r3,r3,r0
00008e  6113              STR      r3,[r2,#0x10]
;;;143      CLK->CLKDIV = (CLK->CLKDIV & ~CLK_CLKDIV_HCLK_N_Msk) | u32ClkDiv; 
000090  6990              LDR      r0,[r2,#0x18]
000092  0900              LSRS     r0,r0,#4
000094  0100              LSLS     r0,r0,#4
000096  4308              ORRS     r0,r0,r1
000098  6190              STR      r0,[r2,#0x18]
;;;144    }
00009a  4770              BX       lr
;;;145    
                          ENDP

                  CLK_SetModuleClock PROC
;;;183      
;;;184    void CLK_SetModuleClock(uint32_t u32ModuleIdx, uint32_t u32ClkSrc, uint32_t u32ClkDiv)
00009c  b570              PUSH     {r4-r6,lr}
;;;185    {
;;;186      uint32_t u32tmp=0,u32sel=0,u32div=0;
;;;187        
;;;188      if(MODULE_CLKSEL_Msk(u32ModuleIdx)!=MODULE_NoMsk)
00009e  0e43              LSRS     r3,r0,#25
0000a0  071b              LSLS     r3,r3,#28
0000a2  d00e              BEQ      |L1.194|
;;;189      {
;;;190        u32sel = (uint32_t)(&(CLK->CLKSEL0))+((MODULE_CLKSEL(u32ModuleIdx))*4);
0000a4  0043              LSLS     r3,r0,#1
0000a6  4c33              LDR      r4,|L1.372|
0000a8  0f9b              LSRS     r3,r3,#30
0000aa  009b              LSLS     r3,r3,#2
0000ac  3410              ADDS     r4,r4,#0x10
0000ae  191b              ADDS     r3,r3,r4
;;;191        u32tmp = *(volatile uint32_t *)(u32sel);
0000b0  681c              LDR      r4,[r3,#0]
;;;192        u32tmp = (u32tmp & (~(MODULE_CLKSEL_Msk(u32ModuleIdx)<<MODULE_CLKSEL_Pos(u32ModuleIdx)))) | u32ClkSrc;    
0000b2  00c5              LSLS     r5,r0,#3
0000b4  0f2d              LSRS     r5,r5,#28
0000b6  01c6              LSLS     r6,r0,#7
0000b8  0ef6              LSRS     r6,r6,#27
0000ba  40b5              LSLS     r5,r5,r6
0000bc  43ac              BICS     r4,r4,r5
0000be  430c              ORRS     r4,r4,r1
;;;193        *(volatile uint32_t *)(u32sel) = u32tmp;
0000c0  601c              STR      r4,[r3,#0]
                  |L1.194|
;;;194      }
;;;195    
;;;196      if(MODULE_CLKDIV_Msk(u32ModuleIdx)!=MODULE_NoMsk)
0000c2  0a83              LSRS     r3,r0,#10
0000c4  0619              LSLS     r1,r3,#24
0000c6  0e09              LSRS     r1,r1,#24
0000c8  d00d              BEQ      |L1.230|
;;;197      {
;;;198        u32div =(uint32_t)(&(CLK->CLKDIV))+((MODULE_CLKDIV(u32ModuleIdx))*4);
0000ca  0301              LSLS     r1,r0,#12
0000cc  4c29              LDR      r4,|L1.372|
0000ce  0f89              LSRS     r1,r1,#30
0000d0  0089              LSLS     r1,r1,#2
0000d2  3418              ADDS     r4,r4,#0x18
0000d4  1909              ADDS     r1,r1,r4
;;;199        u32tmp = *(volatile uint32_t *)(u32div);
0000d6  680c              LDR      r4,[r1,#0]
;;;200        u32tmp = (u32tmp & (~(MODULE_CLKDIV_Msk(u32ModuleIdx)<<MODULE_CLKDIV_Pos(u32ModuleIdx)))) | u32ClkDiv;  
0000d8  0580              LSLS     r0,r0,#22
0000da  b2db              UXTB     r3,r3
0000dc  0ec0              LSRS     r0,r0,#27
0000de  4083              LSLS     r3,r3,r0
0000e0  439c              BICS     r4,r4,r3
0000e2  4314              ORRS     r4,r4,r2
;;;201        *(volatile uint32_t *)(u32div) = u32tmp;    
0000e4  600c              STR      r4,[r1,#0]
                  |L1.230|
;;;202      }
;;;203    }
0000e6  bd70              POP      {r4-r6,pc}
;;;204    
                          ENDP

                  CLK_SetSysTickClockSrc PROC
;;;213      */
;;;214    void CLK_SetSysTickClockSrc(uint32_t u32ClkSrc)
0000e8  4a22              LDR      r2,|L1.372|
;;;215    {
;;;216      CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_STCLK_S_Msk) | u32ClkSrc;
0000ea  6911              LDR      r1,[r2,#0x10]
0000ec  2338              MOVS     r3,#0x38
0000ee  4399              BICS     r1,r1,r3
0000f0  4301              ORRS     r1,r1,r0
0000f2  6111              STR      r1,[r2,#0x10]
;;;217    }
0000f4  4770              BX       lr
;;;218    
                          ENDP

                  CLK_EnableXtalRC PROC
;;;226      */
;;;227    void CLK_EnableXtalRC(uint32_t u32ClkMask)
0000f6  491f              LDR      r1,|L1.372|
;;;228    {
;;;229      CLK->PWRCON |=u32ClkMask; 
0000f8  680a              LDR      r2,[r1,#0]
0000fa  4302              ORRS     r2,r2,r0
0000fc  600a              STR      r2,[r1,#0]
;;;230    }
0000fe  4770              BX       lr
;;;231    
                          ENDP

                  CLK_DisableXtalRC PROC
;;;239      */
;;;240    void CLK_DisableXtalRC(uint32_t u32ClkMask)
000100  491c              LDR      r1,|L1.372|
;;;241    {
;;;242      CLK->PWRCON &=~u32ClkMask;
000102  680a              LDR      r2,[r1,#0]
000104  4382              BICS     r2,r2,r0
000106  600a              STR      r2,[r1,#0]
;;;243    }
000108  4770              BX       lr
;;;244    
                          ENDP

                  CLK_EnableModuleClock PROC
;;;261      */
;;;262    void CLK_EnableModuleClock(uint32_t u32ModuleIdx)
00010a  0fc1              LSRS     r1,r0,#31
;;;263    {
;;;264      *(volatile uint32_t *)((uint32_t)&CLK->APBCLK+(MODULE_APBCLK(u32ModuleIdx)*4))  |= 1<<MODULE_IP_EN_Pos(u32ModuleIdx);
00010c  008a              LSLS     r2,r1,#2
00010e  4919              LDR      r1,|L1.372|
000110  1851              ADDS     r1,r2,r1
000112  688a              LDR      r2,[r1,#8]
000114  06c3              LSLS     r3,r0,#27
000116  0edb              LSRS     r3,r3,#27
000118  2001              MOVS     r0,#1
00011a  4098              LSLS     r0,r0,r3
00011c  4302              ORRS     r2,r2,r0
00011e  608a              STR      r2,[r1,#8]
;;;265    }
000120  4770              BX       lr
;;;266    
                          ENDP

                  CLK_DisableModuleClock PROC
;;;283      */
;;;284    void CLK_DisableModuleClock(uint32_t u32ModuleIdx)
000122  0fc1              LSRS     r1,r0,#31
;;;285    {
;;;286      *(volatile uint32_t *)((uint32_t)&CLK->APBCLK+(MODULE_APBCLK(u32ModuleIdx)*4))  &= ~(1<<MODULE_IP_EN_Pos(u32ModuleIdx));
000124  008a              LSLS     r2,r1,#2
000126  4913              LDR      r1,|L1.372|
000128  1851              ADDS     r1,r2,r1
00012a  688a              LDR      r2,[r1,#8]
00012c  06c3              LSLS     r3,r0,#27
00012e  0edb              LSRS     r3,r3,#27
000130  2001              MOVS     r0,#1
000132  4098              LSLS     r0,r0,r3
000134  4382              BICS     r2,r2,r0
000136  608a              STR      r2,[r1,#8]
;;;287    }
000138  4770              BX       lr
;;;288    
                          ENDP

                  CLK_SysTickDelay PROC
;;;296      */
;;;297    void CLK_SysTickDelay(uint32_t us)
00013a  4912              LDR      r1,|L1.388|
;;;298    {
;;;299        SysTick->LOAD = us * CyclesPerUs;
00013c  6809              LDR      r1,[r1,#0]  ; CyclesPerUs
00013e  4348              MULS     r0,r1,r0
000140  4911              LDR      r1,|L1.392|
000142  6148              STR      r0,[r1,#0x14]
;;;300        SysTick->VAL  =  (0x00);
000144  2000              MOVS     r0,#0
000146  6188              STR      r0,[r1,#0x18]
;;;301        SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
000148  2005              MOVS     r0,#5
00014a  6108              STR      r0,[r1,#0x10]
                  |L1.332|
;;;302    
;;;303        /* Waiting for down-count to zero */
;;;304        while((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) == 0);
00014c  6908              LDR      r0,[r1,#0x10]
00014e  03c0              LSLS     r0,r0,#15
000150  d5fc              BPL      |L1.332|
;;;305    }
000152  4770              BX       lr
;;;306    
                          ENDP

                  CLK_WaitClockReady PROC
;;;316      */
;;;317    void CLK_WaitClockReady(uint32_t u32ClkMask)
000154  b510              PUSH     {r4,lr}
;;;318    {
;;;319        int32_t i32TimeOutCnt;
;;;320    
;;;321        i32TimeOutCnt = __HSI / 200; /* About 5ms */
000156  211b              MOVS     r1,#0x1b
000158  4604              MOV      r4,r0                 ;318
00015a  0309              LSLS     r1,r1,#12
;;;322        
;;;323        while((CLK->CLKSTATUS & u32ClkMask) != u32ClkMask)
00015c  4b05              LDR      r3,|L1.372|
00015e  e003              B        |L1.360|
                  |L1.352|
;;;324        {
;;;325            if(i32TimeOutCnt-- <= 0)
000160  460a              MOV      r2,r1
000162  1e49              SUBS     r1,r1,#1
000164  2a00              CMP      r2,#0
000166  dd03              BLE      |L1.368|
                  |L1.360|
000168  68da              LDR      r2,[r3,#0xc]          ;323
00016a  4620              MOV      r0,r4                 ;323
00016c  4390              BICS     r0,r0,r2              ;323
00016e  d1f7              BNE      |L1.352|
                  |L1.368|
;;;326                break;    
;;;327        } 
;;;328    }
000170  bd10              POP      {r4,pc}
;;;329    
                          ENDP

000172  0000              DCW      0x0000
                  |L1.372|
                          DCD      0x50000200
                  |L1.376|
                          DCD      0xe000ed00
                  |L1.380|
                          DCD      0x00b71b00
                  |L1.384|
                          DCD      SystemCoreClock
                  |L1.388|
                          DCD      CyclesPerUs
                  |L1.392|
                          DCD      0xe000e000

;*** Start embedded assembler ***

#line 1 "StdDriver\\src\\clk.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____REV16|
#line 118 ".\\CMSIS\\core_cmInstr.h"
|__asm___5_clk_c_9b5832dc____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____REVSH|
#line 132
|__asm___5_clk_c_9b5832dc____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
