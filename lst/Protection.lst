L 1 "User\Protection.c"
N/******************************************************************************
N * @file     Protection.c
N * @version  V1.00
N * $Revision: 1 $
N * $Date: 16/04/20 21:13p $
N * @brief    Protection for Mini51 series MCU
N *
N * @note
N * Copyright (C) 2016 Zulolo Technology Corp. All rights reserved.
N*****************************************************************************/
N
N#define __USED_BY_PTC_C__
N#include "Protection.h"
L 1 "User\Protection.h" 1
N#ifndef __PROTECTION_H__
N#define __PROTECTION_H__
N
N#include "global.h"
L 1 "User\global.h" 1
N#ifndef __GLOBAL_H__
N#define __GLOBAL_H__
N
N#include "Mini51Series.h"
L 1 ".\CMSIS\Mini51Series.h" 1
N/**************************************************************************//**
N * @file     Mini51Series.h
N * @version  V1.00
N * $Revision: 14 $
N * $Date: 13/10/08 9:50a $ 
N * @brief    Mini51 series peripheral access layer header file.
N *           This file contains all the peripheral register's definitions, 
N *           bits definitions and memory mapping for NuMicro Mini51 series MCU.
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/ 
N/**
N   \mainpage NuMicro Mini51DE Driver Reference Guide
N   *
N   * <b>Introduction</b>
N   *
N   * This user manual describes the usage of Mini51DE Series MCU device driver
N   *
N   * <b>Discalimer</b> 
N   *
N   * The Software is furnished "AS IS", without warranty as to performance or results, and 
N   * the entire risk as to performance or results is assumed by YOU. Nuvoton disclaims all 
N   * warranties, express, implied or otherwise, with regard to the Software, its use, or 
N   * operation, including without limitation any and all warranties of merchantability, fitness 
N   * for a particular purpose, and non-infringement of intellectual property rights.
N   *
N   * <b>Copyright Notice</b>
N   *
N   * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N   */
N#ifndef __MINI51SERIES_H__
N#define __MINI51SERIES_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @addtogroup MINI51_Definitions MINI51 Definitions
N  This file defines all structures and symbols for Mini5x:
N    - interrupt numbers
N    - registers and bitfields
N    - peripheral base address
N    - peripheral ID
N    - Peripheral definitions
N  @{
N*/
N
N/******************************************************************************/
N/*                Processor and Core Peripherals                              */
N/******************************************************************************/
N/** @addtogroup MINI51_CMSIS Device CMSIS Definitions
N  Configuration of the Cortex-M0 Processor and Core Peripherals
N  @{
N*/
N
N/**
N * @details  Interrupt Number Definition. The maximum of 32 Specific Interrupts are possible.
N */
Ntypedef enum IRQn
N{
N/******  Cortex-M0 Processor Exceptions Numbers *****************************************/
N
N  NonMaskableInt_IRQn   = -14,    /*!< 2 Non Maskable Interrupt                           */
N  HardFault_IRQn        = -13,    /*!< 3 Cortex-M0 Hard Fault Interrupt                   */
N  SVCall_IRQn           = -5,     /*!< 11 Cortex-M0 SV Call Interrupt                     */
N  PendSV_IRQn           = -2,     /*!< 14 Cortex-M0 Pend SV Interrupt                     */
N  SysTick_IRQn          = -1,     /*!< 15 Cortex-M0 System Tick Interrupt                 */
N
N/******  Mini5x specific Interrupt Numbers ***********************************************/
N
N  BOD_IRQn              = 0,      /*!< Brownout low voltage detected interrupt            */
N  WDT_IRQn              = 1,      /*!< Watch Dog Timer interrupt                          */
N  EINT0_IRQn            = 2,      /*!< External signal interrupt from P3.2 pin            */
N  EINT1_IRQn            = 3,      /*!< External signal interrupt from P3.3 pin            */
N  GPIO01_IRQn           = 4,      /*!< External signal interrupt from P0/P1               */
N  GPIO234_IRQn          = 5,      /*!< External interrupt from P2/P3/P4                   */
N  PWM_IRQn              = 6,      /*!< PWM interrupt                                      */
N  FB_IRQn               = 7,      /*!< Fault break interrupt                              */
N  TMR0_IRQn             = 8,      /*!< Timer 0 interrupt                                  */
N  TMR1_IRQn             = 9,      /*!< Timer 1 interrupt                                  */
N  UART_IRQn             = 12,     /*!< UART interrupt                                     */
N  SPI_IRQn              = 14,     /*!< SPI interrupt                                      */
N  GPIO5_IRQn            = 16,     /*!< External interrupt from P5                         */
N  HIRC_IRQn             = 17,     /*!< HIRC trim interrupt                                */
N  I2C_IRQn              = 18,     /*!< I2C interrupt                                      */
N  ACMP_IRQn             = 25,     /*!< ACMP interrupt                                     */
N  PDWU_IRQn             = 28,     /*!< Power Down Wake up interrupt                       */
N  ADC_IRQn              = 29      /*!< ADC interrupt                                      */
N  
N} IRQn_Type;
N
N
N/*
N * ==========================================================================
N * ----------- Processor and Core Peripheral Section ------------------------
N * ==========================================================================
N */
N
N
N/* Configuration of the Cortex-M0 Processor and Core Peripherals */
N#define __CM0_REV                0x0201    /*!< Core Revision r2p1                               */
N#define __NVIC_PRIO_BITS         2         /*!< Number of Bits used for Priority Levels          */
N#define __Vendor_SysTickConfig   0         /*!< Set to 1 if different SysTick Config is used     */
N#define __MPU_PRESENT            0         /*!< MPU present or not                               */
N#define __FPU_PRESENT            0         /*!< FPU present or not                               */
N
N/*@}*/ /* end of group MINI51_CMSIS */
N
N
N#include "core_cm0.h"                       /* Cortex-M0 processor and core peripherals           */
L 1 ".\CMSIS\core_cm0.h" 1
N/**************************************************************************//**
N * @file     core_cm0.h
N * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
N * @version  V3.01
N * @date     13. March 2012
N *
N * @note
N * Copyright (C) 2009-2012 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N#if defined ( __ICCARM__ )
X#if 0L
S #pragma system_include  /* treat file as system include file for MISRA check */
N#endif
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N#ifndef __CORE_CM0_H_GENERIC
N#define __CORE_CM0_H_GENERIC
N
N/** @addtogroup CMSIS_Definitions CMSIS
N  @{
N*/
N
N/** \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/** \ingroup Cortex_M0
N  @{
N */
N
N/*  CMSIS CM0 definitions */
N#define __CM0_CMSIS_VERSION_MAIN  (0x03)                                   /*!< [31:16] CMSIS HAL main version   */
N#define __CM0_CMSIS_VERSION_SUB   (0x01)                                   /*!< [15:0]  CMSIS HAL sub version    */
N#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16) | \
N                                    __CM0_CMSIS_VERSION_SUB          )     /*!< CMSIS HAL version number         */
X#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16) |                                     __CM0_CMSIS_VERSION_SUB          )      
N
N#define __CORTEX_M                (0x00)                                   /*!< Cortex-M Core                    */
N
N
N#if   defined ( __CC_ARM )
X#if   1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
N  #define __STATIC_INLINE  static __inline
N
N#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
S  #define __STATIC_INLINE  static inline
S
N#endif
N
N/** __FPU_USED indicates whether an FPU is used or not. This core does not support an FPU at all
N*/
N#define __FPU_USED       0
N
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 0L
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
N  #endif
N
N#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
N#endif
N
N#include <stdint.h>                      /* standard types definitions                      */
L 1 "D:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision: 185525 $
N * Checkin $Date: 2014-05-29 12:44:48 +0100 (Thu, 29 May 2014) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060002
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX INT64_MAX
N#else
N#define UINTPTR_MAX INT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 116 ".\CMSIS\core_cm0.h" 2
N#include <core_cmInstr.h>                /* Core Instruction Access                         */
L 1 ".\CMSIS\core_cmInstr.h" 1
N/**************************************************************************//**
N * @file     core_cmInstr.h
N * @brief    CMSIS Cortex-M Core Instruction Access Header File
N * @version  V3.01
N * @date     06. March 2012
N *
N * @note
N * Copyright (C) 2009-2012 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifndef __CORE_CMINSTR_H
N#define __CORE_CMINSTR_H
N
N/** @addtogroup CMSIS_Definitions CMSIS
N  @{
N*/
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5060061 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N
N/** \brief  No Operation
N
N    No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/** \brief  Wait For Interrupt
N
N    Wait For Interrupt is a hint instruction that suspends execution
N    until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/** \brief  Wait For Event
N
N    Wait For Event is a hint instruction that permits the processor to enter
N    a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/** \brief  Send Event
N
N    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/** \brief  Instruction Synchronization Barrier
N
N    Instruction Synchronization Barrier flushes the pipeline in the processor,
N    so that all instructions following the ISB are fetched from cache or
N    memory, after the instruction has been completed.
N */
N#define __ISB()                           __isb(0xF)
N
N
N/** \brief  Data Synchronization Barrier
N
N    This function acts as a special kind of Data Memory Barrier.
N    It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB()                           __dsb(0xF)
N
N
N/** \brief  Data Memory Barrier
N
N    This function ensures the apparent order of the explicit memory operations before
N    and after the instruction, without ensuring their completion.
N */
N#define __DMB()                           __dmb(0xF)
N
N
N/** \brief  Reverse byte order (32 bit)
N
N    This function reverses the byte order in integer value.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/** \brief  Reverse byte order (16 bit)
N
N    This function reverses the byte order in two unsigned short values.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N
N
N/** \brief  Reverse byte order in signed short value
N
N    This function reverses the byte order in a signed short value with sign extension to integer.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N
N
N/** \brief  Rotate Right in unsigned value (32 bit)
N
N    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N
N    \param [in]    value  Value to rotate
N    \param [in]    value  Number of Bits to rotate
N    \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x00) >= 0x03)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S#define __RBIT                            __rbit
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function performs a exclusive LDR command for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S#define __LDREXB(ptr)                     ((uint8_t ) __ldrex(ptr))
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function performs a exclusive LDR command for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S#define __LDREXH(ptr)                     ((uint16_t) __ldrex(ptr))
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function performs a exclusive LDR command for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S#define __LDREXW(ptr)                     ((uint32_t ) __ldrex(ptr))
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function performs a exclusive STR command for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXB(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function performs a exclusive STR command for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXH(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function performs a exclusive STR command for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXW(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S#define __CLREX                           __clrex
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT                            __ssat
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT                            __usat
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S#define __CLZ                             __clz
S
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N
N#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/** \brief  No Operation
S
S    No Operation does nothing. This instruction can be used for code alignment purposes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
S{
S  __ASM volatile ("nop");
S}
S
S
S/** \brief  Wait For Interrupt
S
S    Wait For Interrupt is a hint instruction that suspends execution
S    until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFI(void)
S{
S  __ASM volatile ("wfi");
S}
S
S
S/** \brief  Wait For Event
S
S    Wait For Event is a hint instruction that permits the processor to enter
S    a low-power state until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFE(void)
S{
S  __ASM volatile ("wfe");
S}
S
S
S/** \brief  Send Event
S
S    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __SEV(void)
S{
S  __ASM volatile ("sev");
S}
S
S
S/** \brief  Instruction Synchronization Barrier
S
S    Instruction Synchronization Barrier flushes the pipeline in the processor,
S    so that all instructions following the ISB are fetched from cache or
S    memory, after the instruction has been completed.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __ISB(void)
S{
S  __ASM volatile ("isb");
S}
S
S
S/** \brief  Data Synchronization Barrier
S
S    This function acts as a special kind of Data Memory Barrier.
S    It completes when all explicit memory accesses before this instruction complete.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
S{
S  __ASM volatile ("dsb");
S}
S
S
S/** \brief  Data Memory Barrier
S
S    This function ensures the apparent order of the explicit memory operations before
S    and after the instruction, without ensuring their completion.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
S{
S  __ASM volatile ("dmb");
S}
S
S
S/** \brief  Reverse byte order (32 bit)
S
S    This function reverses the byte order in integer value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order (16 bit)
S
S    This function reverses the byte order in two unsigned short values.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV16(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("rev16 %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order in signed short value
S
S    This function reverses the byte order in a signed short value with sign extension to integer.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE int32_t __REVSH(int32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("revsh %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S/** \brief  Rotate Right in unsigned value (32 bit)
S
S    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
S
S    \param [in]    value  Value to rotate
S    \param [in]    value  Number of Bits to rotate
S    \return               Rotated value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
S{
S
S  __ASM volatile ("ror %0, %0, %1" : "+r" (op1) : "r" (op2) );
S  return(op1);
S}
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S
S   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function performs a exclusive LDR command for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __LDREXB(volatile uint8_t *addr)
S{
S    uint8_t result;
S
S   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function performs a exclusive LDR command for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint16_t __LDREXH(volatile uint16_t *addr)
S{
S    uint16_t result;
S
S   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function performs a exclusive LDR command for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
S{
S    uint32_t result;
S
S   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function performs a exclusive STR command for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexb %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function performs a exclusive STR command for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexh %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function performs a exclusive STR command for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __CLREX(void)
S{
S  __ASM volatile ("clrex");
S}
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __SSAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __USAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
S{
S  uint8_t result;
S
S  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all intrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N/*@}*/ /* end of group CMSIS_Definitions */
N
N#endif /* __CORE_CMINSTR_H */
L 117 ".\CMSIS\core_cm0.h" 2
N#include <core_cmFunc.h>                 /* Core Function Access                            */
L 1 ".\CMSIS\core_cmFunc.h" 1
N/**************************************************************************//**
N * @file     core_cmFunc.h
N * @brief    CMSIS Cortex-M Core Function Access Header File
N * @version  V3.01
N * @date     06. March 2012
N *
N * @note
N * Copyright (C) 2009-2012 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifndef __CORE_CMFUNC_H
N#define __CORE_CMFUNC_H
N
N/** @addtogroup CMSIS_Definitions CMSIS
N  @{
N*/
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5060061 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N/** \brief  Get Control Register
N
N    This function returns the content of the Control Register.
N
N    \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/** \brief  Set Control Register
N
N    This function writes the given value to the Control Register.
N
N    \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/** \brief  Get IPSR Register
N
N    This function returns the content of the IPSR Register.
N
N    \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/** \brief  Get APSR Register
N
N    This function returns the content of the APSR Register.
N
N    \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/** \brief  Get xPSR Register
N
N    This function returns the content of the xPSR Register.
N
N    \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/** \brief  Get Process Stack Pointer
N
N    This function returns the current value of the Process Stack Pointer (PSP).
N
N    \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/** \brief  Set Process Stack Pointer
N
N    This function assigns the given value to the Process Stack Pointer (PSP).
N
N    \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/** \brief  Get Main Stack Pointer
N
N    This function returns the current value of the Main Stack Pointer (MSP).
N
N    \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/** \brief  Set Main Stack Pointer
N
N    This function assigns the given value to the Main Stack Pointer (MSP).
N
N    \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/** \brief  Get Priority Mask
N
N    This function returns the current state of the priority mask bit from the Priority Mask Register.
N
N    \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/** \brief  Set Priority Mask
N
N    This function assigns the given value to the Priority Mask Register.
N
N    \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x00) >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S#define __enable_fault_irq                __enable_fiq
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S#define __disable_fault_irq               __disable_fiq
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S__STATIC_INLINE uint32_t  __get_BASEPRI(void)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  return(__regBasePri);
S}
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  __regBasePri = (basePri & 0xff);
S}
S
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S__STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  return(__regFaultMask);
S}
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  __regFaultMask = (faultMask & (uint32_t)1);
S}
S
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N#if       (__CORTEX_M == 0x04)
X#if       ((0x00) == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
S#endif
S}
S
N#endif /* (__CORTEX_M == 0x04) */
N
N
N#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/** \brief  Enable IRQ Interrupts
S
S  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
S{
S  __ASM volatile ("cpsie i");
S}
S
S
S/** \brief  Disable IRQ Interrupts
S
S  This function disables IRQ interrupts by setting the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
S{
S  __ASM volatile ("cpsid i");
S}
S
S
S/** \brief  Get Control Register
S
S    This function returns the content of the Control Register.
S
S    \return               Control Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_CONTROL(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, control" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Control Register
S
S    This function writes the given value to the Control Register.
S
S    \param [in]    control  Control Register value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_CONTROL(uint32_t control)
S{
S  __ASM volatile ("MSR control, %0" : : "r" (control) );
S}
S
S
S/** \brief  Get IPSR Register
S
S    This function returns the content of the IPSR Register.
S
S    \return               IPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get APSR Register
S
S    This function returns the content of the APSR Register.
S
S    \return               APSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_APSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, apsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get xPSR Register
S
S    This function returns the content of the xPSR Register.
S
S    \return               xPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_xPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get Process Stack Pointer
S
S    This function returns the current value of the Process Stack Pointer (PSP).
S
S    \return               PSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Process Stack Pointer
S
S    This function assigns the given value to the Process Stack Pointer (PSP).
S
S    \param [in]    topOfProcStack  Process Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
S{
S  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) );
S}
S
S
S/** \brief  Get Main Stack Pointer
S
S    This function returns the current value of the Main Stack Pointer (MSP).
S
S    \return               MSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_MSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Main Stack Pointer
S
S    This function assigns the given value to the Main Stack Pointer (MSP).
S
S    \param [in]    topOfMainStack  Main Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
S{
S  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) );
S}
S
S
S/** \brief  Get Priority Mask
S
S    This function returns the current state of the priority mask bit from the Priority Mask Register.
S
S    \return               Priority Mask value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, primask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Priority Mask
S
S    This function assigns the given value to the Priority Mask Register.
S
S    \param [in]    priMask  Priority Mask
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
S{
S  __ASM volatile ("MSR primask, %0" : : "r" (priMask) );
S}
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_fault_irq(void)
S{
S  __ASM volatile ("cpsie f");
S}
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_fault_irq(void)
S{
S  __ASM volatile ("cpsid f");
S}
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
S{
S  __ASM volatile ("MSR basepri, %0" : : "r" (value) );
S}
S
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) );
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S#if       (__CORTEX_M == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  uint32_t result;
S
S  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
S  return(result);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) );
S#endif
S}
S
S#endif /* (__CORTEX_M == 0x04) */
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all instrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N/*@}*/ /* end of group CMSIS_Definitions */
N
N#endif /* __CORE_CMFUNC_H */
L 118 ".\CMSIS\core_cm0.h" 2
N
N#endif /* __CORE_CM0_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM0_H_DEPENDANT
N#define __CORE_CM0_H_DEPENDANT
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM0_REV
S    #define __CM0_REV               0x0000
S    #warning "__CM0_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          2
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions                 */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions                 */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions                */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions              */
N
N/*@} end of group Cortex_M0 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N ******************************************************************************/
N/** \defgroup CMSIS_core_register Defines and Type Definitions
N    \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_CORE  Status and Control Registers
N    \brief  Core Register type definitions.
N  @{
N */
N
N/** \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N#if (__CORTEX_M != 0x04)
X#if ((0x00) != 0x04)
N    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
N#else
S    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
N#endif
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} APSR_Type;
N
N
N/** \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} IPSR_Type;
N
N
N/** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N#if (__CORTEX_M != 0x04)
X#if ((0x00) != 0x04)
N    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
N#else
S    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
N#endif
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
N    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} xPSR_Type;
N
N
N/** \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
N    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
N    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} CONTROL_Type;
N
N/*@} end of group CMSIS_CORE */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N    \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IO uint32_t ISER[1];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register           */
X  volatile uint32_t ISER[1];                  
N       uint32_t RESERVED0[31];
N  __IO uint32_t ICER[1];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register          */
X  volatile uint32_t ICER[1];                  
N       uint32_t RSERVED1[31];
N  __IO uint32_t ISPR[1];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register           */
X  volatile uint32_t ISPR[1];                  
N       uint32_t RESERVED2[31];
N  __IO uint32_t ICPR[1];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register         */
X  volatile uint32_t ICPR[1];                  
N       uint32_t RESERVED3[31];
N       uint32_t RESERVED4[64];
N  __IO uint32_t IP[8];                   /*!< Offset: 0x300 (R/W)  Interrupt Priority Register              */
X  volatile uint32_t IP[8];                    
N}  NVIC_Type;
N
N/*@} end of group CMSIS_NVIC */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SCB     System Control Block (SCB)
N    \brief      Type definitions for the System Control Block Registers
N  @{
N */
N
N/** \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPUID Base Register                                   */
X  volatile const  uint32_t CPUID;                    
N  __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register                  */
X  volatile uint32_t ICSR;                     
N       uint32_t RESERVED0;
N  __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register      */
X  volatile uint32_t AIRCR;                    
N  __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register                               */
X  volatile uint32_t SCR;                      
N  __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register                        */
X  volatile uint32_t CCR;                      
N       uint32_t RESERVED1;
N  __IO uint32_t SHP[2];                  /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED   */
X  volatile uint32_t SHP[2];                   
N  __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State Register             */
X  volatile uint32_t SHCSR;                    
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N    \brief      Type definitions for the System Timer Registers.
N  @{
N */
N
N/** \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
X  volatile uint32_t LOAD;                     
N  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
X  volatile uint32_t VAL;                      
N  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
X  volatile const  uint32_t CALIB;                    
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N    \brief      Cortex-M0 Core Debug Registers (DCB registers, SHCSR, and DFSR)
N                are only accessible over DAP and not via processor. Therefore
N                they are not covered by the Cortex-M0 header file.
N  @{
N */
N/*@} end of group CMSIS_CoreDebug */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_core_base     Core Definitions
N    \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Cortex-M0 Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address              */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                 */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct           */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct       */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct          */
N
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/** \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N    \brief      Functions that manage interrupts and exceptions via the NVIC.
N    @{
N */
N
N/* Interrupt Priorities are WORD accessible only under ARMv6M                   */
N/* The following MACROS handle generation of the register offset and byte masks */
N#define _BIT_SHIFT(IRQn)         (  (((uint32_t)(IRQn)       )    &  0x03) * 8 )
N#define _SHP_IDX(IRQn)           ( ((((uint32_t)(IRQn) & 0x0F)-8) >>    2)     )
N#define _IP_IDX(IRQn)            (   ((uint32_t)(IRQn)            >>    2)     )
N
N
N/** \brief  Enable External Interrupt
N
N    The function enables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Disable External Interrupt
N
N    The function disables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Get Pending Interrupt
N
N    The function reads the pending register in the NVIC and returns the pending bit
N    for the specified interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N
N    \return             0  Interrupt status is not pending.
N    \return             1  Interrupt status is pending.
N */
N__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t) ((NVIC->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));
X  return((uint32_t) ((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));
N}
N
N
N/** \brief  Set Pending Interrupt
N
N    The function sets the pending bit of an external interrupt.
N
N    \param [in]      IRQn  Interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Clear Pending Interrupt
N
N    The function clears the pending bit of an external interrupt.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N
N/** \brief  Set Interrupt Priority
N
N    The function sets the priority of an interrupt.
N
N    \note The priority cannot be set for every core interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N    \param [in]  priority  Priority to set.
N */
N__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if(IRQn < 0) {
N    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] = (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] & ~(0xFF << ( (((uint32_t)(IRQn) ) & 0x03) * 8 ))) |
N        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
X        (((priority << (8 - 2)) & 0xFF) << ( (((uint32_t)(IRQn) ) & 0x03) * 8 )); }
N  else {
N    NVIC->IP[_IP_IDX(IRQn)] = (NVIC->IP[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( ((uint32_t)(IRQn) >> 2) )] = (((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( ((uint32_t)(IRQn) >> 2) )] & ~(0xFF << ( (((uint32_t)(IRQn) ) & 0x03) * 8 ))) |
N        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
X        (((priority << (8 - 2)) & 0xFF) << ( (((uint32_t)(IRQn) ) & 0x03) * 8 )); }
N}
N
N
N/** \brief  Get Interrupt Priority
N
N    The function reads the priority of an interrupt. The interrupt
N    number can be positive to specify an external (device specific)
N    interrupt, or negative to specify an internal (core) interrupt.
N
N
N    \param [in]   IRQn  Interrupt number.
N    \return             Interrupt Priority. Value is aligned automatically to the implemented
N                        priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if(IRQn < 0) {
N    return((uint32_t)((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M0 system interrupts */
X    return((uint32_t)((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] >> ( (((uint32_t)(IRQn) ) & 0x03) * 8 ) ) >> (8 - 2)));  }  
N  else {
N    return((uint32_t)((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
X    return((uint32_t)((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[ ( ((uint32_t)(IRQn) >> 2) )] >> ( (((uint32_t)(IRQn) ) & 0x03) * 8 ) ) >> (8 - 2)));  }  
N}
N
N
N/** \brief  System Reset
N
N    The function initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  __DSB();                                                     /* Ensure all outstanding memory accesses included
X  __dsb(0xF);                                                     
N                                                                  buffered write are completed before reset */
N  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = ((0x5FA << 16)      |
N                 SCB_AIRCR_SYSRESETREQ_Msk);
X                 (1UL << 2));
N  __DSB();                                                     /* Ensure completion of memory access */
X  __dsb(0xF);                                                      
N  while(1);                                                    /* wait until reset */
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N    \brief      Functions that configure the System.
N  @{
N */
N
N#if (__Vendor_SysTickConfig == 0)
X#if (0 == 0)
N
N/** \brief  System Tick Configuration
N
N    The function initializes the System Timer and its interrupt, and starts the System Tick Timer.
N    Counter is in free running mode to generate periodic interrupts.
N
N    \param [in]  ticks  Number of ticks between two interrupts.
N
N    \return          0  Function succeeded.
N    \return          1  Function failed.
N
N    \note     When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N    must contain a vendor-specific implementation of this function.
N
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */
X  if (ticks > (0xFFFFFFUL << 0))  return (1);             
N
N  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (ticks & (0xFFFFFFUL << 0)) - 1;       
N  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
X  NVIC_SetPriority (SysTick_IRQn, (1<<2) - 1);   
N  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0;                                           
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1)   |
N                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL << 0);                     
N  return (0);                                                  /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N
N#endif /* __CORE_CM0_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
N
N/*@}*/ /* end of group CMSIS_Definitions */
N
N#ifdef __cplusplus
S}
N#endif
L 112 ".\CMSIS\Mini51Series.h" 2
N#include "system_Mini51Series.h"            /* Mini51 Series System include file                  */
L 1 ".\CMSIS\system_Mini51Series.h" 1
N/**************************************************************************//**
N * @file     system_Mini51Series.h
N * @version  V1.00
N * $Revision: 3 $
N * $Date: 13/10/01 9:05a $ 
N * @brief    Mini51 series system clock definition file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/  
N 
N
N#ifndef __SYSTEM_MINI51SERIES_H__
N#define __SYSTEM_MINI51SERIES_H__
N
N#ifdef __cplusplus
S extern "C" {
N#endif 
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Macro Definition                                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/*----------------------------------------------------------------------------
N  Define SYSCLK
N *----------------------------------------------------------------------------*/
N
N#define __XTAL12M        (12000000UL)
N#define __XTAL32K        (32768UL)
N#define __IRC22M        (22118400UL)
N#define __IRC10K        (10000UL)
N#define __XTAL            __XTAL12M
N#define __HSI            (__IRC22M)      /* Factory Default is internal 22MHz */
N
N
Nextern uint32_t SystemCoreClock;        /*!< System Clock Frequency (Core Clock) */
Nextern uint32_t CyclesPerUs;            /*!< Cycles per micro second */
N
N/**
N * Update SystemCoreClock variable
N *
N * @param  None
N * @return None
N *
N * @brief  Updates the SystemCoreClock with current core Clock 
N *         retrieved from cpu registers.
N */
N
Nextern void SystemCoreClockUpdate (void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif  //__SYSTEM_MINI51SERIES_H__
N
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 113 ".\CMSIS\Mini51Series.h" 2
N#include <stdint.h>
N
N/******************************************************************************/
N/*                Device Specific Peripheral registers structures             */
N/******************************************************************************/
N/** @addtogroup MINI51_Peripherals MINI51 Peripherals
N  MINI51 Device Specific Peripheral registers structures
N  @{
N*/
N
N#if defined ( __CC_ARM  )
X#if 1L
N#pragma anon_unions
N#endif
N
N
N/*---------------------------- Global Controller -----------------------------*/
N
N/** @addtogroup MINI51_GCR MINI51 GCR
N  Memory Mapped Structure for MINI51 Series System Global Controller
N  @{
N */ 
N/**
N  * @brief GCR register map
N  */   
Ntypedef struct
N{
N    /**
N     * PDID
N     * ===================================================================================================
N     * Offset: 0x00  Part Device Identification Number Register.
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |PDID      |This register reflects device part number code. S/W can read this register to identify which device is 
N     * |        |          |used.
N     */
N  __I  uint32_t  PDID;
X  volatile const  uint32_t  PDID;
N
N    /**
N     * RSTSRC
N     * ===================================================================================================
N     * Offset: 0x04  System Reset Source Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:8]  |Reserved  |Reserved
N     * |[7]     |RSTS_CPU  |The RSTS_CPU flag is set by hardware if software writes CPU_RST (IPRSTC1[1]) 1 to reset Cortex-M0 CPU kernel and Flash memory controller (FMC).
N     * |        |          |1 = The Cortex-M0 CPU kernel and FMC are reset by software setting CPU_RST to 1.
N     * |        |          |0 = No reset from CPU
N     * |        |          |Software can write 1 to clear this bit to zero.
N     * |[6]     |Reserved  |Reserved
N     * |[5]     |RSTS_MCU  |The RSTS_MCU flag is set by the "reset signal" from the MCU Cortex_M0 kernel to indicate the previous reset source.
N     * |        |          |1= The MCU Cortex_M0 had issued the reset signal to reset the system by software writing 1 to bit SYSRESTREQ(AIRCR[2], Application Interrupt and Reset Control Register) in system control registers of Cortex_M0 kernel.
N     * |        |          |0= No reset from MCU
N     * |        |          |This bit is cleared by writing 1 to itself.
N     * |[4]     |RSTS_BOD  |The RSTS_BOD flag is set by the "reset signal" from the Brown-Out Detector to indicate the previous reset source.
N     * |        |          |1= The Brown-Out Detector module had issued the reset signal to reset the system.
N     * |        |          |0= No reset from BOD
N     * |        |          |Software can write 1 to clear this bit to zero.
N     * |[3]     |Reserved  |Reserved
N     * |[2]     |RSTS_WDT  |The RSTS_WDT flag is set by the "reset signal" from the Watchdog timer to indicate the previous reset source.
N     * |        |          |1= The Watchdog timer had issued the reset signal to reset the system.
N     * |        |          |0= No reset from Watchdog timer
N     * |        |          |Software can write 1 to clear this bit to zero.
N     * |[1]     |RSTS_RESET|The RSTS_RESET flag is set by the "reset signal" from the /RESET pin to indicate the previous reset source.
N     * |        |          |1= The Pin /RESET had issued the reset signal to reset the system.
N     * |        |          |0= No reset from Pin /RESET
N     * |        |          |Software can write 1 to clear this bit to zero.
N     * |[0]     |RSTS_POR  |The RSTS_POR flag is set by the "reset signal", which is from the Power-On Reset (POR) module or bit CHIP_RST (IPRSTC1[0]) is set, to indicate the previous reset source.
N     * |        |          |1= The Power-On-Reset (POR) or CHIP_RST had issued the reset signal to reset the system.
N     * |        |          |0= No reset from POR or CHIP_RST
N     * |        |          |Software can write 1 to clear this bit to zero.
N     */    
N  __IO uint32_t  RSTSRC;
X  volatile uint32_t  RSTSRC;
N
N    /**
N     * IPRSTC1
N     * ===================================================================================================
N     * Offset: 0x08  Peripheral Reset Control Resister 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CHIP_RST  |CHIP one shot reset.
N     * |        |          |Set this bit will reset the CHIP, including CPU kernel and all peripherals, and this bit will 
N     * |        |          |automatically return to "0" after the 2 clock cycles.
N     * |        |          |The CHIP_RST is same as the POR reset , all the chip module is reset and the chip setting from 
N     * |        |          |flash are also reload
N     * |        |          |This bit is the protected bit, program this need an open lock sequence, write "59h","16h","88h" to 
N     * |        |          |address 0x5000_0100 to un-lock this bit. Reference the register REGWRPROT at address GCR_BA 
N     * |        |          |+ 0x100
N     * |        |          |0= Normal
N     * |        |          |1= Reset CHIP
N     * |[1]     |CPU_RST   |CPU kernel one shot reset.
N     * |        |          |Set this bit will reset the Cortex-M0 CPU kernel and Flash memory controller (FMC). This bit will 
N     * |        |          |automatically return to "0" after the 2 clock cycles
N     * |        |          |This bit is the protected bit, program this need an open lock sequence, write "59h","16h","88h" to 
N     * |        |          |address 0x5000_0100 to un-lock this bit. Reference the register REGWRPROT at address GCR_BA 
N     * |        |          |+ 0x100
N     * |        |          |0= Normal
N     * |        |          |1= Reset CPU
N     */    
N  __IO uint32_t  IPRSTC1;
X  volatile uint32_t  IPRSTC1;
N
N    /**
N     * IPRSTC2
N     * ===================================================================================================
N     * Offset: 0x0C  Peripheral Reset Control Resister 2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |GPIO_RST  |GPIO (P0~P4) controller Reset
N     * |        |          |0= GPIO controller normal operation
N     * |        |          |1= GPIO controller reset
N     * |[2]     |TMR0_RST  |Timer0 controller Reset
N     * |        |          |0= Timer0 controller normal operation
N     * |        |          |1= Timer0 controller reset
N     * |[3]     |TMR1_RST  |Timer1 controller Reset
N     * |        |          |0= Timer1 controller normal operation
N     * |        |          |1= Timer1 controller reset
N     * |[8]     |I2C_RST   |I2C controller Reset
N     * |        |          |0= I2C controller normal operation
N     * |        |          |1= I2C controller reset
N     * |[12]    |SPI_RST   |SPI controller Reset
N     * |        |          |0= SPI controller normal operation
N     * |        |          |1= SPI controller reset
N     * |[16]    |UART_RST  |UART controller Reset
N     * |        |          |0= UART controller Normal operation
N     * |        |          |1= UART controller reset
N     * |[20]    |PWM_RST   |PWM controller Reset
N     * |        |          |0= PWM controller normal operation
N     * |        |          |1= PWM controller reset
N     * |[22]    |ACMP_RST  |ACMP controller Reset
N     * |        |          |0= ACMP controller normal operation
N     * |        |          |1= ACMP controller reset
N     * |[28]    |ADC_RST   |ADC Controller Reset
N     * |        |          |0= ADC controller normal operation
N     * |        |          |1= ADC controller reset
N     */    
N  __IO uint32_t  IPRSTC2;
X  volatile uint32_t  IPRSTC2;
N
N    /**
N     * RESERVED0
N     * ===================================================================================================
N     * 
N     * ---------------------------------------------------------------------------------------------------
N     */    
N       uint32_t  RESERVED0[2];
N
N    /**
N     * BODCR
N     * ===================================================================================================
N     * Offset: 0x18  Brown-Out Detector Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:1]   |BOD_VL    |Brown Out Detector Threshold Voltage Selection (initiated & write-protected bit)
N     * |        |          |The default value is set by flash controller user configuration register config0 bit[22:21]
N     * |        |          |Brown out voltage
N     * |        |          |11 = Disable 2.7V and 3.8V
N     * |        |          |10 = 3.8V
N     * |        |          |01 = 2.7V
N     * |        |          |00 = Reserved
N     * |[3]     |BOD_RSTEN |Brown Out Reset Enable (initiated & write-protected bit)
N     * |        |          |1= Enable the Brown Out "RESET" function, when the Brown Out Detector function is enable 
N     * |        |          |and the detected voltage is lower than the threshold then assert a signal to reset the chip
N     * |        |          |The default value is set by flash controller user configuration register config0 bit[20]
N     * |        |          |0= Enable the Brown Out "INTERRUPT" function, when the Brown Out Detector function is 
N     * |        |          |enable and the detected voltage is lower than the threshold then assert a signal to interrupt 
N     * |        |          |the MCU Cortex-M0
N     * |        |          |When the BOD_EN is enabled and the interrupt is assert, the interrupt will keep till to the 
N     * |        |          |BOD_EN set to "0". The interrupt for CPU can be blocked by disable the NVIC in CPU for BOD 
N     * |        |          |interrupt or disable the interrupt source by disable the BOD_EN and then re-enable the BOD_EN 
N     * |        |          |function if the BOD function is required
N     * |[4]     |BOD_INTF  |Brown Out Detector Interrupt Flag
N     * |        |          |1= When Brown Out Detector detects the VDD is dropped through the voltage of BOD_VL setting 
N     * |        |          |or the VDD is raised up through the voltage of BOD_VL setting, this bit is set to "1" and the 
N     * |        |          |brown out interrupt is requested if brown out interrupt is enabled.
N     * |        |          |0= Brown Out Detector does not detect any voltage draft at VDD down through or up through the 
N     * |        |          |voltage of BOD_VL setting.
N     * |[6]     |BOD_OUT   |The status for Brown Out Detector output state
N     * |        |          |1= Brown Out Detector status output is 1, the detected voltage is lower than BOD_VL setting. If 
N     * |        |          |the BOD_EN is "0"(disabled), this bit always response "0"
N     * |        |          |0= Brown Out Detector status output is 0, the detected voltage is higher than BOD_VL setting
N     */    
N  __IO uint32_t  BODCTL;
X  volatile uint32_t  BODCTL;
N
N    /**
N     * RESERVED1
N     * ===================================================================================================
N     * 
N     * ---------------------------------------------------------------------------------------------------
N     */    
N       uint32_t  RESERVED1[5];
N
N    /**
N     * P0_MFP
N     * ===================================================================================================
N     * Offset: 0x30  P0 Multiple Function and Input Type Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |P0_MFP    |P0 multiple function Selection
N     * |        |          |The pin function of P0 is depending on P0_MFP and P0_ALT.
N     * |        |          |Refer to P0_ALT descriptions in detail.
N     * |[8]     |P0_ALT0   |P0.0 alternate function Selection
N     * |        |          |The pin function of P0.0 is depend on P0_MFP[0] and P0_ALT[0].
N     * |        |          |P0_ALT[0]P0_MFP[0] = P0.0 Function
N     * |        |          |00 = P0.0
N     * |        |          |10 = CTS(UART)
N     * |        |          |11 = TX(UART)
N     * |[9]     |P0_ALT1   |P0.1 alternate function Selection
N     * |        |          |The pin function of P0.1 is depend on P0_MFP[1] and P0_ALT[1].
N     * |        |          |P0_ALT[1] P0_MFP[1] = P0.1 Function
N     * |        |          |00 = P0.1
N     * |        |          |01 = SPISS (SPI)
N     * |        |          |10 = RTS(UART)
N     * |        |          |11 = RX(UART)
N     * |[12]    |P0_ALT4   |P0.4 alternate function Selection
N     * |        |          |The pin function of P0.4 is depend on P0_MFP[4] and P0_ALT[4].
N     * |        |          |P0_ALT[4] P0_MFP[4] = P0.4 Function
N     * |        |          |00 = P0.4
N     * |        |          |01 = Reserved
N     * |        |          |10 = SPISS(SPI)
N     * |        |          |11 = PWM5(PWM)
N     * |[13]    |P0_ALT5   |P0.5 alternate function Selection
N     * |        |          |The pin function of P0.5 is depend on P0_MFP[5] and P0_ALT[5].
N     * |        |          |P0_ALT[5] P0_MFP[5] = P0.5 Function
N     * |        |          |00 = P0.5
N     * |        |          |01 = Reserved
N     * |        |          |10 = MOSI(SPI)
N     * |        |          |11 = Reserved
N     * |[14]    |P0_ALT6   |P0.6 alternate function Selection
N     * |        |          |The pin function of P0.6 is depend on P0_MFP[6] and P0_ALT[6].
N     * |        |          |P0_ALT[6] P0_MFP[6] = P0.6 Function
N     * |        |          |00 = P0.6
N     * |        |          |01 = Reserved
N     * |        |          |10 = MISO(SPI)
N     * |        |          |11 = Reserved
N     * |[15]    |P0_ALT7   |P0.7 alternate function Selection
N     * |        |          |The pin function of P0.7 is depend on P0_MFP[7] and P0_ALT[7].
N     * |        |          |P0_ALT[7] P0_MFP[7] = P0.7 Function
N     * |        |          |00 = P0.7
N     * |        |          |01 = Reserved
N     * |        |          |10 = SPICLK(SPI)
N     * |        |          |11 = Reserved
N     * |[23:16] |P0_TYPEn  |P0[7:0] input Schmitt Trigger function Enable
N     * |        |          |1= P0[7:0] I/O input Schmitt Trigger function enable
N     * |        |          |0= P0[7:0] I/O input Schmitt Trigger function disable 
N     */    
N  __IO uint32_t  P0_MFP;
X  volatile uint32_t  P0_MFP;
N
N    /**
N     * P1_MFP
N     * ===================================================================================================
N     * Offset: 0x34  P1 Multiple Function and Input Type Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |P1_MFP    |P1 multiple function Selection
N     * |        |          |The pin function of P1 is depending on P1_MFP and P1_ALT.
N     * |        |          |Refer to P1_ALT descriptions in detail.
N     * |[8]     |P1_ALT0   |P1.0 alternate function Selection
N     * |        |          |The pin function of P1.0 is depend on P1_MFP[0] and P1_ALT[0].
N     * |        |          |P1_ALT[0] P1_MFP[0] = P1.0 Function
N     * |        |          |00 = P1.0
N     * |        |          |01 = AIN1(ADC)
N     * |        |          |10 = Reserved
N     * |        |          |11 = CPP0 (ACMP)
N     * |[10]    |P1_ALT2   |P1.2 alternate function Selection
N     * |        |          |The pin function of P1.2 is depend on P1_MFP[2] and P1_ALT[2].
N     * |        |          |P1_ALT[2] P1_MFP[2] = P1.2 Function
N     * |        |          |00 = P1.2
N     * |        |          |01 = AIN2(ADC)
N     * |        |          |10 = RX(UART)
N     * |        |          |11 = CPP0 (ACMP)
N     * |[11]    |P1_ALT3   |P1.3 alternate function Selection
N     * |        |          |The pin function of P1.3 is depend on P1_MFP[3] and P1_ALT[3].
N     * |        |          |P1_ALT[3] P1_MFP[3] = P1.3 Function
N     * |        |          |00 = P1.3
N     * |        |          |01 = AIN3(ADC)
N     * |        |          |10 = TX(UART)
N     * |        |          |11 = CPP0 (ACMP)
N     * |[12]    |P1_ALT4   |P1.4 alternate function Selection
N     * |        |          |The pin function of P1.4 is depend on P1_MFP[4] and P1_ALT[4].
N     * |        |          |P1_ALT[4] P1_MFP[4] = P1.4 Function
N     * |        |          |00 = P1.4
N     * |        |          |01 = AIN4(ADC)
N     * |        |          |10 = Reserved
N     * |        |          |11 = CPN0 (CMP)
N     * |[13]    |P1_ALT5   |P1.5 alternate function Selection
N     * |        |          |The pin function of P1.5 is depend on P1_MFP[5] and P1_ALT[5].
N     * |        |          |P1_ALT[5] P1_MFP[5] = P1.5 Function
N     * |        |          |00 = P1.5
N     * |        |          |01 = AIN5(ADC)
N     * |        |          |10 = Reserved
N     * |        |          |11 = CPP0 (CMP)
N     * |[23:16] |P1_TYPEn  |P1[7:0] input Schmitt Trigger function Enable
N     * |        |          |1= P1[7:0] I/O input Schmitt Trigger function enable
N     * |        |          |0= P1[7:0] I/O input Schmitt Trigger function disable 
N     */    
N  __IO uint32_t  P1_MFP;
X  volatile uint32_t  P1_MFP;
N
N    /**
N     * P2_MFP
N     * ===================================================================================================
N     * Offset: 0x38  P2 Multiple Function and Input Type Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |P2_MFP    |P2 multiple function Selection
N     * |        |          |The pin function of P2 is depending on P2_MFP and P2_ALT.
N     * |        |          |Refer to P2_ALT descriptions in detail.
N     * |[10]    |P2_ALT2   |P2.2 alternate function Selection
N     * |        |          |The pin function of P2.2 is depend on P2_MFP[2] and P2_ALT[2].
N     * |        |          |P2_ALT[2] P2_MFP[2] = P2.2 Function
N     * |        |          |00 = P2.2
N     * |        |          |01 = Reserved
N     * |        |          |10 = PWM0(PWM)
N     * |        |          |11 = Reserved
N     * |[11]    |P2_ALT3   |P2.3 alternate function Selection
N     * |        |          |The pin function of P2.3 is depend on P2_MFP[3] and P2_ALT[3].
N     * |        |          |P2_ALT[3] P2_MFP[3] = P2.3 Function
N     * |        |          |00 = P2.3
N     * |        |          |01 = Reserved
N     * |        |          |10 = PWM1(PWM)
N     * |        |          |11 = Reserved
N     * |[12]    |P2_ALT4   |P2.4 alternate function Selection
N     * |        |          |The pin function of P2.4 is depend on P2_MFP[4] and P2_ALT[4].
N     * |        |          |P2_ALT[4] P2_MFP[4] = P0.4 Function
N     * |        |          |00 = P2.4
N     * |        |          |01 = Reserved
N     * |        |          |10 = PWM2(PWM)
N     * |        |          |11 = Reserved
N     * |[13]    |P2_ALT5   |P2.5 alternate function Selection
N     * |        |          |The pin function of P2.5 is depend on P2_MFP[5] and P2_ALT[5].
N     * |        |          |P2_ALT[5] P2_MFP[5] = P2.5 Function
N     * |        |          |00 = P2.5
N     * |        |          |01 = Reserved
N     * |        |          |10 = PWM3(PWM)
N     * |        |          |11 = Reserved
N     * |[14]    |P2_ALT6   |P2.6 alternate function Selection
N     * |        |          |The pin function of P2.6 is depend on P2_MFP[6] and P2_ALT[6].
N     * |        |          |P2_ALT[6] P2_MFP[6] = P2.6 Function
N     * |        |          |00 = P2.6
N     * |        |          |01 = Reserved
N     * |        |          |10 = PWM4(PWM)
N     * |        |          |11 = CPO1
N     * |[23:16] |P2_TYPEn  |P2[7:0] input Schmitt Trigger function Enable
N     * |        |          |1= P2[7:0] I/O input Schmitt Trigger function enable
N     * |        |          |0= P2[7:0] I/O input Schmitt Trigger function disable 
N     */    
N  __IO uint32_t  P2_MFP;
X  volatile uint32_t  P2_MFP;
N
N    /**
N     * P3_MFP
N     * ===================================================================================================
N     * Offset: 0x3C  P3 Multiple Function and Input Type Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |P3_MFP    |P3 multiple function Selection
N     * |        |          |The pin function of P3 is depending on P3_MFP and P3_ALT.
N     * |        |          |Refer to P3_ALT descriptions in detail.
N     * |[8]     |P3_ALT0   |P3.0 alternate function Selection
N     * |        |          |The pin function of P3.0 is depend on P3_MFP[0] and P3_ALT[0].
N     * |        |          |P3_ALT[0] P3_MFP[0] = P3.0 Function
N     * |        |          |00 = P3.0
N     * |        |          |01 = Reserved
N     * |        |          |10 = CPN1
N     * |        |          |11 = AIN6(ADC)
N     * |[9]     |P3_ALT1   |P3.1 alternate function Selection
N     * |        |          |The pin function of P3.1 is depend on P3_MFP[1] and P3_ALT[1].
N     * |        |          |P3_ALT[1] P3_MFP[1] = P3.1 Function
N     * |        |          |00 = P3.1
N     * |        |          |01 = Reserved
N     * |        |          |10 = CPP1
N     * |        |          |11 = AIN7(ADC)
N     * |[10]    |P3_ALT2   |P3.2 alternate function Selection
N     * |        |          |The pin function of P3.2 is depend on P3_MFP[2] and P3_ALT[2].
N     * |        |          |P3_ALT[2] P3_MFP[2] = P3.2 Function
N     * |        |          |00 = P3.2
N     * |        |          |01 = /INT0
N     * |        |          |10 = T0EX
N     * |        |          |11 = STADC(ADC)
N     * |[12]    |P3_ALT4   |P3.4 alternate function Selection
N     * |        |          |The pin function of P3.4 is depend on P3_MFP[4] and P3_ALT[4].
N     * |        |          |P3_ALT[4] P3_MFP[4] = P3.4 Function
N     * |        |          |00 = P3.4
N     * |        |          |01 = T0(Timer0)
N     * |        |          |10 = SDA(I2C)
N     * |        |          |11 = CPP1(ACMP)
N     * |[13]    |P3_ALT5   |P3.5 alternate function Selection
N     * |        |          |The pin function of P3.5 is depend on P3_MFP[5] and P3_ALT[5].
N     * |        |          |P3_ALT[5] P3_MFP[5] = P3.5 Function
N     * |        |          |00 = P3.5
N     * |        |          |01 = T1(Timer1)
N     * |        |          |10 = SCL(I2C)
N     * |        |          |11 = CPP1(ACMP)
N     * |[14]    |P3_ALT6   |P3.6 alternate function Selection
N     * |        |          |The pin function of P3.6 is depend on P3_MFP[6] and P3_ALT[6].
N     * |        |          |P3_ALT[6] P3_MFP[6] = P3.6 Function
N     * |        |          |00 = P3.6
N     * |        |          |01 = T1EX
N     * |        |          |10 = CKO(Clock Driver output)
N     * |        |          |11 = CPO0(CMP)
N     * |[23:16] |P3_TYPEn  |P3[7:0] input Schmitt Trigger function Enable
N     * |        |          |1= P3[7:0] I/O input Schmitt Trigger function enable
N     * |        |          |0= P3[7:0] I/O input Schmitt Trigger function disable 
N     * |[24]    |P32CPP1   |P3.2 Alternate Function Selection Extension
N     * |        |          |0 = P3.2 is set by P3_ALT[2] and P3_MFP[2]
N     * |        |          |1 = P3.2 is set to CPP1 of ACMP1     
N     */    
N  __IO uint32_t  P3_MFP;
X  volatile uint32_t  P3_MFP;
N
N    /**
N     * P4_MFP
N     * ===================================================================================================
N     * Offset: 0x40  P4 Multiple Function and Input Type Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |P4_MFP    |P4 multiple function Selection
N     * |        |          |The pin function of P4 is depending on P4_MFP and P4_ALT.
N     * |        |          |Refer to P4_ALT descriptions in detail.
N     * |[14]    |P4_ALT6   |P4.6 alternate function Selection
N     * |        |          |The pin function of P4.6 is depend on P4_MFP[6] and P4_ALT[6].
N     * |        |          |P4_ALT[6] P4_MFP[6] = P4.6 Function
N     * |        |          |00 = P4.6
N     * |        |          |01 = ICE_CLK(ICE)
N     * |        |          |1x = Reserved
N     * |[15]    |P4_ALT7   |P4.7 alternate function Selection
N     * |        |          |The pin function of P4.7 is depend on P4_MFP[7] and P4_ALT[7].
N     * |        |          |P4_ALT[7] P4_MFP[7] = P4.7 Function
N     * |        |          |00 = P4.7
N     * |        |          |01 = ICE_DAT(ICE)
N     * |        |          |1x = Reserved
N     * |[23:16] |P4_TYPEn  |P4[7:0] input Schmitt Trigger function Enable
N     * |        |          |1= P4[7:0] I/O input Schmitt Trigger function enable
N     * |        |          |0= P4[7:0] I/O input Schmitt Trigger function disable 
N     */    
N  __IO uint32_t  P4_MFP;
X  volatile uint32_t  P4_MFP;
N
N    /**
N     * P5_MFP
N     * ===================================================================================================
N     * Offset: 0x44  P5 Multiple Function and Input Type Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |P5_MFP    |P5 multiple function Selection
N     * |        |          |The pin function of P5 is depending on P5_MFP and P5_ALT.
N     * |        |          |Refer to P5_ALT descriptions in detail.
N     * |[8]     |P5_ALT0   |P5.0 alternate function Selection
N     * |        |          |The pin function of P5.0 is depend on P5_MFP[0] and P5_ALT[0].
N     * |        |          |P5_ALT[0] P5_MFP[0] = P5.0 Function
N     * |        |          |00 = P5.0
N     * |        |          |01 = XTAL1
N     * |        |          |1x = Reserved
N     * |[9]     |P5_ALT1   |P5.1 alternate function Selection
N     * |        |          |The pin function of P5.1 is depend on P5_MFP[1] and P5_ALT[1].
N     * |        |          |P5_ALT[1] P5_MFP[1] = P5.1 Function
N     * |        |          |00 = P5.1
N     * |        |          |01 = XTAL2
N     * |        |          |1x = Reserved
N     * |[10]    |P5_ALT2   |P5.2 alternate function Selection
N     * |        |          |The pin function of P5.2 is depend on P5_MFP[2] and P5_ALT[2].
N     * |        |          |P5_ALT[2] P5_MFP[2] = P5.2 Function
N     * |        |          |00 = P5.2
N     * |        |          |01 = /INT1
N     * |        |          |1x = Reserved
N     * |[11]    |P5_ALT3   |P5.3 alternate function Selection
N     * |        |          |The pin function of P5.3 is depend on P5_MFP[3] and P5_ALT[3].
N     * |        |          |P5_ALT[3] P5_MFP[3] = P5.3 Function
N     * |        |          |00 = P5.3
N     * |        |          |01 = AIN0(ADC)
N     * |        |          |1x = Reserved
N     * |[12]    |P5_ALT4   |P5.4 alternate function Selection
N     * |        |          |The pin function of P5.4 is depend on P5_MFP[4] and P5_ALT[4].
N     * |        |          |P5_ALT[4] P5_MFP[4] = P5.4 Function
N     * |        |          |00 = P5.4
N     * |        |          |01 = Reserved
N     * |        |          |1x = Reserved
N     * |[13]    |P5_ALT5   |P5.5 alternate function Selection
N     * |        |          |The pin function of P5.5 is depend on P5_MFP[5] and P5_ALT[5].
N     * |        |          |P5_ALT[5] P5_MFP[5] = P5.5 Function
N     * |        |          |00 = P5.5
N     * |        |          |01 = Reserved
N     * |        |          |1x = Reserved
N     * |[23:16] |P5_TYPEn  |P5[7:0] input Schmitt Trigger function Enable
N     * |        |          |1= P5[7:0] I/O input Schmitt Trigger function enable
N     * |        |          |0= P5[7:0] I/O input Schmitt Trigger function disable 
N     */    
N  __IO uint32_t  P5_MFP;
X  volatile uint32_t  P5_MFP;
N
N    /**
N     * RESERVED3
N     * ===================================================================================================
N     * 
N     * ---------------------------------------------------------------------------------------------------
N     */    
N       uint32_t  RESERVED3[14];
N
N    /**
N     * IRCTRIMCTL
N     * ===================================================================================================
N     * Offset: 0x80  HIRC Trim Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TRIM_SEL  |Trim Frequency Selection
N     * |        |          |This bit is to enable the HIRC auto trim.
N     * |        |          |When setting this bit to 1, the HFIRC auto trim function will trim HIRC to 22.1184 MHz 
N     * |        |          |automatically based on the 32.768 KHz reference clock.
N     * |        |          |During auto trim operation, if 32.768 KHz clock error is detected or trim retry limitation 
N     * |        |          |count reached, this field will be cleared to 0 automatically.
N     * |        |          |0 = HIRC auto trim function Disabled.
N     * |        |          |1 = HIRC auto trim function Enabled and HIRC trimmed to 22.1184 MHz.
N     * |[5:4]   |TRIM_LOOP |Trim Calculation Loop
N     * |        |          |This field defines trim value calculation based on the number of 32.768 KHz clock.
N     * |        |          |This field also defines how many times the auto trim circuit will try to update the 
N     * |        |          |HIRC trim value before the frequency of HIRC is locked.
N     * |        |          |Once the HIRC is locked, the internal trim value update counter will be reset
N     * |        |          |If the trim value update counter reaches this limitation value and frequency of HIRC 
N     * |        |          |is still not locked, the auto trim operation will be disabled and TRIM_SEL will be cleared to 0.
N     * |        |          |00 = Trim value calculation is based on average difference in 4 32.768 KHz clock and trim retry count limitation is 64.
N     * |        |          |01 = Trim value calculation is based on average difference in 8 32.768 KHz clock and trim retry count limitation is 128.
N     * |        |          |10 = Trim value calculation is based on average difference in 16 32.768 KHz clock and trim retry count limitation is 256.
N     * |        |          |11 = Trim value calculation is based on average difference in 32 32.768 KHz clock and trim retry count limitation is 512.
N     */    
N  __IO uint32_t  IRCTRIMCTL;
X  volatile uint32_t  IRCTRIMCTL;
N
N    /**
N     * IRCTRIMIER
N     * ===================================================================================================
N     * Offset: 0x84  HIRC Trim Interrupt Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field         |Descriptions
N     * | :----: | :----:       | :---- |
N     * |[1]     |TRIM_FAIL_IEN |Trim Failure Interrupt Enable
N     * |        |              |This bit controls if an interrupt will be triggered while HIRC trim value update limitation 
N     * |        |              |count is reached and HIRC frequency is still not locked on target frequency set by TRIM_SEL.
N     * |        |              |If this bit is high and TRIM_FAIL_INT is set during auto trim operation, an interrupt will be 
N     * |        |              |triggered to notify that HFIRC trim value update limitation count is reached.
N     * |        |              |0 = TRIM_FAIL_INT status Disabled to trigger an interrupt to CPU.
N     * |        |              |1 = TRIM_FAIL_INT status Enabled to trigger an interrupt to CPU.
N     * |[2]     |32K_ERR_IEN   |32.768 KHz Clock Error Interrupt Enable
N     * |        |              |This bit controls if CPU could get an interrupt while 32.768 KHz clock is inaccurate during 
N     * |        |              |auto trim operation.
N     * |        |              |If this bit is high, and 32K_ERR_INT is set during auto trim operation, an interrupt will be triggered 
N     * |        |              |to notify the 32.768 KHz clock frequency is inaccurate.
N     * |        |              |0 = 32K_ERR_INT status Disabled to trigger an interrupt to CPU.
N     * |        |              |1 = 32K_ERR_INT status Enabled to trigger an interrupt to CPU.
N     */    
N  __IO uint32_t  IRCTRIMIER;
X  volatile uint32_t  IRCTRIMIER;
N
N    /**
N     * IRCTRIMISR
N     * ===================================================================================================
N     * Offset: 0x88  HIRC Trim Interrupt Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field         |Descriptions
N     * | :----: | :----:       | :---- |
N     * |[0]     |FREQ_LOCK     |HIRC Frequency Lock Status
N     * |        |              |1 = This bit indicates the HIRC frequency lock.
N     * |[1]     |TRIM_FAIL_INT |Trim Failure Interrupt Status
N     * |        |              |This bit indicates that HIRC trim value update limitation count reached and HIRC 
N     * |        |              |clock frequency still doesnt lock. Once this bit is set, the auto trim operation 
N     * |        |              |stopped and TRIM_SEL will be cleared to 0 by hardware automatically.
N     * |        |              |If this bit is set and TRIM_FAIL_IEN is high, an interrupt will be triggered to notify 
N     * |        |              |that HIRC trim value update limitation count was reached. Write 1 to clear this to zero.
N     * |        |              |0 = Trim value update limitation count is not reached.
N     * |        |              |1 = Trim value update limitation count is reached and HFIRC frequency is still not locked.
N     * |[2]     |32K_ERR_INT   |32.768 KHz Clock Error Interrupt Status
N     * |        |              |This bit indicates that 32.768 KHz clock frequency is inaccuracy. Once this bit is set, the 
N     * |        |              |auto trim operation stopped and TRIM_SEL will be cleared to 0 by hardware automatically.
N     * |        |              |If this bit is set and 32K_ERR_IEN is high, an interrupt will be triggered to notify the 
N     * |        |              |32.768 KHz clock frequency is inaccuracy. Write 1 to clear this to zero.
N     * |        |              |0 = 32.768 KHz clock frequency is accuracy.
N     * |        |              |1 = 32.768 KHz clock frequency is inaccuracy.
N     */    
N  __IO uint32_t  IRCTRIMISR;
X  volatile uint32_t  IRCTRIMISR;
N
N    /**
N     * RESERVED4
N     * ===================================================================================================
N     * 
N     * ---------------------------------------------------------------------------------------------------
N     */    
N       uint32_t  RESERVED4[29];
N
N    /**
N     * RegLockAddr
N     * ===================================================================================================
N     * Offset: 0x100 Register Lock Key Address Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RegUnLock |Register Write-Protected Disable index (Read only)
N     * |        |          |1 = Protected registers are Unlock.
N     * |        |          |0 = Protected registers are locked. Any write to the target register is ignored.
N     * |        |          |The Protected registers are:
N     * |        |          |IPRSTC1 0x5000_0008 None
N     * |        |          |BODCR 0x5000_0018 None
N     * |        |          |LDOCR 0x5000_001C None
N     * |        |          |PORCR 0x5000_0024 None
N     * |        |          |PWRCON 0x5000_0200 bit[6] is not protected for power, wake-up interrupt clear
N     * |        |          |APBCLK bit[0] 0x5000_0208 bit[0] is watch dog clock enable
N     * |        |          |CLKSEL0 0x5000_0210 HCLK and CPU STCLK clock source select
N     * |        |          |CLK_SEL1 bit[1:0] 0x5000_0214 Watch dog clock source select
N     * |        |          |ISPCON 0x5000_C000 Flash ISP Control register
N     * |        |          |WTCR 0x4000_4000 None
N     * |        |          |NMI_SEL[8] V address 0x5000_380 (NMI interrupt source enable)
N     */    
N  __IO uint32_t  RegLockAddr;
X  volatile uint32_t  RegLockAddr;
N} GCR_T;
N
N/* GCR RSTSRC Bit Field Definitions */
N#define SYS_RSTSRC_RSTS_CPU_Pos                 7                                       /*!< GCR RSTSRC: RSTS_CPU Position  */
N#define SYS_RSTSRC_RSTS_CPU_Msk                 (1ul << SYS_RSTSRC_RSTS_CPU_Pos)        /*!< GCR RSTSRC: RSTS_CPU Mask      */
N
N#define SYS_RSTSRC_RSTS_MCU_Pos                 5                                       /*!< GCR RSTSRC: RSTS_MCU Position  */
N#define SYS_RSTSRC_RSTS_MCU_Msk                 (1ul << SYS_RSTSRC_RSTS_MCU_Pos)        /*!< GCR RSTSRC: RSTS_MCU Mask      */
N
N#define SYS_RSTSRC_RSTS_BOD_Pos                 4                                       /*!< GCR RSTSRC: RSTS_BOD Position  */
N#define SYS_RSTSRC_RSTS_BOD_Msk                 (1ul << SYS_RSTSRC_RSTS_BOD_Pos)        /*!< GCR RSTSRC: RSTS_BOD Mask      */
N
N#define SYS_RSTSRC_RSTS_WDT_Pos                 2                                       /*!< GCR RSTSRC: RSTS_WDT Position  */
N#define SYS_RSTSRC_RSTS_WDT_Msk                 (1ul << SYS_RSTSRC_RSTS_WDT_Pos)        /*!< GCR RSTSRC: RSTS_WDT Mask      */
N
N#define SYS_RSTSRC_RSTS_RESET_Pos               1                                       /*!< GCR RSTSRC: RSTS_RESET Position    */
N#define SYS_RSTSRC_RSTS_RESET_Msk               (1ul << SYS_RSTSRC_RSTS_RESET_Pos)      /*!< GCR RSTSRC: RSTS_RESET Mask        */
N
N#define SYS_RSTSRC_RSTS_POR_Pos                 0                                       /*!< GCR RSTSRC: RSTS_POR Position  */
N#define SYS_RSTSRC_RSTS_POR_Msk                 (1ul << SYS_RSTSRC_RSTS_POR_Pos)        /*!< GCR RSTSRC: RSTS_POR Mask      */
N
N/* GCR IPRSTC1 Bit Field Definitions */
N#define SYS_IPRSTC1_CPU_RST_Pos                 1                                       /*!< GCR IPRSTC1: CPU_RST Position  */
N#define SYS_IPRSTC1_CPU_RST_Msk                 (1ul << SYS_IPRSTC1_CPU_RST_Pos)        /*!< GCR IPRSTC1: CPU_RST Mask      */
N
N#define SYS_IPRSTC1_CHIP_RST_Pos                0                                       /*!< GCR IPRSTC1: CHIP_RST Position */
N#define SYS_IPRSTC1_CHIP_RST_Msk                (1ul << SYS_IPRSTC1_CHIP_RST_Pos)       /*!< GCR IPRSTC1: CHIP_RST Mask     */
N
N/* GCR IPRSTC2 Bit Field Definitions */
N#define SYS_IPRSTC2_ADC_RST_Pos                 28                                      /*!< GCR IPRSTC2: ADC_RST Position  */
N#define SYS_IPRSTC2_ADC_RST_Msk                 (1ul << SYS_IPRSTC2_ADC_RST_Pos)        /*!< GCR IPRSTC2: ADC_RST Mask      */
N
N#define SYS_IPRSTC2_ACMP_RST_Pos                22                                      /*!< GCR IPRSTC2: ACMP_RST Position */
N#define SYS_IPRSTC2_ACMP_RST_Msk                (1ul << SYS_IPRSTC2_ACMP_RST_Pos)       /*!< GCR IPRSTC2: ACMP_RST Mask     */
N
N#define SYS_IPRSTC2_PWM_RST_Pos                 20                                      /*!< GCR IPRSTC2: PWM_RST Position  */
N#define SYS_IPRSTC2_PWM_RST_Msk                 (1ul << SYS_IPRSTC2_PWM_RST_Pos)        /*!< GCR IPRSTC2: PWM_RST Mask      */
N
N#define SYS_IPRSTC2_UART_RST_Pos                16                                      /*!< GCR IPRSTC2: UART_RST Position */
N#define SYS_IPRSTC2_UART_RST_Msk                (1ul << SYS_IPRSTC2_UART_RST_Pos)       /*!< GCR IPRSTC2: UART_RST Mask     */
N
N#define SYS_IPRSTC2_SPI_RST_Pos                 12                                      /*!< GCR IPRSTC2: SPI_RST Position  */
N#define SYS_IPRSTC2_SPI_RST_Msk                 (1ul << SYS_IPRSTC2_SPI_RST_Pos)        /*!< GCR IPRSTC2: SPI_RST Mask      */
N
N#define SYS_IPRSTC2_I2C_RST_Pos                 8                                       /*!< GCR IPRSTC2: I2C_RST Position  */
N#define SYS_IPRSTC2_I2C_RST_Msk                 (1ul << SYS_IPRSTC2_I2C_RST_Pos)        /*!< GCR IPRSTC2: I2C_RST Mask      */
N
N#define SYS_IPRSTC2_TMR1_RST_Pos                3                                       /*!< GCR IPRSTC2: TMR1_RST Position */
N#define SYS_IPRSTC2_TMR1_RST_Msk                (1ul << SYS_IPRSTC2_TMR1_RST_Pos)       /*!< GCR IPRSTC2: TMR1_RST Mask     */
N
N#define SYS_IPRSTC2_TMR0_RST_Pos                2                                       /*!< GCR IPRSTC2: TMR0_RST Position */
N#define SYS_IPRSTC2_TMR0_RST_Msk                (1ul << SYS_IPRSTC2_TMR0_RST_Pos)       /*!< GCR IPRSTC2: TMR0_RST Mask     */
N
N#define SYS_IPRSTC2_GPIO_RST_Pos                1                                       /*!< GCR IPRSTC2: GPIO_RST Position */
N#define SYS_IPRSTC2_GPIO_RST_Msk                (1ul << SYS_IPRSTC2_GPIO_RST_Pos)       /*!< GCR IPRSTC2: GPIO_RST Mask     */
N
N/* GCR BODCR Bit Field Definitions */
N#define SYS_BODCR_BOD_OUT_Pos                   6                                       /*!< GCR BODCR: BOD_OUT Position    */
N#define SYS_BODCR_BOD_OUT_Msk                   (1ul << SYS_BODCR_BOD_OUT_Pos)          /*!< GCR BODCR: BOD_OUT Mask        */
N
N#define SYS_BODCR_BOD_LPM_Pos                  5                                        /*!< GCR BODCR: BOD_LPM Position    */
N#define SYS_BODCR_BOD_LPM_Msk                  (1ul << SYS_BODCR_BOD_LPM_Pos)           /*!< GCR BODCR: BOD_LPM Mask        */
N
N#define SYS_BODCR_BOD_INTF_Pos                  4                                       /*!< GCR BODCR: BOD_INTF Position   */
N#define SYS_BODCR_BOD_INTF_Msk                  (1ul << SYS_BODCR_BOD_INTF_Pos)         /*!< GCR BODCR: BOD_INTF Mask       */
N
N#define SYS_BODCR_BOD_RSTEN_Pos                 3                                       /*!< GCR BODCR: BOD_RSTEN Position  */
N#define SYS_BODCR_BOD_RSTEN_Msk                 (1ul << SYS_BODCR_BOD_RSTEN_Pos)        /*!< GCR BODCR: BOD_RSTEN Mask      */
N
N#define SYS_BODCR_BOD_VL_Pos                    1                                       /*!< GCR BODCR: BOD_VL Position     */
N#define SYS_BODCR_BOD_VL_Msk                    (3ul << SYS_BODCR_BOD_VL_Pos)           /*!< GCR BODCR: BOD_VL Mask         */
N
N#define SYS_BODCR_BOD_VL_EXT_Pos                0                                       /*!< GCR BODCR: BOD_VL_EXT Position */
N#define SYS_BODCR_BOD_VL_EXT_Msk                (1ul << SYS_BODCR_BOD_VL_EXT_Pos)       /*!< GCR BODCR: BOD_VL_EXT Mask     */
N
N/* GCR P0_MFP Bit Field Definitions */
N#define SYS_P0_MFP_P0_TYPE_Pos                  16                                      /*!< GCR P0_MFP: P0_TYPE Position   */
N#define SYS_P0_MFP_P0_TYPE_Msk                  (0xFFul << SYS_P0_MFP_P0_TYPE_Pos)      /*!< GCR P0_MFP: P0_TYPE Mask       */
N
N#define SYS_P0_MFP_P0_ALT_Pos                   8                                       /*!< GCR P0_MFP: P0_ALT Position    */
N#define SYS_P0_MFP_P0_ALT_Msk                   (0xFFul << SYS_P0_MFP_P0_ALT_Pos)       /*!< GCR P0_MFP: P0_ALT Mask        */
N
N#define SYS_P0_MFP_P0_MFP_Pos                   0                                       /*!< GCR P0_MFP: P0_MFP Position    */
N#define SYS_P0_MFP_P0_MFP_Msk                   (0xFFul << SYS_P0_MFP_P0_MFP_Pos)       /*!< GCR P0_MFP: P0_MFP Mask        */
N
N/* GCR P1_MFP Bit Field Definitions */
N#define SYS_P1_MFP_P1_TYPE_Pos                  16                                      /*!< GCR P1_MFP: P1_TYPE Position   */
N#define SYS_P1_MFP_P1_TYPE_Msk                  (0xFFul << SYS_P1_MFP_P1_TYPE_Pos)      /*!< GCR P1_MFP: P1_TYPE Mask       */
N
N#define SYS_P1_MFP_P1_ALT_Pos                   8                                       /*!< GCR P1_MFP: P1_ALT Position    */
N#define SYS_P1_MFP_P1_ALT_Msk                   (0xFFul << SYS_P1_MFP_P1_ALT_Pos)       /*!< GCR P1_MFP: P1_ALT Mask        */
N
N#define SYS_P1_MFP_P1_MFP_Pos                   0                                       /*!< GCR P1_MFP: P1_MFP Position    */
N#define SYS_P1_MFP_P1_MFP_Msk                   (0xFFul << SYS_P1_MFP_P1_MFP_Pos)       /*!< GCR P1_MFP: P1_MFP Mask        */
N
N/* GCR P2_MFP Bit Field Definitions */
N#define SYS_P2_MFP_P2_TYPE_Pos                  16                                      /*!< GCR P2_MFP: P2_TYPE Position   */
N#define SYS_P2_MFP_P2_TYPE_Msk                  (0xFFul << SYS_P2_MFP_P2_TYPE_Pos)      /*!< GCR P2_MFP: P2_TYPE Mask       */
N
N#define SYS_P2_MFP_P2_ALT_Pos                   8                                       /*!< GCR P2_MFP: P2_ALT Position    */
N#define SYS_P2_MFP_P2_ALT_Msk                   (0xFFul << SYS_P2_MFP_P2_ALT_Pos)       /*!< GCR P2_MFP: P2_ALT Mask        */
N
N#define SYS_P2_MFP_P2_MFP_Pos                   0                                       /*!< GCR P2_MFP: P2_MFP Position    */
N#define SYS_P2_MFP_P2_MFP_Msk                   (0xFFul << SYS_P2_MFP_P2_MFP_Pos)       /*!< GCR P2_MFP: P2_MFP Mask        */
N
N/* GCR P3_MFP Bit Field Definitions */
N#define SYS_P3_MFP_P3_TYPE_Pos                  16                                      /*!< GCR P3_MFP: P3_TYPE Position   */
N#define SYS_P3_MFP_P3_TYPE_Msk                  (0xFFul << SYS_P3_MFP_P3_TYPE_Pos)      /*!< GCR P3_MFP: P3_TYPE Mask       */
N
N#define SYS_P3_MFP_P3_ALT_Pos                   8                                       /*!< GCR P3_MFP: P3_ALT Position    */
N#define SYS_P3_MFP_P3_ALT_Msk                   (0xFFul << SYS_P3_MFP_P3_ALT_Pos)       /*!< GCR P3_MFP: P3_ALT Mask        */
N
N#define SYS_P3_MFP_P3_MFP_Pos                   0                                       /*!< GCR P3_MFP: P3_MFP Position    */
N#define SYS_P3_MFP_P3_MFP_Msk                   (0xFFul << SYS_P3_MFP_P3_MFP_Pos)       /*!< GCR P3_MFP: P3_MFP Mask        */
N
N/* GCR P4_MFP Bit Field Definitions */
N#define SYS_P4_MFP_P4_TYPE_Pos                  16                                      /*!< GCR P4_MFP: P4_TYPE Position   */
N#define SYS_P4_MFP_P4_TYPE_Msk                  (0xFFul << SYS_P4_MFP_P4_TYPE_Pos)      /*!< GCR P4_MFP: P4_TYPE Mask       */
N
N#define SYS_P4_MFP_P4_ALT_Pos                   8                                       /*!< GCR P4_MFP: P4_ALT Position    */
N#define SYS_P4_MFP_P4_ALT_Msk                   (0xFFul << SYS_P4_MFP_P4_ALT_Pos)       /*!< GCR P4_MFP: P4_ALT Mask        */
N
N#define SYS_P4_MFP_P4_MFP_Pos                   0                                       /*!< GCR P4_MFP: P4_MFP Position    */
N#define SYS_P4_MFP_P4_MFP_Msk                   (0xFFul << SYS_P4_MFP_P4_MFP_Pos)       /*!< GCR P4_MFP: P4_MFP Mask        */
N
N/* GCR P5_MFP Bit Field Definitions */
N#define SYS_P5_MFP_P5_TYPE_Pos                  16                                      /*!< GCR P5_MFP: P5_TYPE Position   */
N#define SYS_P5_MFP_P5_TYPE_Msk                  (0xFFul << SYS_P5_MFP_P5_TYPE_Pos)      /*!< GCR P5_MFP: P5_TYPE Mask       */
N
N#define SYS_P5_MFP_P5_ALT_Pos                   8                                       /*!< GCR P5_MFP: P5_ALT Position    */
N#define SYS_P5_MFP_P5_ALT_Msk                   (0xFFul << SYS_P5_MFP_P5_ALT_Pos)       /*!< GCR P5_MFP: P5_ALT Mask        */
N
N#define SYS_P5_MFP_P5_MFP_Pos                   0                                       /*!< GCR P5_MFP: P5_MFP Position    */
N#define SYS_P5_MFP_P5_MFP_Msk                   (0xFFul << SYS_P5_MFP_P5_MFP_Pos)       /*!< GCR P5_MFP: P5_MFP Mask        */
N
N/* GCR IRCTRIMCTL Bit Field Definitions */
N#define SYS_IRCTRIMCTL_TRIM_LOOP_Pos            3                                       /*!< GCR IRCTRIMCTL: TRIM_LOOP Position */
N#define SYS_IRCTRIMCTL_TRIM_LOOP_Msk            (0x3ul << SYS_IRCTRIMCTL_TRIM_LOOP_Pos) /*!< GCR IRCTRIMCTL: TRIM_LOOP Mask     */
N
N#define SYS_IRCTRIMCTL_TRIM_SEL_Pos             0                                       /*!< GCR IRCTRIMCTL: TRIM_SEL Position  */
N#define SYS_IRCTRIMCTL_TRIM_SEL_Msk             (0x1ul << SYS_IRCTRIMCTL_TRIM_SEL_Pos)  /*!< GCR IRCTRIMCTL: TRIM_SEL Mask      */
N
N/* GCR IRCTRIMIEN Bit Field Definitions */
N#define SYS_IRCTRIMIEN_32K_ERR_IEN_Pos          2                                         /*!< GCR IRCTRIMIEN: 32K_ERR_IEN Position     */
N#define SYS_IRCTRIMIEN_32K_ERR_IEN_Msk          (0x1ul << SYS_IRCTRIMIEN_32K_ERR_IEN_Pos) /*!< GCR IRCTRIMIEN: 32K_ERR_IEN Mask         */
N
N#define SYS_IRCTRIMIEN_TRIM_FAIL_IEN_Pos        1                                         /*!< GCR IRCTRIMIEN: TRIM_FAIL_IEN Position   */
N#define SYS_IRCTRIMIEN_TRIM_FAIL_IEN_Msk        (0x1ul << SYS_IRCTRIMIEN_TRIM_FAIL_IEN_Pos)/*!< GCR IRCTRIMIEN: TRIM_FAIL_IEN Mask      */
N
N/* GCR IRCTRIMINT Bit Field Definitions */
N#define SYS_IRCTRIMINT_32K_ERR_INT_Pos          2                                         /*!< GCR IRCTRIMINT: 32K_ERR_INT Position */
N#define SYS_IRCTRIMINT_32K_ERR_INT_Msk          (0x1ul << SYS_IRCTRIMINT_32K_ERR_IEN_Pos) /*!< GCR IRCTRIMINT: 32K_ERR_INT Mask     */
N
N#define SYS_IRCTRIMINT_TRIM_FAIL_INT_Pos        1                                         /*!< GCR IRCTRIMINT: TRIM_FAIL_INT Position   */
N#define SYS_IRCTRIMINT_TRIM_FAIL_INT_Msk        (0x1ul << SYS_IRCTRIMINT_TRIM_FAIL_IEN_Pos)/*!< GCR IRCTRIMINT: TRIM_FAIL_INT Mask      */
N
N#define SYS_IRCTRIMINT_FREQ_LOCK_Pos            0                                         /*!< GCR IRCTRIMINT: FREQ_LOCK Position   */
N#define SYS_IRCTRIMINT_FREQ_LOCK_Msk            (0x1ul << SYS_IRCTRIMINT_FREQ_LOCK_Pos)   /*!< GCR IRCTRIMINT: FREQ_LOCK Mask       */
N
N/* GCR RegLockAddr Bit Field Definitions */
N#define SYS_RegLockAddr_RegUnLock_Pos           0                                         /*!< GCR RegLockAddr: RegUnLock Position  */
N#define SYS_RegLockAddr_RegUnLock_Msk           (0x1ul << SYS_RegLockAddr_RegUnLock_Pos)  /*!< GCR RegLockAddr: RegUnLock Mask      */
N
N/*@}*/ /* end of group MINI51_GCR */
N
N
N/*---------------------------- Clock Controller ------------------------------*/
N
N/** @addtogroup MINI51_CLK MINI51 Clock Controller
N  Memory Mapped Structure for MINI51 Series Clock Controller
N  @{
N */ 
N/**
N  * @brief CLK register map
N  */   
Ntypedef struct
N{
N    /**
N     * PWRCON
N     * ===================================================================================================
N     * Offset: 0x00  System Power Down Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field       |Descriptions
N     * | :----: | :----:     | :---- |
N     * |[1:0]   |XTLCLK_EN   |External Crystal Oscillator Control
N     * |        |            |The default clock source is from internal 22.1184 MHz. These two bits are default set to 00 
N     * |             |                         |and the XTAL1 and XTAL2 pins are GPIO.
N     * |        |            |00 = XTAL1 and XTAL2 are GPIO, disable both XTL32K & XTAL12M 
N     * |        |            |01 = XTAL12M (HXT) Enabled 
N     * |        |            |10 = XTAL32K (LXT) Enabled 
N     * |        |            |11 = XTAL1 is external clock input pin, XTAL2 is GPIO 
N     * |        |            |Note: To enable external XTAL function, P5_ALT[1:0] and P5_MFP[1:0] bits must also be set in P5_MFP.
N     * |[2]     |OSC22M_EN   |Internal 22.1184 MHz Oscillator Control
N     * |        |            |1 = 22.1184 MHz Oscillation enable 
N     * |        |            |0 = 22.1184 MHz Oscillation disable 
N     * |[3]     |OSC10K_EN   |Internal 10KHz Oscillator Control
N     * |        |            |1 = 10KHz Oscillation enable 
N     * |        |            |0 = 10KHz Oscillation disable 
N     * |[4]     |PU_DLY      |Enable the wake up delay counter.
N     * |        |            |When the chip wakes up from power down mode, the clock control will delay certain clock 
N     * |        |            |cycles to wait system clock stable.
N     * |        |            |The delayed clock cycle is 4096 clock cycles when chip work at external crystal (4 ~ 
N     * |        |            |24MHz), and 256 clock cycles when chip work at 22.1184 MHz oscillator.
N     * |        |            |1 = Enable the clock cycle delay
N     * |        |            |0 = Disable the clock cycle delay
N     * |[5]     |WINT_EN     |Power down mode wake Up Interrupt Enable
N     * |        |            |0 = Disable
N     * |        |            |1 = Enable. The interrupt will occur when Power down mode wakeup.
N     * |[6]     |PD_WU_STS   |Chip power down wake up status flag
N     * |        |            |Set by "power down wake up", it indicates that resume from power down mode 
N     * |        |            |The flag is set if the GPIO, UART, WDT, ACMP, Timer or BOD wakeup
N     * |        |            |Write 1 to clear the bit 
N     * |        |            |Note: This bit is working only if PD_WU_INT_EN (PWRCON[5]) set to 1. 
N     * |[7]     |PWR_DOWN    |System Power-down Active or Enable Bit
N     * |        |            |When chip waked-up from power-down, this bit is automatically cleared, and user needs to set  
N     * |        |            |this bit again for the next power-down.
N     * |        |            |In Power-down mode, the LDO, external crystal and the 22.1184 MHz OSC will be disabled, and 
N     * |        |            |the 10K enable is not controlled by this bit.
N     * |        |            |Note: If XTLCLK_EN[1:0] = 10 (enable 32 KHz External Crystal Oscillator) and when PWR_DOWN_EN =1 (system entering
N     * |        |            | Power-down mode), the external crystal oscillator cannot be disabled to ensure system wake-up enabled.
N     * |        |            |When power down, all of the AMBA clocks (HCLKx, CPU clock and the PCLKx) are also disabled, and the clock 
N     * |        |            |source selection is ignored. The IP engine clock is not controlled by this bit if the IP clock source is from 
N     * |        |            |the 10K clock and the WDT from 10K).
N     * |        |            |1 = Chip entering the Power-down mode instantly or wait CPU Idle command
N     * |        |            |0 = Chip operated in Normal mode or CPU enters into Idle mode.
N     * |[9]     |PD_32K      |This bit controls the crystal oscillator active or not in Power-down mode.
N     * |        |            |1 = If XTLCLK_EN[1:0] = 10, 32.768 KHz crystal oscillator (LXT) is still active in Power-down mode.
N     * |        |            |0 = No effect to Power-down mode
N     */    
N  __IO uint32_t  PWRCON;
X  volatile uint32_t  PWRCON;
N
N    /**
N     * AHBCLK
N     * ===================================================================================================
N     * Offset: 0x04  AHB Devices Clock Enable Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2]     |ISP_EN    |Flash ISP Controller Clock Enable Control.
N     * |        |          |1 = To enable the Flash ISP controller clock.
N     * |        |          |0 = To disable the Flash ISP controller clock.
N     */    
N  __IO uint32_t  AHBCLK;
X  volatile uint32_t  AHBCLK;
N
N    /**
N     * APBCLK
N     * ===================================================================================================
N     * Offset: 0x08  APB Devices Clock Enable Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |WDT_EN    |Watch Dog Timer Clock Enable.
N     * |        |          |This bit is the protected bit, program this need a open lock sequence, write "59h","16h","88h" to 
N     * |        |          |address 0x5000_0100 to un-lock this bit. Reference the register REGWRPROT at address 
N     * |        |          |GCR_BA + 0x100
N     * |        |          |0 = Disable Watchdog Timer Clock
N     * |        |          |1 = Enable Watchdog Timer Clock
N     * |[2]     |TMR0_EN   |Timer0 Clock Enable Control
N     * |        |          |0 = Disable Timer0 Clock
N     * |        |          |1 = Enable Timer0 Clock
N     * |[3]     |TMR1_EN   |Timer1 Clock Enable Control
N     * |        |          |0 = Disable Timer1 Clock
N     * |        |          |1 = Enable Timer1 Clock
N     * |[6]     |FDIV_EN   |Clock Divider Clock Enable Control
N     * |        |          |0 = Disable FDIV Clock
N     * |        |          |1 = Enable FDIV Clock
N     * |[8]     |I2C_EN    |I2C Clock Enable Control. 
N     * |        |          |0 = Disable I2C Clock
N     * |        |          |1 = Enable I2C Clock
N     * |[12]    |SPI_EN    |SPI Clock Enable Control. 
N     * |        |          |0 = Disable SPI Clock
N     * |        |          |1 = Enable SPI Clock
N     * |[16]    |UART_EN   |UART Clock Enable Control.
N     * |        |          |1 = Enable UART clock
N     * |        |          |0 = Disable UART clock
N     * |[20]    |PWM01_EN  |PWM_01 Clock Enable Control.
N     * |        |          |1 = Enable PWM01 clock
N     * |        |          |0 = Disable PWM01 clock
N     * |[21]    |PWM23_EN  |PWM_23 Clock Enable Control.
N     * |        |          |1 = Enable PWM23 clock
N     * |        |          |0 = Disable PWM23 clock
N     * |[22]    |PWM45_EN  |PWM_45 Clock Enable Control.
N     * |        |          |1 = Enable PWM45 clock
N     * |        |          |0 = Disable PWM45 clock
N     * |[28]    |ADC_EN    |Analog-Digital-Converter (ADC) Clock Enable Control.
N     * |        |          |1 = Enable ADC clock
N     * |        |          |0 = Disable ADC clock
N     * |[30]    |CMP_EN    |Comparator Clock Enable Control.
N     * |        |          |1 = Enable Analog Comparator clock
N     * |        |          |0 = Disable Analog Comparator clock
N     */    
N  __IO uint32_t  APBCLK;
X  volatile uint32_t  APBCLK;
N
N    /**
N     * CLKSTATUS
N     * ===================================================================================================
N     * Offset: 0x0C  Clock Status Monitor Register 
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field      |Descriptions
N     * | :----: | :----:    | :---- |
N     * |[0]     |XTL_STB    |XTL12M or XTL32K clock source stable flag
N     * |        |           |1 = External Crystal clock is stable
N     * |        |           |0 = External Crystal clock is not stable or not enable
N     * |[3]     |OSC10K_STB |OSC10K clock source stable flag
N     * |        |           |1 = OSC10K clock is stable
N     * |        |           |0 = OSC10K clock is not stable or not enable
N     * |[4]     |OSC22M_STB |OSC22M clock source stable flag
N     * |        |           |1 = OSC22M clock is stable
N     * |        |           |0 = OSC22M clock is not stable or not enable
N     * |[7]     |CLK_SW_FAIL|Clock switch fail flag
N     * |        |           |1 = Clock switch fail
N     * |        |           |0 = Clock switch success
N     * |        |           |This bit will be set when target switch clock source is not stable. Write 1 to clear this bit to zero.
N     */    
N  __IO uint32_t  CLKSTATUS;
X  volatile uint32_t  CLKSTATUS;
N
N    /**
N     * CLKSEL0
N     * ===================================================================================================
N     * Offset: 0x10  Clock Source Select Control Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |HCLK_S    |HCLK clock source select.
N     * |        |          |Note:
N     * |        |          |1.    Before clock switch the related clock sources (pre-select and new-select) must be turn on
N     * |        |          |2.    These bits are protected bit, program this need an open lock sequence, write 
N     * |        |          |"59h","16h","88h" to address 0x5000_0100 to un-lock this bit. Reference the register 
N     * |        |          |REGWRPROT at address GCR_BA + 0x100
N     * |        |          |3.  To set PWRCON[1:0] to select 12 MHz or 32 KHz crystal clock.
N     * |        |          |000 = Clock source from external 12 MHz or 32 KHz crystal clock.
N     * |        |          |011 = clock source from internal 10KHz oscillator clock
N     * |        |          |111 = clock source from internal 22.1184 MHz oscillator clock
N     * |        |          |others = Reserved
N     * |[5:3]   |STCLK_S   |MCU Cortex_M0 SysTick clock source select.
N     * |        |          |These bits are protected bit, program this need an open lock sequence, write "59h","16h","88h" to 
N     * |        |          |address 0x5000_0100 to un-lock this bit. Reference the register REGWRPROT at address GCR_BA 
N     * |        |          |+ 0x100
N     * |        |          |000 = Clock source from 12 MHz or 32 KHz crystal clock
N     * |        |          |010 = Clock source from 12 MHz or 32 KHz crystal clock/2
N     * |        |          |011 = clock source from HCLK/2
N     * |        |          |111 = clock source from internal 22.1184 MHz oscillator clock/2
N     * |        |          |others = Reserved
N     * |        |          |Note: To set PWRCON[1:0] to select 12 MHz or 32 KHz crystal clock.
N     */    
N  __IO uint32_t  CLKSEL0;
X  volatile uint32_t  CLKSEL0;
N
N    /**
N     * CLKSEL1
N     * ===================================================================================================
N     * Offset: 0x14  Clock Source Select Control Register 1 
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |WDT_S     |Watchdog Timer clock source select.
N     * |        |          |These bits are protected bit, program this need a open lock sequence, write "59h","16h","88h" to 
N     * |        |          |address 0x5000_0100 to un-lock this bit. Reference the register REGWRPROT at address 
N     * |        |          |GCR_BA + 0x100
N     * |        |          |00 = Clock source from external 12 MHz or 32 KHz crystal clock.
N     * |        |          |10 = clock source from HCLK/2048 clock
N     * |        |          |11 = clock source from internal 10KHz oscillator clock
N     * |[3:2]   |ADC_S     |ADC clock source select.
N     * |        |          |00 = Clock source from external 12 MHz or 32 KHz crystal clock.
N     * |        |          |10 = clock source from HCLK
N     * |        |          |11 = clock source from internal 22.1184 MHz oscillator clock
N     * |[10:8]  |TMR0_S    |TIMER0 clock source select.
N     * |        |          |000 = Clock source from external 12 MHz or 32 KHz crystal clock
N     * |        |          |001 = Clock source from internal 10 KHz oscillator clock.
N     * |        |          |010 = clock source from HCLK
N     * |        |          |011 = clock source from external trigger
N     * |        |          |111 = clock source from internal 22.1184 MHz oscillator clock
N     * |[14:12] |TMR1_S    |TIMER1 clock source select.
N     * |        |          |000 = Clock source from external 12 MHz or 32 KHz crystal clock
N     * |        |          |001 = Clock source from internal 10 KHz oscillator clock.
N     * |        |          |010 = clock source from HCLK
N     * |        |          |011 = clock source from external trigger
N     * |        |          |111 = clock source from internal 22.1184 MHz oscillator clock
N     * |[25:24] |UART_S    |UART clock source select.
N     * |        |          |00 = Clock source from external 12 MHz or 32 KHz crystal clock
N     * |        |          |10 = clock source from internal 22.1184 MHz oscillator clock
N     * |[29:28] |PWM01_S   |PWM0 and PWM1 clock source select.
N     * |        |          |PWM0 and PWM1 uses the same Engine clock source, both of them with the same pre-scalar
N     * |        |          |10 = clock source from HCLK
N     * |        |          |others = Reserved
N     * |[31:30] |PWM23_S   |PWM2 and PWM3 clock source select.
N     * |        |          |PWM2 and PWM3 uses the same Engine clock source, both of them with the same pre-scalar
N     * |        |          |10 = clock source from HCLK
N     * |        |          |others = Reserved
N     */    
N  __IO uint32_t  CLKSEL1;
X  volatile uint32_t  CLKSEL1;
N
N    /**
N     * CLKDIV
N     * ===================================================================================================
N     * Offset: 0x18  Clock Divider Number Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |HCLK_N    |HCLK clock divide number from HCLK clock source
N     * |        |          |The HCLK clock frequency = (HCLK clock source frequency) / (HCLK_N + 1)
N     * |[11:8]  |UART_N    |UART clock divide number from UART clock source
N     * |        |          |The UART clock frequency = (UART clock source frequency ) / (UART_N + 1)
N     * |[23:16] |ADC_N     |ADC clock divide number from ADC clock source
N     * |        |          |The ADC clock frequency = (ADC clock source frequency ) / (ADC_N + 1)
N     */    
N  __IO uint32_t  CLKDIV;
X  volatile uint32_t  CLKDIV;
N
N    /**
N     * CLKSEL2
N     * ===================================================================================================
N     * Offset: 0x1C  Clock Source Select Control Register 2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:2]   |FRQDIV_S  |Clock Divider Clock Source Select
N     * |        |          |00 = Clock source from external 12 MHz or 32 KHz crystal clock
N     * |        |          |10 = clock source from HCLK
N     * |        |          |11 = clock source from internal 22.1184 MHz oscillator clock
N     * |[5:4]   |PWM45_S   |PWM4 and PWM5 clock source select. - PWM4 and PWM5 used the same Engine clock source, 
N     * |        |          |both of them with the same pre-scalar
N     * |        |          |10 = clock source from HCLK
N     * |        |          |others = Reserved
N     */    
N  __IO uint32_t  CLKSEL2;
X  volatile uint32_t  CLKSEL2;
N    /**
N     * Reserved
N     */
N       uint32_t  RESERVED0; 
N
N    /**
N     * FRQDIV
N     * ===================================================================================================
N     * Offset: 0x24  Frequency Divider Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |FSEL      |Divider Output Frequency Selection Bits
N     * |        |          |The formula of output frequency is
N     * |        |          |Fout = Fin/2^(N+1), 
N     * |        |          |where Fin is the input clock frequency, Fout is the frequency of divider output clock, N is the 4-bit 
N     * |        |          |value of FSEL[3:0].
N     * |[4]     |DIVIDER_EN|Frequency Divider Enable Bit
N     * |        |          |0 = Disable Frequency Divider
N     * |        |          |1 = Enable Frequency Divider
N     */    
N  __IO uint32_t  FRQDIV;
X  volatile uint32_t  FRQDIV;
N} CLK_T;
N
N/* CLK PWRCON Bit Field Definitions */
N#define CLK_PWRCON_PD_32K_Pos                9                                       /*!< CLK PWRCON: PD_32K Position   */
N#define CLK_PWRCON_PD_32K_Msk                (1ul << CLK_PWRCON_PD_32K_Pos)          /*!< CLK PWRCON: PD_32K Mask       */
N
N#define CLK_PWRCON_PWR_DOWN_EN_Pos           7                                       /*!< CLK PWRCON: PWR_DOWN_EN Position  */
N#define CLK_PWRCON_PWR_DOWN_EN_Msk           (1ul << CLK_PWRCON_PWR_DOWN_EN_Pos)     /*!< CLK PWRCON: PWR_DOWN_EN Mask      */
N
N#define CLK_PWRCON_PD_WU_STS_Pos             6                                       /*!< CLK PWRCON: PD_WU_STS Position    */
N#define CLK_PWRCON_PD_WU_STS_Msk             (1ul << CLK_PWRCON_PD_WU_STS_Pos)       /*!< CLK PWRCON: PD_WU_STS Mask        */
N
N#define CLK_PWRCON_WINT_EN_Pos               5                                       /*!< CLK PWRCON: WINT_EN Position  */
N#define CLK_PWRCON_WINT_EN_Msk               (1ul << CLK_PWRCON_WINT_EN_Pos)         /*!< CLK PWRCON: WINT_EN Mask      */
N
N#define CLK_PWRCON_WU_DLY_Pos                4                                       /*!< CLK PWRCON: WU_DLY Position   */
N#define CLK_PWRCON_WU_DLY_Msk                (1ul << CLK_PWRCON_WU_DLY_Pos)          /*!< CLK PWRCON: WU_DLY Mask       */
N
N#define CLK_PWRCON_OSC10K_EN_Pos             3                                       /*!< CLK PWRCON: OSC10K_EN Position    */
N#define CLK_PWRCON_OSC10K_EN_Msk             (1ul << CLK_PWRCON_OSC10K_EN_Pos)       /*!< CLK PWRCON: OSC10K_EN Mask        */
N#define CLK_PWRCON_IRC10K_EN_Pos             3                                       /*!< CLK PWRCON: OSC10K_EN Position    */
N#define CLK_PWRCON_IRC10K_EN_Msk             (1ul << CLK_PWRCON_OSC10K_EN_Pos)       /*!< CLK PWRCON: OSC10K_EN Mask        */
N
N#define CLK_PWRCON_OSC22M_EN_Pos             2                                       /*!< CLK PWRCON: OSC22M_EN Position    */
N#define CLK_PWRCON_OSC22M_EN_Msk             (1ul << CLK_PWRCON_OSC22M_EN_Pos)       /*!< CLK PWRCON: OSC22M_EN Mask        */
N#define CLK_PWRCON_IRC22M_EN_Pos             2                                       /*!< CLK PWRCON: OSC22M_EN Position    */
N#define CLK_PWRCON_IRC22M_EN_Msk             (1ul << CLK_PWRCON_OSC22M_EN_Pos)       /*!< CLK PWRCON: OSC22M_EN Mask        */
N
N#define CLK_PWRCON_XTLCLK_EN_Pos             0                                       /*!< CLK PWRCON: XTLCLK_EN Position    */
N#define CLK_PWRCON_XTLCLK_EN_Msk             (3ul << CLK_PWRCON_XTLCLK_EN_Pos)       /*!< CLK PWRCON: XTLCLK_EN Mask        */
N
N/* CLK AHBCLK Bit Field Definitions */
N#define CLK_AHBCLK_ISP_EN_Pos                2                                       /*!< CLK AHBCLK: ISP_EN Position   */
N#define CLK_AHBCLK_ISP_EN_Msk                (1ul << CLK_AHBCLK_ISP_EN_Pos)          /*!< CLK AHBCLK: ISP_EN Mask       */
N
N/* CLK APBCLK Bit Field Definitions */
N#define CLK_APBCLK_CMP_EN_Pos                30                                      /*!< CLK APBCLK: CMP_EN Position   */
N#define CLK_APBCLK_CMP_EN_Msk                (1ul << CLK_APBCLK_CMP_EN_Pos)          /*!< CLK APBCLK: CMP_EN Mask       */
N
N#define CLK_APBCLK_ADC_EN_Pos                28                                      /*!< CLK APBCLK: ADC_EN Position   */
N#define CLK_APBCLK_ADC_EN_Msk                (1ul << CLK_APBCLK_ADC_EN_Pos)          /*!< CLK APBCLK: ADC_EN Mask       */
N
N#define CLK_APBCLK_PWM45_EN_Pos              22                                      /*!< CLK APBCLK: PWM45_EN Position */
N#define CLK_APBCLK_PWM45_EN_Msk              (1ul << CLK_APBCLK_PWM45_EN_Pos)        /*!< CLK APBCLK: PWM45_EN Mask     */
N
N#define CLK_APBCLK_PWM23_EN_Pos              21                                      /*!< CLK APBCLK: PWM23_EN Position */
N#define CLK_APBCLK_PWM23_EN_Msk              (1ul << CLK_APBCLK_PWM23_EN_Pos)        /*!< CLK APBCLK: PWM23_EN Mask     */
N
N#define CLK_APBCLK_PWM01_EN_Pos              20                                      /*!< CLK APBCLK: PWM01_EN Position */
N#define CLK_APBCLK_PWM01_EN_Msk              (1ul << CLK_APBCLK_PWM01_EN_Pos)        /*!< CLK APBCLK: PWM01_EN Mask     */
N
N#define CLK_APBCLK_UART_EN_Pos               16                                      /*!< CLK APBCLK: UART_EN Position  */
N#define CLK_APBCLK_UART_EN_Msk               (1ul << CLK_APBCLK_UART_EN_Pos)         /*!< CLK APBCLK: UART_EN Mask      */
N
N#define CLK_APBCLK_SPI_EN_Pos                12                                      /*!< CLK APBCLK: SPI_EN Position   */
N#define CLK_APBCLK_SPI_EN_Msk                (1ul << CLK_APBCLK_SPI_EN_Pos)          /*!< CLK APBCLK: SPI_EN Mask       */
N
N#define CLK_APBCLK_I2C_EN_Pos                8                                       /*!< CLK APBCLK: I2C_EN Position   */
N#define CLK_APBCLK_I2C_EN_Msk                (1ul << CLK_APBCLK_I2C_EN_Pos)          /*!< CLK APBCLK: I2C_EN Mask       */
N
N#define CLK_APBCLK_FDIV_EN_Pos               6                                       /*!< CLK APBCLK: FDIV_EN Position  */
N#define CLK_APBCLK_FDIV_EN_Msk               (1ul << CLK_APBCLK_FDIV_EN_Pos)         /*!< CLK APBCLK: FDIV_EN Mask      */
N
N#define CLK_APBCLK_TMR1_EN_Pos               3                                       /*!< CLK APBCLK: TMR1_EN Position  */
N#define CLK_APBCLK_TMR1_EN_Msk               (1ul << CLK_APBCLK_TMR1_EN_Pos)         /*!< CLK APBCLK: TMR1_EN Mask      */
N                                                
N#define CLK_APBCLK_TMR0_EN_Pos               2                                       /*!< CLK APBCLK: TMR0_EN Position  */
N#define CLK_APBCLK_TMR0_EN_Msk               (1ul << CLK_APBCLK_TMR0_EN_Pos)         /*!< CLK APBCLK: TMR0_EN Mask      */
N
N#define CLK_APBCLK_WDT_EN_Pos                0                                       /*!< CLK APBCLK: WDT_EN Position   */
N#define CLK_APBCLK_WDT_EN_Msk                (1ul << CLK_APBCLK_WDT_EN_Pos)          /*!< CLK APBCLK: WDT_EN Mask       */
N
N/* CLK CLKSTATUS Bit Field Definitions */
N#define CLK_CLKSTATUS_CLK_SW_FAIL_Pos        7                                       /*!< CLK CLKSTATUS: CLK_SW_FAIL Position   */
N#define CLK_CLKSTATUS_CLK_SW_FAIL_Msk        (1ul << CLK_CLKSTATUS_CLK_SW_FAIL_Pos)  /*!< CLK CLKSTATUS: CLK_SW_FAIL Mask       */
N
N#define CLK_CLKSTATUS_OSC22M_STB_Pos         4                                       /*!< CLK CLKSTATUS: OSC22M_STB Position    */
N#define CLK_CLKSTATUS_OSC22M_STB_Msk         (1ul << CLK_CLKSTATUS_OSC22M_STB_Pos)   /*!< CLK CLKSTATUS: OSC22M_STB Mask        */
N#define CLK_CLKSTATUS_IRC22M_STB_Pos         4                                       /*!< CLK CLKSTATUS: OSC22M_STB Position    */
N#define CLK_CLKSTATUS_IRC22M_STB_Msk         (1ul << CLK_CLKSTATUS_OSC22M_STB_Pos)   /*!< CLK CLKSTATUS: OSC22M_STB Mask        */
N
N#define CLK_CLKSTATUS_OSC10K_STB_Pos         3                                       /*!< CLK CLKSTATUS: OSC10K_STB Position    */
N#define CLK_CLKSTATUS_OSC10K_STB_Msk         (1ul << CLK_CLKSTATUS_OSC10K_STB_Pos)   /*!< CLK CLKSTATUS: OSC10K_STB Mask        */
N#define CLK_CLKSTATUS_IRC10K_STB_Pos         3                                       /*!< CLK CLKSTATUS: OSC10K_STB Position    */
N#define CLK_CLKSTATUS_IRC10K_STB_Msk         (1ul << CLK_CLKSTATUS_OSC10K_STB_Pos)   /*!< CLK CLKSTATUS: OSC10K_STB Mask        */
N
N#define CLK_CLKSTATUS_XTL_STB_Pos            0                                       /*!< CLK CLKSTATUS: XTL_STB Position   */
N#define CLK_CLKSTATUS_XTL_STB_Msk            (1ul << CLK_CLKSTATUS_XTL_STB_Pos)      /*!< CLK CLKSTATUS: XTL_STB Mask       */
N
N/* CLK CLKSEL0 Bit Field Definitions */
N#define CLK_CLKSEL0_STCLK_S_Pos              3                                       /*!< CLK CLKSEL0: STCLK_S Position */
N#define CLK_CLKSEL0_STCLK_S_Msk              (7ul << CLK_CLKSEL0_STCLK_S_Pos)        /*!< CLK CLKSEL0: STCLK_S Mask     */
N
N#define CLK_CLKSEL0_HCLK_S_Pos               0                                       /*!< CLK CLKSEL0: HCLK_S Position  */
N#define CLK_CLKSEL0_HCLK_S_Msk               (7ul << CLK_CLKSEL0_HCLK_S_Pos)         /*!< CLK CLKSEL0: HCLK_S Mask      */
N
N/* CLK CLKSEL1 Bit Field Definitions */
N#define CLK_CLKSEL1_PWM23_S_Pos              30                                      /*!< CLK CLKSEL1: PWM23_S Position */
N#define CLK_CLKSEL1_PWM23_S_Msk              (3ul << CLK_CLKSEL1_PWM23_S_Pos)        /*!< CLK CLKSEL1: PWM23_S Mask     */
N
N#define CLK_CLKSEL1_PWM01_S_Pos              28                                      /*!< CLK CLKSEL1: PWM01_S Position */
N#define CLK_CLKSEL1_PWM01_S_Msk              (3ul << CLK_CLKSEL1_PWM01_S_Pos)        /*!< CLK CLKSEL1: PWM01_S Mask     */
N
N#define CLK_CLKSEL1_UART_S_Pos               24                                      /*!< CLK CLKSEL1: UART_S Position  */
N#define CLK_CLKSEL1_UART_S_Msk               (3ul << CLK_CLKSEL1_UART_S_Pos)         /*!< CLK CLKSEL1: UART_S Mask      */
N
N#define CLK_CLKSEL1_TMR1_S_Pos               12                                      /*!< CLK CLKSEL1: TMR1_S Position  */
N#define CLK_CLKSEL1_TMR1_S_Msk               (7ul << CLK_CLKSEL1_TMR1_S_Pos)         /*!< CLK CLKSEL1: TMR1_S Mask      */
N
N#define CLK_CLKSEL1_TMR0_S_Pos               8                                       /*!< CLK CLKSEL1: TMR0_S Position  */
N#define CLK_CLKSEL1_TMR0_S_Msk               (7ul << CLK_CLKSEL1_TMR0_S_Pos)         /*!< CLK CLKSEL1: TMR0_S Mask      */
N
N#define CLK_CLKSEL1_ADC_S_Pos                2                                       /*!< CLK CLKSEL1: ADC_S Position   */
N#define CLK_CLKSEL1_ADC_S_Msk                (3ul << CLK_CLKSEL1_ADC_S_Pos)          /*!< CLK CLKSEL1: ADC_S Mask       */
N
N#define CLK_CLKSEL1_WDT_S_Pos                0                                       /*!< CLK CLKSEL1: WDT_S Position   */
N#define CLK_CLKSEL1_WDT_S_Msk                (3ul << CLK_CLKSEL1_WDT_S_Pos)          /*!< CLK CLKSEL1: WDT_S Mask       */
N
N/* CLK CLKSEL2 Bit Field Definitions */
N#define CLK_CLKSEL2_PWM45_S_Pos              4                                       /*!< CLK CLKSEL2: PWM45_S Position */
N#define CLK_CLKSEL2_PWM45_S_Msk              (3ul << CLK_CLKSEL2_PWM45_S_Pos)        /*!< CLK CLKSEL2: PWM45_S Mask     */
N
N#define CLK_CLKSEL2_FRQDIV_S_Pos             2                                       /*!< CLK CLKSEL2: FRQDIV_S Position    */
N#define CLK_CLKSEL2_FRQDIV_S_Msk             (3ul << CLK_CLKSEL2_FRQDIV_S_Pos)       /*!< CLK CLKSEL2: FRQDIV_S Mask        */
N
N/* CLK CLKDIV Bit Field Definitions */
N#define CLK_CLKDIV_ADC_N_Pos                 16                                      /*!< CLK CLKDIV: ADC_N Position        */
N#define CLK_CLKDIV_ADC_N_Msk                 (0xFFul << CLK_CLKDIV_ADC_N_Pos)        /*!< CLK CLKDIV: ADC_N Mask            */
N
N#define CLK_CLKDIV_UART_N_Pos                8                                       /*!< CLK CLKDIV: UART_N Position       */
N#define CLK_CLKDIV_UART_N_Msk                (0xFul << CLK_CLKDIV_UART_N_Pos)        /*!< CLK CLKDIV: UART_N Mask           */
N
N#define CLK_CLKDIV_HCLK_N_Pos                0                                       /*!< CLK CLKDIV: HCLK_N Position       */
N#define CLK_CLKDIV_HCLK_N_Msk                (0xFul << CLK_CLKDIV_HCLK_N_Pos)        /*!< CLK CLKDIV: HCLK_N Mask           */
N
N/* CLK FRQDIV Bit Field Definitions */
N#define CLK_FRQDIV_DIVIDER1_Pos              5                                       /*!< CLK FRQDIV: DIVIDER1 Position     */
N#define CLK_FRQDIV_DIVIDER1_Msk              (1ul << CLK_FRQDIV_DIVIDER_EN_Pos)      /*!< CLK FRQDIV: DIVIDER1 Mask         */
N
N#define CLK_FRQDIV_DIVIDER_EN_Pos            4                                       /*!< CLK FRQDIV: DIVIDER_EN Position   */
N#define CLK_FRQDIV_DIVIDER_EN_Msk            (1ul << CLK_FRQDIV_DIVIDER_EN_Pos)      /*!< CLK FRQDIV: DIVIDER_EN Mask       */
N
N#define CLK_FRQDIV_FSEL_Pos                  0                                       /*!< CLK FRQDIV: FSEL Position         */
N#define CLK_FRQDIV_FSEL_Msk                  (0xFul << CLK_FRQDIV_FSEL_Pos)          /*!< CLK FRQDIV: FSEL Mask             */
N
N/*@}*/ /* end of group MINI51_CLK */
N
N
N/*---------------------- Analog Comparator Controller -------------------------*/
N/** @addtogroup MINI51_ACMP MINI51 ACMP
N  Memory Mapped Structure for MINI51 Series ACMP Controller
N  @{
N */
N/**
N  * @brief ACMP register map
N  */   
Ntypedef struct
N{
N  __IO uint32_t  CMPCR[2];      /*!< Offset: 0x0000, 0x0004   Comparator Contro 0 & 1                 */
X  volatile uint32_t  CMPCR[2];       
N  __IO uint32_t  CMPSR;         /*!< Offset: 0x0008   Comparator Status Register                      */
X  volatile uint32_t  CMPSR;          
N  __IO uint32_t  CMPRVCR;       /*!< Offset: 0x000C   Comparator Reference Voltage Control Register   */
X  volatile uint32_t  CMPRVCR;        
N} ACMP_T; 
N
N/* CMPCR Bit Field Definitions */
N#define ACMP_CMPCR_CPPSEL_Pos        29                                        /*!< ACMP CMPCR: CPPSEL Position     */
N#define ACMP_CMPCR_CPPSEL_Msk        (3ul << ACMP_CMPCR_CPPSEL_Pos)            /*!< ACMP CMPCR: CPPSEL Mask         */
N
N#define ACMP_CMPCR_FALLING_Pos       9                                         /*!< ACMP CMPCR: FALLING Position    */
N#define ACMP_CMPCR_FALLING_Msk       (1ul << ACMP_CMPCR_FALLING_Pos)           /*!< ACMP CMPCR: FALLING Mask        */
N
N#define ACMP_CMPCR_RISING_Pos       8                                          /*!< ACMP CMPCR: RISING Position     */
N#define ACMP_CMPCR_RISING_Msk       (1ul << ACMP_CMPCR_RISING_Pos)             /*!< ACMP CMPCR: RISING Mask         */
N
N#define ACMP_CMPCR_NEGSEL_Pos       4                                          /*!< ACMP CMPCR: NEGSEL Position     */
N#define ACMP_CMPCR_NEGSEL_Msk       (1ul << ACMP_CMPCR_NEGSEL_Pos)             /*!< ACMP CMPCR: NEGSEL Mask         */
N
N#define ACMP_CMPCR_HYSEN_Pos        2                                          /*!< ACMP CMPCR: HYSEN Position      */
N#define ACMP_CMPCR_HYSEN_Msk        (1ul << ACMP_CMPCR_HYSEN_Pos)              /*!< ACMP CMPCR: HYSEN Mask          */
N
N#define ACMP_CMPCR_ACMPIE_Pos       1                                          /*!< ACMP CMPCR: ACMPIE Position     */
N#define ACMP_CMPCR_ACMPIE_Msk       (1ul << ACMP_CMPCR_ACMPIE_Pos)             /*!< ACMP CMPCR: ACMPIE Mask         */
N
N#define ACMP_CMPCR_ACMPEN_Pos       0                                          /*!< ACMP CMPCR: ACMPEN Position     */
N#define ACMP_CMPCR_ACMPEN_Msk       (1ul << ACMP_CMPCR_ACMPEN_Pos)             /*!< ACMP CMPCR: ACMPEN Mask         */
N
N/* CMPSR Bit Field Definitions */
N#define ACMP_CMPSR_ACMPCO1_Pos      3                                          /*!< ACMP CMPSR: ACMPCO1 Position    */
N#define ACMP_CMPSR_ACMPCO1_Msk      (1ul << ACMP_CMPSR_ACMPCO1_Pos)            /*!< ACMP CMPSR: ACMPCO1 Mask        */
N
N#define ACMP_CMPSR_ACMPCO0_Pos      2                                          /*!< ACMP CMPSR: ACMPCO0 Position    */
N#define ACMP_CMPSR_ACMPCO0_Msk      (1ul << ACMP_CMPSR_ACMPCO0_Pos)            /*!< ACMP CMPSR: ACMPCO0 Mask        */
N
N#define ACMP_CMPSR_ACMPF1_Pos       1                                          /*!< ACMP CMPSR: ACMPF1 Position     */
N#define ACMP_CMPSR_ACMPF1_Msk       (1ul << ACMP_CMPSR_ACMPF1_Pos)             /*!< ACMP CMPSR: ACMPF1 Mask         */
N
N#define ACMP_CMPSR_ACMPF0_Pos       0                                          /*!< ACMP CMPSR: ACMPF0 Position     */
N#define ACMP_CMPSR_ACMPF0_Msk       (1ul << ACMP_CMPSR_ACMPF0_Pos)             /*!< ACMP CMPSR: ACMPF0 Mask         */
N
N#define ACMP_CMPRVCR_OUT_SEL_Pos    7                                          /*!< ACMP CMPRVCR: OUT_SEL Position  */
N#define ACMP_CMPRVCR_OUT_SEL_Msk    (1ul << ACMP_CMPRVCR_OUT_SEL_Pos)          /*!< ACMP CMPRVCR: OUT_SEL Mask      */
N
N#define ACMP_CMPRVCR_CRVS_Pos       0                                          /*!< ACMP CMPRVCR: CRVS Position     */
N#define ACMP_CMPRVCR_CRVS_Msk       (0xFul << ACMP_CMPRVCR_CRVS_Pos)           /*!< ACMP CMPRVCR: CRVS Mask         */
N
N/*@}*/ /* end of group MINI51_ACMP */
N
N
N/*----------------------------- ADC Controller -------------------------------*/
N
N/** @addtogroup MINI51_ADC MINI51 ADC
N  Memory Mapped Structure for MINI51 Series ADC Controller
N  @{
N */ 
N/**
N  * @brief ADC register map
N  */   
Ntypedef struct
N{
N  __IO uint32_t  ADDR;           /*!< Offset: 0x0000   A/D Data Register                    */
X  volatile uint32_t  ADDR;            
N       uint32_t  RESERVED0[7];   /*!< Offset: 0x0004 ~ 0x001C   Reserved                    */
N  __IO uint32_t  ADCR;           /*!< Offset: 0x0020   A/D Control Register                 */
X  volatile uint32_t  ADCR;            
N  __IO uint32_t  ADCHER;         /*!< Offset: 0x0024   A/D Channel Enable Register          */
X  volatile uint32_t  ADCHER;          
N  __IO uint32_t  ADCMPR[2];      /*!< Offset: 0x0028, 0x002C   A/D Compare Register 0 & 1   */
X  volatile uint32_t  ADCMPR[2];       
N  __IO uint32_t  ADSR;           /*!< Offset: 0x0030   A/D Status Register                  */
X  volatile uint32_t  ADSR;            
N  __IO uint32_t  ADTDCR;         /*!< Offset: 0x0044   A/D Trigger Delay Control Register   */
X  volatile uint32_t  ADTDCR;          
N  __IO uint32_t  ADSAMP;         /*!< Offset: 0x0048   ADC Sampling Time Counter Register   */  
X  volatile uint32_t  ADSAMP;            
N} ADC_T; 
N
N/* ADDR Bit Field Definitions */
N#define ADC_ADDR_VALID_Pos      17                                      /*!< ADC ADDR: VALID Position       */
N#define ADC_ADDR_VALID_Msk      (1ul << ADC_ADDR_VALID_Pos)             /*!< ADC ADDR: VALID Mask           */
N
N#define ADC_ADDR_OVERRUN_Pos    16                                      /*!< ADC ADDR: OVERRUN Position     */
N#define ADC_ADDR_OVERRUN_Msk    (1ul << ADC_ADDR_OVERRUN_Pos)           /*!< ADC ADDR: OVERRUN Mask         */
N
N#define ADC_ADDR_RSLT_Pos       0                                       /*!< ADC ADDR: RSLT Position        */
N#define ADC_ADDR_RSLT_Msk       (0x3FFul << ADC_ADDR_RSLT_Pos)          /*!< ADC ADDR: RSLT Mask            */
N
N/* ADCR Bit Field Definitions */
N#define ADC_ADCR_ADST_Pos       11                                      /*!< ADC ADCR: ADST Position        */
N#define ADC_ADCR_ADST_Msk       (1ul << ADC_ADCR_ADST_Pos)              /*!< ADC ADCR: ADST Mask            */
N
N#define ADC_ADCR_TRGEN_Pos      8                                       /*!< ADC ADCR: TRGEN Position       */
N#define ADC_ADCR_TRGEN_Msk      (1ul << ADC_ADCR_TRGEN_Pos)             /*!< ADC ADCR: TRGEN Mask           */
N
N#define ADC_ADCR_TRGCOND_Pos    6                                       /*!< ADC ADCR: TRGCOND Position     */
N#define ADC_ADCR_TRGCOND_Msk    (1ul << ADC_ADCR_TRGCOND_Pos)           /*!< ADC ADCR: TRGCOND Mask         */
N
N#define ADC_ADCR_TRGS_Pos       4                                       /*!< ADC ADCR: TRGS Position        */
N#define ADC_ADCR_TRGS_Msk       (3ul << ADC_ADCR_TRGS_Pos)              /*!< ADC ADCR: TRGS Mask            */
N
N#define ADC_ADCR_ADIE_Pos       1                                       /*!< ADC ADCR: ADIE Position        */
N#define ADC_ADCR_ADIE_Msk       (1ul << ADC_ADCR_ADIE_Pos)              /*!< ADC ADCR: ADIE Mask            */
N
N#define ADC_ADCR_ADEN_Pos       0                                       /*!< ADC ADCR: ADEN Position        */
N#define ADC_ADCR_ADEN_Msk       (1ul << ADC_ADCR_ADEN_Pos)              /*!< ADC ADCR: ADEN Mask            */
N
N/* ADCHER Bit Field Definitions */
N#define ADC_ADCHER_PRESEL_Pos   8                                       /*!< ADC ADCHER: PRESEL Position    */
N#define ADC_ADCHER_PRESEL_Msk   (1ul << ADC_ADCHER_PRESEL_Pos)          /*!< ADC ADCHER: PRESEL Mask        */
N
N#define ADC_ADCHER_CHEN_Pos     0                                       /*!< ADC ADCHER: CHEN Position      */
N#define ADC_ADCHER_CHEN_Msk     (0xFFul << ADC_ADCHER_CHEN_Pos)         /*!< ADC ADCHER: CHEN Mask          */
N
N/* ADCMPR Bit Field Definitions */
N#define ADC_ADCMPR_CMPD_Pos        16                                    /*!< ADC ADCMPR: CMPD Position     */
N#define ADC_ADCMPR_CMPD_Msk        (0x3FFul << ADC_ADCMPR_CMPD_Pos)      /*!< ADC ADCMPR: CMPD Mask         */
N
N#define ADC_ADCMPR_CMPMATCNT_Pos   8                                     /*!< ADC ADCMPR: CMPMATCNT Position    */
N#define ADC_ADCMPR_CMPMATCNT_Msk   (0xFul << ADC_ADCMPR_CMPMATCNT_Pos)   /*!< ADC ADCMPR: CMPMATCNT Mask        */
N
N#define ADC_ADCMPR_CMPCH_Pos       3                                     /*!< ADC ADCMPR: CMPCH Position    */
N#define ADC_ADCMPR_CMPCH_Msk       (7ul << ADC_ADCMPR_CMPCH_Pos)         /*!< ADC ADCMPR: CMPCH Mask        */
N
N#define ADC_ADCMPR_CMPCOND_Pos     2                                     /*!< ADC ADCMPR: CMPCOND Position  */
N#define ADC_ADCMPR_CMPCOND_Msk     (1ul << ADC_ADCMPR_CMPCOND_Pos)       /*!< ADC ADCMPR: CMPCOND Mask      */
N
N#define ADC_ADCMPR_CMPIE_Pos       1                                     /*!< ADC ADCMPR: CMPIE Position    */
N#define ADC_ADCMPR_CMPIE_Msk       (1ul << ADC_ADCMPR_CMPIE_Pos)         /*!< ADC ADCMPR: CMPIE Mask        */
N
N#define ADC_ADCMPR_CMPEN_Pos       0                                     /*!< ADC ADCMPR: CMPEN Position    */
N#define ADC_ADCMPR_CMPEN_Msk       (1ul << ADC_ADCMPR_CMPEN_Pos)         /*!< ADC ADCMPR: CMPEN Mask        */
N
N/* ADSR Bit Field Definitions */
N#define ADC_ADSR_OVERRUN_Pos       16                                    /*!< ADC ADSR: OVERRUN Position    */
N#define ADC_ADSR_OVERRUN_Msk       (0xFFul << ADC_ADSR_OVERRUN_Pos)      /*!< ADC ADSR: OVERRUN Mask        */
N
N#define ADC_ADSR_VALID_Pos         8                                     /*!< ADC ADSR: VALID Position      */
N#define ADC_ADSR_VALID_Msk         (0xFFul << ADC_ADSR_VALID_Pos)        /*!< ADC ADSR: VALID Mask          */
N
N#define ADC_ADSR_CHANNEL_Pos       4                                     /*!< ADC ADSR: CHANNEL Position    */
N#define ADC_ADSR_CHANNEL_Msk       (7ul << ADC_ADSR_CHANNEL_Pos)         /*!< ADC ADSR: CHANNEL Mask        */
N
N#define ADC_ADSR_BUSY_Pos          3                                     /*!< ADC ADSR: BUSY Position       */
N#define ADC_ADSR_BUSY_Msk          (1ul << ADC_ADSR_BUSY_Pos)            /*!< ADC ADSR: BUSY Mask           */
N
N#define ADC_ADSR_CMPF1_Pos         2                                     /*!< ADC ADSR: CMPF1 Position      */
N#define ADC_ADSR_CMPF1_Msk         (1ul << ADC_ADSR_CMPF1_Pos)           /*!< ADC ADSR: CMPF1 Mask          */
N
N#define ADC_ADSR_CMPF0_Pos         1                                     /*!< ADC ADSR: CMPF0 Position      */
N#define ADC_ADSR_CMPF0_Msk         (1ul << ADC_ADSR_CMPF0_Pos)           /*!< ADC ADSR: CMPF0 Mask          */
N
N#define ADC_ADSR_ADF_Pos           0                                     /*!< ADC ADSR: ADF Position        */
N#define ADC_ADSR_ADF_Msk           (1ul << ADC_ADSR_ADF_Pos)             /*!< ADC ADSR: ADF Mask            */
N
N/* ADTDCR Bit Field Definitions */
N#define ADC_ADTDCR_PTDT_Pos        0                                     /*!< ADC ADTDCR: PTDT Position     */
N#define ADC_ADTDCR_PTDT_Msk        (0xFFul << ADC_ADTDCR_PTDT_Pos)       /*!< ADC ADTDCR: PTDT Mask         */
N
N/* ADSAMP Bit Field Definitions */
N#define ADC_ADSAMP_SAMPCNT_Pos     0                                     /*!< ADC ADSAMP: SAMPCNT Position */
N#define ADC_ADSAMP_SAMPCNT_Msk     (0xFul << ADC_ADTDCR_PTDT_Pos)        /*!< ADC ADSAMP: SAMPCNT Mask     */
N
N/*@}*/ /* end of group MINI51_ADC */
N
N
N/*-------------------------- FLASH Memory Controller -------------------------*/
N
N/** @addtogroup MINI51_FMC MINI51 FMC
N  Memory Mapped Structure for MINI51 Series Flash Memory Controller
N  @{
N */ 
N/**
N  * @brief FMC register map
N  */   
Ntypedef struct
N{
N    /**
N     * ISPCON
N     * ===================================================================================================
N     * Offset: 0x00  ISP Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ISPEN     |ISP Enable
N     * |        |          |ISP function enable bit. Set this bit to enable ISP function.
N     * |        |          |1 = Enable ISP function
N     * |        |          |0 = Disable ISP function
N     * |[1]     |BS        |Boot Select 
N     * |        |          |Set/clear this bit to select next booting from LDROM/APROM, respectively. 
N     * |        |          |This bit also functions as MCU booting status flag, which can be used to 
N     * |        |          |check where MCU booted from. This bit is initiated with the inversed value 
N     * |        |          |of CBS in Config0 after power-on reset; It keeps the same value at other reset.
N     * |        |          |1 = Boot from LDROM
N     * |        |          |0 = Boot from APROM
N     * |[4]     |CFGUEN    |Enable Config-bits Update by ISP 
N     * |        |          |1 = Enable ISP can update config-bits 
N     * |        |          |0 = Disable ISP can update config-bits.
N     * |[5]     |LDUEN     |LDROM Update Enable
N     * |        |          |LDROM update enable bit. 
N     * |        |          |1 = LDROM can be updated when the MCU runs in APROM.
N     * |        |          |0 = LDROM cannot be updated
N     * |[6]     |ISPFF     |ISP Fail Flag
N     * |        |          |This bit is set by hardware when a triggered ISP meets any of the following conditions:
N     * |        |          |(1) APROM writes to itself.
N     * |        |          |(2) LDROM writes to itself. 
N     * |        |          |(3) CONFIG is erased/programmed when the MCU is running in APROM.
N     * |        |          |(4) Destination address is illegal, such as over an available range.
N     * |        |          |Write 1 to clear.
N     * |[7]     |SWRST     |Software Reset
N     * |        |          |Writing 1 to this bit to start software reset. 
N     * |        |          |It is cleared by hardware after reset is finished.
N     * |[10:8]  |PT        |Flash Program Time
N     * |        |          |000 = 40 us
N     * |        |          |001 = 45 us
N     * |        |          |010 = 50 us
N     * |        |          |011 = 55 us
N     * |        |          |100 = 20 us
N     * |        |          |101 = 25 us
N     * |        |          |110 = 30 us
N     * |        |          |111 = 35 us
N     * |[14:12] |ET        |Flash Erase Time
N     * |        |          |000 = 20 ms (default)
N     * |        |          |001 = 25 ms 
N     * |        |          |010 = 30 ms 
N     * |        |          |011 = 35 ms 
N     * |        |          |100 = 3  ms 
N     * |        |          |101 = 5  ms 
N     * |        |          |110 = 10 ms 
N     * |        |          |111 = 15 ms 
N     */    
N    __IO uint32_t ISPCON;
X    volatile uint32_t ISPCON;
N
N    /**
N     * ISPADR
N     * ===================================================================================================
N     * Offset: 0x04  ISP Address Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |ISPADR    |ISP Address 
N     * |        |          |NuMicro MINI51TM series supports word program only. ISPADR[1:0] must be kept 
N     * |        |          |00b for ISP operation. 
N     */    
N    __IO uint32_t ISPADR;
X    volatile uint32_t ISPADR;
N
N    /**
N     * ISPDAT
N     * ===================================================================================================
N     * Offset: 0x08  ISP Data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |ISPDAT    |ISP Data 
N     * |        |          |Write data to this register before ISP program operation
N     * |        |          |Read data from this register after ISP read operation
N     */    
N    __IO uint32_t ISPDAT;
X    volatile uint32_t ISPDAT;
N
N    /**
N     * ISPCMD
N     * ===================================================================================================
N     * Offset: 0x0C  ISP Command Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |FOEN_FCEN_FCTRL|ISP Command 
N     * |        |          |ISP command table is shown below:
N     * |        |          |Operation Mode, FOEN, FCEN, FCTRL[3:0]
N     * |        |          |Read          ,    0,    0, 0000
N     * |        |          |Program       ,    1,    0, 0001
N     * |        |          |Page Erase    ,    1,    0, 0010
N     * |        |          |Read CID      ,    0,    0, 1011
N     * |        |          |Read DID      ,    0,    0, 1100
N     * |        |          |Read UID      ,    0,    0, 0100
N     */    
N    __IO uint32_t ISPCMD;
X    volatile uint32_t ISPCMD;
N
N    /**
N     * ISPTRG
N     * ===================================================================================================
N     * Offset: 0x10  IISP Trigger Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ISPGO     |ISP start trigger
N     * |        |          |Write 1 to start ISP operation and this bit will be cleared to 0 by hardware automatically when ISP 
N     * |        |          |operation is finish. 
N     * |        |          |1 = ISP is on going 
N     * |        |          |0 = ISP operation is finished.
N     */    
N    __IO uint32_t ISPTRG;
X    volatile uint32_t ISPTRG;
N
N    /**
N     * DFBADR
N     * ===================================================================================================
N     * Offset: 0x14  Data Flash Base Address Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |DFBA      |Data Flash Base Address
N     * |        |          |This register indicates data flash start address. It is a read only register.
N     * |        |          | 
N     * |        |          |It is a read only register. 
N     * |        |          | 
N     * |        |          |The data flash start address is defined by user. Since on chip flash erase 
N     * |        |          |unit is 512 bytes, it is mandatory to keep bit 8-0 as 0.
N     */    
N    __I  uint32_t DFBADR;
X    volatile const  uint32_t DFBADR;
N
N} FMC_T;
N
N
N/* FMC ISPCON Bit Field Definitions */
N#define FMC_ISPCON_ISPFF_Pos                    6                                       /*!< FMC ISPCON: ISPFF Position */
N#define FMC_ISPCON_ISPFF_Msk                    (1ul << FMC_ISPCON_ISPFF_Pos)           /*!< FMC ISPCON: ISPFF Mask     */
N
N#define FMC_ISPCON_LDUEN_Pos                    5                                       /*!< FMC ISPCON: LDUEN Position */
N#define FMC_ISPCON_LDUEN_Msk                    (1ul << FMC_ISPCON_LDUEN_Pos)           /*!< FMC ISPCON: LDUEN Mask     */
N
N#define FMC_ISPCON_CFGUEN_Pos                   4                                       /*!< FMC ISPCON: CFGUEN Position    */
N#define FMC_ISPCON_CFGUEN_Msk                   (1ul << FMC_ISPCON_CFGUEN_Pos)          /*!< FMC ISPCON: CFGUEN Mask        */
N
N#define FMC_ISPCON_APUEN_Pos                    3                                       /*!< FMC ISPCON: APUEN Position */
N#define FMC_ISPCON_APUEN_Msk                    (1ul << FMC_ISPCON_APUEN_Pos)           /*!< FMC ISPCON: APUEN Mask     */
N
N#define FMC_ISPCON_BS_Pos                       1                                       /*!< FMC ISPCON: BS Position    */
N#define FMC_ISPCON_BS_Msk                       (1ul << FMC_ISPCON_BS_Pos)              /*!< FMC ISPCON: BS Mask        */
N                                                                                        
N#define FMC_ISPCON_ISPEN_Pos                    0                                       /*!< FMC ISPCON: ISPEN Position */
N#define FMC_ISPCON_ISPEN_Msk                    (1ul << FMC_ISPCON_ISPEN_Pos)           /*!< FMC ISPCON: ISPEN Mask     */
N
N/* FMC ISPCMD Bit Field Definitions */
N#define FMC_ISPCMD_FOEN_Pos                     5                                       /*!< FMC ISPCMD: FOEN Position  */
N#define FMC_ISPCMD_FOEN_Msk                     (1ul << FMC_ISPCMD_FOEN_Pos)            /*!< FMC ISPCMD: FOEN Mask      */
N
N#define FMC_ISPCMD_FCEN_Pos                     4                                       /*!< FMC ISPCMD: FCEN Position  */
N#define FMC_ISPCMD_FCEN_Msk                     (1ul << FMC_ISPCMD_FCEN_Pos)            /*!< FMC ISPCMD: FCEN Mask      */
N
N#define FMC_ISPCMD_FCTRL_Pos                    0                                       /*!< FMC ISPCMD: FCTRL Position */
N#define FMC_ISPCMD_FCTRL_Msk                    (0xFul << FMC_ISPCMD_FCTRL_Pos)         /*!< FMC ISPCMD: FCTRL Mask     */
N
N/* FMC ISPTRG Bit Field Definitions */
N#define FMC_ISPTRG_ISPGO_Pos                    0                                       /*!< FMC ISPTRG: ISPGO Position */
N#define FMC_ISPTRG_ISPGO_Msk                    (1ul << FMC_ISPTRG_ISPGO_Pos)           /*!< FMC ISPTRG: ISPGO Mask     */
N
N
N/*@}*/ /* end of group MINI51_FMC */
N
N
N/** @addtogroup MINI51_GPIO MINI51 GPIO
N  Memory Mapped Structure for MINI51 Series General Purpose I/O
N  @{
N */ 
N/**
N  * @brief GPIO configuration register map
N  */   
Ntypedef struct
N{
N  __IO uint32_t  PMD;                        /*!< Offset: 0x0000   GPIO Port Bit Mode Control                         */ 
X  volatile uint32_t  PMD;                          
N  __IO uint32_t  OFFD;                       /*!< Offset: 0x0004   GPIO Port Bit Off Digital Enable                   */
X  volatile uint32_t  OFFD;                        
N  __IO uint32_t  DOUT;                       /*!< Offset: 0x0008   GPIO Port Data Output                              */
X  volatile uint32_t  DOUT;                        
N  __IO uint32_t  DMASK;                      /*!< Offset: 0x000C   GPIO Port Data Output Write Mask                   */
X  volatile uint32_t  DMASK;                       
N  __I  uint32_t  PIN;                        /*!< Offset: 0x0010   GPIO Port Pin Value                                */
X  volatile const  uint32_t  PIN;                         
N  __IO uint32_t  DBEN;                       /*!< Offset: 0x0014   GPIO Port De-bounce Enable                         */
X  volatile uint32_t  DBEN;                        
N  __IO uint32_t  IMD;                        /*!< Offset: 0x0018   GPIO Port Interrupt Mode Select                    */
X  volatile uint32_t  IMD;                         
N  __IO uint32_t  IEN;                        /*!< Offset: 0x001C   GPIO Port Interrupt Enable                         */
X  volatile uint32_t  IEN;                         
N  __IO uint32_t  ISRC;                       /*!< Offset: 0x0020   GPIO Port Interrupt Source Flag                    */
X  volatile uint32_t  ISRC;                        
N} GPIO_T;  
N
N/**
N  * @brief GPIO debounce register map
N  */  
Ntypedef struct                                  
N{                                               
N  __IO uint32_t  DBNCECON;             /*!< Offset: 0x0000   GPIO De-bounce Cycle Control Register              */                    
X  volatile uint32_t  DBNCECON;                                  
N} GPIO_DBNCECON_T; 
N
N/* GPIO PMD Bit Field Definitions */
N#define GPIO_PMD_PMD7_Pos           14                                          /*!< GPIO PMD: PMD7 Position    */
N#define GPIO_PMD_PMD7_Msk           (0x3ul << GPIO_PMD_PMD7_Pos)                /*!< GPIO PMD: PMD7 Mask        */
N
N#define GPIO_PMD_PMD6_Pos           12                                          /*!< GPIO PMD: PMD6 Position    */    
N#define GPIO_PMD_PMD6_Msk           (0x3ul << GPIO_PMD_PMD6_Pos)                /*!< GPIO PMD: PMD6 Mask        */
N
N#define GPIO_PMD_PMD5_Pos           10                                          /*!< GPIO PMD: PMD5 Position    */
N#define GPIO_PMD_PMD5_Msk           (0x3ul << GPIO_PMD_PMD5_Pos)                /*!< GPIO PMD: PMD5 Mask        */
N
N#define GPIO_PMD_PMD4_Pos           8                                           /*!< GPIO PMD: PMD4 Position    */
N#define GPIO_PMD_PMD4_Msk           (0x3ul << GPIO_PMD_PMD4_Pos)                /*!< GPIO PMD: PMD4 Mask        */
N
N#define GPIO_PMD_PMD3_Pos           6                                           /*!< GPIO PMD: PMD3 Position    */
N#define GPIO_PMD_PMD3_Msk           (0x3ul << GPIO_PMD_PMD3_Pos)                /*!< GPIO PMD: PMD3 Mask        */
N
N#define GPIO_PMD_PMD2_Pos           4                                           /*!< GPIO PMD: PMD2 Position    */
N#define GPIO_PMD_PMD2_Msk           (0x3ul << GPIO_PMD_PMD2_Pos)                /*!< GPIO PMD: PMD2 Mask        */
N
N#define GPIO_PMD_PMD1_Pos           2                                           /*!< GPIO PMD: PMD1 Position    */
N#define GPIO_PMD_PMD1_Msk           (0x3ul << GPIO_PMD_PMD1_Pos)                /*!< GPIO PMD: PMD1 Mask        */
N
N#define GPIO_PMD_PMD0_Pos           0                                           /*!< GPIO PMD: PMD0 Position    */
N#define GPIO_PMD_PMD0_Msk           (0x3ul << GPIO_PMD_PMD0_Pos)                /*!< GPIO PMD: PMD0 Mask        */
N
N/* GPIO OFFD Bit Field Definitions */
N#define GPIO_OFFD_OFFD_Pos          16                                          /*!< GPIO OFFD: OFFD Position   */
N#define GPIO_OFFD_OFFD_Msk          (0xFFul << GPIO_OFFD_OFFD_Pos)              /*!< GPIO OFFD: OFFD Mask       */
N
N/* GPIO DOUT Bit Field Definitions */                                           
N#define GPIO_DOUT_DOUT_Pos          0                                           /*!< GPIO DOUT: DOUT Position   */
N#define GPIO_DOUT_DOUT_Msk          (0xFFul << GPIO_DOUT_DOUT_Pos)              /*!< GPIO DOUT: DOUT Mask       */
N
N/* GPIO DMASK Bit Field Definitions */
N#define GPIO_DMASK_DMASK_Pos        0                                           /*!< GPIO DMASK: DMASK Position */
N#define GPIO_DMASK_DMASK_Msk        (0xFFul << GPIO_DMASK_DMASK_Pos)            /*!< GPIO DMASK: DMASK Mask     */
N
N/* GPIO PIN Bit Field Definitions */
N#define GPIO_PIN_PIN_Pos            0                                           /*!< GPIO PIN: PIN Position     */   
N#define GPIO_PIN_PIN_Msk            (0xFFul << GPIO_PIN_PIN_Pos)                /*!< GPIO PIN: PIN Mask         */
N
N/* GPIO DBEN Bit Field Definitions */
N#define GPIO_DBEN_DBEN_Pos          0                                           /*!< GPIO DBEN: DBEN Position   */
N#define GPIO_DBEN_DBEN_Msk          (0xFFul << GPIO_DBEN_DBEN_Pos)              /*!< GPIO DBEN: DBEN Mask       */
N
N/* GPIO IMD Bit Field Definitions */
N#define GPIO_IMD_IMD_Pos            0                                           /*!< GPIO IMD: IMD Position     */
N#define GPIO_IMD_IMD_Msk            (0xFFul << GPIO_IMD_IMD_Pos)                /*!< GPIO IMD: IMD Mask         */
N
N/* GPIO IEN Bit Field Definitions */
N#define GPIO_IEN_IR_EN_Pos          16                                          /*!< GPIO IEN: IR_EN Position   */
N#define GPIO_IEN_IR_EN_Msk          (0xFFul << GPIO_IEN_IR_EN_Pos)              /*!< GPIO IEN: IR_EN Mask       */
N
N#define GPIO_IEN_IF_EN_Pos          0                                           /*!< GPIO IEN: IF_EN Position   */
N#define GPIO_IEN_IF_EN_Msk          (0xFFul << GPIO_IEN_IF_EN_Pos)              /*!< GPIO IEN: IF_EN Mask       */
N
N/* GPIO ISRC Bit Field Definitions */
N#define GPIO_ISRC_ISRC_Pos          0                                           /*!< GPIO ISRC: ISRC Position   */
N#define GPIO_ISRC_ISRC_Msk          (0xFFul << GPIO_ISRC_ISRC_Pos)              /*!< GPIO ISRC: ISRC Mask       */
N
N/* GPIO DBNCECON Bit Field Definitions */
N#define GPIO_DBNCECON_ICLK_ON_Pos   5                                           /*!< GPIO DBNCECON: ICLK_ON  Position   */
N#define GPIO_DBNCECON_ICLK_ON_Msk   (1ul << GPIO_DBNCECON_ICLK_ON_Pos)          /*!< GPIO DBNCECON: ICLK_ON  Mask       */
N
N#define GPIO_DBNCECON_DBCLKSRC_Pos  4                                           /*!< GPIO DBNCECON: DBCLKSRC Position   */
N#define GPIO_DBNCECON_DBCLKSRC_Msk  (1ul << GPIO_DBNCECON_DBCLKSRC_Pos)         /*!< GPIO DBNCECON: DBCLKSRC Mask       */
N
N#define GPIO_DBNCECON_DBCLKSEL_Pos  0                                           /*!< GPIO DBNCECON: DBCLKSEL Position   */
N#define GPIO_DBNCECON_DBCLKSEL_Msk  (0xFul << GPIO_DBNCECON_DBCLKSEL_Pos)       /*!< GPIO DBNCECON: DBCLKSEL Mask       */
N
N/**
N  * @brief GPIO bit access register map
N  */  
Ntypedef struct
N{
N  __IO uint32_t  GP_BIT0;      /*!< Offset: 0x0000   Px.0 Data Output Value                         */ 
X  volatile uint32_t  GP_BIT0;        
N  __IO uint32_t  GP_BIT1;      /*!< Offset: 0x0004   Px.1 Data Output Value                         */ 
X  volatile uint32_t  GP_BIT1;        
N  __IO uint32_t  GP_BIT2;      /*!< Offset: 0x0008   Px.2 Data Output Value                         */ 
X  volatile uint32_t  GP_BIT2;        
N  __IO uint32_t  GP_BIT3;      /*!< Offset: 0x000C   Px.3 Data Output Value                         */ 
X  volatile uint32_t  GP_BIT3;        
N  __IO uint32_t  GP_BIT4;      /*!< Offset: 0x0010   Px.4 Data Output Value                         */ 
X  volatile uint32_t  GP_BIT4;        
N  __IO uint32_t  GP_BIT5;      /*!< Offset: 0x0014   Px.5 Data Output Value                         */ 
X  volatile uint32_t  GP_BIT5;        
N  __IO uint32_t  GP_BIT6;      /*!< Offset: 0x0018   Px.6 Data Output Value                         */ 
X  volatile uint32_t  GP_BIT6;        
N  __IO uint32_t  GP_BIT7;      /*!< Offset: 0x001C   Px.7 Data Output Value                         */ 
X  volatile uint32_t  GP_BIT7;        
N} GPIOBIT_T; 
N
N/*@}*/ /* end of group MINI51_GPIO */
N
N
N/*------------------------------ I2C Controller ------------------------------*/
N
N/** @addtogroup MINI51_I2C MINI51 I2C
N  Memory Mapped Structure for MINI51 Series I2C Serial Interface Controller
N  @{
N */ 
N/**
N  * @brief I2C register map
N  */   
Ntypedef struct
N{
N  __IO uint32_t  I2CON;            /*!< Offset: 0x0000  I2C Control Register                     */
X  volatile uint32_t  I2CON;             
N  __IO uint32_t  I2CADDR0;         /*!< Offset: 0x0004  I2C Slave Address Register 0             */
X  volatile uint32_t  I2CADDR0;          
N  __IO uint32_t  I2CDAT;           /*!< Offset: 0x0008  I2C Data Register                        */
X  volatile uint32_t  I2CDAT;            
N  __IO uint32_t  I2CSTATUS;        /*!< Offset: 0x000C  I2C Status Register                      */
X  volatile uint32_t  I2CSTATUS;         
N  __IO uint32_t  I2CLK;            /*!< Offset: 0x0010  I2C Clock Divided Register               */
X  volatile uint32_t  I2CLK;             
N  __IO uint32_t  I2CTOC;           /*!< Offset: 0x0014  I2C Time-Out Counter Register            */
X  volatile uint32_t  I2CTOC;            
N  __IO uint32_t  I2CADDR1;         /*!< Offset: 0x0018  I2C Slave Address Register 1             */
X  volatile uint32_t  I2CADDR1;          
N  __IO uint32_t  I2CADDR2;         /*!< Offset: 0x001C  I2C Slave Address Register 2             */
X  volatile uint32_t  I2CADDR2;          
N  __IO uint32_t  I2CADDR3;         /*!< Offset: 0x0020  I2C Slave Address Register 3             */
X  volatile uint32_t  I2CADDR3;          
N  __IO uint32_t  I2CADM0;          /*!< Offset: 0x0024  I2C Slave Address Mask Register 0        */
X  volatile uint32_t  I2CADM0;           
N  __IO uint32_t  I2CADM1;          /*!< Offset: 0x0028  I2C Slave Address Mask Register 1        */
X  volatile uint32_t  I2CADM1;           
N  __IO uint32_t  I2CADM2;          /*!< Offset: 0x002C  I2C Slave Address Mask Register 2        */
X  volatile uint32_t  I2CADM2;           
N  __IO uint32_t  I2CADM3;          /*!< Offset: 0x0030  I2C Slave Address Mask Register 3        */
X  volatile uint32_t  I2CADM3;           
N       uint32_t  RESERVED0;        /*!< Offset: 0x0034  Reserved                                 */
N       uint32_t  RESERVED1;        /*!< Offset: 0x0038  Reserved                                 */
N  __IO uint32_t  I2CON2;           /*!< Offset: 0x003C  I2C Control Register 2                   */
X  volatile uint32_t  I2CON2;            
N  __IO uint32_t  I2CSTATUS2;       /*!< Offset: 0x0040  I2C Status Register 2                    */
X  volatile uint32_t  I2CSTATUS2;        
N} I2C_T; 
N
N
N/* I2C I2CON Bit Field Definitions */
N#define I2C_I2CON_EI_Pos                        7                                       /*!< I2C I2CON: EI Position             */
N#define I2C_I2CON_EI_Msk                        (1ul << I2C_I2CON_EI_Pos)               /*!< I2C I2CON: EI Mask                 */
N
N#define I2C_I2CON_ENSI_Pos                      6                                       /*!< I2C I2CON: ENSI Position           */
N#define I2C_I2CON_ENSI_Msk                      (1ul << I2C_I2CON_ENSI_Pos)             /*!< I2C I2CON: ENSI Mask               */
N
N#define I2C_I2CON_STA_Pos                       5                                       /*!< I2C I2CON: STA Position            */
N#define I2C_I2CON_STA_Msk                       (1ul << I2C_I2CON_STA_Pos)              /*!< I2C I2CON: STA Mask                */
N
N#define I2C_I2CON_STO_Pos                       4                                       /*!< I2C I2CON: STO Position            */
N#define I2C_I2CON_STO_Msk                       (1ul << I2C_I2CON_STO_Pos)              /*!< I2C I2CON: STO Mask                */
N
N#define I2C_I2CON_SI_Pos                        3                                       /*!< I2C I2CON: SI Position             */
N#define I2C_I2CON_SI_Msk                        (1ul << I2C_I2CON_SI_Pos)               /*!< I2C I2CON: SI Mask                 */
N
N#define I2C_I2CON_AA_Pos                        2                                       /*!< I2C I2CON: AA Position             */
N#define I2C_I2CON_AA_Msk                        (1ul << I2C_I2CON_AA_Pos)               /*!< I2C I2CON: AA Mask                 */
N
N/* I2C I2CADDR Bit Field Definitions */
N#define I2C_I2CADDR_I2CADDR_Pos                 1                                       /*!< I2C I2CADDR: I2CADDR Position      */
N#define I2C_I2CADDR_I2CADDR_Msk                 (0x7Ful << I2C_I2CADDR_I2CADDR_Pos)     /*!< I2C I2CADDR: I2CADDR Mask          */
N
N#define I2C_I2CADDR_GC_Pos                      0                                       /*!< I2C I2CADDR: GC Position           */
N#define I2C_I2CADDR_GC_Msk                      (1ul << I2C_I2CADDR_GC_Pos)             /*!< I2C I2CADDR: GC Mask               */
N
N/* I2C I2CDAT Bit Field Definitions */
N#define I2C_I2CDAT_I2CDAT_Pos                   0                                       /*!< I2C I2CDAT: I2CDAT Position        */
N#define I2C_I2CDAT_I2CDAT_Msk                   (0xFFul << I2C_I2CDAT_I2CDAT_Pos)       /*!< I2C I2CDAT: I2CDAT Mask            */
N
N/* I2C I2CSTATUS Bit Field Definitions */
N#define I2C_I2CSTATUS_I2CSTATUS_Pos             0                                       /*!< I2C I2CSTATUS: I2CSTATUS Position  */
N#define I2C_I2CSTATUS_I2CSTATUS_Msk             (0xFFul << I2C_I2CSTATUS_I2CSTATUS_Pos) /*!< I2C I2CSTATUS: I2CSTATUS Mask      */
N
N/* I2C I2CLK Bit Field Definitions */
N#define I2C_I2CLK_I2CLK_Pos                     0                                       /*!< I2C I2CLK: I2CLK Position          */
N#define I2C_I2CLK_I2CLK_Msk                     (0xFFul << I2C_I2CLK_I2CLK_Pos)         /*!< I2C I2CLK: I2CLK Mask              */
N
N/* I2C I2CTOC Bit Field Definitions */
N#define I2C_I2CTOC_ENTI_Pos                     2                                       /*!< I2C I2CTOC: ENTI Position          */
N#define I2C_I2CTOC_ENTI_Msk                     (1ul << I2C_I2CTOC_ENTI_Pos)            /*!< I2C I2CTOC: ENTI Mask              */
N
N#define I2C_I2CTOC_DIV4_Pos                     1                                       /*!< I2C I2CTOC: DIV4 Position          */
N#define I2C_I2CTOC_DIV4_Msk                     (1ul << I2C_I2CTOC_DIV4_Pos)            /*!< I2C I2CTOC: DIV4 Mask              */
N
N#define I2C_I2CTOC_TIF_Pos                      0                                       /*!< I2C I2CTOC: TIF Position           */
N#define I2C_I2CTOC_TIF_Msk                      (1ul << I2C_I2CTOC_TIF_Pos)             /*!< I2C I2CTOC: TIF Mask               */
N
N/* I2C I2CADM Bit Field Definitions */
N#define I2C_I2CADM_I2CADM_Pos                   1                                       /*!< I2C I2CADM: I2CADM Position        */
N#define I2C_I2CADM_I2CADM_Msk                   (0x7Ful << I2C_I2CADM_I2CADM_Pos)       /*!< I2C I2CADM: I2CADM Mask            */
N
N/* I2C I2CON2 Bit Field Definitions */
N#define I2C_I2CON2_WKUPEN_Pos                   0                                       /*!< I2C I2CON2: WKUPEN Position        */
N#define I2C_I2CON2_WKUPEN_Msk                   (1ul << I2C_I2CON2_WKUPEN_Pos)          /*!< I2C I2CON2: WKUPEN Mask            */
N
N#define I2C_I2CON2_TWOFF_EN_Pos                 1                                       /*!< I2C I2CON2: TWOFF_EN Position      */
N#define I2C_I2CON2_TWOFF_EN_Msk                 (1ul << I2C_I2CON2_TWOFF_EN_Pos)        /*!< I2C I2CON2: TWOFF_EN Mask          */
N
N#define I2C_I2CON2_NOSTRETCH_Pos                2                                       /*!< I2C I2CON2: NOSTRETCH Position     */
N#define I2C_I2CON2_NOSTRETCH_Msk                (1ul << I2C_I2CON2_NOSTRETCH_Pos)       /*!< I2C I2CON2: NOSTRETCH Mask         */
N
N#define I2C_I2CON2_OVER_INTEN_Pos               3                                       /*!< I2C I2CON2: OVER_INTEN Position    */
N#define I2C_I2CON2_OVER_INTEN_Msk               (1ul << I2C_I2CON2_OVER_INTEN_Pos)      /*!< I2C I2CON2: OVER_INTEN Mask        */
N
N#define I2C_I2CON2_UNDER_INTEN_Pos              4                                       /*!< I2C I2CON2: UNDER_INTEN Position   */
N#define I2C_I2CON2_UNDER_INTEN_Msk              (1ul << I2C_I2CON2_UNDER_INTEN_Pos)     /*!< I2C I2CON2: UNDER_INTEN Mask       */
N
N/* I2C I2CSTATUS2 Bit Field Definitions */
N#define I2C_I2CSTATUS2_WAKEUP_Pos               0                                       /*!< I2C I2CSTATUS2: WAKEUP Position    */
N#define I2C_I2CSTATUS2_WAKEUP_Msk               (1ul << I2C_I2CSTATUS2_WAKEUP_Pos)      /*!< I2C I2CSTATUS2: WAKEUP Mask        */
N
N#define I2C_I2CSTATUS2_FULL_Pos                 1                                       /*!< I2C I2CSTATUS2: FULL Position      */
N#define I2C_I2CSTATUS2_FULL_Msk                 (1ul << I2C_I2CSTATUS2_FULL_Pos)        /*!< I2C I2CSTATUS2: FULL Mask          */
N
N#define I2C_I2CSTATUS2_EMPTY_Pos                2                                       /*!< I2C I2CSTATUS2: EMPTY Position     */
N#define I2C_I2CSTATUS2_EMPTY_Msk                (1ul << I2C_I2CSTATUS2_EMPTY_Pos)       /*!< I2C I2CSTATUS2: EMPTY Mask         */
N
N#define I2C_I2CSTATUS2_OVERUN_Pos               3                                       /*!< I2C I2CSTATUS2: OVERUN Position    */
N#define I2C_I2CSTATUS2_OVERUN_Msk               (1ul << I2C_I2CSTATUS2_OVERUN_Pos)      /*!< I2C I2CSTATUS2: OVERUN Mask        */
N
N#define I2C_I2CSTATUS2_UNDERUN_Pos              4                                       /*!< I2C I2CSTATUS2: UNDERUN Position   */
N#define I2C_I2CSTATUS2_UNDERUN_Msk              (1ul << I2C_I2CSTATUS2_UNDERUN_P        /*!< I2C I2CSTATUS2: UNDERUN Mask       */
N
N/*@}*/ /* end of group MINI51_I2C */
N
N/** @addtogroup MINI51_INT MINI51 INT
N  Memory Mapped Structure for MINI51 Series Interrupt Source Controller
N  @{
N */
N/**
N  * @brief INT register map
N  */  
Ntypedef struct
N{   
N    __I  uint32_t IRQSRC[32]; /*!< Offset: 0x0000 ~ 0x007C   Interrupt Source Identity Registers            */
X    volatile const  uint32_t IRQSRC[32];  
N    __IO uint32_t NMICNO;     /*!< Offset: 0x0080            NMI Source Interrupt Select Control Register   */
X    volatile uint32_t NMICNO;      
N    __IO uint32_t MCUIRQ;     /*!< Offset: 0x0084            MCU IRQ Number Identity Register               */
X    volatile uint32_t MCUIRQ;      
N
N} INT_T;
N/*@}*/ /* end of group MINI51_INT */
N
N/*----------------------------- PWM Controller -------------------------------*/
N
N/** @addtogroup MINI51_PWM MINI51 PWM
N  Memory Mapped Structure for MINI51 Series PWM Generator and Capture Timer
N  @{
N */ 
N/**
N  * @brief PWM register map
N  */   
Ntypedef struct
N{
N  __IO uint32_t  PPR;                  /*!< Offset: 0x0000   PWM Pre-scale Register                */
X  volatile uint32_t  PPR;                   
N  __IO uint32_t  CSR;                  /*!< Offset: 0x0004   PWM Clock Select Register             */
X  volatile uint32_t  CSR;                   
N  __IO uint32_t  PCR;                  /*!< Offset: 0x0008   PWM Control Register                  */
X  volatile uint32_t  PCR;                   
N  __IO uint32_t  CNR[6];               /*!< Offset: 0x000C ~ 0x0020 PWM Counter Register 0 ~ 5     */
X  volatile uint32_t  CNR[6];                
N  __IO uint32_t  CMR[6];               /*!< Offset: 0x0024 ~ 0x0038 PWM Comparator Register 0 ~ 5  */
X  volatile uint32_t  CMR[6];                
N       uint32_t  RESERVED0[6];         /*!< Offset: 0x003C ~ 0x0050 Reserved                       */
N  __IO uint32_t  PIER;                 /*!< Offset: 0x0054   PWM Interrupt Enable Register         */
X  volatile uint32_t  PIER;                  
N  __IO uint32_t  PIIR;                 /*!< Offset: 0x0058   PWM Interrupt Indication Register     */
X  volatile uint32_t  PIIR;                  
N  __IO uint32_t  POE;                  /*!< Offset: 0x005C   PWM Output Enable Register            */
X  volatile uint32_t  POE;                   
N  __IO uint32_t  PFBCON;               /*!< Offset: 0x0060   PWM Fault Brake Control Register      */
X  volatile uint32_t  PFBCON;                
N  __IO uint32_t  PDZIR;                /*!< Offset: 0x0064   PWM Dead-zone Interval Register       */
X  volatile uint32_t  PDZIR;                 
N  __IO uint32_t  TRGCON0;              /*!< Offset: 0x0068   PWM Trigger Control Register 0        */
X  volatile uint32_t  TRGCON0;               
N  __IO uint32_t  TRGCON1;              /*!< Offset: 0x006C   PWM Trigger Control Register 1        */
X  volatile uint32_t  TRGCON1;               
N  __IO uint32_t  TRGSTS0;              /*!< Offset: 0x0070   PWM Trigger Status Register 0         */
X  volatile uint32_t  TRGSTS0;               
N  __IO uint32_t  TRGSTS1;              /*!< Offset: 0x0074   PWM Trigger Status Register 1         */
X  volatile uint32_t  TRGSTS1;               
N  __IO uint32_t  PHCHG;                /*!< Offset: 0x0078   PWM Phase Changed Register            */
X  volatile uint32_t  PHCHG;                 
N  __IO uint32_t  PHCHGNXT;             /*!< Offset: 0x007C   PWM Next Phase Change Register        */
X  volatile uint32_t  PHCHGNXT;              
N  __IO uint32_t  PHCHGMASK;            /*!< Offset: 0x0080   PWM Phase Change MASK Register        */
X  volatile uint32_t  PHCHGMASK;             
N  __IO uint32_t  INTACCUCTL;           /*!< Offset: 0x0084   PWM Period Interrupt Accumulation Control Register   */
X  volatile uint32_t  INTACCUCTL;            
N} PWM_T;
N
N/* PWM PPR Bit Field Definitions */
N#define PWM_PPR_CP45_Pos                        16                                  /*!< PWM PPR: CP45 Position     */
N#define PWM_PPR_CP45_Msk                        (0xFFul << PWM_PPR_CP45_Pos)        /*!< PWM PPR: CP45 Mask         */
N
N#define PWM_PPR_CP23_Pos                        8                                   /*!< PWM PPR: CP23 Position     */
N#define PWM_PPR_CP23_Msk                        (0xFFul << PWM_PPR_CP23_Pos)        /*!< PWM PPR: CP23 Mask         */
N
N#define PWM_PPR_CP01_Pos                        0                                   /*!< PWM PPR: CP01 Position     */
N#define PWM_PPR_CP01_Msk                        (0xFFul << PWM_PPR_CP01_Pos)        /*!< PWM PPR: CP01 Mask         */
N
N/* PWM CSR Bit Field Definitions */
N#define PWM_CSR_CSR5_Pos                        20                                  /*!< PWM CSR: CSR5 Position     */
N#define PWM_CSR_CSR5_Msk                        (7ul << PWM_CSR_CSR5_Pos)           /*!< PWM CSR: CSR5 Mask         */
N
N#define PWM_CSR_CSR4_Pos                        16                                  /*!< PWM CSR: CSR4 Position     */
N#define PWM_CSR_CSR4_Msk                        (7ul << PWM_CSR_CSR4_Pos)           /*!< PWM CSR: CSR4 Mask         */
N
N#define PWM_CSR_CSR3_Pos                        12                                  /*!< PWM CSR: CSR3 Position     */
N#define PWM_CSR_CSR3_Msk                        (7ul << PWM_CSR_CSR3_Pos)           /*!< PWM CSR: CSR3 Mask         */
N
N#define PWM_CSR_CSR2_Pos                        8                                   /*!< PWM CSR: CSR2 Position     */
N#define PWM_CSR_CSR2_Msk                        (7ul << PWM_CSR_CSR2_Pos)           /*!< PWM CSR: CSR2 Mask         */
N
N#define PWM_CSR_CSR1_Pos                        4                                   /*!< PWM CSR: CSR1 Position     */
N#define PWM_CSR_CSR1_Msk                        (7ul << PWM_CSR_CSR1_Pos)           /*!< PWM CSR: CSR1 Mask         */
N
N#define PWM_CSR_CSR0_Pos                        0                                   /*!< PWM CSR: CSR0 Position     */
N#define PWM_CSR_CSR0_Msk                        (7ul << PWM_CSR_CSR0_Pos)           /*!< PWM CSR: CSR0 Mask         */
N
N/* PWM PCR Bit Field Definitions */
N#define PWM_PCR_PWMTYPE_Pos                     31                                  /*!< PWM PCR: PWMTYPE Position  */
N#define PWM_PCR_PWMTYPE_Msk                     (1ul << PWM_PCR_PWMTYPE_Pos)        /*!< PWM PCR: PWMTYPE Mask      */
N
N#define PWM_PCR_GRP_Pos                         30                                  /*!< PWM PCR: GRP Position      */
N#define PWM_PCR_GRP_Msk                         (1ul << PWM_PCR_GRP_Pos)            /*!< PWM PCR: GRP Mask          */
N
N#define PWM_PCR_PWMMOD_Pos                      28                                  /*!< PWM PCR: PWMMOD Position   */
N#define PWM_PCR_PWMMOD_Msk                      (3ul << PWM_PCR_PWMMOD_Pos)         /*!< PWM PCR: PWMMOD Mask       */
N
N#define PWM_PCR_CLRPWM_Pos                      27                                  /*!< PWM PCR: CLRPWM Position   */
N#define PWM_PCR_CLRPWM_Msk                      (1ul << PWM_PCR_CLRPWM_Pos)         /*!< PWM PCR: CLRPWM Mask       */
N
N#define PWM_PCR_DZEN45_Pos                      26                                  /*!< PWM PCR: DZEN45 Position   */
N#define PWM_PCR_DZEN45_Msk                      (1ul << PWM_PCR_DZEN45_Pos)         /*!< PWM PCR: DZEN45 Mask       */
N
N#define PWM_PCR_DZEN23_Pos                      25                                  /*!< PWM PCR: DZEN23 Position   */
N#define PWM_PCR_DZEN23_Msk                      (1ul << PWM_PCR_DZEN23_Pos)         /*!< PWM PCR: DZEN23 Mask       */
N
N#define PWM_PCR_DZEN01_Pos                      24                                  /*!< PWM PCR: DZEN01 Position   */
N#define PWM_PCR_DZEN01_Msk                      (1ul << PWM_PCR_DZEN01_Pos)         /*!< PWM PCR: DZEN01 Mask       */
N
N#define PWM_PCR_CH5MOD_Pos                      23                                  /*!< PWM PCR: CH5MOD Position   */
N#define PWM_PCR_CH5MOD_Msk                      (1ul << PWM_PCR_CH5MOD_Pos)         /*!< PWM PCR: CH5MOD Mask       */
N
N#define PWM_PCR_CH5INV_Pos                      22                                  /*!< PWM PCR: CH5INV Position   */
N#define PWM_PCR_CH5INV_Msk                      (1ul << PWM_PCR_CH5INV_Pos)         /*!< PWM PCR: CH5INV Mask       */
N
N#define PWM_PCR_CH5EN_Pos                       20                                  /*!< PWM PCR: CH5EN Position    */
N#define PWM_PCR_CH5EN_Msk                       (1ul << PWM_PCR_CH5EN_Pos)          /*!< PWM PCR: CH5EN Mask        */
N
N#define PWM_PCR_CH4MOD_Pos                      19                                  /*!< PWM PCR: CH4MOD Position   */
N#define PWM_PCR_CH4MOD_Msk                      (1ul << PWM_PCR_CH4MOD_Pos)         /*!< PWM PCR: CH4MOD Mask       */
N
N#define PWM_PCR_CH4INV_Pos                      18                                  /*!< PWM PCR: CH4INV Position   */
N#define PWM_PCR_CH4INV_Msk                      (1ul << PWM_PCR_CH4INV_Pos)         /*!< PWM PCR: CH4INV Mask       */
N
N#define PWM_PCR_CH4EN_Pos                       16                                  /*!< PWM PCR: CH4EN Position    */
N#define PWM_PCR_CH4EN_Msk                       (1ul << PWM_PCR_CH4EN_Pos)          /*!< PWM PCR: CH4EN Mask        */
N
N#define PWM_PCR_CH3MOD_Pos                      15                                  /*!< PWM PCR: CH3MOD Position   */
N#define PWM_PCR_CH3MOD_Msk                      (1ul << PWM_PCR_CH3MOD_Pos)         /*!< PWM PCR: CH3MOD Mask       */
N
N#define PWM_PCR_CH3INV_Pos                      14                                  /*!< PWM PCR: CH3INV Position   */
N#define PWM_PCR_CH3INV_Msk                      (1ul << PWM_PCR_CH3INV_Pos)         /*!< PWM PCR: CH3INV Mask       */
N
N#define PWM_PCR_CH3EN_Pos                       12                                  /*!< PWM PCR: CH3EN Position    */
N#define PWM_PCR_CH3EN_Msk                       (1ul << PWM_PCR_CH3EN_Pos)          /*!< PWM PCR: CH3EN Mask        */
N
N#define PWM_PCR_CH2MOD_Pos                      11                                  /*!< PWM PCR: CH2MOD Position   */
N#define PWM_PCR_CH2MOD_Msk                      (1ul << PWM_PCR_CH2MOD_Pos)         /*!< PWM PCR: CH2MOD Mask       */
N
N#define PWM_PCR_CH2INV_Pos                      10                                  /*!< PWM PCR: CH2INV Position   */
N#define PWM_PCR_CH2INV_Msk                      (1ul << PWM_PCR_CH2INV_Pos)         /*!< PWM PCR: CH2INV Mask       */
N
N#define PWM_PCR_CH2EN_Pos                       8                                   /*!< PWM PCR: CH2EN Position    */
N#define PWM_PCR_CH2EN_Msk                       (1ul << PWM_PCR_CH2EN_Pos)          /*!< PWM PCR: CH2EN Mask        */
N
N#define PWM_PCR_CH1MOD_Pos                      7                                   /*!< PWM PCR: CH1MOD Position   */
N#define PWM_PCR_CH1MOD_Msk                      (1ul << PWM_PCR_CH1MOD_Pos)         /*!< PWM PCR: CH1MOD Mask       */
N
N#define PWM_PCR_CH1INV_Pos                      6                                   /*!< PWM PCR: CH1INV Position   */
N#define PWM_PCR_CH1INV_Msk                      (1ul << PWM_PCR_CH1INV_Pos)         /*!< PWM PCR: CH1INV Mask       */
N
N#define PWM_PCR_CH1EN_Pos                       4                                   /*!< PWM PCR: CH1EN Position    */
N#define PWM_PCR_CH1EN_Msk                       (1ul << PWM_PCR_CH0EN_Pos)          /*!< PWM PCR: CH1EN Mask        */
N
N#define PWM_PCR_CH0MOD_Pos                      3                                   /*!< PWM PCR: CH0MOD Position   */
N#define PWM_PCR_CH0MOD_Msk                      (1ul << PWM_PCR_CH0MOD_Pos)         /*!< PWM PCR: CH0MOD Mask       */
N
N#define PWM_PCR_CH0INV_Pos                      2                                   /*!< PWM PCR: CH0INV Position   */
N#define PWM_PCR_CH0INV_Msk                      (1ul << PWM_PCR_CH0INV_Pos)         /*!< PWM PCR: CH0INV Mask       */
N
N#define PWM_PCR_DB_MOD_Pos                      1                                   /*!< PWM PCR: DB_MOD Position   */
N#define PWM_PCR_DB_MOD_Msk                     (1ul << PWM_PCR_DB_MOD_Pos)          /*!< PWM PCR: DB_MOD Mask       */
N
N#define PWM_PCR_CH0EN_Pos                       0                                   /*!< PWM PCR: CH0EN Position    */
N#define PWM_PCR_CH0EN_Msk                       (1ul << PWM_PCR_CH0EN_Pos)          /*!< PWM PCR: CH0EN Mask        */
N
N/* PWM CNR Bit Field Definitions */
N#define PWM_CNR_CNR_Pos                         0                                   /*!< PWM CNR: CNR Position  */
N#define PWM_CNR_CNR_Msk                         (0xFFFFul << PWM_CNR_CNR_Pos)       /*!< PWM CNR: CNR Mask      */
N
N/* PWM CMR Bit Field Definitions */
N#define PWM_CMR_CMR_Pos                         0                                   /*!< PWM CMR: CMR Position  */
N#define PWM_CMR_CMR_Msk                         (0xFFFFul << PWM_CMR_CMR_Pos)       /*!< PWM CMR: CMR Mask      */
N
N
N/* PWM PIER Bit Field Definitions */
N#define PWM_PIER_INT_TYPE_Pos                   17                                  /*!< PWM PIER: INT_TYPE Position    */
N#define PWM_PIER_INT_TYPE_Msk                   (1ul << PWM_PIER_INT_TYPE_Pos)      /*!< PWM PIER: INT_TYPE Mask        */
N
N#define PWM_PIER_BRKIE_Pos                      16                                  /*!< PWM PIER: BRKIE Position   */
N#define PWM_PIER_BRKIE_Msk                      (1ul << PWM_PIER_BRKIE_Pos)         /*!< PWM PIER: BRKIE Mask       */
N
N#define PWM_PIER_PWMDIE5_Pos                    13                                  /*!< PWM PIER: PWMDIE5 Position */
N#define PWM_PIER_PWMDIE5_Msk                    (1ul << PWM_PIER_PWMDIE5_Pos)       /*!< PWM PIER: PWMDIE5 Mask     */
N
N#define PWM_PIER_PWMDIE4_Pos                    12                                  /*!< PWM PIER: PWMDIE4 Position */
N#define PWM_PIER_PWMDIE4_Msk                    (1ul << PWM_PIER_PWMDIE4_Pos)       /*!< PWM PIER: PWMDIE4 Mask     */
N
N#define PWM_PIER_PWMDIE3_Pos                    11                                  /*!< PWM PIER: PWMDIE3 Position */
N#define PWM_PIER_PWMDIE3_Msk                    (1ul << PWM_PIER_PWMDIE3_Pos)       /*!< PWM PIER: PWMDIE3 Mask     */
N
N#define PWM_PIER_PWMDIE2_Pos                    10                                  /*!< PWM PIER: PWMDIE2 Position */
N#define PWM_PIER_PWMDIE2_Msk                    (1ul << PWM_PIER_PWMDIE2_Pos)       /*!< PWM PIER: PWMDIE2 Mask     */
N
N#define PWM_PIER_PWMDIE1_Pos                    9                                   /*!< PWM PIER: PWMDIE1 Position */
N#define PWM_PIER_PWMDIE1_Msk                    (1ul << PWM_PIER_PWMDIE1_Pos)       /*!< PWM PIER: PWMDIE1 Mask     */
N
N#define PWM_PIER_PWMDIE0_Pos                    8                                   /*!< PWM PIER: PWMDIE0 Position */
N#define PWM_PIER_PWMDIE0_Msk                    (1ul << PWM_PIER_PWMDIE0_Pos)       /*!< PWM PIER: PWMDIE0 Mask     */
N
N#define PWM_PIER_PWMPIE5_Pos                    5                                   /*!< PWM PIER: PWMPIE5 Position */
N#define PWM_PIER_PWMPIE5_Msk                    (1ul << PWM_PIER_PWMPIE5_Pos)       /*!< PWM PIER: PWMPIE5 Mask     */
N
N#define PWM_PIER_PWMPIE4_Pos                    4                                   /*!< PWM PIER: PWMPIE4 Position */
N#define PWM_PIER_PWMPIE4_Msk                    (1ul << PWM_PIER_PWMPIE4_Pos)       /*!< PWM PIER: PWMPIE4 Mask     */
N
N#define PWM_PIER_PWMPIE3_Pos                    3                                   /*!< PWM PIER: PWMPIE3 Position */
N#define PWM_PIER_PWMPIE3_Msk                    (1ul << PWM_PIER_PWMPIE3_Pos)       /*!< PWM PIER: PWMPIE3 Mask     */
N
N#define PWM_PIER_PWMPIE2_Pos                    2                                   /*!< PWM PIER: PWMPIE2 Position */
N#define PWM_PIER_PWMPIE2_Msk                    (1ul << PWM_PIER_PWMPIE2_Pos)       /*!< PWM PIER: PWMPIE2 Mask     */
N
N#define PWM_PIER_PWMPIE1_Pos                    1                                   /*!< PWM PIER: PWMPIE1 Position */
N#define PWM_PIER_PWMPIE1_Msk                    (1ul << PWM_PIER_PWMPIE1_Pos)       /*!< PWM PIER: PWMPIE1 Mask     */
N
N#define PWM_PIER_PWMPIE0_Pos                    0                                   /*!< PWM PIER: PWMPIE0 Position */
N#define PWM_PIER_PWMPIE0_Msk                    (1ul << PWM_PIER_PWMPIE0_Pos)       /*!< PWM PIER: PWMPIE0 Mask     */
N
N/* PWM PIIR Bit Field Definitions */
N#define PWM_PIIR_BKF1_Pos                       17                                  /*!< PWM PIIR: BKF1 Position    */
N#define PWM_PIIR_BKF1_Msk                       (1ul << PWM_PIIR_BKF1_Pos)          /*!< PWM PIIR: BKF1 Mask        */
N
N#define PWM_PIIR_BKF0_Pos                       16                                  /*!< PWM PIIR: BKF0 Position    */
N#define PWM_PIIR_BKF0_Msk                       (1ul << PWM_PIIR_BKF0_Pos)          /*!< PWM PIIR: BKF0 Mask        */
N
N#define PWM_PIIR_PWMDIF5_Pos                    13                                  /*!< PWM PIIR: PWMDIF5 Position */
N#define PWM_PIIR_PWMDIF5_Msk                    (1ul << PWM_PIIR_PWMDIF5_Pos)       /*!< PWM PIIR: PWMDIF5 Mask     */
N
N#define PWM_PIIR_PWMDIF4_Pos                    12                                  /*!< PWM PIIR: PWMDIF4 Position */
N#define PWM_PIIR_PWMDIF4_Msk                    (1ul << PWM_PIIR_PWMDIF4_Pos)       /*!< PWM PIIR: PWMDIF4 Mask     */
N
N#define PWM_PIIR_PWMDIF3_Pos                    11                                  /*!< PWM PIIR: PWMDIF3 Position */
N#define PWM_PIIR_PWMDIF3_Msk                    (1ul << PWM_PIIR_PWMDIF3_Pos)       /*!< PWM PIIR: PWMDIF3 Mask     */
N
N#define PWM_PIIR_PWMDIF2_Pos                    10                                  /*!< PWM PIIR: PWMDIF2 Position */
N#define PWM_PIIR_PWMDIF2_Msk                    (1ul << PWM_PIIR_PWMDIF2_Pos)       /*!< PWM PIIR: PWMDIF2 Mask     */
N
N#define PWM_PIIR_PWMDIF1_Pos                    9                                   /*!< PWM PIIR: PWMDIF1 Position */
N#define PWM_PIIR_PWMDIF1_Msk                    (1ul << PWM_PIIR_PWMDIF1_Pos)       /*!< PWM PIIR: PWMDIF1 Mask     */
N
N#define PWM_PIIR_PWMDIF0_Pos                    8                                   /*!< PWM PIIR: PWMDIF0 Position */
N#define PWM_PIIR_PWMDIF0_Msk                    (1ul << PWM_PIIR_PWMDIF0_Pos)       /*!< PWM PIIR: PWMDIF0 Mask     */
N
N#define PWM_PIIR_PWMPIF5_Pos                    5                                   /*!< PWM PIIR: PWMPIF5 Position */
N#define PWM_PIIR_PWMPIF5_Msk                    (1ul << PWM_PIIR_PWMPIF5_Pos)       /*!< PWM PIIR: PWMPIF5 Mask     */
N
N#define PWM_PIIR_PWMPIF4_Pos                    4                                   /*!< PWM PIIR: PWMPIF4 Position */
N#define PWM_PIIR_PWMPIF4_Msk                    (1ul << PWM_PIIR_PWMPIF4_Pos)       /*!< PWM PIIR: PWMPIF4 Mask     */
N
N#define PWM_PIIR_PWMPIF3_Pos                    3                                   /*!< PWM PIIR: PWMPIF3 Position */
N#define PWM_PIIR_PWMPIF3_Msk                    (1ul << PWM_PIIR_PWMPIF3_Pos)       /*!< PWM PIIR: PWMPIF3 Mask     */
N
N#define PWM_PIIR_PWMPIF2_Pos                    2                                   /*!< PWM PIIR: PWMPIF2 Position */
N#define PWM_PIIR_PWMPIF2_Msk                    (1ul << PWM_PIIR_PWMPIF2_Pos)       /*!< PWM PIIR: PWMPIF2 Mask     */
N
N#define PWM_PIIR_PWMPIF1_Pos                    1                                   /*!< PWM PIIR: PWMPIF1 Position */
N#define PWM_PIIR_PWMPIF1_Msk                    (1ul << PWM_PIIR_PWMPIF1_Pos)       /*!< PWM PIIR: PWMPIF1 Mask     */
N
N#define PWM_PIIR_PWMPIF0_Pos                    0                                   /*!< PWM PIIR: PWMPIF0 Position */
N#define PWM_PIIR_PWMPIF0_Msk                    (1ul << PWM_PIIR_PWMPIF0_Pos)       /*!< PWM PIIR: PWMPIF0 Mask     */
N
N/* PWM POE Bit Field Definitions */
N#define PWM_POE_PWM5_Pos                        5                                   /*!< PWM POE: POE5 Position     */
N#define PWM_POE_PWM5_Msk                        (1ul << PWM_POE_PWM5_Pos)           /*!< PWM POE: POE5 Mask         */   
N
N#define PWM_POE_PWM4_Pos                        4                                   /*!< PWM POE: POE4 Position     */
N#define PWM_POE_PWM4_Msk                        (1ul << PWM_POE_PWM4_Pos)           /*!< PWM POE: POE4 Mask         */  
N
N#define PWM_POE_PWM3_Pos                        3                                   /*!< PWM POE: POE3 Position     */
N#define PWM_POE_PWM3_Msk                        (1ul << PWM_POE_PWM3_Pos)           /*!< PWM POE: POE3 Mask         */   
N
N#define PWM_POE_PWM2_Pos                        2                                   /*!< PWM POE: POE2 Position     */
N#define PWM_POE_PWM2_Msk                        (1ul << PWM_POE_PWM2_Pos)           /*!< PWM POE: POE2 Mask         */  
N
N#define PWM_POE_PWM1_Pos                        1                                   /*!< PWM POE: POE1 Position     */
N#define PWM_POE_PWM1_Msk                        (1ul << PWM_POE_PWM1_Pos)           /*!< PWM POE: POE1 Mask         */  
N
N#define PWM_POE_PWM0_Pos                        0                                   /*!< PWM POE: POE0 Position     */
N#define PWM_POE_PWM0_Msk                        (1ul << PWM_POE_PWM0_Pos)           /*!< PWM POE: POE0 Mask         */  
N
N/* PWM PFBCON Bit Field Definitions */
N#define PWM_PFBCON_D7BKO7_Pos                   31                                  /*!< PWM PFBCON: D7BKO7 Position    */
N#define PWM_PFBCON_D7BKO7_Msk                   (1ul << PWM_PFBCON_D7BKO7_Pos)      /*!< PWM PFBCON: D7BKO7 Mask        */  
N
N#define PWM_PFBCON_D6BKO6_Pos                   30                                  /*!< PWM PFBCON: D6BKO6 Position    */
N#define PWM_PFBCON_D6BKO6_Msk                   (1ul << PWM_PFBCON_D6BKO6_Pos)      /*!< PWM PFBCON: D6BKO6 Mask        */  
N
N#define PWM_PFBCON_PWMBKO5_Pos                  29                                  /*!< PWM PFBCON: PWMBKO5 Position   */
N#define PWM_PFBCON_PWMBKO5_Msk                  (1ul << PWM_PFBCON_PWMBKO5_Pos)     /*!< PWM PFBCON: PWMBKO5 Mask       */  
N
N#define PWM_PFBCON_PWMBKO4_Pos                  28                                  /*!< PWM PFBCON: PWMBKO4 Position   */
N#define PWM_PFBCON_PWMBKO4_Msk                  (1ul << PWM_PFBCON_PWMBKO4_Pos)     /*!< PWM PFBCON: PWMBKO4 Mask       */  
N
N#define PWM_PFBCON_PWMBKO3_Pos                  27                                  /*!< PWM PFBCON: PWMBKO3 Position   */
N#define PWM_PFBCON_PWMBKO3_Msk                  (1ul << PWM_PFBCON_PWMBKO3_Pos)     /*!< PWM PFBCON: PWMBKO3 Mask       */  
N
N#define PWM_PFBCON_PWMBKO2_Pos                  26                                  /*!< PWM PFBCON: PWMBKO2 Position   */
N#define PWM_PFBCON_PWMBKO2_Msk                  (1ul << PWM_PFBCON_PWMBKO2_Pos)     /*!< PWM PFBCON: PWMBKO2 Mask       */  
N
N#define PWM_PFBCON_PWMBKO1_Pos                  25                                  /*!< PWM PFBCON: PWMBKO1 Position   */
N#define PWM_PFBCON_PWMBKO1_Msk                  (1ul << PWM_PFBCON_PWMBKO1_Pos)     /*!< PWM PFBCON: PWMBKO1 Mask       */  
N
N#define PWM_PFBCON_PWMBKO0_Pos                  24                                  /*!< PWM PFBCON: PWMBKO0 Position   */
N#define PWM_PFBCON_PWMBKO0_Msk                  (1ul << PWM_PFBCON_PWMBKO0_Pos)     /*!< PWM PFBCON: PWMBKO0 Mask       */  
N
N#define PWM_PFBCON_BKF_Pos                      7                                   /*!< PWM PFBCON: BKF Position   */
N#define PWM_PFBCON_BKF_Msk                      (1ul << PWM_PFBCON_BKF_Pos)         /*!< PWM PFBCON: BKF Mask       */  
N
N#define PWM_PFBCON_CPO0BKEN_Pos                 2                                   /*!< PWM PFBCON: CPO0BKEN Position  */
N#define PWM_PFBCON_CPO0BKEN_Msk                 (1ul << PWM_PFBCON_CPO0BKEN_Pos)    /*!< PWM PFBCON: CPO0BKEN Mask      */  
N
N#define PWM_PFBCON_BKEN1_Pos                    1                                   /*!< PWM PFBCON: BKEN1 Position */
N#define PWM_PFBCON_BKEN1_Msk                    (1ul << PWM_PFBCON_BKEN1_Pos)       /*!< PWM PFBCON: BKEN1 Mask     */  
N
N#define PWM_PFBCON_BKEN0_Pos                    0                                   /*!< PWM PFBCON: BKEN0 Position */
N#define PWM_PFBCON_BKEN0_Msk                    (1ul << PWM_PFBCON_BKEN0_Pos)       /*!< PWM PFBCON: BKEN0 Mask     */  
N
N/* PWM DZIR Bit Field Definitions */
N#define PWM_DZIR_DZI45_Pos                      16                                  /*!< PWM DZIR: DZI45 Position   */
N#define PWM_DZIR_DZI45_Msk                      (0xFFul << PWM_DZIR_DZI45_Pos)      /*!< PWM DZIR: DZI45 Mask       */
N
N#define PWM_DZIR_DZI23_Pos                      8                                   /*!< PWM DZIR: DZI23 Position   */
N#define PWM_DZIR_DZI23_Msk                      (0xFFul << PWM_DZIR_DZI23_Pos)      /*!< PWM DZIR: DZI23 Mask       */
N
N#define PWM_DZIR_DZI01_Pos                      0                                   /*!< PWM DZIR: DZI01 Position   */
N#define PWM_DZIR_DZI01_Msk                      (0xFFul << PWM_DZIR_DZI01_Pos)      /*!< PWM DZIR: DZI01 Mask       */
N
N/* PWM TRGCON0 Bit Field Definitions */
N#define PWM_TRGCON0_P3TRGEN_Pos                 27                                  /*!< PWM TRGCON0: P3TRGEN Position      */
N#define PWM_TRGCON0_P3TRGEN_Msk                 (1ul << PWM_TRGCON0_P3TRGEN_Pos)    /*!< PWM TRGCON0: P3TRGEN Mask          */
N
N#define PWM_TRGCON0_CM3TRGFEN_Pos               26                                  /*!< PWM TRGCON0: CM3TRGFEN Position    */
N#define PWM_TRGCON0_CM3TRGFEN_Msk               (1ul << PWM_TRGCON0_CM3TRGFEN_Pos)  /*!< PWM TRGCON0: CM3TRGFEN Mask        */
N
N#define PWM_TRGCON0_CNT3TRGEN_Pos               25                                  /*!< PWM TRGCON0: CNT3TRGEN Position    */
N#define PWM_TRGCON0_CNT3TRGEN_Msk               (1ul << PWM_TRGCON0_CNT3TRGEN_Pos)  /*!< PWM TRGCON0: CNT3TRGEN Mask        */
N
N#define PWM_TRGCON0_CM3TRGREN_Pos               24                                  /*!< PWM TRGCON0: CM3TRGREN Position    */
N#define PWM_TRGCON0_CM3TRGREN_Msk               (1ul << PWM_TRGCON0_CM3TRGREN_Pos)  /*!< PWM TRGCON0: CM3TRGREN Mask        */
N
N#define PWM_TRGCON0_P2TRGEN_Pos                 19                                  /*!< PWM TRGCON0: P2TRGEN Position      */
N#define PWM_TRGCON0_P2TRGEN_Msk                 (1ul << PWM_TRGCON0_P2TRGEN_Pos)    /*!< PWM TRGCON0: P2TRGEN Mask          */
N
N#define PWM_TRGCON0_CM2TRGFEN_Pos               18                                  /*!< PWM TRGCON0: CM2TRGFEN Position    */
N#define PWM_TRGCON0_CM2TRGFEN_Msk               (1ul << PWM_TRGCON0_CM2TRGFEN_Pos)  /*!< PWM TRGCON0: CM2TRGFEN Mask        */
N
N#define PWM_TRGCON0_CNT2TRGEN_Pos               17                                  /*!< PWM TRGCON0: CNT2TRGEN Position    */
N#define PWM_TRGCON0_CNT2TRGEN_Msk               (1ul << PWM_TRGCON0_CNT2TRGEN_Pos)  /*!< PWM TRGCON0: CNT2TRGEN Mask        */
N
N#define PWM_TRGCON0_CM2TRGREN_Pos               16                                  /*!< PWM TRGCON0: CM2TRGREN Position    */
N#define PWM_TRGCON0_CM2TRGREN_Msk               (1ul << PWM_TRGCON0_CM2TRGREN_Pos)  /*!< PWM TRGCON0: CM2TRGREN Mask        */
N
N#define PWM_TRGCON0_P1TRGEN_Pos                 11                                  /*!< PWM TRGCON0: P1TRGEN Position      */
N#define PWM_TRGCON0_P1TRGEN_Msk                 (1ul << PWM_TRGCON0_P1TRGEN_Pos)    /*!< PWM TRGCON0: P1TRGEN Mask          */
N
N#define PWM_TRGCON0_CM1TRGFEN_Pos               10                                  /*!< PWM TRGCON0: CM1TRGFEN Position    */
N#define PWM_TRGCON0_CM1TRGFEN_Msk               (1ul << PWM_TRGCON0_CM1TRGFEN_Pos)  /*!< PWM TRGCON0: CM1TRGFEN Mask        */
N
N#define PWM_TRGCON0_CNT1TRGEN_Pos               9                                   /*!< PWM TRGCON0: CNT1TRGEN Position    */
N#define PWM_TRGCON0_CNT1TRGEN_Msk               (1ul << PWM_TRGCON0_CNT1TRGEN_Pos)  /*!< PWM TRGCON0: CNT1TRGEN Mask        */
N
N#define PWM_TRGCON0_CM1TRGREN_Pos               8                                   /*!< PWM TRGCON0: CM1TRGREN Position    */
N#define PWM_TRGCON0_CM1TRGREN_Msk               (1ul << PWM_TRGCON0_CM1TRGREN_Pos)  /*!< PWM TRGCON0: CM1TRGREN Mask        */
N                        
N#define PWM_TRGCON0_P0TRGEN_Pos                 3                                   /*!< PWM TRGCON0: P0TRGEN Position      */
N#define PWM_TRGCON0_P0TRGEN_Msk                 (1ul << PWM_TRGCON0_P0TRGEN_Pos)    /*!< PWM TRGCON0: P0TRGEN Mask          */
N
N#define PWM_TRGCON0_CM0TRGFEN_Pos               2                                   /*!< PWM TRGCON0: CM0TRGFEN Position    */
N#define PWM_TRGCON0_CM0TRGFEN_Msk               (1ul << PWM_TRGCON0_CM0TRGFEN_Pos)  /*!< PWM TRGCON0: CM0TRGFEN Mask        */
N                        
N#define PWM_TRGCON0_CNT0TRGEN_Pos               1                                   /*!< PWM TRGCON0: CNT0TRGEN Position    */
N#define PWM_TRGCON0_CNT0TRGEN_Msk               (1ul << PWM_TRGCON0_CNT0TRGEN_Pos)  /*!< PWM TRGCON0: CNT0TRGEN Mask        */
N
N#define PWM_TRGCON0_CM0TRGREN_Pos               0                                   /*!< PWM TRGCON0: CM0TRGREN Position    */
N#define PWM_TRGCON0_CM0TRGREN_Msk               (1ul << PWM_TRGCON0_CM0TRGREN_Pos)  /*!< PWM TRGCON0: CM0TRGREN Mask        */
N
N/* PWM TRGCON1 Bit Field Definitions */
N#define PWM_TRGCON1_P5TRGEN_Pos                 11                                  /*!< PWM TRGCON1: P5TRGEN Position      */
N#define PWM_TRGCON1_P5TRGEN_Msk                 (1ul << PWM_TRGCON1_P5TRGEN_Pos)    /*!< PWM TRGCON1: P5TRGEN Mask          */
N
N#define PWM_TRGCON1_CM5TRGFEN_Pos               10                                  /*!< PWM TRGCON1: CM5TRGFEN Position    */
N#define PWM_TRGCON1_CM5TRGFEN_Msk               (1ul << PWM_TRGCON1_CM5TRGFEN_Pos)  /*!< PWM TRGCON1: CM5TRGFEN Mask        */
N
N#define PWM_TRGCON1_CNT5TRGEN_Pos               9                                   /*!< PWM TRGCON1: CNT5TRGEN Position    */
N#define PWM_TRGCON1_CNT5TRGEN_Msk               (1ul << PWM_TRGCON1_CNT5TRGEN_Pos)  /*!< PWM TRGCON1: CNT5TRGEN Mask        */
N
N#define PWM_TRGCON1_CM5TRGREN_Pos               8                                   /*!< PWM TRGCON1: CM5TRGREN Position    */
N#define PWM_TRGCON1_CM5TRGREN_Msk               (1ul << PWM_TRGCON1_CM5TRGREN_Pos)  /*!< PWM TRGCON1: CM5TRGREN Mask        */
N                        
N#define PWM_TRGCON1_P4TRGEN_Pos                 3                                   /*!< PWM TRGCON1: P4TRGEN Position      */
N#define PWM_TRGCON1_P4TRGEN_Msk                 (1ul << PWM_TRGCON1_P4TRGEN_Pos)    /*!< PWM TRGCON1: P4TRGEN Mask          */
N
N#define PWM_TRGCON1_CM4TRGFEN_Pos               2                                   /*!< PWM TRGCON1: CM4TRGFEN Position    */
N#define PWM_TRGCON1_CM4TRGFEN_Msk               (1ul << PWM_TRGCON1_CM4TRGFEN_Pos)  /*!< PWM TRGCON1: CM4TRGFEN Mask        */
N                        
N#define PWM_TRGCON1_CNT4TRGEN_Pos               1                                   /*!< PWM TRGCON1: CNT4TRGEN Position    */
N#define PWM_TRGCON1_CNT4TRGEN_Msk               (1ul << PWM_TRGCON1_CNT4TRGEN_Pos)  /*!< PWM TRGCON1: CNT4TRGEN Mask        */
N
N#define PWM_TRGCON1_CM4TRGREN_Pos               0                                   /*!< PWM TRGCON1: CM4TRGREN Position    */
N#define PWM_TRGCON1_CM4TRGREN_Msk               (1ul << PWM_TRGCON1_CM4TRGREN_Pos)  /*!< PWM TRGCON1: CM4TRGREN Mask        */
N
N/* PWM TRGSTS0 Bit Field Definitions */
N#define PWM_TRGSTS0_PERID3FLAG_Pos              27                                  /*!< PWM TRGSTS0: PERID3FLAG Position   */
N#define PWM_TRGSTS0_PERID3FLAG_Msk              (1ul << PWM_TRGSTS0_PERID3FLAG_Pos) /*!< PWM TRGSTS0: PERID3FLAG Mask       */
N
N#define PWM_TRGSTS0_CMR3FLAG_F_Pos              26                                  /*!< PWM TRGSTS0: CMR3FLAG_F Position   */
N#define PWM_TRGSTS0_CMR3FLAG_F_Msk              (1ul << PWM_TRGSTS0_CMR3FLAG_F_Pos) /*!< PWM TRGSTS0: CMR3FLAG_F Mask       */
N
N#define PWM_TRGSTS0_CNT3FLAG_Pos                25                                  /*!< PWM TRGSTS0: CNT3FLAG Position     */
N#define PWM_TRGSTS0_CNT3FLAG_Msk                (1ul << PWM_TRGSTS0_CNT3FLAG_Pos)   /*!< PWM TRGSTS0: CNT3FLAG Mask         */
N
N#define PWM_TRGSTS0_CMR3FLAG_R_Pos              24                                  /*!< PWM TRGSTS0: CMR3FLAG_R Position   */
N#define PWM_TRGSTS0_CMR3FLAG_R_Msk              (1ul << PWM_TRGSTS0_CMR3FLAG_R_Pos) /*!< PWM TRGSTS0: CMR3FLAG_R Mask       */
N
N#define PWM_TRGSTS0_PERID2FLAG_Pos              19                                  /*!< PWM TRGSTS0: PERID2FLAG Position   */
N#define PWM_TRGSTS0_PERID2FLAG_Msk              (1ul << PWM_TRGSTS0_PERID2FLAG_Pos) /*!< PWM TRGSTS0: PERID2FLAG Mask       */
N
N#define PWM_TRGSTS0_CMR2FLAG_F_Pos              18                                  /*!< PWM TRGSTS0: CMR2FLAG_F Position   */
N#define PWM_TRGSTS0_CMR2FLAG_F_Msk              (1ul << PWM_TRGSTS0_CMR2FLAG_F_Pos) /*!< PWM TRGSTS0: CMR2FLAG_F Mask       */
N
N#define PWM_TRGSTS0_CNT2FLAG_Pos                17                                  /*!< PWM TRGSTS0: CNT2FLAG Position     */
N#define PWM_TRGSTS0_CNT2FLAG_Msk                (1ul << PWM_TRGSTS0_CNT2FLAG_Pos)   /*!< PWM TRGSTS0: CNT2FLAG Mask         */
N
N#define PWM_TRGSTS0_CMR2FLAG_R_Pos              16                                  /*!< PWM TRGSTS0: CMR2FLAG_R Position   */
N#define PWM_TRGSTS0_CMR2FLAG_R_Msk              (1ul << PWM_TRGSTS0_CMR2FLAG_R_Pos) /*!< PWM TRGSTS0: CMR2FLAG_R Mask       */
N
N#define PWM_TRGSTS0_PERID1FLAG_Pos              11                                  /*!< PWM TRGSTS0: PERID1FLAG Position   */
N#define PWM_TRGSTS0_PERID1FLAG_Msk              (1ul << PWM_TRGSTS0_PERID1FLAG_Pos) /*!< PWM TRGSTS0: PERID1FLAG Mask       */
N
N#define PWM_TRGSTS0_CMR1FLAG_F_Pos              10                                  /*!< PWM TRGSTS0: CMR1FLAG_F Position   */
N#define PWM_TRGSTS0_CMR1FLAG_F_Msk              (1ul << PWM_TRGSTS0_CMR1FLAG_F_Pos) /*!< PWM TRGSTS0: CMR1FLAG_F Mask       */
N
N#define PWM_TRGSTS0_CNT1FLAG_Pos                9                                   /*!< PWM TRGSTS0: CNT1FLAG Position     */
N#define PWM_TRGSTS0_CNT1FLAG_Msk                (1ul << PWM_TRGSTS0_CNT1FLAG_Pos)   /*!< PWM TRGSTS0: CNT1FLAG Mask         */
N
N#define PWM_TRGSTS0_CMR1FLAG_R_Pos              8                                   /*!< PWM TRGSTS0: CMR1FLAG_R Position   */
N#define PWM_TRGSTS0_CMR1FLAG_R_Msk              (1ul << PWM_TRGSTS0_CMR1FLAG_R_Pos) /*!< PWM TRGSTS0: CMR1FLAG_R Mask       */
N                        
N#define PWM_TRGSTS0_PERID0FLAG_Pos              3                                   /*!< PWM TRGSTS0: PERID0FLAG Position   */
N#define PWM_TRGSTS0_PERID0FLAG_Msk              (1ul << PWM_TRGSTS0_PERID0FLAG_Pos) /*!< PWM TRGSTS0: PERID0FLAG Mask       */
N                        
N#define PWM_TRGSTS0_CMR0FLAG_F_Pos              2                                   /*!< PWM TRGSTS0: CMR0FLAG_F Position   */
N#define PWM_TRGSTS0_CMR0FLAG_F_Msk              (1ul << PWM_TRGSTS0_CMR0FLAG_F_Pos) /*!< PWM TRGSTS0: CMR0FLAG_F Mask       */
N                        
N#define PWM_TRGSTS0_CNT0FLAG_Pos                1                                   /*!< PWM TRGSTS0: CNT0FLAG Position     */
N#define PWM_TRGSTS0_CNT0FLAG_Msk                (1ul << PWM_TRGSTS0_CNT0FLAG_Pos)   /*!< PWM TRGSTS0: CNT0FLAG Mask         */
N
N#define PWM_TRGSTS0_CMR0FLAG_R_Pos              0                                   /*!< PWM TRGSTS0: CMR0FLAG_R Position   */
N#define PWM_TRGSTS0_CMR0FLAG_R_Msk              (1ul << PWM_TRGSTS0_CMR0FLAG_R_Pos) /*!< PWM TRGSTS0: CMR0FLAG_R Mask       */
N
N/* PWM TRGSTS1 Bit Field Definitions */
N#define PWM_TRGSTS1_PERID5FLAG_Pos              11                                  /*!< PWM TRGSTS1: PERID5FLAG Position   */
N#define PWM_TRGSTS1_PERID5FLAG_Msk              (1ul << PWM_TRGSTS1_PERID5FLAG_Pos) /*!< PWM TRGSTS1: PERID5FLAG Mask       */
N
N#define PWM_TRGSTS1_CMR5FLAG_F_Pos              10                                  /*!< PWM TRGSTS1: CMR5FLAG_F Position   */
N#define PWM_TRGSTS1_CMR5FLAG_F_Msk              (1ul << PWM_TRGSTS1_CMR5FLAG_F_Pos) /*!< PWM TRGSTS1: CMR5FLAG_F Mask       */
N
N#define PWM_TRGSTS1_CNT5FLAG_Pos                9                                   /*!< PWM TRGSTS1: CNT5FLAG Position     */
N#define PWM_TRGSTS1_CNT5FLAG_Msk                (1ul << PWM_TRGSTS1_CNT5FLAG_Pos)   /*!< PWM TRGSTS1: CNT5FLAG Mask         */
N
N#define PWM_TRGSTS1_CMR5FLAG_R_Pos              8                                   /*!< PWM TRGSTS1: CMR5FLAG_R Position   */
N#define PWM_TRGSTS1_CMR5FLAG_R_Msk              (1ul << PWM_TRGSTS1_CMR5FLAG_R_Pos) /*!< PWM TRGSTS1: CMR5FLAG_R Mask       */
N                        
N#define PWM_TRGSTS1_PERID4FLAG_Pos              3                                   /*!< PWM TRGSTS1: PERID4FLAG Position   */
N#define PWM_TRGSTS1_PERID4FLAG_Msk              (1ul << PWM_TRGSTS1_PERID4FLAG_Pos) /*!< PWM TRGSTS1: PERID4FLAG Mask       */
N                        
N#define PWM_TRGSTS1_CMR4FLAG_F_Pos              2                                   /*!< PWM TRGSTS1: CMR4FLAG_F Position   */
N#define PWM_TRGSTS1_CMR4FLAG_F_Msk              (1ul << PWM_TRGSTS1_CMR4FLAG_F_Pos) /*!< PWM TRGSTS1: CMR4FLAG_F Mask       */
N                        
N#define PWM_TRGSTS1_CNT4FLAG_Pos                1                                   /*!< PWM TRGSTS1: CNT4FLAG Position     */
N#define PWM_TRGSTS1_CNT4FLAG_Msk                (1ul << PWM_TRGSTS1_CNT4FLAG_Pos)   /*!< PWM TRGSTS1: CNT4FLAG Mask         */
N
N#define PWM_TRGSTS1_CMR4FLAG_R_Pos              0                                   /*!< PWM TRGSTS1: CMR4FLAG_R Position   */
N#define PWM_TRGSTS1_CMR4FLAG_R_Msk              (1ul << PWM_TRGSTS1_CMR4FLAG_R_Pos) /*!< PWM TRGSTS1: CMR4FLAG_R Mask       */
N
N/* PWM PHCHG Bit Field Definitions */
N#define PWM_PHCHG_CE0_Pos                       31                                  /*!< PWM PHCHG: CE0 Position        */
N#define PWM_PHCHG_CE0_Msk                       (1ul << PWM_PHCHG_CE0_Pos)          /*!< PWM PHCHG: CE0 Mask            */
N
N#define PWM_PHCHG_T0_Pos                        30                                  /*!< PWM PHCHG: T0 Position         */
N#define PWM_PHCHG_T0_Msk                        (1ul << PWM_PHCHG_T0_Pos)           /*!< PWM PHCHG: T0 Mask             */
N
N#define PWM_PHCHG_CMP0SEL_Pos                   28                                  /*!< PWM PHCHG: CMP0SEL Position    */
N#define PWM_PHCHG_CMP0SEL_Msk                   (3ul << PWM_PHCHG_CMP0SEL_Pos)      /*!< PWM PHCHG: CMP0SEL Mask        */
N
N#define PWM_PHCHG_CH31TOFF0_Pos                 27                                  /*!< PWM PHCHG: CH31TOFF0 Position  */
N#define PWM_PHCHG_CH31TOFF0_Msk                 (1ul << PWM_PHCHG_CH31TOFF0_Pos)    /*!< PWM PHCHG: CH31TOFF0 Mask      */
N
N#define PWM_PHCHG_CH21TOFF0_Pos                 26                                  /*!< PWM PHCHG: CH21TOFF0 Position  */
N#define PWM_PHCHG_CH21TOFF0_Msk                 (1ul << PWM_PHCHG_CH21TOFF0_Pos)    /*!< PWM PHCHG: CH21TOFF0 Mask      */
N
N#define PWM_PHCHG_CH11TOFF0_Pos                 25                                  /*!< PWM PHCHG: CH11TOFF0 Position  */
N#define PWM_PHCHG_CH11TOFF0_Msk                 (1ul << PWM_PHCHG_CH11TOFF0_Pos)    /*!< PWM PHCHG: CH11TOFF0 Mask      */
N
N#define PWM_PHCHG_CH01TOFF0_Pos                 24                                  /*!< PWM PHCHG: CH01TOFF0 Position  */
N#define PWM_PHCHG_CH01TOFF0_Msk                 (1ul << PWM_PHCHG_CH01TOFF0_Pos)    /*!< PWM PHCHG: CH01TOFF0 Mask      */
N
N#define PWM_PHCHG_CE1_Pos                       23                                  /*!< PWM PHCHG: CE1 Position    */
N#define PWM_PHCHG_CE1_Msk                       (1ul << PWM_PHCHG_CE1_Pos)          /*!< PWM PHCHG: CE1 Mask        */
N
N#define PWM_PHCHG_T1_Pos                        22                                  /*!< PWM PHCHG: T1 Position     */
N#define PWM_PHCHG_T1_Msk                        (1ul << PWM_PHCHG_T1_Pos)           /*!< PWM PHCHG: T1 Mask         */
N
N#define PWM_PHCHG_CMP1SEL_Pos                   20                                  /*!< PWM PHCHG: CMP1SEL Position    */
N#define PWM_PHCHG_CMP1SEL_Msk                   (3ul << PWM_PHCHG_CMP1SEL_Pos)      /*!< PWM PHCHG: CMP1SEL Mask        */
N
N#define PWM_PHCHG_CH31TOFF1_Pos                 19                                  /*!< PWM PHCHG: CH31TOFF1 Position  */
N#define PWM_PHCHG_CH31TOFF1_Msk                 (1ul << PWM_PHCHG_CH31TOFF1_Pos)    /*!< PWM PHCHG: CH31TOFF1 Mask      */
N
N#define PWM_PHCHG_CH21TOFF1_Pos                 18                                  /*!< PWM PHCHG: CH21TOFF1 Position  */
N#define PWM_PHCHG_CH21TOFF1_Msk                 (1ul << PWM_PHCHG_CH21TOFF1_Pos)    /*!< PWM PHCHG: CH21TOFF1 Mask      */
N
N#define PWM_PHCHG_CH11TOFF1_Pos                 17                                  /*!< PWM PHCHG: CH11TOFF1 Position  */
N#define PWM_PHCHG_CH11TOFF1_Msk                 (1ul << PWM_PHCHG_CH11TOFF1_Pos)    /*!< PWM PHCHG: CH11TOFF1 Mask      */
N
N#define PWM_PHCHG_CH01TOFF1_Pos                 16                                  /*!< PWM PHCHG: CH01TOFF1 Position  */
N#define PWM_PHCHG_CH01TOFF1_Msk                 (1ul << PWM_PHCHG_CH01TOFF1_Pos)    /*!< PWM PHCHG: CH01TOFF1 Mask      */
N
N#define PWM_PHCHG_ACCNT1_Pos                    15                                  /*!< PWM PHCHG: ACCNT1 Position */
N#define PWM_PHCHG_ACCNT1_Msk                    (1ul << PWM_PHCHG_ACCNT1_Pos)       /*!< PWM PHCHG: ACCNT1 Mask     */
N
N#define PWM_PHCHG_ACCNT0_Pos                    14                                  /*!< PWM PHCHG: ACCNT0 Position */
N#define PWM_PHCHG_ACCNT0_Msk                    (1ul << PWM_PHCHG_ACCNT0_Pos)       /*!< PWM PHCHG: ACCNT0 Mask     */
N
N#define PWM_PHCHG_PWM5_Pos                      13                                  /*!< PWM PHCHG: PWM5 Position   */
N#define PWM_PHCHG_PWM5_Msk                      (1ul << PWM_PHCHGPWM5_Pos)          /*!< PWM PHCHG: PWM5 Mask       */
N
N#define PWM_PHCHG_PWM4_Pos                      12                                  /*!< PWM PHCHG: PWM4 Position   */
N#define PWM_PHCHG_PWM4_Msk                      (1ul << PWM_PHCHG_PWM4_Pos)         /*!< PWM PHCHG: PWM4 Mask       */
N
N#define PWM_PHCHG_PWM3_Pos                      11                                  /*!< PWM PHCHG: PWM3 Position   */
N#define PWM_PHCHG_PWM3_Msk                      (1ul << PWM_PHCHG_PWM3_Pos)         /*!< PWM PHCHG: PWM3 Mask       */
N
N#define PWM_PHCHG_PWM2_Pos                      10                                  /*!< PWM PHCHG: PWM2 Position   */
N#define PWM_PHCHG_PWM2_Msk                      (1ul << PWM_PHCHG_PWM2_Pos)         /*!< PWM PHCHG: PWM2 Mask       */
N
N#define PWM_PHCHG_PWM1_Pos                      9                                   /*!< PWM PHCHG: PWM1 Position   */
N#define PWM_PHCHG_PWM1_Msk                      (1ul << PWM_PHCHG_PWM1_Pos)         /*!< PWM PHCHG: PWM1 Mask       */
N
N#define PWM_PHCHG_PWM0_Pos                      8                                   /*!< PWM PHCHG: PWM0 Position   */
N#define PWM_PHCHG_PWM0_Msk                      (1ul << PWM_PHCHG_PWM0_Pos)         /*!< PWM PHCHG: PWM0 Mask       */
N
N#define PWM_PHCHG_D7_Pos                        7                                   /*!< PWM PHCHG: D7 Position */
N#define PWM_PHCHG_D7_Msk                        (1ul << PWM_PHCHG_D7_Pos)           /*!< PWM PHCHG: D7 Mask     */
N
N#define PWM_PHCHG_D6_Pos                        6                                   /*!< PWM PHCHG: D6 Position */
N#define PWM_PHCHG_D6_Msk                        (1ul << PWM_PHCHG_D6_Pos)           /*!< PWM PHCHG: D6 Mask     */
N
N#define PWM_PHCHG_D5_Pos                        5                                   /*!< PWM PHCHG: D5 Position */
N#define PWM_PHCHG_D5_Msk                        (1ul << PWM_PHCHG_D5_Pos)           /*!< PWM PHCHG: D5 Mask     */
N
N#define PWM_PHCHG_D4_Pos                        4                                   /*!< PWM PHCHG: D4 Position */
N#define PWM_PHCHG_D4_Msk                        (1ul << PWM_PHCHG_D4_Pos)           /*!< PWM PHCHG: D4 Mask     */
N
N#define PWM_PHCHG_D3_Pos                        3                                   /*!< PWM PHCHG: D3 Position */
N#define PWM_PHCHG_D3_Msk                        (1ul << PWM_PHCHG_D3_Pos)           /*!< PWM PHCHG: D3 Mask     */
N
N#define PWM_PHCHG_D2_Pos                        2                                   /*!< PWM PHCHG: D2 Position */
N#define PWM_PHCHG_D2_Msk                        (1ul << PWM_PHCHG_D2_Pos)           /*!< PWM PHCHG: D2 Mask     */
N
N#define PWM_PHCHG_D1_Pos                        1                                   /*!< PWM PHCHG: D1 Position */
N#define PWM_PHCHG_D1_Msk                        (1ul << PWM_PHCHG_D1_Pos)           /*!< PWM PHCHG: D1 Mask     */
N
N#define PWM_PHCHG_D0_Pos                        0                                   /*!< PWM PHCHG: D0 Position */
N#define PWM_PHCHG_D0_Msk                        (1ul << PWM_PHCHG_D0_Pos)           /*!< PWM PHCHG: D0 Mask     */
N
N/* PWM PHCHGNXT Bit Field Definitions */
N#define PWM_PHCHGNXT_CE0_Pos                       31                                  /*!< PWM PHCHGNXT: CE0 Position  */
N#define PWM_PHCHGNXT_CE0_Msk                       (1ul << PWM_PHCHGNXT_CE0_Pos)       /*!< PWM PHCHGNXT: CE0 Mask      */
N
N#define PWM_PHCHGNXT_T0_Pos                        30                                  /*!< PWM PHCHGNXT: T0 Position   */
N#define PWM_PHCHGNXT_T0_Msk                        (1ul << PWM_PHCHGNXT_T0_Pos)        /*!< PWM PHCHGNXT: T0 Mask       */
N
N#define PWM_PHCHGNXT_CMP0SEL_Pos                   28                                  /*!< PWM PHCHGNXT: CMP0SEL Position  */
N#define PWM_PHCHGNXT_CMP0SEL_Msk                   (3ul << PWM_PHCHGNXT_CMP0SEL_Pos)   /*!< PWM PHCHGNXT: CMP0SEL Mask      */
N
N#define PWM_PHCHGNXT_CH31TOFF0_Pos                 27                                  /*!< PWM PHCHGNXT: CH31TOFF0 Position    */
N#define PWM_PHCHGNXT_CH31TOFF0_Msk                 (1ul << PWM_PHCHGNXT_CH31TOFF0_Pos) /*!< PWM PHCHGNXT: CH31TOFF0 Mask        */
N
N#define PWM_PHCHGNXT_CH21TOFF0_Pos                 26                                  /*!< PWM PHCHGNXT: CH21TOFF0 Position    */
N#define PWM_PHCHGNXT_CH21TOFF0_Msk                 (1ul << PWM_PHCHGNXT_CH21TOFF0_Pos) /*!< PWM PHCHGNXT: CH21TOFF0 Mask        */
N
N#define PWM_PHCHGNXT_CH11TOFF0_Pos                 25                                  /*!< PWM PHCHGNXT: CH11TOFF0 Position    */
N#define PWM_PHCHGNXT_CH11TOFF0_Msk                 (1ul << PWM_PHCHGNXT_CH11TOFF0_Pos) /*!< PWM PHCHGNXT: CH11TOFF0 Mask        */
N
N#define PWM_PHCHGNXT_CH01TOFF0_Pos                 24                                  /*!< PWM PHCHGNXT: CH01TOFF0 Position    */
N#define PWM_PHCHGNXT_CH01TOFF0_Msk                 (1ul << PWM_PHCHGNXT_CH01TOFF0_Pos) /*!< PWM PHCHGNXT: CH01TOFF0 Mask        */
N
N#define PWM_PHCHGNXT_CE1_Pos                       23                                  /*!< PWM PHCHGNXT: CE1 Position  */
N#define PWM_PHCHGNXT_CE1_Msk                       (1ul << PWM_PHCHGNXT_CE1_Pos)       /*!< PWM PHCHGNXT: CE1 Mask      */
N
N#define PWM_PHCHGNXT_T1_Pos                        22                                  /*!< PWM PHCHGNXT: T1 Position   */
N#define PWM_PHCHGNXT_T1_Msk                        (1ul << PWM_PHCHGNXT_T1_Pos)        /*!< PWM PHCHGNXT: T1 Mask       */
N
N#define PWM_PHCHGNXT_CMP1SEL_Pos                   20                                  /*!< PWM PHCHGNXT: CMP1SEL Position  */
N#define PWM_PHCHGNXT_CMP1SEL_Msk                   (3ul << PWM_PHCHGNXT_CMP1SEL_Pos)   /*!< PWM PHCHGNXT: CMP1SEL Mask      */
N
N#define PWM_PHCHGNXT_CH31TOFF1_Pos                 19                                  /*!< PWM PHCHGNXT: CH31TOFF1 Position    */
N#define PWM_PHCHGNXT_CH31TOFF1_Msk                 (1ul << PWM_PHCHGNXT_CH31TOFF1_Pos) /*!< PWM PHCHGNXT: CH31TOFF1 Mask        */
N
N#define PWM_PHCHGNXT_CH21TOFF1_Pos                 18                                  /*!< PWM PHCHGNXT: CH21TOFF1 Position    */
N#define PWM_PHCHGNXT_CH21TOFF1_Msk                 (1ul << PWM_PHCHGNXT_CH21TOFF1_Pos) /*!< PWM PHCHGNXT: CH21TOFF1 Mask        */
N
N#define PWM_PHCHGNXT_CH11TOFF1_Pos                 17                                  /*!< PWM PHCHGNXT: CH11TOFF1 Position    */
N#define PWM_PHCHGNXT_CH11TOFF1_Msk                 (1ul << PWM_PHCHGNXT_CH11TOFF1_Pos) /*!< PWM PHCHGNXT: CH11TOFF1 Mask        */
N
N#define PWM_PHCHGNXT_CH01TOFF1_Pos                 16                                  /*!< PWM PHCHGNXT: CH01TOFF1 Position    */
N#define PWM_PHCHGNXT_CH01TOFF1_Msk                 (1ul << PWM_PHCHGNXT_CH01TOFF1_Pos) /*!< PWM PHCHGNXT: CH01TOFF1 Mask        */
N
N#define PWM_PHCHGNXT_ACCNT1_Pos                    15                                  /*!< PWM PHCHGNXT: ACCNT1 Position   */
N#define PWM_PHCHGNXT_ACCNT1_Msk                    (1ul << PWM_PHCHGNXT_ACCNT1_Pos)    /*!< PWM PHCHGNXT: ACCNT1 Mask       */
N
N#define PWM_PHCHGNXT_ACCNT0_Pos                    14                                  /*!< PWM PHCHGNXT: ACCNT0 Position   */
N#define PWM_PHCHGNXT_ACCNT0_Msk                    (1ul << PWM_PHCHGNXT_ACCNT0_Pos)    /*!< PWM PHCHGNXT: ACCNT0 Mask       */
N
N#define PWM_PHCHGNXT_PWM5_Pos                      13                                  /*!< PWM PHCHGNXT: PWM5 Position */
N#define PWM_PHCHGNXT_PWM5_Msk                      (1ul << PWM_PHCHGNXTPWM5_Pos)       /*!< PWM PHCHGNXT: PWM5 Mask     */
N
N#define PWM_PHCHGNXT_PWM4_Pos                      12                                  /*!< PWM PHCHGNXT: PWM4 Position */
N#define PWM_PHCHGNXT_PWM4_Msk                      (1ul << PWM_PHCHGNXT_PWM4_Pos)      /*!< PWM PHCHGNXT: PWM4 Mask     */
N
N#define PWM_PHCHGNXT_PWM3_Pos                      11                                  /*!< PWM PHCHGNXT: PWM3 Position */
N#define PWM_PHCHGNXT_PWM3_Msk                      (1ul << PWM_PHCHGNXT_PWM3_Pos)      /*!< PWM PHCHGNXT: PWM3 Mask     */
N
N#define PWM_PHCHGNXT_PWM2_Pos                      10                                  /*!< PWM PHCHGNXT: PWM2 Position */
N#define PWM_PHCHGNXT_PWM2_Msk                      (1ul << PWM_PHCHGNXT_PWM2_Pos)      /*!< PWM PHCHGNXT: PWM2 Mask     */
N
N#define PWM_PHCHGNXT_PWM1_Pos                      9                                   /*!< PWM PHCHGNXT: PWM1 Position */
N#define PWM_PHCHGNXT_PWM1_Msk                      (1ul << PWM_PHCHGNXT_PWM1_Pos)      /*!< PWM PHCHGNXT: PWM1 Mask     */
N
N#define PWM_PHCHGNXT_PWM0_Pos                      8                                   /*!< PWM PHCHGNXT: PWM0 Position */
N#define PWM_PHCHGNXT_PWM0_Msk                      (1ul << PWM_PHCHGNXT_PWM0_Pos)      /*!< PWM PHCHGNXT: PWM0 Mask     */
N
N#define PWM_PHCHGNXT_D7_Pos                        7                                   /*!< PWM PHCHGNXT: D7 Position   */
N#define PWM_PHCHGNXT_D7_Msk                        (1ul << PWM_PHCHGNXT_D7_Pos)        /*!< PWM PHCHGNXT: D7 Mask       */
N
N#define PWM_PHCHGNXT_D6_Pos                        6                                   /*!< PWM PHCHGNXT: D6 Position   */
N#define PWM_PHCHGNXT_D6_Msk                        (1ul << PWM_PHCHGNXT_D6_Pos)        /*!< PWM PHCHGNXT: D6 Mask       */
N
N#define PWM_PHCHGNXT_D5_Pos                        5                                   /*!< PWM PHCHGNXT: D5 Position   */
N#define PWM_PHCHGNXT_D5_Msk                        (1ul << PWM_PHCHGNXT_D5_Pos)        /*!< PWM PHCHGNXT: D5 Mask       */
N
N#define PWM_PHCHGNXT_D4_Pos                        4                                   /*!< PWM PHCHGNXT: D4 Position   */
N#define PWM_PHCHGNXT_D4_Msk                        (1ul << PWM_PHCHGNXT_D4_Pos)        /*!< PWM PHCHGNXT: D4 Mask       */
N
N#define PWM_PHCHGNXT_D3_Pos                        3                                   /*!< PWM PHCHGNXT: D3 Position   */
N#define PWM_PHCHGNXT_D3_Msk                        (1ul << PWM_PHCHGNXT_D3_Pos)        /*!< PWM PHCHGNXT: D3 Mask       */
N
N#define PWM_PHCHGNXT_D2_Pos                        2                                   /*!< PWM PHCHGNXT: D2 Position   */
N#define PWM_PHCHGNXT_D2_Msk                        (1ul << PWM_PHCHGNXT_D2_Pos)        /*!< PWM PHCHGNXT: D2 Mask       */
N
N#define PWM_PHCHGNXT_D1_Pos                        1                                   /*!< PWM PHCHGNXT: D1 Position   */
N#define PWM_PHCHGNXT_D1_Msk                        (1ul << PWM_PHCHGNXT_D1_Pos)        /*!< PWM PHCHGNXT: D1 Mask       */
N
N#define PWM_PHCHGNXT_D0_Pos                        0                                   /*!< PWM PHCHGNXT: D0 Position   */
N#define PWM_PHCHGNXT_D0_Msk                        (1ul << PWM_PHCHGNXT_D0_Pos)        /*!< PWM PHCHGNXT: D0 Mask       */
N
N/* PWM PHCHGMASK Bit Field Definitions */
N#define PWM_PHCHGMASK_CMPMASK_Pos                  8                                        /*!< PWM PHCHGMASK: CMPMASK Position        */
N#define PWM_PHCHGMASK_CMPMASK_Msk                  (3ul << PWM_PHCHGMASK_CMPMASK_Pos)       /*!< PWM PHCHGMASK: CMPMASK Mask            */
N
N#define PWM_PHCHGMASK_MASK7_Pos                    7                                        /*!< PWM PHCHGMASK: MASK7 Position          */
N#define PWM_PHCHGMASK_MASK7_Msk                    (1ul << PWM_PHCHGMASK_MASK7_Pos)         /*!< PWM PHCHGMASK: MASK7 Mask              */
N
N#define PWM_PHCHGMASK_MASK6_Pos                    6                                        /*!< PWM PHCHGMASK: MASK6 Position          */
N#define PWM_PHCHGMASK_MASK6_Msk                    (1ul << PWM_PHCHGMASK_MASK6_Pos)         /*!< PWM PHCHGMASK: MASK6 Mask              */
N
N/* PWM INTACCUCTL Bit Field Definitions */
N#define PWM_INTACCUCTL_PERIODCNT_Pos               4                                        /*!< PWM INTACCUCTL: PERIODCNT Position     */
N#define PWM_INTACCUCTL_PERIODCNT_Msk               (0xFul << PWM_INTACCUCTL_PERIODCNT_Pos)  /*!< PWM INTACCUCTL: PERIODCNT Mask         */
N
N#define PWM_INTACCUCTL_INTACCUEN0_Pos              0                                        /*!< PWM INTACCUCTL: INTACCUEN0 Position    */
N#define PWM_INTACCUCTL_INTACCUEN0_Msk              (1ul << PWM_INTACCUCTL_INTACCUEN0_Pos)   /*!< PWM INTACCUCTL: INTACCUEN0 Mask        */
N
N
N/*@}*/ /* end of group MINI51_PWM */
N
N
N/*------------------------- SPI Interface Controller -------------------------*/
N
N/** @addtogroup MINI51_SPI MINI51 SPI
N  Memory Mapped Structure for MINI51 Series SPI Controller
N  @{
N */
N/**
N  * @brief SPI register map
N  */   
Ntypedef struct
N{
N    __IO uint32_t CNTRL;          /*!< Offset: 0x0000  SPI Control and Status Register           */
X    volatile uint32_t CNTRL;           
N    __IO uint32_t DIVIDER;        /*!< Offset: 0x0004  SPI Clock Divider Register                */
X    volatile uint32_t DIVIDER;         
N    __IO uint32_t SSR;            /*!< Offset: 0x0008  SPI Slave Select Register                 */
X    volatile uint32_t SSR;             
N         uint32_t RESERVED0;      /*!< Offset: 0x000C  Reserved                                  */
N    __I  uint32_t RX;             /*!< Offset: 0x0010  SPI Data Receive Register                 */
X    volatile const  uint32_t RX;              
N         uint32_t RESERVED1[3];   /*!< Offset: 0x0014~0x001C  Reserved                           */
N    __O  uint32_t TX;             /*!< Offset: 0x0020  SPI Data Transmit Register                */
X    volatile  uint32_t TX;              
N         uint32_t RESERVED2[6];   /*!< Offset: 0x0024 ~ 0x0038  Reserved                         */
N    __IO uint32_t CNTRL2;         /*!< Offset: 0x003C  SPI Control and Status Register 2         */
X    volatile uint32_t CNTRL2;          
N    __IO uint32_t FIFO_CTL;       /*!< Offset: 0x0040  SPI FIFO Control Register                 */
X    volatile uint32_t FIFO_CTL;        
N    __IO uint32_t STATUS;         /*!< Offset: 0x0044  SPI Status Register                       */
X    volatile uint32_t STATUS;          
N} SPI_T; 
N
N/* SPI_CNTRL Bit Field Definitions */
N#define SPI_CNTRL_TX_FULL_Pos      27                                     /*!< SPI CNTRL: TX_FULL Position      */
N#define SPI_CNTRL_TX_FULL_Msk      (1ul << SPI_CNTRL_TX_FULL_Pos)         /*!< SPI CNTRL: TX_FULL Mask          */
N
N#define SPI_CNTRL_TX_EMPTY_Pos     26                                     /*!< SPI CNTRL: TX_EMPTY Position     */
N#define SPI_CNTRL_TX_EMPTY_Msk     (1ul << SPI_CNTRL_TX_EMPTY_Pos)        /*!< SPI CNTRL: TX_EMPTY Mask         */
N
N#define SPI_CNTRL_RX_FULL_Pos      25                                     /*!< SPI CNTRL: RX_FULL Position      */
N#define SPI_CNTRL_RX_FULL_Msk      (1ul << SPI_CNTRL_RX_FULL_Pos)         /*!< SPI CNTRL: RX_FULL Mask          */
N
N#define SPI_CNTRL_RX_EMPTY_Pos     24                                     /*!< SPI CNTRL: RX_EMPTY Position     */
N#define SPI_CNTRL_RX_EMPTY_Msk     (1ul << SPI_CNTRL_RX_EMPTY_Pos)        /*!< SPI CNTRL: RX_EMPTY Mask         */
N
N#define SPI_CNTRL_FIFO_Pos         21                                     /*!< SPI CNTRL: FIFO Position         */
N#define SPI_CNTRL_FIFO_Msk         (1ul << SPI_CNTRL_FIFO_Pos)            /*!< SPI CNTRL: FIFO Mask             */
N
N#define SPI_CNTRL_REORDER_Pos      19                                     /*!< SPI CNTRL: REORDER Position      */
N#define SPI_CNTRL_REORDER_Msk      (3ul << SPI_CNTRL_REORDER_Pos)         /*!< SPI CNTRL: REORDER Mask          */
N
N#define SPI_CNTRL_SLAVE_Pos        18                                     /*!< SPI CNTRL: SLAVE Position        */
N#define SPI_CNTRL_SLAVE_Msk        (1ul << SPI_CNTRL_SLAVE_Pos)           /*!< SPI CNTRL: SLAVE Mask            */
N
N#define SPI_CNTRL_IE_Pos           17                                     /*!< SPI CNTRL: IE Position           */
N#define SPI_CNTRL_IE_Msk           (1ul << SPI_CNTRL_IE_Pos)              /*!< SPI CNTRL: IE Mask               */
N
N#define SPI_CNTRL_IF_Pos           16                                     /*!< SPI CNTRL: IF Position           */
N#define SPI_CNTRL_IF_Msk           (1ul << SPI_CNTRL_IF_Pos)              /*!< SPI CNTRL: IF Mask               */
N
N#define SPI_CNTRL_SP_CYCLE_Pos     12                                     /*!< SPI CNTRL: SP_CYCLE Position     */
N#define SPI_CNTRL_SP_CYCLE_Msk     (0xFul << SPI_CNTRL_SP_CYCLE_Pos)      /*!< SPI CNTRL: SP_CYCLE Mask         */
N
N#define SPI_CNTRL_CLKP_Pos         11                                     /*!< SPI CNTRL: CLKP Position         */
N#define SPI_CNTRL_CLKP_Msk         (1ul << SPI_CNTRL_CLKP_Pos)            /*!< SPI CNTRL: CLKP Mask             */
N
N#define SPI_CNTRL_LSB_Pos          10                                     /*!< SPI CNTRL: LSB Position          */
N#define SPI_CNTRL_LSB_Msk          (1ul << SPI_CNTRL_LSB_Pos)             /*!< SPI CNTRL: LSB Mask              */
N
N#define SPI_CNTRL_TX_BIT_LEN_Pos   3                                      /*!< SPI CNTRL: TX_BIT_LEN Position   */
N#define SPI_CNTRL_TX_BIT_LEN_Msk   (0x1Ful << SPI_CNTRL_TX_BIT_LEN_Pos)   /*!< SPI CNTRL: TX_BIT_LEN Mask       */
N
N#define SPI_CNTRL_TX_NEG_Pos       2                                      /*!< SPI CNTRL: TX_NEG Position       */
N#define SPI_CNTRL_TX_NEG_Msk       (1ul << SPI_CNTRL_TX_NEG_Pos)          /*!< SPI CNTRL: TX_NEG Mask           */
N
N#define SPI_CNTRL_RX_NEG_Pos       1                                      /*!< SPI CNTRL: RX_NEG Position       */
N#define SPI_CNTRL_RX_NEG_Msk       (1ul << SPI_CNTRL_RX_NEG_Pos)          /*!< SPI CNTRL: RX_NEG Mask           */
N
N#define SPI_CNTRL_GO_BUSY_Pos      0                                      /*!< SPI CNTRL: GO_BUSY Position      */
N#define SPI_CNTRL_GO_BUSY_Msk      (1ul << SPI_CNTRL_GO_BUSY_Pos)         /*!< SPI CNTRL: GO_BUSY Mask          */
N
N/* SPI_DIVIDER Bit Field Definitions */
N#define SPI_DIVIDER_DIVIDER_Pos    0                                      /*!< SPI DIVIDER: DIVIDER Position    */
N#define SPI_DIVIDER_DIVIDER_Msk    (0xFul << SPI_DIVIDER_DIVIDER_Pos)     /*!< SPI DIVIDER: DIVIDER Mask        */
N
N/* SPI_SSR Bit Field Definitions */
N#define SPI_SSR_LTRIG_FLAG_Pos     5                                 /*!< SPI SSR: LTRIG_FLAG Position  */
N#define SPI_SSR_LTRIG_FLAG_Msk     (1ul << SPI_SSR_LTRIG_FLAG_Pos)   /*!< SPI SSR: LTRIG_FLAG Mask      */
N
N#define SPI_SSR_SS_LTRIG_Pos       4                                 /*!< SPI SSR: SS_LTRIG Position    */
N#define SPI_SSR_SS_LTRIG_Msk       (1ul << SPI_SSR_SS_LTRIG_Pos)     /*!< SPI SSR: SS_LTRIG Mask        */
N
N#define SPI_SSR_AUTOSS_Pos         3                                 /*!< SPI SSR: AUTOSS Position      */
N#define SPI_SSR_AUTOSS_Msk         (1ul << SPI_SSR_AUTOSS_Pos)       /*!< SPI SSR: AUTOSS Mask          */
N
N#define SPI_SSR_SS_LVL_Pos         2                                 /*!< SPI SSR: SS_LVL Position      */
N#define SPI_SSR_SS_LVL_Msk         (1ul << SPI_SSR_SS_LVL_Pos)       /*!< SPI SSR: SS_LVL Mask          */
N
N#define SPI_SSR_SSR_Pos            0                                 /*!< SPI SSR: SSR Position         */
N#define SPI_SSR_SSR_Msk            (1ul << SPI_SSR_SSR_Pos)          /*!< SPI SSR: SSR Mask             */
N
N/* SPI_CNTRL2 Bit Field Definitions */
N#define SPI_CNTRL2_BCn_Pos   31                                                      /*!< SPI CNTRL2: BCn Position          */
N#define SPI_CNTRL2_BCn_Msk   (1ul << SPI_CNTRL2_BCn_Pos)                             /*!< SPI CNTRL2: BCn Mask              */
N
N#define SPI_CNTRL2_SS_INT_OPT_Pos   16                                               /*!< SPI CNTRL2: SS_INT_OPT Position   */
N#define SPI_CNTRL2_SS_INT_OPT_Msk   (1ul << SPI_CNTRL2_SS_INT_OPT_Pos)               /*!< SPI CNTRL2: SS_INT_OPT Mask       */
N
N#define SPI_CNTRL2_SLV_START_INTSTS_Pos   11                                         /*!< SPI CNTRL2: SLV_START_INTSTS Position */
N#define SPI_CNTRL2_SLV_START_INTSTS_Msk   (1ul << SPI_CNTRL2_SLV_START_INTSTS_Pos)   /*!< SPI CNTRL2: SLV_START_INTSTS Mask     */
N
N#define SPI_CNTRL2_SSTA_INTEN_Pos   10                                               /*!< SPI CNTRL2: SSTA_INTEN Position   */
N#define SPI_CNTRL2_SSTA_INTEN_Msk   (1ul << SPI_CNTRL2_SSTA_INTEN_Pos)               /*!< SPI CNTRL2: SSTA_INTEN Mask       */
N
N#define SPI_CNTRL2_SLV_ABORT_Pos    9                                                /*!< SPI CNTRL2: SLV_ABORT Position    */
N#define SPI_CNTRL2_SLV_ABORT_Msk    (1ul << SPI_CNTRL2_SLV_ABORT_Pos)                /*!< SPI CNTRL2: SLV_ABORT Mask        */
N
N#define SPI_CNTRL2_NOSLVSEL_Pos     8                                                /*!< SPI CNTRL2: NOSLVSEL Position     */
N#define SPI_CNTRL2_NOSLVSEL_Msk     (1ul << SPI_CNTRL2_NOSLVSEL_Pos)                 /*!< SPI CNTRL2: NOSLVSEL Mask         */
N
N/* SPI_FIFO_CTL Bit Field Definitions */
N#define SPI_FIFO_CTL_TX_THRESHOLD_Pos   28                                         /*!< SPI FIFO_CTL: TX_THRESHOLD Position */
N#define SPI_FIFO_CTL_TX_THRESHOLD_Msk   (3ul << SPI_FIFO_CTL_TX_THRESHOLD_Pos)     /*!< SPI FIFO_CTL: TX_THRESHOLD Mask     */
N
N#define SPI_FIFO_CTL_RX_THRESHOLD_Pos   24                                         /*!< SPI FIFO_CTL: RX_THRESHOLD Position */
N#define SPI_FIFO_CTL_RX_THRESHOLD_Msk   (3ul << SPI_FIFO_CTL_RX_THRESHOLD_Pos)     /*!< SPI FIFO_CTL: RX_THRESHOLD Mask     */
N
N#define SPI_FIFO_CTL_TIMEOUT_INTEN_Pos   21                                        /*!< SPI FIFO_CTL: TIMEOUT_INTEN Position    */
N#define SPI_FIFO_CTL_TIMEOUT_INTEN_Msk   (1ul << SPI_FIFO_CTL_TIMEOUT_INTEN_Pos)   /*!< SPI FIFO_CTL: TIMEOUT_INTEN Mask        */
N
N#define SPI_FIFO_CTL_RXOV_INTEN_Pos    6                                           /*!< SPI FIFO_CTL: RXOV_INTEN Position   */
N#define SPI_FIFO_CTL_RXOV_INTEN_Msk    (1ul << SPI_FIFO_CTL_RXOV_INTEN_Pos)        /*!< SPI FIFO_CTL: RXOV_INTEN Mask       */
N
N#define SPI_FIFO_CTL_TX_INTEN_Pos    3                                             /*!< SPI FIFO_CTL: TX_INTEN Position     */
N#define SPI_FIFO_CTL_TX_INTEN_Msk    (1ul << SPI_FIFO_CTL_TX_INTEN_Pos)            /*!< SPI FIFO_CTL: TX_INTEN Mask         */
N
N#define SPI_FIFO_CTL_RX_INTEN_Pos    2                                             /*!< SPI FIFO_CTL: RX_INTEN Position     */
N#define SPI_FIFO_CTL_RX_INTEN_Msk    (1ul << SPI_FIFO_CTL_RX_INTEN_Pos)            /*!< SPI FIFO_CTL: RX_INTEN Mask         */
N
N#define SPI_FIFO_CTL_TX_CLR_Pos     1                                              /*!< SPI FIFO_CTL: TX_CLR Position       */
N#define SPI_FIFO_CTL_TX_CLR_Msk     (1ul << SPI_FIFO_CTL_TX_CLR_Pos)               /*!< SPI FIFO_CTL: TX_CLR Mask           */
N
N#define SPI_FIFO_CTL_RX_CLR_Pos      0                                             /*!< SPI FIFO_CTL: RX_CLR Position       */
N#define SPI_FIFO_CTL_RX_CLR_Msk      (1ul << SPI_FIFO_CTL_RX_CLR_Pos)              /*!< SPI FIFO_CTL: RX_CLR Mask           */
N
N/* SPI_STATUS Bit Field Definitions */
N#define SPI_STATUS_TX_FIFO_COUNT_Pos   28                                            /*!< SPI STATUS: TX_FIFO_COUNT Position    */
N#define SPI_STATUS_TX_FIFO_COUNT_Msk   (0xFul << SPI_STATUS_TX_FIFO_COUNT_Pos)       /*!< SPI STATUS: TX_FIFO_COUNT Mask        */
N
N#define SPI_STATUS_TX_FULL_Pos   27                                                  /*!< SPI STATUS: TX_FULL Position      */
N#define SPI_STATUS_TX_FULL_Msk   (1ul << SPI_STATUS_TX_FULL_Pos)                     /*!< SPI STATUS: TX_FULL Mask          */
N
N#define SPI_STATUS_TX_EMPTY_Pos   26                                                 /*!< SPI STATUS: TX_EMPTY Position     */
N#define SPI_STATUS_TX_EMPTY_Msk   (1ul << SPI_STATUS_TX_EMPTY_Pos)                   /*!< SPI STATUS: TX_EMPTY Mask         */
N
N#define SPI_STATUS_RX_FULL_Pos   25                                                  /*!< SPI STATUS: RX_FULL Position      */
N#define SPI_STATUS_RX_FULL_Msk   (1ul << SPI_STATUS_RX_FULL_Pos)                     /*!< SPI STATUS: RX_FULL Mask          */
N
N#define SPI_STATUS_RX_EMPTY_Pos   24                                                 /*!< SPI STATUS: RX_EMPTY Position     */
N#define SPI_STATUS_RX_EMPTY_Msk   (1ul << SPI_STATUS_RX_EMPTY_Pos)                   /*!< SPI STATUS: RX_EMPTY Mask         */
N
N#define SPI_STATUS_TIMEOUT_Pos   20                                                  /*!< SPI STATUS: TIMEOUT Position      */
N#define SPI_STATUS_TIMEOUT_Msk   (1ul << SPI_STATUS_TIMEOUT_Pos)                     /*!< SPI STATUS: TIMEOUT Mask          */
N
N#define SPI_STATUS_IF_Pos           16                                               /*!< SPI STATUS: IF Position           */
N#define SPI_STATUS_IF_Msk           (1ul << SPI_STATUS_IF_Pos)                       /*!< SPI STATUS: IF Mask               */
N
N#define SPI_STATUS_RX_FIFO_COUNT_Pos   12                                            /*!< SPI STATUS: RX_FIFO_COUNT Position    */
N#define SPI_STATUS_RX_FIFO_COUNT_Msk   (0xFul << SPI_STATUS_RX_FIFO_COUNT_Pos)       /*!< SPI STATUS: RX_FIFO_COUNT Mask        */
N
N#define SPI_STATUS_SLV_START_INTSTS_Pos   11                                         /*!< SPI STATUS: SLV_START_INTSTS Position */
N#define SPI_STATUS_SLV_START_INTSTS_Msk   (1ul << SPI_STATUS_SLV_START_INTSTS_Pos)   /*!< SPI STATUS: SLV_START_INTSTS Mask     */
N
N#define SPI_STATUS_TX_INTSTS_Pos    4                                                /*!< SPI STATUS: TX_INTSTS Position    */
N#define SPI_STATUS_TX_INTSTS_Msk    (1ul << SPI_STATUS_TX_INTSTS_Pos)                /*!< SPI STATUS: TX_INTSTS Mask        */
N
N#define SPI_STATUS_RX_OVERRUN_Pos    2                                               /*!< SPI STATUS: RX_OVERRUN Position   */
N#define SPI_STATUS_RX_OVERRUN_Msk    (1ul << SPI_STATUS_RX_OVERRUN_Pos)              /*!< SPI STATUS: RX_OVERRUN Mask       */
N
N#define SPI_STATUS_RX_INTSTS_Pos    0                                                /*!< SPI STATUS: RX_INTSTS Position    */
N#define SPI_STATUS_RX_INTSTS_Msk    (1ul << SPI_STATUS_RX_INTSTS_Pos)                /*!< SPI STATUS: RX_INTSTS Mask        */
N/*@}*/ /* end of group MINI51_SPI */
N
N
N/*----------------------------- Timer Controller -----------------------------*/
N/** @addtogroup MINI51_TIMER MINI51 TIMER
N  Memory Mapped Structure for MINI51 Series Timer Controller
N  @{
N */ 
N/**
N  * @brief Timer register map
N  */   
Ntypedef struct
N{
N  __IO uint32_t  TCSR;       /*!< Offset: 0x0000   Timer Control and Status Register          */
X  volatile uint32_t  TCSR;        
N  __IO uint32_t  TCMPR;      /*!< Offset: 0x0004   Timer Compare Register                     */
X  volatile uint32_t  TCMPR;       
N  __IO uint32_t  TISR;       /*!< Offset: 0x0008   Timer Interrupt Status Register            */
X  volatile uint32_t  TISR;        
N  __I  uint32_t  TDR;        /*!< Offset: 0x000C   Timer Data Register                        */
X  volatile const  uint32_t  TDR;         
N  __I  uint32_t  TCAP;       /*!< Offset: 0x0010   Timer Capture Data Register                */
X  volatile const  uint32_t  TCAP;        
N  __IO uint32_t  TEXCON;     /*!< Offset: 0x0014   Timer External Control Register            */
X  volatile uint32_t  TEXCON;      
N  __IO uint32_t  TEXISR;     /*!< Offset: 0x0018   Timer External Interrupt Status Register   */
X  volatile uint32_t  TEXISR;      
N} TIMER_T;
N
N/* TIMER TCSR Bit Field Definitions */
N#define TIMER_TCSR_DBGACK_TMR_Pos   31                                          /*!< TIMER TCSR: DBGACK_TMR Position    */
N#define TIMER_TCSR_DBGACK_TMR_Msk   (1ul << TIMER_TCSR_DBGACK_TMR_Pos)          /*!< TIMER TCSR: DBGACK_TMR Mask        */
N
N#define TIMER_TCSR_CEN_Pos          30                                          /*!< TIMER TCSR: CEN Position           */
N#define TIMER_TCSR_CEN_Msk          (1ul << TIMER_TCSR_CEN_Pos)                 /*!< TIMER TCSR: CEN Mask               */
N
N#define TIMER_TCSR_IE_Pos           29                                          /*!< TIMER TCSR: IE Position            */
N#define TIMER_TCSR_IE_Msk           (1ul << TIMER_TCSR_IE_Pos)                  /*!< TIMER TCSR: IE Mask                */
N
N#define TIMER_TCSR_MODE_Pos         27                                          /*!< TIMER TCSR: MODE Position          */
N#define TIMER_TCSR_MODE_Msk         (0x3ul << TIMER_TCSR_MODE_Pos)              /*!< TIMER TCSR: MODE Mask              */
N
N#define TIMER_TCSR_CRST_Pos         26                                          /*!< TIMER TCSR: CRST Position          */
N#define TIMER_TCSR_CRST_Msk         (1ul << TIMER_TCSR_CRST_Pos)                /*!< TIMER TCSR: CRST Mask              */
N
N#define TIMER_TCSR_CACT_Pos         25                                          /*!< TIMER TCSR: CACT Position          */
N#define TIMER_TCSR_CACT_Msk         (1ul << TIMER_TCSR_CACT_Pos)                /*!< TIMER TCSR: CACT Mask              */
N
N#define TIMER_TCSR_CTB_Pos          24                                          /*!< TIMER TCSR: CTB Position           */
N#define TIMER_TCSR_CTB_Msk          (1ul << TIMER_TCSR_CTB_Pos)                 /*!< TIMER TCSR: CTB Mask               */
N
N#define TIMER_TCSR_WAKE_EN_Pos      23                                          /*!< TIMER TCSR: WAKE_EN Position       */
N#define TIMER_TCSR_WAKE_EN_Msk      (1ul << TIMER_TCSR_WAKE_EN_Pos)             /*!< TIMER TCSR: WAKE_EN Mask           */
N
N#define TIMER_TCSR_CAP_SRC_Pos      19                                          /*!< TIMER TCSR: CAP_SRC Position       */
N#define TIMER_TCSR_CAP_SRC_Msk      (1ul << TIMER_TCSR_CAP_SRC_Pos)             /*!< TIMER TCSR: CAP_SRC Mask           */
N
N#define TIMER_TCSR_TOGGLE_PIN_Pos   18                                          /*!< TIMER TCSR: TOGGLE_PIN Position    */
N#define TIMER_TCSR_TOGGLE_PIN_Msk   (1ul << TIMER_TCSR_TOGGLE_PIN_Pos)          /*!< TIMER TCSR: TOGGLE_PIN Mask        */
N
N#define TIMER_TCSR_PERIODIC_SEL_Pos 17                                          /*!< TIMER TCSR: PERIODIC_SEL Position  */
N#define TIMER_TCSR_PERIODIC_SEL_Msk (1ul << TIMER_TCSR_PERIODIC_SEL_Pos)        /*!< TIMER TCSR: PERIODIC_SEL Mask      */
N
N#define TIMER_TCSR_TDR_EN_Pos       16                                          /*!< TIMER TCSR: TDR_EN Position        */
N#define TIMER_TCSR_TDR_EN_Msk       (1ul << TIMER_TCSR_TDR_EN_Pos)              /*!< TIMER TCSR: TDR_EN Mask            */
N
N#define TIMER_TCSR_PRESCALE_Pos     0                                           /*!< TIMER TCSR: PRESCALE Position      */
N#define TIMER_TCSR_PRESCALE_Msk     (0xFFul << TIMER_TCSR_PRESCALE_Pos)         /*!< TIMER TCSR: PRESCALE Mask          */
N
N/* TIMER TCMPR Bit Field Definitions */
N#define TIMER_TCMP_TCMP_Pos         0                                           /*!< TIMER TCMPR: TCMP Position         */
N#define TIMER_TCMP_TCMP_Msk         (0xFFFFFFul << TIMER_TCMP_TCMP_Pos)         /*!< TIMER TCMPR: TCMP Mask             */
N
N/* TIMER TISR Bit Field Definitions */
N#define TIMER_TISR_TWF_Pos          1                                           /*!< TIMER TISR: TWF Position           */
N#define TIMER_TISR_TWF_Msk          (1ul << TIMER_TISR_TWF_Pos)                 /*!< TIMER TISR: TWF Mask               */
N
N#define TIMER_TISR_TIF_Pos          0                                           /*!< TIMER TISR: TIF Position           */
N#define TIMER_TISR_TIF_Msk          (1ul << TIMER_TISR_TIF_Pos)                 /*!< TIMER TISR: TIF Mask               */
N
N/* TIMER TDR Bit Field Definitions */
N#define TIMER_TDR_TDR_Pos           0                                           /*!< TIMER TDR: TDR Position            */
N#define TIMER_TDR_TDR_Msk           (0xFFFFFFul << TIMER_TDR_TDR_Pos)           /*!< TIMER TDR: TDR Mask                */
N
N/* TIMER TCAP Bit Field Definitions */
N#define TIMER_TCAP_TCAP_Pos         0                                           /*!< TIMER TCAP: TCAP Position          */
N#define TIMER_TCAP_TCAP_Msk         (0xFFFFFFul << TIMER_TCAP_TCAP_Pos)         /*!< TIMER TCAP: TCAP Mask              */
N
N/* TIMER TEXCON Bit Field Definitions */
N#define TIMER_TEXCON_CAP_MODE_Pos   8                                           /*!< TIMER TEXCON: CAP_MODE Position    */
N#define TIMER_TEXCON_CAP_MODE_Msk   (1ul << TIMER_TEXCON_CAP_MODE_Pos)          /*!< TIMER TEXCON: CAP_MODE Mask        */
N
N#define TIMER_TEXCON_TCDB_Pos       7                                           /*!< TIMER TEXCON: TCDB Position        */
N#define TIMER_TEXCON_TCDB_Msk       (1ul << TIMER_TEXCON_TCDB_Pos)              /*!< TIMER TEXCON: TCDB Mask            */
N
N#define TIMER_TEXCON_TEXDB_Pos      6                                           /*!< TIMER TEXCON: TEXDB Position       */
N#define TIMER_TEXCON_TEXDB_Msk      (1ul << TIMER_TEXCON_TEXDB_Pos)             /*!< TIMER TEXCON: TEXDB Mask           */
N
N#define TIMER_TEXCON_TEXIEN_Pos     5                                           /*!< TIMER TEXCON: TEXIEN Position      */
N#define TIMER_TEXCON_TEXIEN_Msk     (1ul << TIMER_TEXCON_TEXIEN_Pos)            /*!< TIMER TEXCON: TEXIEN Mask          */
N
N#define TIMER_TEXCON_RSTCAPSEL_Pos  4                                           /*!< TIMER TEXCON: RSTCAPSEL Position   */
N#define TIMER_TEXCON_RSTCAPSEL_Msk  (1ul << TIMER_TEXCON_RSTCAPSEL_Pos)         /*!< TIMER TEXCON: RSTCAPSEL Mask       */
N
N#define TIMER_TEXCON_TEXEN_Pos      3                                           /*!< TIMER TEXCON: TEXEN Position       */
N#define TIMER_TEXCON_TEXEN_Msk      (1ul << TIMER_TEXCON_TEXEN_Pos)             /*!< TIMER TEXCON: TEXEN Mask           */
N
N#define TIMER_TEXCON_TEX_EDGE_Pos   1                                           /*!< TIMER TEXCON: TEX_EDGE Position    */
N#define TIMER_TEXCON_TEX_EDGE_Msk   (0x3ul << TIMER_TEXCON_TEX_EDGE_Pos)        /*!< TIMER TEXCON: TEX_EDGE Mask        */
N
N#define TIMER_TEXCON_TX_PHASE_Pos   0                                           /*!< TIMER TEXCON: TX_PHASE Position    */
N#define TIMER_TEXCON_TX_PHASE_Msk   (1ul << TIMER_TEXCON_TX_PHASE_Pos)          /*!< TIMER TEXCON: TX_PHASE Mask        */
N
N/* TIMER TEXISR Bit Field Definitions */
N#define TIMER_TEXISR_TEXIF_Pos      0                                           /*!< TIMER TEXISR: TEXIF Position       */
N#define TIMER_TEXISR_TEXIF_Msk      (1ul << TIMER_TEXISR_TEXIF_Pos)             /*!< TIMER TEXISR: TEXIF Mask           */
N
N/*@}*/ /* end of group MINI51_TIMER */
N
N
N/*----------------------------- UART Controller -----------------------------*/
N
N/** @addtogroup MINI51_UART MINI51 UART
N  Memory Mapped Structure for MINI51 Series UART Serial Interface Controller
N  @{
N */ 
N/**
N  * @brief UART register map
N  */   
Ntypedef struct
N{
N  union {
N  __I   uint32_t  RBR;         /*!< Offset: 0x0000   UART Receive Buffer Register               */
X  volatile const   uint32_t  RBR;          
N  __O   uint32_t  THR;         /*!< Offset: 0x0000   UART Transmit Holding Register             */
X  volatile   uint32_t  THR;          
N  };
N  __IO uint32_t  IER;          /*!< Offset: 0x0004   UART Interrupt Enable Register             */
X  volatile uint32_t  IER;           
N  __IO uint32_t  FCR;          /*!< Offset: 0x0008   UART FIFO Control Register                 */
X  volatile uint32_t  FCR;           
N  __IO uint32_t  LCR;          /*!< Offset: 0x000C   UART Line Control Register                 */
X  volatile uint32_t  LCR;           
N  __IO uint32_t  MCR;          /*!< Offset: 0x0010   UART Modem Control Register                */
X  volatile uint32_t  MCR;           
N  __IO uint32_t  MSR;          /*!< Offset: 0x0014   UART Modem Status Register                 */
X  volatile uint32_t  MSR;           
N  __IO uint32_t  FSR;          /*!< Offset: 0x0018   UART FIFO Status Register                  */
X  volatile uint32_t  FSR;           
N  __IO uint32_t  ISR;          /*!< Offset: 0x001C   UART Interrupt Status Register             */
X  volatile uint32_t  ISR;           
N  __IO uint32_t  TOR;          /*!< Offset: 0x0020   UART Time-out Register                     */
X  volatile uint32_t  TOR;           
N  __IO uint32_t  BAUD;         /*!< Offset: 0x0024   UART Baud Rate Divisor Register            */
X  volatile uint32_t  BAUD;          
N  __IO uint32_t  IRCR;         /*!< Offset: 0x0028   UART IrDA Control Register                 */
X  volatile uint32_t  IRCR;          
N  __IO uint32_t  ALT_CSR;      /*!< Offset: 0x002C   UART Alternate Control/Status Register     */
X  volatile uint32_t  ALT_CSR;       
N  __IO uint32_t  FUN_SEL;      /*!< Offset: 0x0030   UART Function Select Register              */
X  volatile uint32_t  FUN_SEL;       
N} UART_T; 
N
N
N
N/* UART THR Bit Field Definitions */
N#define UART_THR_THR_Pos         0                                          /*!< UART THR: THR Position  */
N#define UART_THR_THR_Msk        (0xFul << UART_THR_THR_Pos)                 /*!< UART THR: THR Mask      */
N
N/* UART RBR Bit Field Definitions */
N#define UART_RBR_RBR_Pos         0                                          /*!< UART RBR: RBR Posistion */
N#define UART_RBR_RBR_Msk        (0xFul << UART_RBR_RBR_Pos)                 /*!< UART RBR: RBR Mask      */
N
N/* UART IER Bit Field Definitions */
N#define UART_IER_AUTO_CTS_EN_Pos    13                                      /*!< UART IER: AUTO_CTS_EN Posistion      */
N#define UART_IER_AUTO_CTS_EN_Msk    (1ul << UART_IER_AUTO_CTS_EN_Pos)       /*!< UART IER: AUTO_CTS_EN Mask           */
N
N#define UART_IER_AUTO_RTS_EN_Pos    12                                      /*!< UART IER: AUTO_RTS_EN Posistion      */
N#define UART_IER_AUTO_RTS_EN_Msk    (1ul << UART_IER_AUTO_RTS_EN_Pos)       /*!< UART IER: AUTO_RTS_EN Mask           */
N
N#define UART_IER_TIME_OUT_EN_Pos    11                                      /*!< UART IER: TIME_OUT_EN Posistion      */
N#define UART_IER_TIME_OUT_EN_Msk    (1ul << UART_IER_TIME_OUT_EN_Pos)       /*!< UART IER: TIME_OUT_EN Mask           */
N
N#define UART_IER_WAKE_EN_Pos        6                                       /*!< UART IER: WAKE_EN Posistion          */
N#define UART_IER_WAKE_EN_Msk        (1ul << UART_IER_WAKE_EN_Pos)           /*!< UART IER: WAKE_EN Mask               */
N
N#define UART_IER_BUF_ERR_IEN_Pos    5                                       /*!< UART IER: BUF_ERR_IEN Posistion      */
N#define UART_IER_BUF_ERR_IEN_Msk    (1ul << UART_IER_BUF_ERR_IEN_Pos)       /*!< UART IER: BUF_ERR_IEN Mask           */
N
N#define UART_IER_RTO_IEN_Pos        4                                       /*!< UART IER: RTO_IEN Posistion          */
N#define UART_IER_RTO_IEN_Msk        (1ul << UART_IER_RTO_IEN_Pos)           /*!< UART IER: RTO_IEN Mask               */
N
N#define UART_IER_MODEM_IEN_Pos      3                                       /*!< UART IER: MODEM_IEN Posistion        */
N#define UART_IER_MODEM_IEN_Msk      (1ul << UART_IER_MODEM_IEN_Pos)         /*!< UART IER: MODEM_IEN Mask             */
N
N#define UART_IER_RLS_IEN_Pos        2                                       /*!< UART IER: RLS_IEN Posistion          */
N#define UART_IER_RLS_IEN_Msk        (1ul << UART_IER_RLS_IEN_Pos)           /*!< UART IER: RLS_IEN Mask               */
N
N#define UART_IER_THRE_IEN_Pos       1                                       /*!< UART IER: THRE_IEN Posistion         */
N#define UART_IER_THRE_IEN_Msk       (1ul << UART_IER_THRE_IEN_Pos)          /*!< UART IER: THRE_IEN Mask              */
N
N#define UART_IER_RDA_IEN_Pos        0                                       /*!< UART IER: RDA_IEN Position           */
N#define UART_IER_RDA_IEN_Msk        (1ul << UART_IER_RDA_IEN_Pos)           /*!< UART IER: RDA_IEN Mask               */
N
N/* UART FCR Bit Field Definitions */
N#define UART_FCR_RTS_TRI_LEV_Pos    16                                      /*!< UART FCR: RTS_TRI_LEV Position       */
N#define UART_FCR_RTS_TRI_LEV_Msk    (0xFul << UART_FCR_RTS_TRI_LEV_Pos)     /*!< UART FCR: RTS_TRI_LEV Mask           */
N
N#define UART_FCR_RX_DIS_Pos         8                                       /*!< UART FCR: RX_DIS Position            */
N#define UART_FCR_RX_DIS_Msk         (1ul << UART_FCR_RX_DIS_Pos)            /*!< UART FCR: RX_DIS Mask                */
N
N#define UART_FCR_RFITL_Pos          4                                       /*!< UART FCR: RFITL Position             */
N#define UART_FCR_RFITL_Msk          (0xFul << UART_FCR_RFITL_Pos)           /*!< UART FCR: RFITL Mask                 */
N
N#define UART_FCR_TFR_Pos            2                                       /*!< UART FCR: TFR Position               */
N#define UART_FCR_TFR_Msk            (1ul << UART_FCR_TFR_Pos)               /*!< UART FCR: TFR Mask                   */
N
N#define UART_FCR_RFR_Pos            1                                       /*!< UART FCR: RFR Position               */
N#define UART_FCR_RFR_Msk            (1ul << UART_FCR_RFR_Pos)               /*!< UART FCR: RFR Mask                   */
N
N/* UART LCR Bit Field Definitions */
N#define UART_LCR_BCB_Pos            6                                       /*!< UART LCR: BCB Position               */
N#define UART_LCR_BCB_Msk            (1ul << UART_LCR_BCB_Pos)               /*!< UART LCR: BCB Mask                   */
N
N#define UART_LCR_SPE_Pos            5                                       /*!< UART LCR: SPE Position               */
N#define UART_LCR_SPE_Msk            (1ul << UART_LCR_SPE_Pos)               /*!< UART LCR: SPE Mask                   */
N
N#define UART_LCR_EPE_Pos            4                                       /*!< UART LCR: EPE Position               */
N#define UART_LCR_EPE_Msk            (1ul << UART_LCR_EPE_Pos)               /*!< UART LCR: EPE Mask                   */
N
N#define UART_LCR_PBE_Pos            3                                       /*!< UART LCR: PBE Position               */
N#define UART_LCR_PBE_Msk            (1ul << UART_LCR_PBE_Pos)               /*!< UART LCR: PBE Mask                   */
N
N#define UART_LCR_NSB_Pos            2                                       /*!< UART LCR: NSB Position               */
N#define UART_LCR_NSB_Msk            (1ul << UART_LCR_NSB_Pos)               /*!< UART LCR: NSB Mask                   */
N
N#define UART_LCR_WLS_Pos            0                                       /*!< UART LCR: WLS Position               */
N#define UART_LCR_WLS_Msk            (0x3ul << UART_LCR_WLS_Pos)             /*!< UART LCR: WLS Mask                   */
N
N/* UART MCR Bit Field Definitions */
N#define UART_MCR_RTS_ST_Pos         13                                      /*!< UART MCR: RTS_ST Position            */
N#define UART_MCR_RTS_ST_Msk         (1ul << UART_MCR_RTS_ST_Pos)            /*!< UART MCR: RTS_ST Mask                */
N
N#define UART_MCR_LEV_RTS_Pos        9                                       /*!< UART MCR: LEV_RTS Position           */
N#define UART_MCR_LEV_RTS_Msk        (1ul << UART_MCR_LEV_RTS_Pos)           /*!< UART MCR: LEV_RTS Mask               */
N
N#define UART_MCR_RTS_Pos            1                                       /*!< UART MCR: RTS Position               */
N#define UART_MCR_RTS_Msk            (1ul << UART_MCR_RTS_Pos)               /*!< UART MCR: RTS Mask                   */
N
N
N/* UART MSR Bit Field Definitions */
N#define UART_MSR_LEV_CTS_Pos        8                                       /*!< UART MSR: LEV_CTS Position           */
N#define UART_MSR_LEV_CTS_Msk        (1ul << UART_MSR_LEV_CTS_Pos)           /*!< UART MSR: LEV_CTS Mask               */
N
N#define UART_MSR_CTS_ST_Pos         4                                       /*!< UART MSR: CTS_ST Position            */
N#define UART_MSR_CTS_ST_Msk         (1ul << UART_MSR_CTS_ST_Pos)            /*!< UART MSR: CTS_ST Mask                */
N
N#define UART_MSR_DCTSF_Pos          0                                       /*!< UART MSR: DCTST Position             */
N#define UART_MSR_DCTSF_Msk          (1ul << UART_MSR_DCTSF_Pos)             /*!< UART MSR: DCTST Mask                 */
N
N
N/* UART FSR Bit Field Definitions */
N#define UART_FSR_TE_FLAG_Pos        28                                      /*!< UART FSR: TE_FLAG Position           */
N#define UART_FSR_TE_FLAG_Msk        (1ul << UART_FSR_TE_FLAG_Pos)           /*!< UART FSR: TE_FLAG Mask               */
N
N#define UART_FSR_TX_OVER_IF_Pos     24                                      /*!< UART FSR: TX_OVER_IF Position        */
N#define UART_FSR_TX_OVER_IF_Msk     (1ul << UART_FSR_TX_OVER_IF_Pos)        /*!< UART FSR: TX_OVER_IF Mask            */
N
N#define UART_FSR_TX_FULL_Pos        23                                      /*!< UART FSR: TX_FULL Position           */
N#define UART_FSR_TX_FULL_Msk        (1ul << UART_FSR_TX_FULL_Pos)           /*!< UART FSR: TX_FULL Mask               */
N
N#define UART_FSR_TX_EMPTY_Pos       22                                      /*!< UART FSR: TX_EMPTY Position          */
N#define UART_FSR_TX_EMPTY_Msk       (1ul << UART_FSR_TX_EMPTY_Pos)          /*!< UART FSR: TX_EMPTY Mask              */
N
N#define UART_FSR_TX_POINTER_Pos     16                                      /*!< UART FSR: TX_POINTER Position        */
N#define UART_FSR_TX_POINTER_Msk     (0x3Ful << UART_FSR_TX_POINTER_Pos)     /*!< UART FSR: TX_POINTER Mask            */
N
N#define UART_FSR_RX_FULL_Pos        15                                      /*!< UART FSR: RX_FULL Position           */
N#define UART_FSR_RX_FULL_Msk        (1ul << UART_FSR_RX_FULL_Pos)           /*!< UART FSR: RX_FULL Mask               */
N
N#define UART_FSR_RX_EMPTY_Pos       14                                      /*!< UART FSR: RX_EMPTY Position          */
N#define UART_FSR_RX_EMPTY_Msk       (1ul << UART_FSR_RX_EMPTY_Pos)          /*!< UART FSR: RX_EMPTY Mask              */
N
N#define UART_FSR_RX_POINTER_Pos     8                                       /*!< UART FSR: RX_POINTERS Position       */
N#define UART_FSR_RX_POINTER_Msk     (0x3Ful << UART_FSR_RX_POINTER_Pos)     /*!< UART FSR: RX_POINTER Mask            */
N
N#define UART_FSR_BIF_Pos            6                                       /*!< UART FSR: BIF Position               */
N#define UART_FSR_BIF_Msk            (1ul << UART_FSR_BIF_Pos)               /*!< UART FSR: BIF Mask                   */
N
N#define UART_FSR_FEF_Pos            5                                       /*!< UART FSR: FEF Position               */
N#define UART_FSR_FEF_Msk            (1ul << UART_FSR_FEF_Pos)               /*!< UART FSR: FEF Mask                   */
N
N#define UART_FSR_PEF_Pos            4                                       /*!< UART FSR: PEF Position               */
N#define UART_FSR_PEF_Msk            (1ul << UART_FSR_PEF_Pos)               /*!< UART FSR: PEF Mask                   */
N
N#define UART_FSR_RS485_ADD_DETF_Pos 3                                       /*!< UART FSR: RS485_ADD_DETF Position    */
N#define UART_FSR_RS485_ADD_DETF_Msk (1ul << UART_FSR_RS485_ADD_DETF_Pos)    /*!< UART FSR: RS485_ADD_DETF Mask        */
N
N#define UART_FSR_RX_OVER_IF_Pos     0                                       /*!< UART FSR: RX_OVER_IF Position        */
N#define UART_FSR_RX_OVER_IF_Msk     (1ul << UART_FSR_RX_OVER_IF_Pos)        /*!< UART FSR: RX_OVER_IF Mask            */
N
N/* UART ISR Bit Field Definitions */
N#define UART_ISR_BUF_ERR_INT_Pos    13                                      /*!< UART ISR: BUF_ERR_INT Position       */
N#define UART_ISR_BUF_ERR_INT_Msk    (1ul << UART_ISR_BUF_ERR_INT_Pos)       /*!< UART ISR: BUF_ERR_INT Mask           */
N
N#define UART_ISR_TOUT_INT_Pos       12                                      /*!< UART ISR: TOUT_INT Position          */
N#define UART_ISR_TOUT_INT_Msk       (1ul << UART_ISR_TOUT_INT_Pos)          /*!< UART ISR: TOUT_INT Mask              */
N
N#define UART_ISR_MODEM_INT_Pos      11                                      /*!< UART ISR: MODEM_INT Position         */
N#define UART_ISR_MODEM_INT_Msk      (1ul << UART_ISR_MODEM_INT_Pos)         /*!< UART ISR: MODEM_INT Mask             */
N
N#define UART_ISR_RLS_INT_Pos        10                                      /*!< UART ISR: RLS_INT Position           */
N#define UART_ISR_RLS_INT_Msk        (1ul << UART_ISR_RLS_INT_Pos)           /*!< UART ISR: RLS_INT Mask               */
N
N#define UART_ISR_THRE_INT_Pos       9                                       /*!< UART ISR: THRE_INT Position          */
N#define UART_ISR_THRE_INT_Msk       (1ul << UART_ISR_THRE_INT_Pos)          /*!< UART ISR: THRE_INT Mask              */
N
N#define UART_ISR_RDA_INT_Pos        8                                       /*!< UART ISR: RDA_INT Position           */
N#define UART_ISR_RDA_INT_Msk        (1ul << UART_ISR_RDA_INT_Pos)           /*!< UART ISR: RDA_INT Mask               */
N           
N#define UART_ISR_BUF_ERR_IF_Pos     5                                       /*!< UART ISR: BUF_ERR_IF Position        */
N#define UART_ISR_BUF_ERR_IF_Msk     (1ul << UART_ISR_BUF_ERR_IF_Pos)        /*!< UART ISR: BUF_ERR_IF Mask            */
N
N#define UART_ISR_TOUT_IF_Pos        4                                       /*!< UART ISR: TOUT_IF Position           */
N#define UART_ISR_TOUT_IF_Msk        (1ul << UART_ISR_TOUT_IF_Pos)           /*!< UART ISR: TOUT_IF Mask               */
N
N#define UART_ISR_MODEM_IF_Pos       3                                       /*!< UART ISR: MODEM_IF Position          */
N#define UART_ISR_MODEM_IF_Msk       (1ul << UART_ISR_MODEM_IF_Pos)          /*!< UART ISR: MODEM_IF Mask              */
N
N#define UART_ISR_RLS_IF_Pos         2                                       /*!< UART ISR: RLS_IF Position            */
N#define UART_ISR_RLS_IF_Msk         (1ul << UART_ISR_RLS_IF_Pos)            /*!< UART ISR: RLS_IF Mask                */
N
N#define UART_ISR_THRE_IF_Pos        1                                       /*!< UART ISR: THRE_IF Position           */
N#define UART_ISR_THRE_IF_Msk        (1ul << UART_ISR_THRE_IF_Pos)           /*!< UART ISR: THRE_IF Mask               */
N
N#define UART_ISR_RDA_IF_Pos         0                                       /*!< UART ISR: RDA_IF Position            */
N#define UART_ISR_RDA_IF_Msk         (1ul << UART_ISR_RDA_IF_Pos)            /*!< UART ISR: RDA_IF Mask                */
N
N
N/* UART TOR Bit Field Definitions */
N#define UART_TOR_DLY_Pos           8                                        /*!< UART TOR: DLY Position               */
N#define UART_TOR_DLY_Msk           (0xFFul << UART_TOR_DLY_Pos)             /*!< UART TOR: DLY Mask                   */
N
N#define UART_TOR_TOIC_Pos          0                                        /*!< UART TOR: TOIC Position              */
N#define UART_TOR_TOIC_Msk          (0xFFul << UART_TOR_TOIC_Pos)            /*!< UART TOR: TOIC Mask                  */
N
N/* UART BAUD Bit Field Definitions */
N#define UART_BAUD_DIV_X_EN_Pos    29                                        /*!< UART BARD: DIV_X_EN Position         */
N#define UART_BAUD_DIV_X_EN_Msk    (1ul << UART_BAUD_DIV_X_EN_Pos)           /*!< UART BARD: DIV_X_EN Mask             */
N
N#define UART_BAUD_DIV_X_ONE_Pos   28                                        /*!< UART BARD: DIV_X_ONE Position        */
N#define UART_BAUD_DIV_X_ONE_Msk   (1ul << UART_BAUD_DIV_X_ONE_Pos)          /*!< UART BARD: DIV_X_ONE Mask            */
N
N#define UART_BAUD_DIVIDER_X_Pos   24                                        /*!< UART BARD: DIVIDER_X Position        */
N#define UART_BAUD_DIVIDER_X_Msk   (0xFul << UART_BAUD_DIVIDER_X_Pos)        /*!< UART BARD: DIVIDER_X Mask            */
N
N#define UART_BAUD_BRD_Pos         0                                         /*!< UART BARD: BRD Position              */
N#define UART_BAUD_BRD_Msk         (0xFFFFul << UART_BAUD_BRD_Pos)           /*!< UART BARD: BRD Mask                  */
N
N/* UART IRCR Bit Field Definitions */
N#define UART_IRCR_INV_RX_Pos      6                                         /*!< UART IRCR: INV_RX Position           */
N#define UART_IRCR_INV_RX_Msk     (1ul << UART_IRCR_INV_RX_Pos)              /*!< UART IRCR: INV_RX Mask               */
N
N#define UART_IRCR_INV_TX_Pos      5                                         /*!< UART IRCR: INV_TX Position           */
N#define UART_IRCR_INV_TX_Msk     (1ul << UART_IRCR_INV_TX_Pos)              /*!< UART IRCR: INV_TX Mask               */
N
N#define UART_IRCR_TX_SELECT_Pos   1                                         /*!< UART IRCR: TX_SELECT Position        */
N#define UART_IRCR_TX_SELECT_Msk   (1ul << UART_IRCR_TX_SELECT_Pos)          /*!< UART IRCR: TX_SELECT Mask            */
N
N/* UART ALT_CSR Bit Field Definitions */
N#define UART_ALT_CSR_ADDR_MATCH_Pos      24                                      /*!< UART ALT_CSR: ADDR_MATCH Position    */
N#define UART_ALT_CSR_ADDR_MATCH_Msk     (0xFFul << UART_ALT_CSR_ADDR_MATCH_Pos)  /*!< UART ALT_CSR: ADDR_MATCH Mask        */
N
N#define UART_ALT_CSR_RS485_ADD_EN_Pos   15                                       /*!< UART ALT_CSR: RS485_ADD_EN Position  */
N#define UART_ALT_CSR_RS485_ADD_EN_Msk   (1ul << UART_ALT_CSR_RS485_ADD_EN_Pos)   /*!< UART ALT_CSR: RS485_ADD_EN Mask      */
N
N#define UART_ALT_CSR_RS485_AUD_Pos      10                                       /*!< UART ALT_CSR: RS485_AUD Position     */
N#define UART_ALT_CSR_RS485_AUD_Msk      (1ul << UART_ALT_CSR_RS485_AUD_Pos)      /*!< UART ALT_CSR: RS485_AUD Mask         */
N
N#define UART_ALT_CSR_RS485_AAD_Pos      9                                        /*!< UART ALT_CSR: RS485_AAD Position     */
N#define UART_ALT_CSR_RS485_AAD_Msk      (1ul << UART_ALT_CSR_RS485_AAD_Pos)      /*!< UART ALT_CSR: RS485_AAD Mask         */
N
N#define UART_ALT_CSR_RS485_NMM_Pos      8                                        /*!< UART ALT_CSR: RS485_NMM Position     */
N#define UART_ALT_CSR_RS485_NMM_Msk      (1ul << UART_ALT_CSR_RS485_NMM_Pos)      /*!< UART ALT_CSR: RS485_NMM Mask         */
N
N/* UART FUN_SEL Bit Field Definitions */
N#define UART_FUN_SEL_FUN_SEL_Pos        0                                        /*!< UART FUN_SEL: FUN_SEL Position       */
N#define UART_FUN_SEL_FUN_SEL_Msk       (0x3ul << UART_FUN_SEL_FUN_SEL_Pos)       /*!< UART FUN_SEL: FUN_SEL Mask           */
N
N
N
N/*@}*/ /* end of group MINI51_UART */
N
N/*----------------------------- WDT Controller -----------------------------*/
N
N/** @addtogroup MINI51_WDT MINI51 WDT
N  Memory Mapped Structure for MINI51 Series Watchdog Timer
N  @{
N */ 
N/**
N  * @brief WDT register map
N  */   
Ntypedef struct
N{
N  __IO uint32_t  WTCR;          /*!< Offset: 0x0000   Watchdog Timer Control Register   */
X  volatile uint32_t  WTCR;           
N} WDT_T; 
N
N/* WDT WTCR Bit Field Definitions */
N#define WDT_WTCR_DBGACK_WDT_Pos 31                                              /*!< WDT WTCR : DBGACK_WDT Position */
N#define WDT_WTCR_DBGACK_WDT_Msk (1ul << WDT_WTCR_DBGACK_WDT_Pos)                /*!< WDT WTCR : DBGACK_WDT Mask     */
N
N#define WDT_WTCR_WTIS_Pos       8                                               /*!< WDT WTCR : WTIS Position       */
N#define WDT_WTCR_WTIS_Msk       (0x7ul << WDT_WTCR_WTIS_Pos)                    /*!< WDT WTCR : WTIS Mask           */
N
N#define WDT_WTCR_WTE_Pos        7                                               /*!< WDT WTCR : WTE Position        */
N#define WDT_WTCR_WTE_Msk        (1ul << WDT_WTCR_WTE_Pos)                       /*!< WDT WTCR : WTE Mask            */
N
N#define WDT_WTCR_WTIE_Pos       6                                               /*!< WDT WTCR : WTIE Position       */
N#define WDT_WTCR_WTIE_Msk       (1ul << WDT_WTCR_WTIE_Pos)                      /*!< WDT WTCR : WTIE Mask           */
N
N#define WDT_WTCR_WTWKF_Pos      5                                               /*!< WDT WTCR : WTWKF Position      */
N#define WDT_WTCR_WTWKF_Msk      (1ul << WDT_WTCR_WTWKF_Pos)                     /*!< WDT WTCR : WTWKF Mask          */
N
N#define WDT_WTCR_WTWKE_Pos      4                                               /*!< WDT WTCR : WTWKE Position      */
N#define WDT_WTCR_WTWKE_Msk      (1ul << WDT_WTCR_WTWKE_Pos)                     /*!< WDT WTCR : WTWKE Mask          */
N
N#define WDT_WTCR_WTIF_Pos       3                                               /*!< WDT WTCR : WTIF Position       */
N#define WDT_WTCR_WTIF_Msk       (1ul << WDT_WTCR_WTIF_Pos)                      /*!< WDT WTCR : WTIF Mask           */
N
N#define WDT_WTCR_WTRF_Pos       2                                               /*!< WDT WTCR : WTRF Position       */
N#define WDT_WTCR_WTRF_Msk       (1ul << WDT_WTCR_WTRF_Pos)                      /*!< WDT WTCR : WTRF Mask           */
N
N#define WDT_WTCR_WTRE_Pos       1                                               /*!< WDT WTCR : WTRE Position       */
N#define WDT_WTCR_WTRE_Msk       (1ul << WDT_WTCR_WTRE_Pos)                      /*!< WDT WTCR : WTRE Mask           */
N
N#define WDT_WTCR_WTR_Pos        0                                               /*!< WDT WTCR : WTR Position        */
N#define WDT_WTCR_WTR_Msk        (1ul << WDT_WTCR_WTR_Pos)                       /*!< WDT WTCR : WTR Mask            */
N
N/*@}*/ /* end of group MINI51_WDT */
N
N
N#if defined ( __CC_ARM   )
X#if 1L
N#pragma no_anon_unions
N#endif
N
N/** @addtogroup MINI51_PERIPHERAL_MEM_MAP MINI51 Peripheral Memory Map
N  Memory Mapped Structure for MINI51 Series Peripheral
N  @{
N */
N/* Peripheral and SRAM base address */
N#define FLASH_BASE            ((uint32_t)0x00000000)    ///< Flash base address
N#define SRAM_BASE             ((uint32_t)0x20000000)    ///< SRAM base address
N#define APB1PERIPH_BASE       ((uint32_t)0x40000000)    ///< APB1 base address
N#define APB2PERIPH_BASE       ((uint32_t)0x40100000)    ///< APB2 base address
N#define AHBPERIPH_BASE        ((uint32_t)0x50000000)    ///< AHB base address
N
N/* Peripheral memory map */
N#define WDT_BASE              (APB1PERIPH_BASE + 0x04000)    ///< WDT register base address
N#define TIMER0_BASE           (APB1PERIPH_BASE + 0x10000)    ///< TIMER0 register base address
N#define TIMER1_BASE           (APB1PERIPH_BASE + 0x10020)    ///< TIMER1 register base address
N#define I2C_BASE              (APB1PERIPH_BASE + 0x20000)    ///< I2C register base address
N#define SPI_BASE              (APB1PERIPH_BASE + 0x30000)    ///< SPI register base address
N#define PWM_BASE              (APB1PERIPH_BASE + 0x40000)    ///< PWM register base address
N#define UART_BASE             (APB1PERIPH_BASE + 0x50000)    ///< UART register base address
N#define ACMP_BASE             (APB1PERIPH_BASE + 0xD0000)    ///< ACMP register base address
N#define ADC_BASE              (APB1PERIPH_BASE + 0xE0000)    ///< ADC register base address
N
N#define GCR_BASE              (AHBPERIPH_BASE + 0x00000)    ///< GCR register base address
N#define CLK_BASE              (AHBPERIPH_BASE + 0x00200)    ///< CLK register base address
N#define INT_BASE              (AHBPERIPH_BASE + 0x00300)    ///< INT register base address
N#define P0_BASE               (AHBPERIPH_BASE + 0x04000)    ///< GPIO Port 0 register base address
N#define P1_BASE               (AHBPERIPH_BASE + 0x04040)    ///< GPIO Port 1 register base address
N#define P2_BASE               (AHBPERIPH_BASE + 0x04080)    ///< GPIO Port 2 register base address
N#define P3_BASE               (AHBPERIPH_BASE + 0x040C0)    ///< GPIO Port 3 register base address
N#define P4_BASE               (AHBPERIPH_BASE + 0x04100)    ///< GPIO Port 4 register base address
N#define P5_BASE               (AHBPERIPH_BASE + 0x04140)    ///< GPIO Port 5 register base address
N#define GPIO_DBNCECON_BASE    (AHBPERIPH_BASE + 0x04180)    ///< GPIO Debounce register vase
N#define GPIO_PIN_DATA_BASE    (AHBPERIPH_BASE + 0x04200)    ///< GPIO pin data register base address
N#define GPIOBIT0_BASE         (AHBPERIPH_BASE + 0x04200)    ///< GPIO Port 0 bit access register base address
N#define GPIOBIT1_BASE         (AHBPERIPH_BASE + 0x04220)    ///< GPIO Port 1 bit access register base address
N#define GPIOBIT2_BASE         (AHBPERIPH_BASE + 0x04240)    ///< GPIO Port 2 bit access register base address
N#define GPIOBIT3_BASE         (AHBPERIPH_BASE + 0x04260)    ///< GPIO Port 3 bit access register base address
N#define GPIOBIT4_BASE         (AHBPERIPH_BASE + 0x04280)    ///< GPIO Port 4 bit access register base address
N#define GPIOBIT5_BASE         (AHBPERIPH_BASE + 0x042A0)    ///< GPIO Port 5 bit access register base address
N#define FMC_BASE              (AHBPERIPH_BASE + 0x0C000)    ///< FMC register base address
N
N/*@}*/ /* end of group MINI51_PERIPHERAL_MEM_MAP */
N
N
N/** @addtogroup MINI51_PERIPHERAL_DECLARATION MINI51 Peripheral Declaration
N  The Declaration of MINI51 Series Peripheral
N  @{
N */
N#define WDT                   ((WDT_T *) WDT_BASE)              ///< Pointer to WDT register structure
N#define TIMER0                ((TIMER_T *) TIMER0_BASE)         ///< Pointer to Timer 0 register structure
N#define TIMER1                ((TIMER_T *) TIMER1_BASE)         ///< Pointer to Timer 1 register structure
N#define I2C                   ((I2C_T *) I2C_BASE)              ///< Pointer to I2C register structure
N#define SPI                   ((SPI_T *) SPI_BASE)              ///< Pointer to SPI register structure
N#define PWM                   ((PWM_T *) PWM_BASE)              ///< Pointer to PWM register structure
N#define UART                  ((UART_T *) UART_BASE)            ///< Pointer to UART register structure
N#define ADC                   ((ADC_T *) ADC_BASE)              ///< Pointer to ADC register structure
N#define ACMP                  ((ACMP_T *) ACMP_BASE)            ///< Pointer to ACMP register structure
N
N#define SYS                   ((GCR_T *) GCR_BASE)              ///< Pointer to SYS register structure
N#define CLK                   ((CLK_T *) CLK_BASE)              ///< Pointer to CLK register structure
N#define INT                   ((INT_T *) INT_BASE)              ///< Pointer to INT register structure
N#define P0                    ((GPIO_T *) P0_BASE)              ///< Pointer to GPIO port 0 register structure
N#define P1                    ((GPIO_T *) P1_BASE)              ///< Pointer to GPIO port 1 register structure 
N#define P2                    ((GPIO_T *) P2_BASE)              ///< Pointer to GPIO port 2 register structure
N#define P3                    ((GPIO_T *) P3_BASE)              ///< Pointer to GPIO port 3 register structure
N#define P4                    ((GPIO_T *) P4_BASE)              ///< Pointer to GPIO port 4 register structure
N#define P5                    ((GPIO_T *) P5_BASE)              ///< Pointer to GPIO port 5 register structure
N#define GPIO                  ((GPIO_DBNCECON_T *) GPIO_DBNCECON_BASE)      ///< Pointer to GPIO debounce register structure
N#define GPIOBIT0              ((GPIOBIT_T *) GPIOBIT0_BASE)     ///< Pointer to GPIO port 0 bit access register structure
N#define GPIOBIT1              ((GPIOBIT_T *) GPIOBIT1_BASE)     ///< Pointer to GPIO port 1 bit access register structure
N#define GPIOBIT2              ((GPIOBIT_T *) GPIOBIT2_BASE)     ///< Pointer to GPIO port 2 bit access register structure
N#define GPIOBIT3              ((GPIOBIT_T *) GPIOBIT3_BASE)     ///< Pointer to GPIO port 3 bit access register structure
N#define GPIOBIT4              ((GPIOBIT_T *) GPIOBIT4_BASE)     ///< Pointer to GPIO port 4 bit access register structure
N#define GPIOBIT5              ((GPIOBIT_T *) GPIOBIT5_BASE)     ///< Pointer to GPIO port 5 bit access register structure
N#define FMC                   ((FMC_T *) FMC_BASE)              ///< Pointer to FMC register structure
N
N/*@}*/ /* end of group MINI51_PERIPHERAL_DECLARATION */
N/*@}*/ /* end of group MINI51_Peripherals */ 
N
N/** @addtogroup MINI51_IO_ROUTINE MINI5X I/O routines
N  The Declaration of MINI51 I/O routines
N  @{
N */
N
Ntypedef volatile unsigned char  vu8;        ///< Define 8-bit unsigned volatile data type
Ntypedef volatile unsigned short vu16;       ///< Define 16-bit unsigned volatile data type
Ntypedef volatile unsigned long  vu32;       ///< Define 32-bit unsigned volatile data type
N
N/**
N  * @brief Get a 8-bit unsigned value from specified address
N  * @param[in] addr Address to get 8-bit data from
N  * @return  8-bit unsigned value stored in specified address
N  */
N#define M8(addr)  (*((vu8  *) (addr))) 
N
N/**
N  * @brief Get a 16-bit unsigned value from specified address
N  * @param[in] addr Address to get 16-bit data from
N  * @return  16-bit unsigned value stored in specified address
N  * @note The input address must be 16-bit aligned
N  */
N#define M16(addr) (*((vu16 *) (addr)))
N
N/**
N  * @brief Get a 32-bit unsigned value from specified address
N  * @param[in] addr Address to get 32-bit data from
N  * @return  32-bit unsigned value stored in specified address
N  * @note The input address must be 32-bit aligned
N  */
N#define M32(addr) (*((vu32 *) (addr)))
N
N/**
N  * @brief Set a 32-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 32-bit data
N  * @param[in] value Value to write to I/O port  
N  * @return  None
N  * @note The output port must be 32-bit aligned
N  */
N#define outpw(port,value)     *((volatile unsigned int *)(port)) = value
N
N/**
N  * @brief Get a 32-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 32-bit data from
N  * @return  32-bit unsigned value stored in specified I/O port
N  * @note The input port must be 32-bit aligned
N  */
N#define inpw(port)            (*((volatile unsigned int *)(port)))
N
N/**
N  * @brief Set a 16-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 16-bit data
N  * @param[in] value Value to write to I/O port  
N  * @return  None
N  * @note The output port must be 16-bit aligned
N  */
N#define outps(port,value)     *((volatile unsigned short *)(port)) = value
N
N/**
N  * @brief Get a 16-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 16-bit data from
N  * @return  16-bit unsigned value stored in specified I/O port
N  * @note The input port must be 16-bit aligned
N  */
N#define inps(port)            (*((volatile unsigned short *)(port)))
N
N/**
N  * @brief Set a 8-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 8-bit data
N  * @param[in] value Value to write to I/O port  
N  * @return  None
N  */
N#define outpb(port,value)     *((volatile unsigned char *)(port)) = value
N
N/**
N  * @brief Get a 8-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 8-bit data from
N  * @return  8-bit unsigned value stored in specified I/O port
N  */
N#define inpb(port)            (*((volatile unsigned char *)(port)))
N
N/**
N  * @brief Set a 32-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 32-bit data
N  * @param[in] value Value to write to I/O port  
N  * @return  None
N  * @note The output port must be 32-bit aligned
N  */
N#define outp32(port,value)    *((volatile unsigned int *)(port)) = value
N
N/**
N  * @brief Get a 32-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 32-bit data from
N  * @return  32-bit unsigned value stored in specified I/O port
N  * @note The input port must be 32-bit aligned
N  */
N#define inp32(port)           (*((volatile unsigned int *)(port)))
N
N/**
N  * @brief Set a 16-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 16-bit data
N  * @param[in] value Value to write to I/O port  
N  * @return  None
N  * @note The output port must be 16-bit aligned
N  */
N#define outp16(port,value)    *((volatile unsigned short *)(port)) = value
N
N/**
N  * @brief Get a 16-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 16-bit data from
N  * @return  16-bit unsigned value stored in specified I/O port
N  * @note The input port must be 16-bit aligned
N  */
N#define inp16(port)           (*((volatile unsigned short *)(port)))
N
N/**
N  * @brief Set a 8-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 8-bit data
N  * @param[in] value Value to write to I/O port  
N  * @return  None
N  */
N#define outp8(port,value)     *((volatile unsigned char *)(port)) = value
N
N/**
N  * @brief Get a 8-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 8-bit data from
N  * @return  8-bit unsigned value stored in specified I/O port
N  */
N#define inp8(port)            (*((volatile unsigned char *)(port)))
N
N
N/*@}*/ /* end of group MINI51_IO_ROUTINE */
N
N/******************************************************************************/
N/*                Legacy Constants                                            */
N/******************************************************************************/
N/** @addtogroup MINI51_legacy_Constants MINI51 Legacy Constants
N  MINI51 Legacy Constants
N  @{
N*/
N
N#ifndef NULL
N#define NULL           (0)      ///< NULL pointer
N#endif
N
N#define TRUE           (1)      ///< Boolean true, define to use in API parameters or return value
N#define FALSE          (0)      ///< Boolean false, define to use in API parameters or return value
N
N#define ENABLE         (1)      ///< Enable, define to use in API parameters
N#define DISABLE        (0)      ///< Disable, define to use in API parameters
N
N/* Define one bit mask */
N#define BIT0     (0x00000001)       ///< Bit 0 mask of an 32 bit integer
N#define BIT1     (0x00000002)       ///< Bit 1 mask of an 32 bit integer
N#define BIT2     (0x00000004)       ///< Bit 2 mask of an 32 bit integer
N#define BIT3     (0x00000008)       ///< Bit 3 mask of an 32 bit integer
N#define BIT4     (0x00000010)       ///< Bit 4 mask of an 32 bit integer
N#define BIT5     (0x00000020)       ///< Bit 5 mask of an 32 bit integer
N#define BIT6     (0x00000040)       ///< Bit 6 mask of an 32 bit integer
N#define BIT7     (0x00000080)       ///< Bit 7 mask of an 32 bit integer
N#define BIT8     (0x00000100)       ///< Bit 8 mask of an 32 bit integer
N#define BIT9     (0x00000200)       ///< Bit 9 mask of an 32 bit integer
N#define BIT10    (0x00000400)       ///< Bit 10 mask of an 32 bit integer
N#define BIT11    (0x00000800)       ///< Bit 11 mask of an 32 bit integer
N#define BIT12    (0x00001000)       ///< Bit 12 mask of an 32 bit integer
N#define BIT13    (0x00002000)       ///< Bit 13 mask of an 32 bit integer
N#define BIT14    (0x00004000)       ///< Bit 14 mask of an 32 bit integer
N#define BIT15    (0x00008000)       ///< Bit 15 mask of an 32 bit integer
N#define BIT16    (0x00010000)       ///< Bit 16 mask of an 32 bit integer
N#define BIT17    (0x00020000)       ///< Bit 17 mask of an 32 bit integer
N#define BIT18    (0x00040000)       ///< Bit 18 mask of an 32 bit integer
N#define BIT19    (0x00080000)       ///< Bit 19 mask of an 32 bit integer
N#define BIT20    (0x00100000)       ///< Bit 20 mask of an 32 bit integer
N#define BIT21    (0x00200000)       ///< Bit 21 mask of an 32 bit integer
N#define BIT22    (0x00400000)       ///< Bit 22 mask of an 32 bit integer
N#define BIT23    (0x00800000)       ///< Bit 23 mask of an 32 bit integer
N#define BIT24    (0x01000000)       ///< Bit 24 mask of an 32 bit integer
N#define BIT25    (0x02000000)       ///< Bit 25 mask of an 32 bit integer
N#define BIT26    (0x04000000)       ///< Bit 26 mask of an 32 bit integer
N#define BIT27    (0x08000000)       ///< Bit 27 mask of an 32 bit integer
N#define BIT28    (0x10000000)       ///< Bit 28 mask of an 32 bit integer
N#define BIT29    (0x20000000)       ///< Bit 29 mask of an 32 bit integer
N#define BIT30    (0x40000000)       ///< Bit 30 mask of an 32 bit integer
N#define BIT31    (0x80000000)       ///< Bit 31 mask of an 32 bit integer
N
N/* Byte Mask Definitions */
N#define BYTE0_Msk              (0x000000FF)         ///< Mask to get bit0~bit7 from a 32 bit integer
N#define BYTE1_Msk              (0x0000FF00)         ///< Mask to get bit8~bit15 from a 32 bit integer
N#define BYTE2_Msk              (0x00FF0000)         ///< Mask to get bit16~bit23 from a 32 bit integer
N#define BYTE3_Msk              (0xFF000000)         ///< Mask to get bit24~bit31 from a 32 bit integer
N
N#define GET_BYTE0(u32Param)    ((u32Param & BYTE0_Msk)      )  /*!< Extract Byte 0 (Bit  0~ 7) from parameter u32Param */
N#define GET_BYTE1(u32Param)    ((u32Param & BYTE1_Msk) >>  8)  /*!< Extract Byte 1 (Bit  8~15) from parameter u32Param */
N#define GET_BYTE2(u32Param)    ((u32Param & BYTE2_Msk) >> 16)  /*!< Extract Byte 2 (Bit 16~23) from parameter u32Param */
N#define GET_BYTE3(u32Param)    ((u32Param & BYTE3_Msk) >> 24)  /*!< Extract Byte 3 (Bit 24~31) from parameter u32Param */
N
N/*@}*/ /* end of group MINI51_legacy_Constants */
N
N/*@}*/ /* end of group MINI51_Definitions */
N
N#ifdef __cplusplus
S}
N#endif
N
N
N/******************************************************************************/
N/*                         Peripheral header files                            */
N/******************************************************************************/ 
N#include "sys.h"
L 1 ".\StdDriver\inc\sys.h" 1
N/**************************************************************************//**
N * @file     sys.h
N * @version  V1.00
N * $Revision: 11 $
N * $Date: 13/09/30 6:48p $ 
N * @brief    Mini51 series SYS driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/ 
N#ifndef __SYS_H__
N#define __SYS_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N    
N/** @addtogroup MINI51_Device_Driver MINI51 Device Driver
N  @{
N*/
N
N/** @addtogroup MINI51_SYS_Driver SYS Driver
N  @{
N*/
N
N/** @addtogroup MINI51_XXX_EXPORTED_CONSTANTS SYS Exported Constants
N  @{
N*/    
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Module Reset Control Resister constant definitions.                                                    */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CHIP_RST ((0x0<<24) | SYS_IPRSTC1_CPU_RST_Pos  ) /*!< CHIP reset is one of the SYS_ResetModule parameter */
N#define CPU_RST  ((0x0<<24) | SYS_IPRSTC1_CHIP_RST_Pos ) /*!< CPU  reset is one of the SYS_ResetModule parameter */
N#define ADC_RST  ((0x4<<24) | SYS_IPRSTC2_ADC_RST_Pos  ) /*!< ADC  reset is one of the SYS_ResetModule parameter */
N#define ACMP_RST ((0x4<<24) | SYS_IPRSTC2_ACMP_RST_Pos ) /*!< ACMP reset is one of the SYS_ResetModule parameter */
N#define PWM_RST  ((0x4<<24) | SYS_IPRSTC2_PWM_RST_Pos  ) /*!< PWM  reset is one of the SYS_ResetModule parameter */
N#define UART_RST ((0x4<<24) | SYS_IPRSTC2_UART_RST_Pos ) /*!< UART reset is one of the SYS_ResetModule parameter */
N#define SPI_RST  ((0x4<<24) | SYS_IPRSTC2_SPI_RST_Pos  ) /*!< SPI  reset is one of the SYS_ResetModule parameter */
N#define I2C_RST  ((0x4<<24) | SYS_IPRSTC2_I2C_RST_Pos  ) /*!< I2C  reset is one of the SYS_ResetModule parameter */
N#define TMR1_RST ((0x4<<24) | SYS_IPRSTC2_TMR1_RST_Pos ) /*!< TMR1 reset is one of the SYS_ResetModule parameter */
N#define TMR0_RST ((0x4<<24) | SYS_IPRSTC2_TMR0_RST_Pos ) /*!< TMR0 reset is one of the SYS_ResetModule parameter */
N#define GPIO_RST ((0x4<<24) | SYS_IPRSTC2_GPIO_RST_Pos ) /*!< GPIO reset is one of the SYS_ResetModule parameter */
N    
N    
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Brown Out Detector Threshold Voltage Selection constant definitions.                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SYS_BODCR_BOD_RST_EN              (1UL<<SYS_BODCR_BOD_RSTEN_Pos)    /*!< Brown-out Reset Enable */
N#define SYS_BODCR_BOD_INTERRUPT_EN        (0UL<<SYS_BODCR_BOD_RSTEN_Pos)    /*!< Brown-out Interrupt Enable */
N#define SYS_BODCR_BOD_DISABLE             (3UL<<SYS_BODCR_BOD_VL_Pos)       /*!< Disable Brown Out Detector */ 
N#define SYS_BODCR_BOD_VL_4_4V             (3UL<<SYS_BODCR_BOD_VL_Pos)       /*!< Setting Brown Out Detector Threshold Voltage as 4.4V */ 
N#define SYS_BODCR_BOD_VL_3_7V             (2UL<<SYS_BODCR_BOD_VL_Pos)       /*!< Setting Brown Out Detector Threshold Voltage as 3.7V */
N#define SYS_BODCR_BOD_VL_2_7V             (1UL<<SYS_BODCR_BOD_VL_Pos)       /*!< Setting Brown Out Detector Threshold Voltage as 2.7V */
N#define SYS_BODCR_BOD_VL_2_2V             (0UL<<SYS_BODCR_BOD_VL_Pos)       /*!< Setting Brown Out Detector Threshold Voltage as 2.2V */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Multi-Function constant definitions.                                                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SYS_MFP_TYPE_Msk(bit)       (1UL << ((bit) +16)) /*!< TYPE mask for Multiple Function Port */
N#define SYS_MFP_ALT_Msk(bit)        (1UL << ((bit) + 8)) /*!< ALT mask for Multiple Function Port */
N#define SYS_MFP_MFP_Msk(bit)        (1UL << ((bit)    )) /*!< MFP mask for Multiple Function Port */
N
N#define SYS_MFP_P00_GPIO    0x00000000UL /*!< P0_MFP pin 0 setting for GPIO */      
N#define SYS_MFP_P00_CTS     0x00000100UL /*!< P0_MFP pin 0 setting for CTS  */      
N#define SYS_MFP_P00_TXD     0x00000101UL /*!< P0_MFP pin 0 setting for TXD  */      
N#define SYS_MFP_P00_Msk     0x01000101UL /*!< P0_MFP pin 0 mask             */      
N        
N#define SYS_MFP_P01_GPIO    0x00000000UL /*!< P0_MFP pin 1 setting for GPIO  */      
N#define SYS_MFP_P01_SPISS   0x00000002UL /*!< P0_MFP pin 1 setting for SPISS */      
N#define SYS_MFP_P01_RTS     0x00000200UL /*!< P0_MFP pin 1 setting for RTS   */      
N#define SYS_MFP_P01_RXD     0x00000202UL /*!< P0_MFP pin 1 setting for RXD   */      
N#define SYS_MFP_P01_Msk     0x02000202UL /*!< P0_MFP pin 1 mask              */      
N        
N#define SYS_MFP_P04_GPIO    0x00000000UL /*!< P0_MFP pin 4 setting for GPIO   */      
N#define SYS_MFP_P04_SPISS   0x00001000UL /*!< P0_MFP pin 4 setting for SPISS1 */      
N#define SYS_MFP_P04_PWM5    0x00001010UL /*!< P0_MFP pin 4 setting for PWM5   */      
N#define SYS_MFP_P04_Msk     0x00001010UL /*!< P0_MFP pin 4 mask               */      
N        
N#define SYS_MFP_P05_GPIO    0x00000000UL /*!< P0_MFP pin 5 setting for GPIO   */      
N#define SYS_MFP_P05_MOSI    0x00002000UL /*!< P0_MFP pin 5 setting for MOSI   */      
N#define SYS_MFP_P05_Msk     0x00002020UL /*!< P0_MFP pin 5 mask               */      
N        
N#define SYS_MFP_P06_GPIO    0x00000000UL /*!< P0_MFP pin 6 setting for GPIO   */      
N#define SYS_MFP_P06_MISO    0x00004000UL /*!< P0_MFP pin 6 setting for MISO   */      
N#define SYS_MFP_P06_Msk     0x00004040UL /*!< P0_MFP pin 6 mask               */      
N        
N#define SYS_MFP_P07_GPIO    0x00000000UL /*!< P0_MFP pin 7 setting for GPIO    */      
N#define SYS_MFP_P07_SPICLK  0x00008000UL /*!< P0_MFP pin 7 setting for SPICLK  */      
N#define SYS_MFP_P07_Msk     0x00008080UL /*!< P0_MFP pin 7 mask                */      
N        
N#define SYS_MFP_P10_GPIO    0x00000000UL /*!< P1_MFP pin 0 setting for GPIO */      
N#define SYS_MFP_P10_AIN1    0x00000001UL /*!< P1_MFP pin 0 setting for AIN1 */      
N#define SYS_MFP_P10_CPP0    0x00000101UL /*!< P1_MFP pin 0 setting for CPP0 */      
N#define SYS_MFP_P10_Msk     0x00000101UL /*!< P1_MFP pin 0 mask             */      
N        
N#define SYS_MFP_P12_GPIO    0x00000000UL /*!< P1_MFP pin 2 setting for GPIO */      
N#define SYS_MFP_P12_AIN2    0x00000004UL /*!< P1_MFP pin 2 setting for AIN2 */      
N#define SYS_MFP_P12_RXD     0x00000400UL /*!< P1_MFP pin 2 setting for RXD  */      
N#define SYS_MFP_P12_CPP0    0x00000404UL /*!< P1_MFP pin 2 setting for CPP0 */      
N#define SYS_MFP_P12_Msk     0x00000404UL /*!< P1_MFP pin 2 mask             */      
N        
N#define SYS_MFP_P13_GPIO    0x00000000UL /*!< P1_MFP pin 3 setting for GPIO */      
N#define SYS_MFP_P13_AIN3    0x00000008UL /*!< P1_MFP pin 3 setting for AIN3 */      
N#define SYS_MFP_P13_TXD     0x00000800UL /*!< P1_MFP pin 3 setting for TXD  */      
N#define SYS_MFP_P13_CPP0    0x00000808UL /*!< P1_MFP pin 3 setting for CPP0 */      
N#define SYS_MFP_P13_Msk     0x00000808UL /*!< P1_MFP pin 3 mask             */      
N        
N#define SYS_MFP_P14_GPIO    0x00000000UL /*!< P1_MFP pin 4 setting for GPIO   */      
N#define SYS_MFP_P14_AIN4    0x00000010UL /*!< P1_MFP pin 4 setting for AIN4   */      
N#define SYS_MFP_P14_CPN0    0x00001010UL /*!< P1_MFP pin 4 setting for CPN0   */      
N#define SYS_MFP_P14_Msk     0x00001010UL /*!< P1_MFP pin 4 mask               */      
N        
N#define SYS_MFP_P15_GPIO    0x00000000UL /*!< P1_MFP pin 5 setting for GPIO   */      
N#define SYS_MFP_P15_AIN5    0x00000020UL /*!< P1_MFP pin 5 setting for AIN5   */      
N#define SYS_MFP_P15_CPP0    0x00002020UL /*!< P1_MFP pin 5 setting for CPP0   */      
N#define SYS_MFP_P15_Msk     0x00002020UL /*!< P1_MFP pin 5 mask               */      
N        
N#define SYS_MFP_P22_GPIO    0x00000000UL /*!< P2_MFP pin 2 setting for GPIO */      
N#define SYS_MFP_P22_PWM0    0x00000400UL /*!< P2_MFP pin 2 setting for PWM0 */      
N#define SYS_MFP_P22_Msk     0x00000404UL /*!< P2_MFP pin 2 mask             */      
N        
N#define SYS_MFP_P23_GPIO    0x00000000UL /*!< P2_MFP pin 3 setting for GPIO */      
N#define SYS_MFP_P23_PWM1    0x00000800UL /*!< P2_MFP pin 3 setting for PWM1 */      
N#define SYS_MFP_P23_Msk     0x00000808UL /*!< P2_MFP pin 3 mask             */      
N        
N#define SYS_MFP_P24_GPIO    0x00000000UL /*!< P2_MFP pin 4 setting for GPIO */      
N#define SYS_MFP_P24_PWM2    0x00001000UL /*!< P2_MFP pin 4 setting for PWM2 */      
N#define SYS_MFP_P24_Msk     0x00001010UL /*!< P2_MFP pin 4 mask             */      
N        
N#define SYS_MFP_P25_GPIO    0x00000000UL /*!< P2_MFP pin 5 setting for GPIO */      
N#define SYS_MFP_P25_PWM3    0x00002000UL /*!< P2_MFP pin 5 setting for PWM3 */      
N#define SYS_MFP_P25_Msk     0x00002020UL /*!< P2_MFP pin 5 mask             */      
N        
N#define SYS_MFP_P26_GPIO    0x00000000UL /*!< P2_MFP pin 6 setting for GPIO */      
N#define SYS_MFP_P26_PWM4    0x00004000UL /*!< P2_MFP pin 6 setting for PWM4 */      
N#define SYS_MFP_P26_CPO1    0x00004040UL /*!< P2_MFP pin 6 setting for CPO1 */      
N#define SYS_MFP_P26_Msk     0x00004040UL /*!< P2_MFP pin 6 mask             */      
N        
N#define SYS_MFP_P30_GPIO    0x00000000UL /*!< P3_MFP pin 0 setting for GPIO */      
N#define SYS_MFP_P30_CPN1    0x00000100UL /*!< P3_MFP pin 0 setting for CPN1 */      
N#define SYS_MFP_P30_AIN6    0x00000101UL /*!< P3_MFP pin 0 setting for AIN6 */      
N#define SYS_MFP_P30_Msk     0x00000101UL /*!< P3_MFP pin 0 mask             */      
N
N#define SYS_MFP_P31_GPIO    0x00000000UL /*!< P3_MFP pin 1 setting for GPIO */      
N#define SYS_MFP_P31_CPP1    0x00000200UL /*!< P3_MFP pin 1 setting for CPP1 */      
N#define SYS_MFP_P31_AIN7    0x00000202UL /*!< P3_MFP pin 1 setting for AIN7 */      
N#define SYS_MFP_P31_Msk     0x00000202UL /*!< P3_MFP pin 1 mask             */      
N
N#define SYS_MFP_P32_GPIO    0x00000000UL /*!< P3_MFP pin 2 setting for GPIO  */
N#define SYS_MFP_P32_INT0    0x00000004UL /*!< P3_MFP pin 2 setting for /INT0 */            
N#define SYS_MFP_P32_T0EX    0x00000400UL /*!< P3_MFP pin 2 setting for T0EX  */      
N#define SYS_MFP_P32_STADC   0x00000404UL /*!< P3_MFP pin 2 setting for STADC */      
N#define SYS_MFP_P32_Msk     0x00000404UL /*!< P3_MFP pin 2 mask              */      
N
N#define SYS_MFP_P34_GPIO    0x00000000UL /*!< P3_MFP pin 4 setting for GPIO */
N#define SYS_MFP_P34_T0      0x00000010UL /*!< P3_MFP pin 4 setting for T0   */
N#define SYS_MFP_P34_SDA     0x00001000UL /*!< P3_MFP pin 4 setting for SDA  */
N#define SYS_MFP_P34_CPP1    0x00001010UL /*!< P3_MFP pin 4 setting for CPP1 */
N#define SYS_MFP_P34_Msk     0x00001010UL /*!< P3_MFP pin 4 mask             */
N
N#define SYS_MFP_P35_GPIO    0x00000000UL /*!< P3_MFP pin 5 setting for GPIO */
N#define SYS_MFP_P35_T1      0x00000020UL /*!< P3_MFP pin 5 setting for T1   */
N#define SYS_MFP_P35_SCL     0x00002000UL /*!< P3_MFP pin 5 setting for SCL  */
N#define SYS_MFP_P35_CPP1    0x00002020UL /*!< P3_MFP pin 5 setting for CPP1 */
N#define SYS_MFP_P35_Msk     0x00002020UL /*!< P3_MFP pin 5 mask             */
N
N#define SYS_MFP_P36_GPIO    0x00000000UL /*!< P3_MFP pin 6 setting for GPIO */
N#define SYS_MFP_P36_T1EX    0x00000040UL /*!< P3_MFP pin 6 setting for T1EX */
N#define SYS_MFP_P36_CKO     0x00004000UL /*!< P3_MFP pin 6 setting for CKO  */
N#define SYS_MFP_P36_CPO0    0x00004040UL /*!< P3_MFP pin 6 setting for CPO0 */
N#define SYS_MFP_P36_Msk     0x00004040UL /*!< P3_MFP pin 6 mask             */
N
N#define SYS_MFP_P46_GPIO    0x00000000UL /*!< P4_MFP pin 6 setting for GPIO    */
N#define SYS_MFP_P46_ICE_CLK 0x00000040UL /*!< P4_MFP pin 6 setting for ICE_CLK */
N#define SYS_MFP_P46_Msk     0x00004040UL /*!< P4_MFP pin 6 mask                */
N        
N#define SYS_MFP_P47_GPIO    0x00000000UL /*!< P4_MFP pin 7 setting for GPIO    */
N#define SYS_MFP_P47_ICE_DAT 0x00000080UL /*!< P4_MFP pin 7 setting for ICE_DAT */
N#define SYS_MFP_P47_Msk     0x00008080UL /*!< P4_MFP pin 7 mask                */
N
N#define SYS_MFP_P50_GPIO    0x00000000UL /*!< P5_MFP pin 0 setting for GPIO */
N#define SYS_MFP_P50_XTAL1   0x00000001UL /*!< P5_MFP pin 0 setting for XTAL1*/
N#define SYS_MFP_P50_Msk     0x00000101UL /*!< P5_MFP pin 0 mask             */
N
N#define SYS_MFP_P51_GPIO    0x00000000UL /*!< P5_MFP pin 1 setting for GPIO */
N#define SYS_MFP_P51_XTAL2   0x00000002UL /*!< P5_MFP pin 1 setting for XTAL2*/
N#define SYS_MFP_P51_Msk     0x00000202UL /*!< P5_MFP pin 1 mask             */
N
N#define SYS_MFP_P52_GPIO    0x00000000UL /*!< P5_MFP pin 2 setting for GPIO */
N#define SYS_MFP_P52_INT1    0x00000004UL /*!< P5_MFP pin 2 setting for /INT1*/
N#define SYS_MFP_P52_Msk     0x00000404UL /*!< P5_MFP pin 2 mask             */
N
N#define SYS_MFP_P53_GPIO    0x00000000UL /*!< P5_MFP pin 3 setting for GPIO */
N#define SYS_MFP_P53_AIN0    0x00000008UL /*!< P5_MFP pin 3 setting for AIN0 */
N#define SYS_MFP_P53_Msk     0x00000808UL /*!< P5_MFP pin 3 mask             */
N
N#define SYS_MFP_P54_GPIO    0x00000000UL /*!< P5_MFP pin 4 setting for GPIO */
N#define SYS_MFP_P54_Msk     0x00001010UL /*!< P5_MFP pin 4 mask             */
N
N#define SYS_MFP_P55_GPIO    0x00000000UL /*!< P5_MFP pin 5 setting for GPIO */
N#define SYS_MFP_P55_Msk     0x00002020UL /*!< P5_MFP pin 5 mask             */
N    
N
N
N/*@}*/ /* end of group MINI51_SYS_EXPORTED_CONSTANTS */
N
N/** @addtogroup MINI51_SYS_EXPORTED_FUNCTIONS SYS Exported Functions
N  @{
N*/
N#define SYS_CLEAR_BOD_INT_FLAG()        (SYS->BODCR &= ~SYS_BODCR_BOD_INTF_Msk)        /*!< This macro clear Brown-out interrupt flag */    
N#define SYS_CLEAR_BOD_LPM()             (SYS->BODCR &= ~SYS_BODCR_BOD_LPM_Msk)         /*!< This macro set Brown-out detect to normal mode */
N#define SYS_DISABLE_BOD()               (SYS->BODCR |= SYS_BODCR_BOD_DISABLE)          /*!< This macro disable Brown-out detect function */
N#define SYS_ENABLE_BOD()                (SYS->BODCR = (SYS->BODCR & ~SYS_BODCR_BOD_VL_Msk) | SYS_BODCR_BOD_VL_3_7V) /*!< This macro enable Brown-out detect function and set BOD_LV=3.7V */
N#define SYS_GET_BOD_INT_FLAG()          (SYS->BODCR & SYS_BODCR_BOD_INTF_Msk)          /*!< This macro get Brown-out detect interrupt flag */
N#define SYS_GET_BOD_OUTPUT()            (SYS->BODCR & SYS_BODCR_BOD_OUT_Msk)           /*!< This macro get Brown-out detector output status */
N#define SYS_DISABLE_BOD_RST()           (SYS->BODCR &= ~SYS_BODCR_BOD_RSTEN_Msk)       /*!< This macro enable Brown-out detect interrupt function */
N#define SYS_ENABLE_BOD_RST()            (SYS->BODCR |= SYS_BODCR_BOD_RSTEN_Msk)        /*!< This macro enable Brown-out detect reset function */
N#define SYS_SET_BOD_LPM()               (SYS->BODCR |= SYS_BODCR_BOD_LPM_Msk)          /*!< This macro set Brown-out detect to low power mode */
N#define SYS_SET_BOD_LEVEL(u32Level) (SYS->BODCR = (SYS->BODCR & ~SYS_BODCR_BOD_VL_Msk) | u32Level) /*!< This macro set Brown-out detect voltage level.u32Level=0~3 */
N#define SYS_IS_BOD_RST()                (SYS->RSTSRC & SYS_RSTSRC_RSTS_BOD_Msk)        /*!< This macro get previos reset source is from Brown-out detect reset */
N#define SYS_IS_CPU_RST()                (SYS->RSTSRC & SYS_RSTSRC_RSTS_CPU_Msk)        /*!< This macro get previous reset source is from Low-Voltage-Reset */
N
N#define SYS_IS_POR_RST()                (SYS->RSTSRC & SYS_RSTSRC_RSTS_POR_Msk)        /*!< This macro get previous reset source is from Power-on Reset */
N#define SYS_IS_RSTPIN_RST()             (SYS->RSTSRC & SYS_RSTSRC_RSTS_RESET_Msk)      /*!< This macro get previous reset source is from reset pin reset */
N#define SYS_IS_SYSTEM_RST()             (SYS->RSTSRC & SYS_RSTSRC_RSTS_MCU_Msk)        /*!< This macro get previous reset source is from system reset */
N#define SYS_IS_WDT_RST()                (SYS->RSTSRC & SYS_RSTSRC_RSTS_WDT_Msk)        /*!< This macro get previous reset source is from window watch dog  reset */
N#define SYS_DISABLE_POR()               (SYS->PORCR = 0x5AA5)                          /*!< This macro disable Power-on Reset function */
N#define SYS_ENABLE_POR()                (SYS->PORCR = 0)                               /*!< This macro enable Power-on Reset function */
N#define SYS_CLEAR_RST_SOURCE(u32RstSrc) (SYS->RSTSRC | u32RstSrc )                     /*!< This macro clear reset source flag */
N
N    
Nvoid SYS_ClearResetSrc(uint32_t u32Src);
Nuint32_t SYS_GetBODStatus(void);
Nuint32_t SYS_GetResetSrc(void);
Nuint32_t SYS_IsRegLocked(void);
Nvoid SYS_LockReg(void);
Nvoid SYS_UnlockReg(void);
Nuint32_t  SYS_ReadPDID(void);
Nvoid SYS_ResetChip(void);
Nvoid SYS_ResetCPU(void);
Nvoid SYS_ResetModule(uint32_t u32ModuleIndex);
Nvoid SYS_EnableBOD(int32_t i32Mode, uint32_t u32BODLevel);
Nvoid SYS_DisableBOD(void);    
N
N/*@}*/ /* end of group MINI51_SYS_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group MINI51_SYS_Driver */
N
N/*@}*/ /* end of group MINI51_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__SYS_H__
L 3459 ".\CMSIS\Mini51Series.h" 2
N#include "clk.h"
L 1 ".\StdDriver\inc\clk.h" 1
N/**************************************************************************//**
N * @file     clk.h
N * @version  V1.00
N * $Revision: 13 $
N * $Date: 13/09/30 6:48p $ 
N * @brief    Mini51 series CLK driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/ 
N#ifndef __CLK_H__
N#define __CLK_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup MINI51_Device_Driver MINI51 Device Driver
N  @{
N*/
N
N/** @addtogroup MINI51_CLK_Driver CLK Driver
N  @{
N*/
N
N
N
N/** @addtogroup MINI51_CLK_EXPORTED_CONSTANTS CLK Exported Constants
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  PWRCON constant definitions.                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_PWRCON_XTL12M              0x01UL /*!< Setting External Crystal Oscillator as 12MHz         */ 
N#define CLK_PWRCON_XTL32K              0x02UL /*!< Setting External Crystal Oscillator as 32KHz         */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKSEL0 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKSEL0_HCLK_S_XTAL          0x00UL /*!< Setting clock source as external X'tal */ 
N#define CLK_CLKSEL0_HCLK_S_IRC10K        0x03UL /*!< Setting clock source as internal 10KHz RC clock */
N#define CLK_CLKSEL0_HCLK_S_IRC22M        0x07UL /*!< Setting clock source as internal 22.1184MHz RC clock */
N#define CLK_CLKSEL0_STCLK_S_XTAL         0x00UL /*!< Setting clock source as external X'tal */ 
N#define CLK_CLKSEL0_STCLK_S_XTAL_DIV2    0x10UL /*!< Setting clock source as external X'tal/2 */
N#define CLK_CLKSEL0_STCLK_S_HCLK_DIV2    0x18UL /*!< Setting clock source as HCLK/2 */
N#define CLK_CLKSEL0_STCLK_S_IRC22M_DIV2  0x38UL /*!< Setting clock source as internal 22.1184MHz RC clock/2 */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKSEL1 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKSEL1_WDT_S_XTAL          0x00000000UL /*!< Setting WDT clock source as external X'tal */ 
N#define CLK_CLKSEL1_WDT_S_HCLK_DIV2048  0x00000002UL /*!< Setting WDT clock source as HCLK/2048 */
N#define CLK_CLKSEL1_WDT_S_IRC10K        0x00000003UL /*!< Setting WDT clock source as internal 10KHz RC clock */
N#define CLK_CLKSEL1_ADC_S_XTAL          0x00000000UL /*!< Setting ADC clock source as external X'tal */
N#define CLK_CLKSEL1_ADC_S_HCLK          0x00000008UL /*!< Setting ADC clock source as HCLK */
N#define CLK_CLKSEL1_ADC_S_IRC22M        0x0000000CUL /*!< Setting ADC clock source as internal 22.1184MHz RC clock */
N#define CLK_CLKSEL1_SPI_S_HXTorLXT      0x00000000UL /*!< Setting ADC clock source as HXT or LXT */
N#define CLK_CLKSEL1_SPI_S_HCLK          0x00000001UL /*!< Setting ADC clock source as HCLK */
N#define CLK_CLKSEL1_TMR0_S_XTAL         0x00000000UL /*!< Setting Timer 0 clock source as external X'tal */
N#define CLK_CLKSEL1_TMR0_S_IRC10K       0x00000100UL /*!< Setting Timer 0 clock source as internal 10KHz RC clock */
N#define CLK_CLKSEL1_TMR0_S_HCLK         0x00000200UL /*!< Setting Timer 0 clock source as HCLK */
N#define CLK_CLKSEL1_TMR0_S_IRC22M       0x00000700UL /*!< Setting Timer 0 clock source as internal 22.1184MHz RC clock */
N#define CLK_CLKSEL1_TMR1_S_XTAL         0x00000000UL /*!< Setting Timer 1 clock source as external X'tal */
N#define CLK_CLKSEL1_TMR1_S_IRC10K       0x00001000UL /*!< Setting Timer 1 clock source as internal 10KHz RC clock */
N#define CLK_CLKSEL1_TMR1_S_HCLK         0x00002000UL /*!< Setting Timer 1 clock source as HCLK */
N#define CLK_CLKSEL1_TMR1_S_IRC22M       0x00007000UL /*!< Setting Timer 1 clock source as internal 22.1184MHz RC clock */
N#define CLK_CLKSEL1_UART_S_XTAL         0x00000000UL /*!< Setting UART clock source as external X'tal */
N#define CLK_CLKSEL1_UART_S_IRC22M       0x02000000UL /*!< Setting UART clock source as external internal 22.1184MHz RC clock */
N#define CLK_CLKSEL1_PWM01_S_HCLK        0x20000000UL /*!< Setting PWM01 clock source as external HCLK */
N#define CLK_CLKSEL1_PWM23_S_HCLK        0x80000000UL /*!< Setting PWM23 clock source as external HCLK */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKSEL2 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKSEL2_FRQDIV_XTAL        0x00000000UL /*!< Setting FRQDIV clock source as external X'tal */ 
N#define CLK_CLKSEL2_FRQDIV_HCLK        0x00000008UL /*!< Setting FRQDIV clock source as HCLK */
N#define CLK_CLKSEL2_FRQDIV_IRC22M      0x0000000CUL /*!< Setting FRQDIV clock source as internal 22.1184MHz RC clock */
N#define CLK_CLKSEL2_PWM45_S_HCLK       0x00000020UL /*!< Setting PWM45 clock source as HCLK */
N
N       
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKDIV constant definitions.                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKDIV_ADC(x)  (((x)-1) << 16) /*!< CLKDIV Setting for ADC clock divider. It could be 1~256 */ 
N#define CLK_CLKDIV_UART(x) (((x)-1) <<  8) /*!< CLKDIV Setting for UART clock divider. It could be 1~16 */ 
N#define CLK_CLKDIV_HCLK(x)  ((x)-1)        /*!< CLKDIV Setting for HCLK clock divider. It could be 1~16 */ 
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  MODULE constant definitions.                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/ 
N#define MODULE_APBCLK(x)                   (((x) >>31) & 0x1)    /*!< Calculate APBCLK offest on MODULE index */ 
N#define MODULE_CLKSEL(x)                   (((x) >>29) & 0x3)    /*!< Calculate CLKSEL offest on MODULE index */ 
N#define MODULE_CLKSEL_Msk(x)               (((x) >>25) & 0xf)    /*!< Calculate CLKSEL mask offest on MODULE index */ 
N#define MODULE_CLKSEL_Pos(x)               (((x) >>20) & 0x1f)   /*!< Calculate CLKSEL position offest on MODULE index */ 
N#define MODULE_CLKDIV(x)                   (((x) >>18) & 0x3)    /*!< Calculate APBCLK CLKDIV on MODULE index */ 
N#define MODULE_CLKDIV_Msk(x)               (((x) >>10) & 0xff)   /*!< Calculate CLKDIV mask offest on MODULE index */ 
N#define MODULE_CLKDIV_Pos(x)               (((x) >>5 ) & 0x1f)   /*!< Calculate CLKDIV position offest on MODULE index */ 
N#define MODULE_IP_EN_Pos(x)                (((x) >>0 ) & 0x1f)   /*!< Calculate APBCLK offest on MODULE index */ 
N#define MODULE_NoMsk                       0x0                 /*!< Not mask on MODULE index */ 
N/*-------------------------------------------------------------------------------------------------------------------------------*/        
N/*   APBCLK(1) | CLKSEL(2) | CLKSEL_Msk(4) |    CLKSEL_Pos(5)    | CLKDIV(2) | CLKDIV_Msk(8) |     CLKDIV_Pos(5)  |  IP_EN_Pos(5)        */
N/*-------------------------------------------------------------------------------------------------------------------------------*/
N#define WDT_MODULE        ((0x0<<31)|(0x1<<29)|(0x3<<25)|( 0<<20)|(0x3<<18)|(MODULE_NoMsk<<10)|(31<<5)|CLK_APBCLK_WDT_EN_Pos )  /*!< Watchdog Timer Module */ 
N#define TMR0_MODULE       ((0x0<<31)|(0x1<<29)|(0x7<<25)|( 8<<20)|(0x3<<18)|(MODULE_NoMsk<<10)|(31<<5)|CLK_APBCLK_TMR0_EN_Pos)  /*!< Timer0 Module */ 
N#define TMR1_MODULE       ((0x0<<31)|(0x1<<29)|(0x7<<25)|(12<<20)|(0x3<<18)|(MODULE_NoMsk<<10)|(31<<5)|CLK_APBCLK_TMR1_EN_Pos)  /*!< Timer1 Module */ 
N#define FDIV_MODULE       ((0x0<<31)|(0x3<<29)|(0x3<<25)|( 2<<20)|(0x3<<18)|(MODULE_NoMsk<<10)|(31<<5)|CLK_APBCLK_FDIV_EN_Pos)  /*!< Frequency Divider Output Module */ 
N#define I2C_MODULE        ((0x0<<31)|(0x3<<29)|(MODULE_NoMsk<<25)|(31<<20)|(0x3<<18)|(MODULE_NoMsk<<10)|(31<<5)|CLK_APBCLK_I2C_EN_Pos)   /*!< I2C Module */ 
N#define SPI_MODULE        ((0x0<<31)|(0x1<<29)|(0x1<<25)|( 4<<20)|(0x3<<18)|(MODULE_NoMsk<<10)|(31<<5)|CLK_APBCLK_SPI_EN_Pos)   /*!< SPI Module */ 
N#define UART_MODULE       ((0x0<<31)|(0x1<<29)|(0x3<<25)|(24<<20)|(0x0<<18)|(0x0F<<10)|( 8<<5)|CLK_APBCLK_UART_EN_Pos)          /*!< UART Module */ 
N#define PWM01_MODULE      ((0x0<<31)|(0x1<<29)|(0x3<<25)|(28<<20)|(0x3<<18)|(MODULE_NoMsk<<10)|(31<<5)|CLK_APBCLK_PWM01_EN_Pos) /*!< PWM Channel0 and Channel1 Module */ 
N#define PWM23_MODULE      ((0x0<<31)|(0x1<<29)|(0x3<<25)|(30<<20)|(0x3<<18)|(MODULE_NoMsk<<10)|(31<<5)|CLK_APBCLK_PWM23_EN_Pos) /*!< PWM Channel2 and Channel3 Module */ 
N#define PWM45_MODULE      ((0x0<<31)|(0x3<<29)|(0x3<<25)|( 4<<20)|(0x3<<18)|(MODULE_NoMsk<<10)|(31<<5)|CLK_APBCLK_PWM45_EN_Pos) /*!< PWM Channel4 and Channel5 Module */ 
N#define ADC_MODULE        ((0x0<<31)|(0x1<<29)|(0x3<<25)|( 2<<20)|(0x0<<18)|(0xFF<<10)|(16<<5)|CLK_APBCLK_ADC_EN_Pos)           /*!< ADC Module */ 
N#define ACMP_MODULE       ((0x0<<31)|(0x3<<29)|(MODULE_NoMsk<<25)|(31<<20)|(0x3<<18)|(MODULE_NoMsk<<10)|(31<<5)|CLK_APBCLK_CMP_EN_Pos)  /*!< ACMP Module */
N
N/*@}*/ /* end of group MINI51_CLK_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup MINI51_CLK_EXPORTED_FUNCTIONS CLK Exported Functions
N  @{
N*/
N
Nvoid CLK_DisableCKO(void);
Nvoid CLK_EnableCKO(uint32_t u32ClkSrc, uint32_t u32ClkDiv, uint32_t u32ClkDivBy1En);
Nvoid CLK_PowerDown(void);
Nvoid CLK_Idle(void);
Nuint32_t CLK_GetHXTFreq(void);
Nuint32_t CLK_GetLXTFreq(void);
Nuint32_t CLK_GetHCLKFreq(void);
Nuint32_t CLK_GetPCLKFreq(void);
Nuint32_t CLK_GetCPUFreq(void);
Nuint32_t CLK_GetPLLClockFreq(void);
Nuint32_t CLK_SetCoreClock(uint32_t u32Hclk);
Nvoid CLK_SetHCLK(uint32_t u32ClkSrc, uint32_t u32ClkDiv);
Nvoid CLK_SetModuleClock(uint32_t u32ModuleIdx, uint32_t u32ClkSrc, uint32_t u32ClkDiv);
Nvoid CLK_SetSysTickClockSrc(uint32_t u32ClkSrc);
Nvoid CLK_EnableXtalRC(uint32_t u32ClkMask);
Nvoid CLK_DisableXtalRC(uint32_t u32ClkMask);
Nvoid CLK_EnableModuleClock(uint32_t u32ModuleIdx);
Nvoid CLK_DisableModuleClock(uint32_t u32ModuleIdx);
Nuint32_t CLK_EnablePLL(uint32_t u32PllClkSrc, uint32_t u32PllFreq);
Nvoid CLK_DisablePLL(void);
Nvoid CLK_SysTickDelay(uint32_t us);
Nvoid CLK_WaitClockReady(uint32_t u32ClkMask);
N
N
N
N/*@}*/ /* end of group MINI51_CLK_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group MINI51_CLK_Driver */
N
N/*@}*/ /* end of group MINI51_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__CLK_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 3460 ".\CMSIS\Mini51Series.h" 2
N//#include "acmp.h"
N#include "adc.h"
L 1 ".\StdDriver\inc\adc.h" 1
N/**************************************************************************//**
N * @file     adc.h
N * @version  V1.00
N * $Revision: 7 $
N * $Date: 13/10/01 9:25a $ 
N * @brief    Mini51 series ADC driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/ 
N#ifndef __ADC_H__
N#define __ADC_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup MINI51_Device_Driver MINI51 Device Driver
N  @{
N*/
N
N/** @addtogroup MINI51_ADC_Driver ADC Driver
N  @{
N*/
N
N/** @addtogroup MINI51_ADC_EXPORTED_CONSTANTS ADC Exported Constants
N  @{
N*/
N
N#define ADC_CH7_EXT                     (0UL)                       /*!< Use external input pin as ADC channel 7 source */
N#define ADC_CH7_BGP                     (ADC_ADCHER_PRESEL_Msk)     /*!< Use internal band-gap voltage (VBG) as channel 7 source. */
N#define ADC_CMP_LESS_THAN               (0UL)                       /*!< ADC compare condition less than */
N#define ADC_CMP_GREATER_OR_EQUAL_TO     (ADC_ADCMPR_CMPCOND_Msk)    /*!< ADC compare condition greater or equal to */
N#define ADC_TRIGGER_BY_EXT_PIN          (0UL)                       /*!< ADC trigger by STADC (P3.2) pin */
N#define ADC_TRIGGER_BY_PWM              (ADC_ADCR_TRGS_Msk)         /*!< ADC trigger by PWM events */
N#define ADC_FALLING_EDGE_TRIGGER        (0UL)                       /*!< External pin falling edge trigger ADC */
N#define ADC_RISING_EDGE_TRIGGER         (ADC_ADCR_TRGCOND_Msk)      /*!< External pin rising edge trigger ADC */
N#define ADC_ADF_INT                     (ADC_ADSR_ADF_Msk)          /*!< ADC convert complete interrupt */
N#define ADC_CMP0_INT                    (ADC_ADSR_CMPF0_Msk)        /*!< ADC comperator 0 interrupt */
N#define ADC_CMP1_INT                    (ADC_ADSR_CMPF1_Msk)        /*!< ADC comperator 0 interrupt */
N#define ADC_SAMPLE_CLOCK_0              (0UL)                       /*!< ADC sample time is 0 ADC clock */
N#define ADC_SAMPLE_CLOCK_1              (1UL)                       /*!< ADC sample time is 1 ADC clock */
N#define ADC_SAMPLE_CLOCK_2              (2UL)                       /*!< ADC sample time is 2 ADC clock */
N#define ADC_SAMPLE_CLOCK_4              (3UL)                       /*!< ADC sample time is 4 ADC clock */
N#define ADC_SAMPLE_CLOCK_8              (4UL)                       /*!< ADC sample time is 8 ADC clock */
N#define ADC_SAMPLE_CLOCK_16             (5UL)                       /*!< ADC sample time is 16 ADC clock */
N#define ADC_SAMPLE_CLOCK_32             (6UL)                       /*!< ADC sample time is 32 ADC clock */
N#define ADC_SAMPLE_CLOCK_64             (7UL)                       /*!< ADC sample time is 64 ADC clock */
N#define ADC_SAMPLE_CLOCK_128            (8UL)                       /*!< ADC sample time is 128 ADC clock */
N#define ADC_SAMPLE_CLOCK_256            (9UL)                       /*!< ADC sample time is 256 ADC clock */
N#define ADC_SAMPLE_CLOCK_512            (10UL)                      /*!< ADC sample time is 512 ADC clock */
N#define ADC_SAMPLE_CLOCK_1024           (11UL)                      /*!< ADC sample time is 1024 ADC clock */
N
N/*@}*/ /* end of group MINI51_ADC_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup MINI51_ADC_EXPORTED_FUNCTIONS ADC Exported Functions
N  @{
N*/
N
N
N/**
N  * @brief Configure the analog input source of channel 7
N  * @param[in] adc Base address of ADC module
N  * @param[in] u32Source Decides the analog input source of channel 7, valid values are
N  *                     - \ref ADC_CH7_EXT
N  *                     - \ref ADC_CH7_BGP
N  * @return None
N  * @note While using VBG as channel 7 source, ADC module clock must /b not exceed 300kHz 
N  */
N#define ADC_CONFIG_CH7(adc, u32Source) (ADC->ADCHER = (ADC->ADCHER & ~ADC_ADCHER_PRESEL_Msk) | (u32Source))
N
N/**
N  * @brief Get the latest ADC conversion data
N  * @param[in] adc Base address of ADC module
N  * @param[in] u32ChNum Currently not used
N  * @return  Latest ADC conversion data
N  */
N#define ADC_GET_CONVERSION_DATA(adc, u32ChNum) (ADC->ADDR & ADC_ADDR_RSLT_Msk)
N
N/**
N  * @brief Return the user-specified interrupt flags
N  * @param[in] adc Base address of ADC module
N  * @param[in] u32Mask The combination of following interrupt status bits. Each bit corresponds to a interrupt status.
N  *                     - \ref ADC_ADF_INT
N  *                     - \ref ADC_CMP0_INT
N  *                     - \ref ADC_CMP1_INT
N  * @return  User specified interrupt flags
N  */
N#define ADC_GET_INT_FLAG(adc, u32Mask) (ADC->ADSR & (u32Mask))
N
N/**
N  * @brief This macro clear the selected interrupt status bits
N  * @param[in] adc Base address of ADC module
N  * @param[in] u32Mask The combination of following interrupt status bits. Each bit corresponds to a interrupt status.
N  *                     - \ref ADC_ADF_INT
N  *                     - \ref ADC_CMP0_INT
N  *                     - \ref ADC_CMP1_INT
N  * @return  None
N  */
N#define ADC_CLR_INT_FLAG(adc, u32Mask) (ADC->ADSR = (ADC->ADSR & ~(ADC_ADSR_ADF_Msk | \
N                                                                       ADC_ADSR_CMPF0_Msk | \
N                                                                       ADC_ADSR_CMPF1_Msk)) | (u32Mask))
X#define ADC_CLR_INT_FLAG(adc, u32Mask) (ADC->ADSR = (ADC->ADSR & ~(ADC_ADSR_ADF_Msk |                                                                        ADC_ADSR_CMPF0_Msk |                                                                        ADC_ADSR_CMPF1_Msk)) | (u32Mask))
N
N/**
N  * @brief Get the busy state of ADC
N  * @param[in] adc Base address of ADC module
N  * @return busy state of ADC
N  * @retval 0 ADC is not busy
N  * @retval 1 ADC is busy
N  */
N#define ADC_IS_BUSY(adc) (ADC->ADSR & ADC_ADSR_BUSY_Msk ? 1 : 0)
N     
N/**
N  * @brief Check if the ADC conversion data is over written or not
N  * @param[in] adc Base address of ADC module
N  * @param[in] u32ChNum Currently not used
N  * @return Over run state of ADC data
N  * @retval 0 ADC data is not overrun
N  * @retval 1 ADC data us overrun
N  */     
N#define ADC_IS_DATA_OVERRUN(adc, u32ChNum) (ADC->ADSR & ADC_ADSR_OVERRUN_Msk ? 1 : 0)
N
N/**
N  * @brief Check if the ADC conversion data is valid or not
N  * @param[in] adc Base address of ADC module
N  * @param[in] u32ChNum Currently not used
N  * @return Valid state of ADC data
N  * @retval 0 ADC data is not valid
N  * @retval 1 ADC data us valid
N  */  
N#define ADC_IS_DATA_VALID(adc, u32ChNum) (ADC->ADSR & ADC_ADSR_VALID_Msk ? 1 : 0)
N
N/**
N  * @brief Power down ADC module
N  * @param[in] adc Base address of ADC module
N  * @return None
N  */
N#define ADC_POWER_DOWN(adc) (ADC->ADCR &= ~ADC_ADCR_ADEN_Msk)
N
N/**
N  * @brief Power on ADC module
N  * @param[in] adc Base address of ADC module
N  * @return None
N  */
N#define ADC_POWER_ON(adc) (ADC->ADCR |= ADC_ADCR_ADEN_Msk)                                                        
N
N/**
N  * @brief Configure the comparator 0 and enable it
N  * @param[in] adc Base address of ADC module
N  * @param[in] u32ChNum  Specifies the source channel, valid value are from 0 to 7
N  * @param[in] u32Condition Specifies the compare condition
N  *                     - \ref ADC_CMP_LESS_THAN
N  *                     - \ref ADC_CMP_GREATER_OR_EQUAL_TO
N  * @param[in] u32Data Specifies the compare value. Valid valure are between 0 ~ 0x3FF
N  * @param[in] u32MatchCount Specifies the match count setting, valid values are vetween 1~16
N  * @return None
N  * @details For example, ADC_ENABLE_CMP0(ADC, 5, ADC_CMP_GREATER_OR_EQUAL_TO, 0x800, 10);
N  *          Means ADC will assert comperator 0 flag if channel 5 conversion result is 
N  *          greater or equal to 0x800 for 10 times continuously.
N  */ 
N#define ADC_ENABLE_CMP0(adc, \
N                        u32ChNum, \
N                        u32Condition, \
N                        u32Data, \
N                        u32MatchCount) (ADC->ADCMPR[0] = ((u32ChNum) << ADC_ADCMPR_CMPCH_Pos) | \
N                                                                   (u32Condition) | \
N                                                                   ((u32Data) << ADC_ADCMPR_CMPD_Pos) | \
N                                                                   (((u32MatchCount) - 1) << ADC_ADCMPR_CMPMATCNT_Pos) |\
N                                                                   ADC_ADCMPR_CMPEN_Msk)
X#define ADC_ENABLE_CMP0(adc,                         u32ChNum,                         u32Condition,                         u32Data,                         u32MatchCount) (ADC->ADCMPR[0] = ((u32ChNum) << ADC_ADCMPR_CMPCH_Pos) |                                                                    (u32Condition) |                                                                    ((u32Data) << ADC_ADCMPR_CMPD_Pos) |                                                                    (((u32MatchCount) - 1) << ADC_ADCMPR_CMPMATCNT_Pos) |                                                                   ADC_ADCMPR_CMPEN_Msk)
N                                                                   
N/**
N  * @brief Disable comparator 0
N  * @param[in] adc Base address of ADC module
N  */  
N#define ADC_DISABLE_CMP0(adc) (ADC->ADCMPR[0] = 0)              
N
N/**
N  * @brief Configure the comparator 1 and enable it
N  * @param[in] adc Base address of ADC module
N  * @param[in] u32ChNum  Specifies the source channel, valid value are from 0 to 7
N  * @param[in] u32Condition Specifies the compare condition
N  *                     - \ref ADC_CMP_LESS_THAN
N  *                     - \ref ADC_CMP_GREATER_OR_EQUAL_TO
N  * @param[in] u32Data Specifies the compare value. Valid valure are between 0 ~ 0x3FF
N  * @param[in] u32MatchCount Specifies the match count setting, valid values are vetween 1~16
N  * @return None
N  * @details For example, ADC_ENABLE_CMP1(ADC, 5, ADC_CMP_GREATER_OR_EQUAL_TO, 0x800, 10);
N  *          Means ADC will assert comperator 1 flag if channel 5 conversion result is 
N  *          greater or equal to 0x800 for 10 times continuously.
N  */                     
N#define ADC_ENABLE_CMP1(adc, \
N                        u32ChNum, \
N                        u32Condition, \
N                        u32Data, \
N                        u32MatchCount) (ADC->ADCMPR[1] = ((u32ChNum) << ADC_ADCMPR_CMPCH_Pos) | \
N                                                                   (u32Condition) | \
N                                                                   ((u32Data) << ADC_ADCMPR_CMPD_Pos) | \
N                                                                   ((u32MatchCount - 1) << ADC_ADCMPR_CMPMATCNT_Pos) |\
N                                                                   ADC_ADCMPR_CMPEN_Msk)  
X#define ADC_ENABLE_CMP1(adc,                         u32ChNum,                         u32Condition,                         u32Data,                         u32MatchCount) (ADC->ADCMPR[1] = ((u32ChNum) << ADC_ADCMPR_CMPCH_Pos) |                                                                    (u32Condition) |                                                                    ((u32Data) << ADC_ADCMPR_CMPD_Pos) |                                                                    ((u32MatchCount - 1) << ADC_ADCMPR_CMPMATCNT_Pos) |                                                                   ADC_ADCMPR_CMPEN_Msk)  
N
N/**
N  * @brief Disable comparator 1
N  * @param[in] adc Base address of ADC module
N  */                          
N#define ADC_DISABLE_CMP1(adc) (ADC->ADCMPR[1] = 0)
N
N/**
N  * @brief Set ADC input channel. Enabled channel will be converted while ADC starts.
N  * @param[in] adc Base address of ADC module
N  * @param[in] u32Mask  Channel enable bit. Each bit corresponds to a input channel. Bit 0 is channel 0, bit 1 is channel 1...
N  * @return None
N  * @note Mini51 series MCU ADC can only convert 1 channel at a time. If more than 1 channels are enabled, only channel
N  *       with smallest number will be convert.
N  */   
N#define ADC_SET_INPUT_CHANNEL(adc, u32Mask) (ADC->ADCHER = (ADC->ADCHER & ~ADC_ADCHER_CHEN_Msk) | (u32Mask))
N
N/**
N  * @brief Start the A/D conversion.
N  * @param[in] adc Base address of ADC module
N  * @return None
N  */
N#define ADC_START_CONV(adc) (ADC->ADCR |= ADC_ADCR_ADST_Msk)
N
N/**
N  * @brief Stop the A/D conversion.
N  * @param[in] adc Base address of ADC module
N  * @return None
N  */
N#define ADC_STOP_CONV(adc) (ADC->ADCR &= ~ADC_ADCR_ADST_Msk)
N
Nvoid ADC_Open(ADC_T *adc,
N               uint32_t u32InputMode, 
N               uint32_t u32OpMode,  
N               uint32_t u32ChMask);
Nvoid ADC_Close(ADC_T *adc);
Nvoid ADC_EnableHWTrigger(ADC_T *adc,
N                         uint32_t u32Source,
N                         uint32_t u32Param);
Nvoid ADC_DisableHWTrigger(ADC_T *adc);
Nvoid ADC_SetExtraSampleTime(ADC_T *adc,
N                            uint32_t u32ChNum,
N                            uint32_t u32SampleTime);
Nvoid ADC_EnableInt(ADC_T *adc, uint32_t u32Mask);
Nvoid ADC_DisableInt(ADC_T *adc, uint32_t u32Mask);
N                   
N                   
N                   
N/*@}*/ /* end of group MINI51_ADC_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group MINI51_ADC_Driver */
N
N/*@}*/ /* end of group MINI51_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__ADC_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 3462 ".\CMSIS\Mini51Series.h" 2
N#include "fmc.h"
L 1 ".\StdDriver\inc\fmc.h" 1
N/**************************************************************************//**
N * @file     FMC.h
N * @version  V1.00
N * $Revision: 8 $
N * $Date: 13/10/01 9:25a $
N * @brief    MINI51 series FMC driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N ******************************************************************************/
N#ifndef __FMC_H__
N#define __FMC_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N    
N/** @addtogroup MINI51_Device_Driver MINI51 Device Driver
N  @{
N*/
N
N/** @addtogroup MINI51_FMC_Driver FMC Driver
N  @{
N*/
N
N/** @addtogroup MINI51_FMC_EXPORTED_CONSTANTS FMC Exported Constants
N  @{
N*/
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define Base Address                                                                                     */
N/*---------------------------------------------------------------------------------------------------------*/
N#define FMC_APROM_BASE          0x00000000UL    /*!< APROM  Base Address         */  
N#define FMC_LDROM_BASE          0x00100000UL    /*!< LDROM  Base Address         */
N#define FMC_LDROM_END           0x00100800UL    /*!< LDROM  End Address          */
N#define FMC_CONFIG_BASE         0x00300000UL    /*!< CONFIG Base Address         */
N
N#define FMC_FLASH_PAGE_SIZE     0x200           /*!< Flash Page Size (512 Bytes) */
N#define FMC_LDROM_SIZE          0x800           /*!< LDROM Size (2 kBytes)       */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  ISPCMD constant definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define FMC_ISPCMD_READ         0x00            /*!< ISP Command: Read Flash        */
N#define FMC_ISPCMD_PROGRAM      0x21            /*!< ISP Command: Program Flash     */
N#define FMC_ISPCMD_PAGE_ERASE   0x22            /*!< ISP Command: Page Erase Flash  */
N#define FMC_ISPCMD_READ_CID     0x0B            /*!< ISP Command: Read Company ID   */
N#define FMC_ISPCMD_READ_DID     0x0C            /*!< ISP Command: Read Device ID    */
N#define FMC_ISPCMD_READ_UID     0x04            /*!< ISP Command: Read Unique ID    */
N#define FMC_ISPCMD_VECMAP       0x2E            /*!< ISP Command: Vector Page Remap */
N
N
N/*@}*/ /* end of group MINI51_FMC_EXPORTED_CONSTANTS */
N
N/** @addtogroup MINI51_FMC_EXPORTED_FUNCTIONS FMC Exported Functions
N  @{
N*/
N
N#define FMC_SET_APROM_BOOT()        (FMC->ISPCON &= ~FMC_ISPCON_BS_Msk)         /*!< Select booting from APROM  */
N#define FMC_SET_LDROM_BOOT()        (FMC->ISPCON |= FMC_ISPCON_BS_Msk)          /*!< Select booting from LDROM  */
N#define FMC_DISABLE_AP_UPDATE()     (FMC->ISPCON &= ~FMC_ISPCON_APUEN_Msk)      /*!< Disable APROM update  */
N#define FMC_DISABLE_CFG_UPDATE()    (FMC->ISPCON &= ~FMC_ISPCON_CFGUEN_Msk)     /*!< Disable User Config update  */
N#define FMC_DISABLE_LD_UPDATE()     (FMC->ISPCON &= ~FMC_ISPCON_LDUEN_Msk)      /*!< Disable LDROM update  */
N#define FMC_DISABLE_ISP()           (FMC->ISPCON &= ~FMC_ISPCON_ISPEN_Msk)      /*!< Disable ISP function  */
N#define FMC_ENABLE_AP_UPDATE()      (FMC->ISPCON |=  FMC_ISPCON_APUEN_Msk)      /*!< Enable APROM update  */
N#define FMC_ENABLE_LD_UPDATE()      (FMC->ISPCON |=  FMC_ISPCON_LDUEN_Msk)      /*!< Enable LDROM update  */
N#define FMC_ENABLE_CFG_UPDATE()     (FMC->ISPCON |=  FMC_ISPCON_CFGUEN_Msk)     /*!< Enable User Config update  */
N#define FMC_ENABLE_ISP()            (FMC->ISPCON |=  FMC_ISPCON_ISPEN_Msk)      /*!< Enable ISP function  */
N#define FMC_GET_FAIL_FLAG()         ((FMC->ISPCON & FMC_ISPCON_ISPFF_Msk) ? 1 : 0)  /*!< Get ISP fail flag  */
N
N
Nextern void FMC_SetBootSource(int32_t i32BootSrc);
Nextern void FMC_Close(void);
Nextern void FMC_DisableAPUpdate(void);
Nextern void FMC_DisableConfigUpdate(void);
Nextern void FMC_DisableLDUpdate(void);
Nextern void FMC_EnableAPUpdate(void);
Nextern void FMC_EnableConfigUpdate(void);
Nextern void FMC_EnableLDUpdate(void);
Nextern int32_t FMC_Erase(uint32_t u32PageAddr);
Nextern int32_t FMC_GetBootSource(void);
Nextern void FMC_Open(void);
Nextern uint32_t FMC_Read (uint32_t u32Addr);
Nextern uint32_t FMC_ReadCID(void);
Nextern uint32_t FMC_ReadDID(void);
Nextern uint32_t FMC_ReadPID(void);
Nextern uint32_t FMC_ReadUCID(uint32_t u32Index);
Nextern uint32_t FMC_ReadUID(uint32_t u32Index);
Nextern uint32_t FMC_ReadDataFlashBaseAddr(void);
Nextern void FMC_SetVectorPageAddr(uint32_t u32PageAddr);
Nextern void FMC_Write(uint32_t u32Addr, uint32_t u32Data);
Nextern int32_t FMC_ReadConfig(uint32_t *u32Config, uint32_t u32Count);
Nextern int32_t FMC_WriteConfig(uint32_t *u32Config, uint32_t u32Count);
N
N
N/*@}*/ /* end of group MINI51_FMC_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group MINI51_FMC_Driver */
N
N/*@}*/ /* end of group MINI51_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif
N
L 3463 ".\CMSIS\Mini51Series.h" 2
N#include "gpio.h"
L 1 ".\StdDriver\inc\gpio.h" 1
N/**************************************************************************//**
N * @file     gpio.h
N * @version  V1.00
N * $Revision: 5 $
N * $Date: 13/10/01 9:25a $ 
N * @brief    Mini51 series GPIO driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/ 
N#ifndef __GPIO_H__
N#define __GPIO_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup MINI51_Device_Driver MINI51 Device Driver
N  @{
N*/
N
N/** @addtogroup MINI51_GPIO_Driver GPIO Driver
N  @{
N*/
N
N/** @addtogroup MINI51_GPIO_EXPORTED_CONSTANTS GPIO Exported Constants
N  @{
N*/
N#define GPIO_PIN_MAX    8   /*!< Specify Maximum Pins of Each GPIO Port */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  PMD Constant Definitions                                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_PMD_INPUT              0x0UL                  /*!< Input Mode */
N#define GPIO_PMD_OUTPUT             0x1UL                  /*!< Output Mode */
N#define GPIO_PMD_OPEN_DRAIN         0x2UL                  /*!< Open-Drain Mode */
N#define GPIO_PMD_QUASI              0x3UL                  /*!< Quasi-bidirectional Mode */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  GPIO Interrupt Type Constant Definitions                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_INT_RISING             0x00010000UL /*!< Interrupt enable by Input Rising Edge */
N#define GPIO_INT_FALLING            0x00000001UL /*!< Interrupt enable by Input Falling Edge */
N#define GPIO_INT_BOTH_EDGE          0x00010001UL /*!< Interrupt enable by both Rising Edge and Falling Edge */
N#define GPIO_INT_HIGH               0x01010000UL /*!< Interrupt enable by Level-High */    
N#define GPIO_INT_LOW                0x01000001UL /*!< Interrupt enable by Level-Level */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  IMD Constant Definitions                                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_IMD_EDGE               0UL               /*!< IMD Setting for Edge Trigger Mode */
N#define GPIO_IMD_LEVEL              1UL               /*!< IMD Setting for Edge Level Mode */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  DBNCECON Constant Definitions                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_DBNCECON_ICLK_ON           0x00000020UL /*!< DBNCECON setting for all IO pins edge detection circuit is always active after reset */ 
N#define GPIO_DBNCECON_ICLK_OFF          0x00000000UL /*!< DBNCECON setting for edge detection circuit is active only if IO pin corresponding GPIOx_IEN bit is set to 1 */ 
N
N#define GPIO_DBNCECON_DBCLKSRC_IRC10K   0x00000010UL /*!< DBNCECON setting for de-bounce counter clock source is the internal 10 kHz */ 
N#define GPIO_DBNCECON_DBCLKSRC_HCLK     0x00000000UL /*!< DBNCECON setting for de-bounce counter clock source is the internal HCLK */ 
N
N#define GPIO_DBNCECON_DBCLKSEL_1        0x00000000UL /*!< DBNCECON setting for sampling cycle = 1 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_2        0x00000001UL /*!< DBNCECON setting for sampling cycle = 2 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_4        0x00000002UL /*!< DBNCECON setting for sampling cycle = 4 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_8        0x00000003UL /*!< DBNCECON setting for sampling cycle = 8 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_16       0x00000004UL /*!< DBNCECON setting for sampling cycle = 16 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_32       0x00000005UL /*!< DBNCECON setting for sampling cycle = 32 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_64       0x00000006UL /*!< DBNCECON setting for sampling cycle = 64 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_128      0x00000007UL /*!< DBNCECON setting for sampling cycle = 128 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_256      0x00000008UL /*!< DBNCECON setting for sampling cycle = 256 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_512      0x00000009UL /*!< DBNCECON setting for sampling cycle = 512 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_1024     0x0000000AUL /*!< DBNCECON setting for sampling cycle = 1024 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_2048     0x0000000BUL /*!< DBNCECON setting for sampling cycle = 2048 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_4096     0x0000000CUL /*!< DBNCECON setting for sampling cycle = 4096 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_8192     0x0000000DUL /*!< DBNCECON setting for sampling cycle = 8192 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_16384    0x0000000EUL /*!< DBNCECON setting for sampling cycle = 16384 clocks */
N#define GPIO_DBNCECON_DBCLKSEL_32768    0x0000000FUL /*!< DBNCECON setting for sampling cycle = 32768 clocks */
N
N/** Define GPIO Pin Data Input/Output. It could be used to control each I/O pin by pin address mapping.
N *  Example 1:
N *  
N *      P00 = 1; 
N *  
N *  It is used to set P0.0 to high;
N *  
N *  Example 2:
N *  
N *      if (P00)
N *          P00 = 0;
N *  
N *  If P0.0 pin status is high, then set P0.0 data output to low.
N */
N#define GPIO_PIN_ADDR(port, pin)	((volatile uint32_t *)((GPIOBIT0_BASE+(0x20*(port))) + ((pin)<<2)))
N#define GPIO_PIN_VALUE(port, pin)	(*((volatile uint32_t *)((GPIOBIT0_BASE+(0x20*(port))) + ((pin)<<2))))
N#define P00             GPIO_PIN_VALUE(0, 0) /*!< Specify P00 Pin Data Input/Output */
N#define P01             GPIO_PIN_VALUE(0, 1) /*!< Specify P01 Pin Data Input/Output */
N#define P02             GPIO_PIN_VALUE(0, 2) /*!< Specify P02 Pin Data Input/Output */
N#define P03             GPIO_PIN_VALUE(0, 3) /*!< Specify P03 Pin Data Input/Output */
N#define P04             GPIO_PIN_VALUE(0, 4) /*!< Specify P04 Pin Data Input/Output */
N#define P05             GPIO_PIN_VALUE(0, 5) /*!< Specify P05 Pin Data Input/Output */
N#define P06             GPIO_PIN_VALUE(0, 6) /*!< Specify P06 Pin Data Input/Output */
N#define P07             GPIO_PIN_VALUE(0, 7) /*!< Specify P07 Pin Data Input/Output */
N#define P10             GPIO_PIN_VALUE(1, 0) /*!< Specify P10 Pin Data Input/Output */
N#define P11             GPIO_PIN_VALUE(1, 1) /*!< Specify P11 Pin Data Input/Output */
N#define P12             GPIO_PIN_VALUE(1, 2) /*!< Specify P12 Pin Data Input/Output */
N#define P13             GPIO_PIN_VALUE(1, 3) /*!< Specify P13 Pin Data Input/Output */
N#define P14             GPIO_PIN_VALUE(1, 4) /*!< Specify P14 Pin Data Input/Output */
N#define P15             GPIO_PIN_VALUE(1, 5) /*!< Specify P15 Pin Data Input/Output */
N#define P16             GPIO_PIN_VALUE(1, 6) /*!< Specify P16 Pin Data Input/Output */
N#define P17             GPIO_PIN_VALUE(1, 7) /*!< Specify P17 Pin Data Input/Output */
N#define P20             GPIO_PIN_VALUE(2, 0) /*!< Specify P20 Pin Data Input/Output */
N#define P21             GPIO_PIN_VALUE(2, 1) /*!< Specify P21 Pin Data Input/Output */
N#define P22             GPIO_PIN_VALUE(2, 2) /*!< Specify P22 Pin Data Input/Output */
N#define P23             GPIO_PIN_VALUE(2, 3) /*!< Specify P23 Pin Data Input/Output */
N#define P24             GPIO_PIN_VALUE(2, 4) /*!< Specify P24 Pin Data Input/Output */
N#define P25             GPIO_PIN_VALUE(2, 5) /*!< Specify P25 Pin Data Input/Output */
N#define P26             GPIO_PIN_VALUE(2, 6) /*!< Specify P26 Pin Data Input/Output */
N#define P27             GPIO_PIN_VALUE(2, 7) /*!< Specify P27 Pin Data Input/Output */
N#define P30             GPIO_PIN_VALUE(3, 0) /*!< Specify P30 Pin Data Input/Output */
N#define P31             GPIO_PIN_VALUE(3, 1) /*!< Specify P31 Pin Data Input/Output */
N#define P32             GPIO_PIN_VALUE(3, 2) /*!< Specify P32 Pin Data Input/Output */
N#define P33             GPIO_PIN_VALUE(3, 3) /*!< Specify P33 Pin Data Input/Output */
N#define P34             GPIO_PIN_VALUE(3, 4) /*!< Specify P34 Pin Data Input/Output */
N#define P35             GPIO_PIN_VALUE(3, 5) /*!< Specify P35 Pin Data Input/Output */
N#define P36             GPIO_PIN_VALUE(3, 6) /*!< Specify P36 Pin Data Input/Output */
N#define P37             GPIO_PIN_VALUE(3, 7) /*!< Specify P37 Pin Data Input/Output */
N#define P40             GPIO_PIN_VALUE(4, 0) /*!< Specify P40 Pin Data Input/Output */
N#define P41             GPIO_PIN_VALUE(4, 1) /*!< Specify P41 Pin Data Input/Output */
N#define P42             GPIO_PIN_VALUE(4, 2) /*!< Specify P42 Pin Data Input/Output */
N#define P43             GPIO_PIN_VALUE(4, 3) /*!< Specify P43 Pin Data Input/Output */
N#define P44             GPIO_PIN_VALUE(4, 4) /*!< Specify P44 Pin Data Input/Output */
N#define P45             GPIO_PIN_VALUE(4, 5) /*!< Specify P45 Pin Data Input/Output */
N#define P46             GPIO_PIN_VALUE(4, 6) /*!< Specify P46 Pin Data Input/Output */
N#define P47             GPIO_PIN_VALUE(4, 7) /*!< Specify P47 Pin Data Input/Output */
N#define P50             GPIO_PIN_VALUE(5, 0) /*!< Specify P50 Pin Data Input/Output */
N#define P51             GPIO_PIN_VALUE(5, 1) /*!< Specify P51 Pin Data Input/Output */
N#define P52             GPIO_PIN_VALUE(5, 2) /*!< Specify P52 Pin Data Input/Output */
N#define P53             GPIO_PIN_VALUE(5, 3) /*!< Specify P53 Pin Data Input/Output */
N#define P54             GPIO_PIN_VALUE(5, 4) /*!< Specify P54 Pin Data Input/Output */
N#define P55             GPIO_PIN_VALUE(5, 5) /*!< Specify P55 Pin Data Input/Output */
N
N/*@}*/ /* end of group MINI51_GPIO_EXPORTED_CONSTANTS */
N
N/** @addtogroup MINI51_GPIO_EXPORTED_FUNCTIONS GPIO Exported Functions
N  @{
N*/
N
N/**
N * @brief       Clear GPIO Pin Interrupt Flag
N *
N * @param[in]   PORT        GPIO port. It could be P0, P1, P2, P3, P4 or P5.
N * @param[in]   pin_mask    The single or multiple pins of specified GPIO port.
N *
N * @return      None
N *
N * @details     Clear the interrupt status of specified GPIO pin.
N */
N#define GPIO_CLR_INT_FLAG(PORT, pin_mask)   ((PORT)->ISRC = pin_mask)
N
N/**
N * @brief       Disable Pin De-bounce Function
N *
N * @param[in]   PORT        GPIO port. It could be P0, P1, P2, P3, P4 or P5.
N * @param[in]   pin_mask    The single or multiple pins of specified GPIO port.
N *
N * @return      None
N *
N * @details     Disable the interrupt de-bounce function of specified GPIO pin.
N */
N#define GPIO_DISABLE_DEBOUNCE(PORT, pin_mask)   ((PORT)->DBEN &= ~pin_mask)
N
N/**
N * @brief       Enable Pin De-bounce Function
N *
N * @param[in]   PORT        GPIO port. It could be P0, P1, P2, P3, P4 or P5.
N * @param[in]   pin_mask    The single or multiple pins of specified GPIO port.
N *
N * @return      None
N *
N * @details     Enable the interrupt de-bounce function of specified GPIO pin.
N */
N#define GPIO_ENABLE_DEBOUNCE(PORT, pin_mask)    ((PORT)->DBEN |= pin_mask)
N
N/**
N * @brief       Disable I/O Digital Input Path
N *
N * @param[in]   PORT        GPIO port. It could be P0, P1, P2, P3, P4 or P5.
N * @param[in]   pin_mask    The single or multiple pins of specified GPIO port.
N *
N * @return      None
N *
N * @details     Disable I/O digital input path of specified GPIO pin.
N */
N#define GPIO_DISABLE_DIGITAL_PATH(PORT, pin_mask)   ((PORT)->OFFD |= pin_mask)
N
N/**
N * @brief       Enable I/O Digital Input Path
N *
N * @param[in]   PORT        GPIO port. It could be P0, P1, P2, P3, P4 or P5.
N * @param[in]   pin_mask    The single or multiple pins of specified GPIO port.
N *
N * @return      None
N *
N * @details     Enable I/O digital input path of specified GPIO pin.
N */
N#define GPIO_ENABLE_DIGITAL_PATH(PORT, pin_mask)    ((PORT)->OFFD &= ~pin_mask)
N
N/**
N * @brief       Disable I/O DOUT mask
N *
N * @param[in]   PORT        GPIO port. It could be P0, P1, P2, P3, P4 or P5.
N * @param[in]   pin_mask    The single or multiple pins of specified GPIO port.
N *
N * @return      None
N *
N * @details     Disable I/O DOUT mask of specified GPIO pin.
N */
N#define GPIO_DISABLE_DOUT_MASK(PORT, pin_mask)   ((PORT)->DMASK |= pin_mask)
N
N/**
N * @brief       Enable I/O DOUT mask
N *
N * @param[in]   PORT        GPIO port. It could be P0, P1, P2, P3, P4 or P5.
N * @param[in]   pin_mask    The single or multiple pins of specified GPIO port.
N *
N * @return      None
N *
N * @details     Enable I/O DOUT mask of specified GPIO pin.
N */
N#define GPIO_ENABLE_DOUT_MASK(PORT, pin_mask)   ((PORT)->DMASK &= ~pin_mask)
N
N/**
N * @brief       Get GPIO Pin Interrupt Flag
N *
N * @param[in]   PORT        GPIO port. It could be P0, P1, P2, P3, P4 or P5.
N * @param[in]   pin_mask    The single or multiple pins of specified GPIO port.
N *
N * @retval      0           No interrupt at specified GPIO pin
N * @retval      1           The specified GPIO pin generate an interrupt
N *
N * @details     Get the interrupt status of specified GPIO pin.
N */
N#define GPIO_GET_INT_FLAG(PORT, pin_mask)   ((PORT)->ISRC & pin_mask)
N
N/**
N * @brief       Set De-bounce Sampling Cycle Time
N *
N * @param[in]   clksrc      The de-bounce counter clock source. It could be GPIO_DBNCECON_DBCLKSRC_HCLK or GPIO_DBNCECON_DBCLKSRC_IRC10K.
N * @param[in]   clksel      The de-bounce sampling cycle selectionn. It could be \n
N *                              GPIO_DBNCECON_DBCLKSEL_1, GPIO_DBNCECON_DBCLKSEL_2, GPIO_DBNCECON_DBCLKSEL_4, GPIO_DBNCECON_DBCLKSEL_8, \n
N *                              GPIO_DBNCECON_DBCLKSEL_16, GPIO_DBNCECON_DBCLKSEL_32, GPIO_DBNCECON_DBCLKSEL_64, GPIO_DBNCECON_DBCLKSEL_128, \n
N *                              GPIO_DBNCECON_DBCLKSEL_256, GPIO_DBNCECON_DBCLKSEL_512, GPIO_DBNCECON_DBCLKSEL_1024, GPIO_DBNCECON_DBCLKSEL_2048, \n
N *                              GPIO_DBNCECON_DBCLKSEL_4096, GPIO_DBNCECON_DBCLKSEL_8192, GPIO_DBNCECON_DBCLKSEL_16384, GPIO_DBNCECON_DBCLKSEL_32768.
N *
N * @return      None
N *
N * @details     Set the interrupt de-bounce sampling cycle time based on the debounce counter clock source. \n
N *              Example: _GPIO_SET_DEBOUNCE_TIME(GPIO_DBNCECON_DBCLKSRC_IRC10K, GPIO_DBNCECON_DBCLKSEL_4). \n
N *              It's meaning the De-debounce counter clock source is internal 10 KHz and sampling cycle selection is 4. \n
N *              Then the target de-bounce sampling cycle time is (2^4)*(1/(10*1000)) s = 16*0.0001 s = 1600 us,
N *              and system will sampling interrupt input once per 1600 us.
N */
N#define GPIO_SET_DEBOUNCE_TIME(clksrc, clksel)  (GPIO->DBNCECON = (GPIO_DBNCECON_ICLK_ON_Msk | clksrc | clksel))
N
N/**
N * @brief       Get GPIO Port IN Data
N *
N * @param[in]   PORT        GPIO port. It could be P0, P1, P2, P3, P4 or P5.
N *
N * @retval      The specified port data
N *
N * @details     Get the PIN register of specified GPIO port.
N */
N#define GPIO_GET_IN_DATA(PORT)   ((PORT)->PIN)
N
N/**
N * @brief       Set GPIO Port OUT Data
N *
N * @param[in]   PORT        GPIO port. It could be P0, P1, P2, P3, P4 or P5.
N * @param[in]   data        GPIO port data.
N *
N * @retval      None
N *
N * @details     Set the Data into specified GPIO port.
N */
N#define GPIO_SET_OUT_DATA(PORT, data)   ((PORT)->DOUT = (data))
N
N/**
N * @brief       Toggle Specified GPIO pin
N *
N * @param[in]   port        Pxy
N *
N * @retval      None
N *
N * @details     Toggle the specified GPIO pint.
N */
N#define GPIO_TOGGLE(port)   ((port) ^= 1)
N
N/**
N * @brief       Enable External GPIO interrupt 0
N *
N * @param[in]   PORT            GPIO port. It could be P0, P1, P2, P3, P4 or P5.
N * @param[in]   u32Pin          The pin of specified GPIO port.
N * @param[in]   u32IntAttribs   The interrupt attribute of specified GPIO pin. It could be \n
N *                              GPIO_INT_RISING, GPIO_INT_FALLING, GPIO_INT_BOTH_EDGE, GPIO_INT_HIGH, GPIO_INT_LOW.
N *
N * @return      None
N *
N * @details     This function is used to enable specified GPIO pin interrupt.
N */
N#define GPIO_EnableEINT0    GPIO_EnableInt
N
N
N/**
N * @brief       Disable External GPIO interrupt 0
N *
N * @param[in]   PORT        GPIO port. It could be P0, P1, P2, P3, P4 or P5.
N * @param[in]   u32Pin      The pin of specified GPIO port. It could be 0 ~ 7.
N *
N * @return      None
N *
N * @details     This function is used to enable specified GPIO pin interrupt.
N */
N#define GPIO_DisableEINT0   GPIO_DisableInt
N
N
N/**
N * @brief       Enable External GPIO interrupt 1
N *
N * @param[in]   PORT            GPIO port. It could be P0, P1, P2, P3, P4 or P5.
N * @param[in]   u32Pin          The pin of specified GPIO port.
N * @param[in]   u32IntAttribs   The interrupt attribute of specified GPIO pin. It could be \n
N *                              GPIO_INT_RISING, GPIO_INT_FALLING, GPIO_INT_BOTH_EDGE, GPIO_INT_HIGH, GPIO_INT_LOW.
N *
N * @return      None
N *
N * @details     This function is used to enable specified GPIO pin interrupt.
N */
N#define GPIO_EnableEINT1    GPIO_EnableInt
N
N
N/**
N * @brief       Disable External GPIO interrupt 1
N *
N * @param[in]   PORT        GPIO port. It could be P0, P1, P2, P3, P4 or P5.
N * @param[in]   u32Pin      The pin of specified GPIO port. It could be 0 ~ 7.
N *
N * @return      None
N *
N * @details     This function is used to enable specified GPIO pin interrupt.
N */
N#define GPIO_DisableEINT1   GPIO_DisableInt
N
N
Nvoid GPIO_SetMode(GPIO_T *PORT, uint32_t pin_mask, uint32_t mode);
Nvoid GPIO_EnableInt(GPIO_T *PORT, uint32_t u32Pin, uint32_t u32IntAttribs);
Nvoid GPIO_DisableInt(GPIO_T *PORT, uint32_t u32Pin);
N
N
N
N/*@}*/ /* end of group MINI51_GPIO_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group MINI51_GPIO_Driver */
N
N/*@}*/ /* end of group MINI51_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__GPIO_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 3464 ".\CMSIS\Mini51Series.h" 2
N#include "i2c.h"
L 1 ".\StdDriver\inc\i2c.h" 1
N/**************************************************************************//**
N * @file     i2c.h
N * @version  V1.00
N * $Revision: 5 $
N * $Date: 13/09/30 6:48p $ 
N * @brief    Mini51 series I2C driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/ 
N#ifndef __I2C_H__
N#define __I2C_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup MINI51_Device_Driver MINI51 Device Driver
N  @{
N*/
N
N/** @addtogroup MINI51_I2C_Driver I2C Driver
N  @{
N*/
N
N
N/** @addtogroup MINI51_I2C_EXPORTED_CONSTANTS I2C Exported Constants
N  @{
N*/
N
N#define I2C_STA 0x20    /*!< I2C START */
N#define I2C_STO 0x10    /*!< I2C STOP */
N#define I2C_SI  0x08    /*!< I2C SI */
N#define I2C_AA  0x04    /*!< I2C ACK */
N
N/*@}*/ /* end of group MINI51_I2C_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup MINI51_I2C_EXPORTED_FUNCTIONS I2C Exported Functions
N  @{
N*/
N
N/**
N  * @brief This macro sets the I2C control register at one time.
N  * @param i2c is the base address of I2C module.
N  * @param u8Ctrl is the register value of I2C control register.
N  * @return None
N  */
Nstatic __INLINE void I2C_SET_CONTROL_REG(I2C_T *i2c, uint8_t u8Ctrl)
Xstatic __inline void I2C_SET_CONTROL_REG(I2C_T *i2c, uint8_t u8Ctrl)
N{
N    i2c->I2CON = (i2c->I2CON & ~0x3c) | u8Ctrl;
N}
N
N/**
N  * @brief This macro only set START bit to the control register of I2C module.
N  * @param i2c is the base address of I2C module.
N  * @return None
N  */
Nstatic __INLINE void I2C_START(I2C_T *i2c)
Xstatic __inline void I2C_START(I2C_T *i2c)
N{
N    i2c->I2CON = (i2c->I2CON & ~I2C_I2CON_SI_Msk) | I2C_I2CON_STA_Msk;
X    i2c->I2CON = (i2c->I2CON & ~(1ul << 3)) | (1ul << 5);
N}
N
N/**
N  * @brief This macro only set STOP bit to the control register of I2C module.
N  * @param i2c is the base address of I2C module.
N  * @return None
N  */
Nstatic __INLINE void I2C_STOP(I2C_T *i2c)
Xstatic __inline void I2C_STOP(I2C_T *i2c)
N{
N    i2c->I2CON = (i2c->I2CON & ~I2C_I2CON_SI_Msk) | I2C_I2CON_STO_Msk;
X    i2c->I2CON = (i2c->I2CON & ~(1ul << 3)) | (1ul << 4);
N}
N
N/**
N  * @brief This macro will return when I2C module is ready.
N  * @param i2c is the base address of I2C module.
N  * @return None
N  */
Nstatic __INLINE void I2C_WAIT_READY(I2C_T *i2c)
Xstatic __inline void I2C_WAIT_READY(I2C_T *i2c)
N{
N    while(!(i2c->I2CON & I2C_I2CON_SI_Msk));
X    while(!(i2c->I2CON & (1ul << 3)));
N}
N
N/**
N  * @brief This macro disables the FIFO function.
N  * @param i2c is the base address of I2C module.
N  * @return None
N  */
Nstatic __INLINE void I2C_DISABLE_FIFO(I2C_T *i2c)
Xstatic __inline void I2C_DISABLE_FIFO(I2C_T *i2c)
N{
N    i2c->I2CON2 &= ~I2C_I2CON2_TWOFF_EN_Msk;
X    i2c->I2CON2 &= ~(1ul << 1);
N}
N
N/**
N  * @brief This macro enables the FIFO function.
N  * @param i2c is the base address of I2C module.
N  * @return None
N  */
Nstatic __INLINE void I2C_ENABLE_FIFO(I2C_T *i2c)
Xstatic __inline void I2C_ENABLE_FIFO(I2C_T *i2c)
N{
N    i2c->I2CON2 |= I2C_I2CON2_TWOFF_EN_Msk;
X    i2c->I2CON2 |= (1ul << 1);
N}
N
N/**
N  * @brief This macro disables clock stretch function.
N  * @param i2c is the base address of I2C module.
N  * @return None
N  */
Nstatic __INLINE void I2C_DISABLE_CLOCK_STRETCH(I2C_T *i2c)
Xstatic __inline void I2C_DISABLE_CLOCK_STRETCH(I2C_T *i2c)
N{
N    i2c->I2CON2 |= I2C_I2CON2_NOSTRETCH_Msk;
X    i2c->I2CON2 |= (1ul << 2);
N}
N
N/**
N  * @brief This macro enables clock stretch function.
N  * @param i2c is the base address of I2C module.
N  * @return None
N  */
Nstatic __INLINE void I2C_ENABLE_CLOCK_STRETCH(I2C_T *i2c)
Xstatic __inline void I2C_ENABLE_CLOCK_STRETCH(I2C_T *i2c)
N{
N    i2c->I2CON2 &= ~I2C_I2CON2_NOSTRETCH_Msk;
X    i2c->I2CON2 &= ~(1ul << 2);
N}
N
N/**
N  * @brief This macro disables over-run interrupt.
N  * @param i2c is the base address of I2C module.
N  * @return None
N  */
Nstatic __INLINE void I2C_DISABLE_OVERRUN_INT(I2C_T *i2c)
Xstatic __inline void I2C_DISABLE_OVERRUN_INT(I2C_T *i2c)
N{
N    i2c->I2CON2 &= ~I2C_I2CON2_OVER_INTEN_Msk;
X    i2c->I2CON2 &= ~(1ul << 3);
N}
N
N/**
N  * @brief This macro enables over-run interrupt.
N  * @param i2c is the base address of I2C module.
N  * @return None
N  */
Nstatic __INLINE void I2C_ENABLE_OVERRUN_INT(I2C_T *i2c)
Xstatic __inline void I2C_ENABLE_OVERRUN_INT(I2C_T *i2c)
N{
N    i2c->I2CON2 |= I2C_I2CON2_OVER_INTEN_Msk;
X    i2c->I2CON2 |= (1ul << 3);
N}
N
N/**
N  * @brief This macro enables under-run interrupt.
N  * @param i2c is the base address of I2C module.
N  * @return None
N  */
Nstatic __INLINE void I2C_ENABLE_UNDERRUN_INT(I2C_T *i2c)
Xstatic __inline void I2C_ENABLE_UNDERRUN_INT(I2C_T *i2c)
N{
N    i2c->I2CON2 |= I2C_I2CON2_UNDER_INTEN_Msk;
X    i2c->I2CON2 |= (1ul << 4);
N}
N
N/**
N  * @brief This macro disables under-run interrupt.
N  * @param i2c is the base address of I2C module.
N  * @return None
N  */
Nstatic __INLINE void I2C_DISABLE_UNDERRUN_INT(I2C_T *i2c)
Xstatic __inline void I2C_DISABLE_UNDERRUN_INT(I2C_T *i2c)
N{
N    i2c->I2CON2 &= ~I2C_I2CON2_UNDER_INTEN_Msk;
X    i2c->I2CON2 &= ~(1ul << 4);
N}
N
N/**
N  * @brief This macro returns the data stored in data register of I2C module.
N  * @param i2c is the base address of I2C module.
N  * @return Data.
N  */
Nstatic __INLINE uint32_t I2C_GET_DATA(I2C_T *i2c)
Xstatic __inline uint32_t I2C_GET_DATA(I2C_T *i2c)
N{
N    return ( i2c->I2CDAT );
N}
N
N/**
N  * @brief This macro writes the data to data register of I2C module.
N  * @param i2c is the base address of I2C module.
N  * @param u8Data is the data which will be write to data register of I2C module.
N  * @return Data.
N  */
Nstatic __INLINE void I2C_SET_DATA(I2C_T *i2c, uint8_t u8Data)
Xstatic __inline void I2C_SET_DATA(I2C_T *i2c, uint8_t u8Data)
N{
N    i2c->I2CDAT = u8Data;
N}
N
N/**
N  * @brief This macro returns the status of I2C module.
N  * @param i2c is the base address of I2C module.
N  * @return Status.
N  */
Nstatic __INLINE uint32_t I2C_GET_STATUS(I2C_T *i2c)
Xstatic __inline uint32_t I2C_GET_STATUS(I2C_T *i2c)
N{
N    return ( i2c->I2CSTATUS );
N}
N
N/**
N  * @brief This macro returns timeout flag.
N  * @param i2c is the base address of I2C module.
N  * @return Status.
N  * @retval 0 Flag is not set.
N  * @retval 1 Flag is set.
N  */
Nstatic __INLINE uint32_t I2C_GET_TIMEOUT_FLAG(I2C_T *i2c)
Xstatic __inline uint32_t I2C_GET_TIMEOUT_FLAG(I2C_T *i2c)
N{
N    return ( (i2c->I2CTOC & I2C_I2CTOC_TIF_Msk) == I2C_I2CTOC_TIF_Msk ? 1:0  );
X    return ( (i2c->I2CTOC & (1ul << 0)) == (1ul << 0) ? 1:0  );
N}
N
N/**
N  * @brief This macro returns wakeup flag.
N  * @param i2c is the base address of I2C module.
N  * @return Status.
N  * @retval 0 Flag is not set.
N  * @retval 1 Flag is set.
N  */
Nstatic __INLINE uint32_t I2C_GET_WAKEUP_FLAG(I2C_T *i2c)
Xstatic __inline uint32_t I2C_GET_WAKEUP_FLAG(I2C_T *i2c)
N{
N    return ( (i2c->I2CSTATUS2 & I2C_I2CSTATUS2_WAKEUP_Msk) == I2C_I2CSTATUS2_WAKEUP_Msk ? 1:0  );
X    return ( (i2c->I2CSTATUS2 & (1ul << 0)) == (1ul << 0) ? 1:0  );
N}
N
Nuint32_t I2C_Open(I2C_T *i2c, uint32_t u32BusClock);
Nvoid I2C_Close(I2C_T *i2c);
Nvoid I2C_ClearTimeoutFlag(I2C_T *i2c);
Nvoid I2C_Trigger(I2C_T *i2c, uint8_t u8Start, uint8_t u8Stop, uint8_t u8Si, uint8_t u8Ack);
Nvoid I2C_DisableInt(I2C_T *i2c);
Nvoid I2C_EnableInt(I2C_T *i2c);
Nuint32_t I2C_GetClockBusFreq(I2C_T *i2c);
Nuint32_t I2C_SetClockBusFreq(I2C_T *i2c, uint32_t u32BusClock);
Nuint32_t I2C_GetIntFlag(I2C_T *i2c);
Nuint32_t I2C_GetStatus(I2C_T *i2c);
Nuint32_t I2C_GetData(I2C_T *i2c);
Nvoid I2C_SetData(I2C_T *i2c, uint8_t u8Data);
Nvoid I2C_SetSlaveAddr(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddr, uint8_t u8GCMode);
Nvoid I2C_SetSlaveMask(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddrMask);
Nvoid I2C_EnableTimeout(I2C_T *i2c, uint8_t u8LongTimeout);
Nvoid I2C_DisableTimeout(I2C_T *i2c);
Nvoid I2C_EnableWakeup(I2C_T *i2c);
Nvoid I2C_DisableWakeup(I2C_T *i2c);
N
N/*@}*/ /* end of group MINI51_I2C_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group MINI51_I2C_Driver */
N
N/*@}*/ /* end of group MINI51_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__I2C_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 3465 ".\CMSIS\Mini51Series.h" 2
N#include "pwm.h"
L 1 ".\StdDriver\inc\pwm.h" 1
N/**************************************************************************//**
N * @file     pwm.h
N * @version  V1.00
N * $Revision: 5 $
N * $Date: 13/09/30 6:48p $ 
N * @brief    Mini51 series PWM driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/ 
N#ifndef __PWM_H__
N#define __PWM_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup MINI51_Device_Driver MINI51 Device Driver
N  @{
N*/
N
N/** @addtogroup MINI51_PWM_Driver PWM Driver
N  @{
N*/
N
N/** @addtogroup MINI51_PWM_EXPORTED_CONSTANTS PWM Exported Constants
N  @{
N*/
N#define PWM_CHANNEL_NUM                     (6)   /*!< PWM channel number */
N#define PWM_CLK_DIV_1                       (4UL) /*!< PWM clock divid by 1 */
N#define PWM_CLK_DIV_2                       (0UL) /*!< PWM clock divid by 2 */
N#define PWM_CLK_DIV_4                       (1UL) /*!< PWM clock divid by 4 */
N#define PWM_CLK_DIV_8                       (2UL) /*!< PWM clock divid by 8 */
N#define PWM_CLK_DIV_16                      (3UL) /*!< PWM clock divid by 16 */
N#define PWM_EDGE_ALIGNED                    (0UL)                   /*!< PWM working in edge aligned type */
N#define PWM_CENTER_ALIGNED                  (PWM_PCR_PWMTYPE_Msk)   /*!< PWM working in center aligned type */
N#define PWM_TRIGGER_ADC_CNTR_IS_0           PWM_TRGCON0_P0TRGEN_Msk     /*!< PWM trigger ADC while counter matches 0 */
N#define PWM_TRIGGER_ADC_CNTR_IS_CMR_D       PWM_TRGCON0_CM0TRGFEN_Msk   /*!< PWM trigger ADC while counter matches CMR during down count */
N#define PWM_TRIGGER_ADC_CNTR_IS_CNR         PWM_TRGCON0_CNT0TRGEN_Msk   /*!< PWM trigger ADC while counter matches CNR */
N#define PWM_TRIGGER_ADC_CNTR_IS_CMR_U       PWM_TRGCON0_CM0TRGREN_Msk   /*!< PWM trigger ADC while counter matches CMR during up count  */
N#define PWM_FB0_EINT0       (PWM_PFBCON_BKEN0_Msk)                              /*!< External interrupt 0 as fault break 0 source */
N#define PWM_FB0_ACMP1       (PWM_PFBCON_BKEN0_Msk | PWM_PFBCON_CPO1BKEN_Msk)    /*!< Comparator 1 as fault break 0 source */
N#define PWM_FB1_EINT1       (PWM_PFBCON_BKEN1_Msk)                              /*!< External interrupt 1 as fault break 1 source */
N#define PWM_FB1_ACMP0       (PWM_PFBCON_BKEN0_Msk | PWM_PFBCON_CPO0BKEN_Msk)    /*!< Comparator 0 as fault break 1 source */
N#define PWM_PERIOD_INT_UNDERFLOW            (0)                         /*!< PWM period interrupt trigged if counter underflow */
N#define PWM_PERIOD_INT_MATCH_CNR            (PWM_PIER_INT_TYPE_Msk)     /*!< PWM period interrupt trigged if counter match CNR */
N
N/*@}*/ /* end of group MINI51_PWM_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup MINI51_PWM_EXPORTED_FUNCTIONS PWM Exported Functions
N  @{
N*/
N
N/**
N * @brief This macro enable complementary mode
N * @param[in] pwm The base address of PWM module
N * @return None
N */
N#define PWM_ENABLE_COMPLEMENTARY_MODE(pwm) (PWM->PCR = (PWM->PCR & ~PWM_PCR_PWMMOD_Msk) |(1UL << PWM_PCR_PWMMOD_Pos))
N
N/**
N * @brief This macro disable complementary mode, and enable independent mode.
N * @param[in] pwm The base address of PWM module
N * @return None
N */
N#define PWM_DISABLE_COMPLEMENTARY_MODE(pwm) (PWM->PCR &= ~PWM_PCR_PWMMOD_Msk)
N
N/**
N * @brief This macro enable group mode
N * @param[in] pwm The base address of PWM module
N * @return None
N */
N#define PWM_ENABLE_GROUP_MODE(pwm) (PWM->PCR |= PWM_PCR_GRP_Msk)
N
N/**
N * @brief This macro disable group mode
N * @param[in] pwm The base address of PWM module
N * @return None
N */
N#define PWM_DISABLE_GROUP_MODE(pwm) (PWM->PCR &= ~PWM_PCR_GRP_Msk)
N
N/**
N * @brief This macro enable synchronous mode
N * @param[in] pwm The base address of PWM module
N * @return None
N */
N#define PWM_ENABLE_SYNC_MODE(pwm) (PWM->PCR = (PWM->PCR & ~PWM_PCR_PWMMOD_Msk) |(2UL << PWM_PCR_PWMMOD_Pos))
N 
N/**
N * @brief This macro disable synchronous mode, and enable independent mode.
N * @param[in] pwm The base address of PWM module
N * @return None
N */
N#define PWM_DISABLE_SYNC_MODE(pwm) (PWM->PCR &= ~PWM_PCR_PWMMOD_Msk)
N
N/**
N * @brief This macro enable output inverter of specified channel(s)
N * @param[in] pwm The base address of PWM module
N * @param[in] u32ChannelMask Combination of enabled channels. Each bit corresponds to a channel
N *                           Bit 0 represents channel 0, bit 1 represents channel 1...
N * @return None
N */
N#define PWM_ENABLE_OUTPUT_INVERTER(pwm, u32ChannelMask) \
N    do{ \
N        int i;\
N        for(i = 0; i < 6; i++) { \
N            if((u32ChannelMask) & (1 << i)) \
N                PWM->PCR |= (PWM_PCR_CH0INV_Msk << (PWM_PCR_CH0INV_Pos * (i * 4))); \
N        } \
N    }while(0)
X#define PWM_ENABLE_OUTPUT_INVERTER(pwm, u32ChannelMask)     do{         int i;        for(i = 0; i < 6; i++) {             if((u32ChannelMask) & (1 << i))                 PWM->PCR |= (PWM_PCR_CH0INV_Msk << (PWM_PCR_CH0INV_Pos * (i * 4)));         }     }while(0)
N
N/**
N * @brief This macro set the prescaler of the selected channel
N * @param[in] pwm The base address of PWM module
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~5
N * @param[in] u32Prescaler Clock prescaler of specified channel. Valid values are between 1 ~ 0xFF
N * @return None
N * @note Every even channel N, and channel (N + 1) share a prescaler. So if channel 0 prescaler changed, 
N *       channel 1 will also be affected.
N */
N#define PWM_SET_PRESCALER(pwm, u32ChannelNum, u32Prescaler) \
N    (PWM->PPR = (PWM->PPR & ~(PWM_PPR_CP01_Msk << (((u32ChannelNum) >> 1) * 8))) | ((u32Prescaler) << (((u32ChannelNum) >> 1) * 8))) 
X#define PWM_SET_PRESCALER(pwm, u32ChannelNum, u32Prescaler)     (PWM->PPR = (PWM->PPR & ~(PWM_PPR_CP01_Msk << (((u32ChannelNum) >> 1) * 8))) | ((u32Prescaler) << (((u32ChannelNum) >> 1) * 8))) 
N
N/**
N * @brief This macro set the divider of the selected channel
N * @param[in] pwm The base address of PWM module
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~5
N * @param[in] u32Divider Clock divider of specified channel. Valid values are
N *              - \ref PWM_CLK_DIV_1
N *              - \ref PWM_CLK_DIV_2
N *              - \ref PWM_CLK_DIV_4
N *              - \ref PWM_CLK_DIV_8
N *              - \ref PWM_CLK_DIV_16 
N * @return None
N */
N#define PWM_SET_DIVIDER(pwm, u32ChannelNum, u32Divider) \
N    (PWM->CSR = (PWM->CSR & ~(PWM_CSR_CSR0_Msk << ((u32ChannelNum) * 4))) | ((u32Divider) << ((u32ChannelNum) * 4)))
X#define PWM_SET_DIVIDER(pwm, u32ChannelNum, u32Divider)     (PWM->CSR = (PWM->CSR & ~(PWM_CSR_CSR0_Msk << ((u32ChannelNum) * 4))) | ((u32Divider) << ((u32ChannelNum) * 4)))
N
N/**
N * @brief This macro set the duty of the selected channel
N * @param[in] pwm The base address of PWM module
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~5 
N * @param[in] u32CMR Duty of specified channel. Valid values are between 0~0xFFFF
N * @return None
N * @note This new setting will take effect on next PWM period
N */
N#define PWM_SET_CMR(pwm, u32ChannelNum, u32CMR) (PWM->CMR[u32ChannelNum] = (u32CMR))
N
N/**
N * @brief This macro set the period of the selected channel
N * @param[in] pwm The base address of PWM module
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~5 
N * @param[in] u32CNR Period of specified channel. Valid values are between 0~0xFFFF
N * @return None
N * @note This new setting will take effect on next PWM period
N * @note PWM counter will stop if period length set to 0
N */
N#define PWM_SET_CNR(pwm, u32ChannelNum, u32CNR)  (PWM->CNR[u32ChannelNum] = (u32CNR))
N
N/**
N * @brief This macro set the PWM aligned type
N * @param[in] pwm The base address of PWM module
N * @param[in] u32ChannelMask This parameter is not used
N * @param[in] u32AlignedType PWM aligned type, valid values are:
N *                  - PWM_EDGE_ALIGNED
N *                  - PWM_CENTER_ALIGNED
N * @return None
N */
N#define PWM_SET_ALIGNED_TYPE(pwm, u32ChannelMask, u32AlignedType) \
N    (PWM->PCR = (PWM->PCR & ~PWM_PCR_PWMTYPE_Msk) | (u32AlignedType))
X#define PWM_SET_ALIGNED_TYPE(pwm, u32ChannelMask, u32AlignedType)     (PWM->PCR = (PWM->PCR & ~PWM_PCR_PWMTYPE_Msk) | (u32AlignedType))
N
N
Nuint32_t PWM_ConfigOutputChannel(PWM_T *pwm,
N                                  uint32_t u32ChannelNum, 
N                                  uint32_t u32Frequncy, 
N                                  uint32_t u32DutyCycle);
Nvoid PWM_Start(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_Stop(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_ForceStop(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_EnableADCTrigger(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition);
Nvoid PWM_DisableADCTrigger(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_ClearADCTriggerFlag(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition);
Nuint32_t PWM_GetADCTriggerFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnableFaultBreak(PWM_T *pwm, 
N                           uint32_t u32ChannelMask, 
N                           uint32_t u32LevelMask, 
N                           uint32_t u32BreakSource);
Nvoid PWM_ClearFaultBreakFlag(PWM_T *pwm, uint32_t u32BreakSource);
Nvoid PWM_EnableOutput(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_DisableOutput(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_EnableDeadZone(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Duration);
Nvoid PWM_DisableDeadZone(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnableDutyInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32IntDutyType);
Nvoid PWM_DisableDutyInt(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_ClearDutyIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nuint32_t PWM_GetDutyIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnableFaultBreakInt(PWM_T *pwm, uint32_t u32BreakSource);
Nvoid PWM_DisableFaultBreakInt(PWM_T *pwm, uint32_t u32BreakSource);
Nvoid PWM_ClearFaultBreakIntFlag(PWM_T *pwm, uint32_t u32BreakSource);
Nuint32_t PWM_GetFaultBreakIntFlag(PWM_T *pwm, uint32_t u32BreakSource);
Nvoid PWM_EnablePeriodInt(PWM_T *pwm, uint32_t u32ChannelNum,  uint32_t u32IntPeriodType);
Nvoid PWM_DisablePeriodInt(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_ClearPeriodIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nuint32_t PWM_GetPeriodIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
N
N
N
N/*@}*/ /* end of group MINI51_PWM_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group MINI51_PWM_Driver */
N
N/*@}*/ /* end of group MINI51_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__PWM_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 3466 ".\CMSIS\Mini51Series.h" 2
N#include "spi.h"
L 1 ".\StdDriver\inc\spi.h" 1
N/**************************************************************************//**
N * @file     spi.h
N * @version  V1.00
N * $Revision: 5 $
N * $Date: 13/09/30 6:48p $ 
N * @brief    Mini51 series SPI driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/ 
N#ifndef __SPI_H__
N#define __SPI_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup MINI51_Device_Driver MINI51 Device Driver
N  @{
N*/
N
N/** @addtogroup MINI51_SPI_Driver SPI Driver
N  @{
N*/
N
N/** @addtogroup MINI51_SPI_EXPORTED_CONSTANTS SPI Exported Constants
N  @{
N*/
N
N#define SPI_MODE_0        (SPI_CNTRL_TX_NEG_Msk)                            /*!< CLKP=0; RX_NEG=0; TX_NEG=1 */
N#define SPI_MODE_1        (SPI_CNTRL_RX_NEG_Msk)                            /*!< CLKP=0; RX_NEG=1; TX_NEG=0 */
N#define SPI_MODE_2        (SPI_CNTRL_CLKP_Msk | SPI_CNTRL_RX_NEG_Msk)       /*!< CLKP=1; RX_NEG=1; TX_NEG=0 */
N#define SPI_MODE_3        (SPI_CNTRL_CLKP_Msk | SPI_CNTRL_TX_NEG_Msk)       /*!< CLKP=1; RX_NEG=0; TX_NEG=1 */
N
N#define SPI_SLAVE         (SPI_CNTRL_SLAVE_Msk)                             /*!< Set as slave */
N#define SPI_MASTER        (0x0)                                             /*!< Set as master */
N
N#define SPI_SS                (SPI_SSR_SSR_Msk)                             /*!< Set SS0 */
N#define SPI_SS_ACTIVE_HIGH    (SPI_SSR_SS_LVL_Msk)                          /*!< SS active high */
N#define SPI_SS_ACTIVE_LOW     (0x0)                                         /*!< SS active low */
N
N#define SPI_IE_MASK                        (0x01)                           /*!< Interrupt enable mask */
N#define SPI_SS_INT_OPT_MASK                (0x02)                           /*!< SS inactive interrupt option mask */
N#define SPI_SSTA_INTEN_MASK                (0x04)                           /*!< Slave 3-Wire mode start interrupt enable mask */
N#define SPI_FIFO_TX_INTEN_MASK             (0x08)                           /*!< FIFO TX interrupt mask */
N#define SPI_FIFO_RX_INTEN_MASK             (0x10)                           /*!< FIFO RX interrupt mask */
N#define SPI_FIFO_RXOV_INTEN_MASK           (0x12)                           /*!< FIFO RX overrun interrupt mask */
N#define SPI_FIFO_TIMEOUT_INTEN_MASK        (0x14)                           /*!< FIFO timeout interrupt mask */
N
N
N/*@}*/ /* end of group MINI51_SPI_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup MINI51_SPI_EXPORTED_FUNCTIONS SPI Exported Functions
N  @{
N*/
N
N/**
N  * @brief  Abort the current transfer in slave 3-wire mode.
N  * @param  spi is the base address of SPI module.
N  * @return None
N  */
Nstatic __INLINE void SPI_ABORT_3WIRE_TRANSFER(SPI_T *spi)
Xstatic __inline void SPI_ABORT_3WIRE_TRANSFER(SPI_T *spi)
N{
N  spi->CNTRL2 |= SPI_CNTRL2_SLV_ABORT_Msk;
X  spi->CNTRL2 |= (1ul << 9);
N}
N
N/**
N  * @brief  Clear the slave 3-wire mode start interrupt flag.
N  * @param  spi is the base address of SPI module.
N  * @return None
N  */
Nstatic __INLINE void SPI_CLR_3WIRE_START_INT_FLAG(SPI_T *spi)
Xstatic __inline void SPI_CLR_3WIRE_START_INT_FLAG(SPI_T *spi)
N{
N  spi->STATUS |= SPI_STATUS_SLV_START_INTSTS_Msk;
X  spi->STATUS |= (1ul << 11);
N}
N
N/**
N  * @brief  Clear the unit transfer interrupt flag.
N  * @param  spi is the base address of SPI module.
N  * @return None
N  */
Nstatic __INLINE void SPI_CLR_UNIT_TRANS_INT_FLAG(SPI_T *spi)
Xstatic __inline void SPI_CLR_UNIT_TRANS_INT_FLAG(SPI_T *spi)
N{
N  spi->STATUS |= SPI_STATUS_IF_Msk;
X  spi->STATUS |= (1ul << 16);
N}
N
N/**
N  * @brief  Disable slave 3-wire mode.
N  * @param  spi is the base address of SPI module.
N  * @return None
N  */
Nstatic __INLINE void SPI_DISABLE_3WIRE_MODE(SPI_T *spi)
Xstatic __inline void SPI_DISABLE_3WIRE_MODE(SPI_T *spi)
N{
N  spi->CNTRL2 &= ~SPI_CNTRL2_NOSLVSEL_Msk;
X  spi->CNTRL2 &= ~(1ul << 8);
N}
N
N/**
N  * @brief  Enable slave 3-wire mode.
N  * @param  spi is the base address of SPI module.
N  * @return None
N  */
Nstatic __INLINE void SPI_ENABLE_3WIRE_MODE(SPI_T *spi)
Xstatic __inline void SPI_ENABLE_3WIRE_MODE(SPI_T *spi)
N{
N  spi->CNTRL2 |= SPI_CNTRL2_NOSLVSEL_Msk;
X  spi->CNTRL2 |= (1ul << 8);
N}
N
N/**
N  * @brief  Get the count of available data in RX FIFO.
N  * @param  spi is the base address of SPI module.
N  * @return The count of available data in RX FIFO.
N  */
Nstatic __INLINE uint32_t SPI_GET_RX_FIFO_COUNT(SPI_T *spi)
Xstatic __inline uint32_t SPI_GET_RX_FIFO_COUNT(SPI_T *spi)
N{
N  return ( ((spi->STATUS & SPI_STATUS_RX_FIFO_COUNT_Msk) >> SPI_STATUS_RX_FIFO_COUNT_Pos) & 0xf );
X  return ( ((spi->STATUS & (0xFul << 12)) >> 12) & 0xf );
N}
N
N/**
N  * @brief  Get the Rx FIFO empty flag.
N  * @param  spi is the base address of SPI module.
N  * @return Rx FIFO flag
N  * @retval 0 Rx FIFO is not empty
N  * @retval 1 Rx FIFO is empty
N  */
Nstatic __INLINE uint32_t SPI_GET_RX_FIFO_EMPTY_FLAG(SPI_T *spi)
Xstatic __inline uint32_t SPI_GET_RX_FIFO_EMPTY_FLAG(SPI_T *spi)
N{
N  return ( (spi->STATUS & SPI_STATUS_RX_EMPTY_Msk) == SPI_STATUS_RX_EMPTY_Msk ? 1:0);
X  return ( (spi->STATUS & (1ul << 24)) == (1ul << 24) ? 1:0);
N}
N
N/**
N  * @brief  Get the Tx FIFO empty flag.
N  * @param  spi is the base address of SPI module.
N  * @return Tx FIFO flag
N  * @retval 0 Tx FIFO is not empty
N  * @retval 1 Tx FIFO is empty
N  */
Nstatic __INLINE uint32_t SPI_GET_TX_FIFO_EMPTY_FLAG(SPI_T *spi)
Xstatic __inline uint32_t SPI_GET_TX_FIFO_EMPTY_FLAG(SPI_T *spi)
N{
N  return ( (spi->STATUS & SPI_STATUS_TX_EMPTY_Msk) == SPI_STATUS_TX_EMPTY_Msk ? 1:0);
X  return ( (spi->STATUS & (1ul << 26)) == (1ul << 26) ? 1:0);
N}
N
N/**
N  * @brief  Get the datum read from Rx FIFO.
N  * @param  spi is the base address of SPI module.
N  * @return None
N  */
Nstatic __INLINE uint32_t SPI_READ_RX(SPI_T *spi)
Xstatic __inline uint32_t SPI_READ_RX(SPI_T *spi)
N{
N  return (spi->RX);
N}
N
N/**
N  * @brief  Write datum to TX register.
N  * @param  spi is the base address of SPI module.
N  * @param  u32TxData is the datum which user attempt to transfer through SPI bus.
N  * @return None
N  */
Nstatic __INLINE void SPI_WRITE_TX(SPI_T *spi, uint32_t u32TxData)
Xstatic __inline void SPI_WRITE_TX(SPI_T *spi, uint32_t u32TxData)
N{
N  spi->TX = u32TxData;
N}
N
N/**
N  * @brief  Disable automatic slave select function and set SPI_SS pin to high state.
N  * @param  spi is the base address of SPI module.
N  * @return None
N  */
Nstatic __INLINE void SPI_SET_SS_HIGH(SPI_T *spi)
Xstatic __inline void SPI_SET_SS_HIGH(SPI_T *spi)
N{
N  spi->SSR &= ~SPI_SSR_AUTOSS_Msk;  
X  spi->SSR &= ~(1ul << 3);  
N  spi->SSR |= SPI_SSR_LTRIG_FLAG_Msk;
X  spi->SSR |= (1ul << 5);
N  spi->SSR &= ~(SPI_SSR_SS_LVL_Msk | SPI_SSR_SSR_Msk);
X  spi->SSR &= ~((1ul << 2) | (1ul << 0));
N}
N
N/**
N  * @brief  Disable automatic slave select function and set SPI_SS pin to low state.
N  * @param  spi is the base address of SPI module.
N  * @return None
N  */
Nstatic __INLINE void SPI_SET_SS_LOW(SPI_T *spi)
Xstatic __inline void SPI_SET_SS_LOW(SPI_T *spi)
N{
N  spi->SSR &= ~SPI_SSR_AUTOSS_Msk;  
X  spi->SSR &= ~(1ul << 3);  
N  spi->SSR |= SPI_SSR_LTRIG_FLAG_Msk | SPI_SSR_SS_LVL_Msk | SPI_SSR_SSR_Msk;  
X  spi->SSR |= (1ul << 5) | (1ul << 2) | (1ul << 0);  
N}
N
N/**
N  * @brief Enable byte reorder function.
N  * @param  spi is the base address of SPI module.
N  * @return None
N  */
Nstatic __INLINE void SPI_ENABLE_BYTE_REORDER(SPI_T *spi)
Xstatic __inline void SPI_ENABLE_BYTE_REORDER(SPI_T *spi)
N{
N   spi->CNTRL |= SPI_CNTRL_REORDER_Msk;
X   spi->CNTRL |= (3ul << 19);
N}
N
N/**
N  * @brief  Disable byte reorder function.
N  * @param  spi is the base address of SPI module.
N  * @return None
N  */
Nstatic __INLINE void SPI_DISABLE_BYTE_REORDER(SPI_T *spi)
Xstatic __inline void SPI_DISABLE_BYTE_REORDER(SPI_T *spi)
N{
N   spi->CNTRL &= ~SPI_CNTRL_REORDER_Msk;
X   spi->CNTRL &= ~(3ul << 19);
N}
N
N/**
N  * @brief  Set the length of suspend interval.
N  * @param  spi is the base address of SPI module.
N  * @param  u32SuspCycle decides the length of suspend interval.
N  * @return None
N  */
Nstatic __INLINE void SPI_SET_SUSPEND_CYCLE(SPI_T *spi, uint32_t u32SuspCycle)
Xstatic __inline void SPI_SET_SUSPEND_CYCLE(SPI_T *spi, uint32_t u32SuspCycle)
N{
N   spi->CNTRL = (spi->CNTRL & ~SPI_CNTRL_SP_CYCLE_Msk) | (u32SuspCycle << SPI_CNTRL_SP_CYCLE_Pos);
X   spi->CNTRL = (spi->CNTRL & ~(0xFul << 12)) | (u32SuspCycle << 12);
N}
N
N/**
N  * @brief  Set the SPI transfer sequence with LSB first.
N  * @param  spi is the base address of SPI module.
N  * @return None
N  */
Nstatic __INLINE void SPI_SET_LSB_FIRST(SPI_T *spi)
Xstatic __inline void SPI_SET_LSB_FIRST(SPI_T *spi)
N{
N   spi->CNTRL |= SPI_CNTRL_LSB_Msk;
X   spi->CNTRL |= (1ul << 10);
N}
N
N/**
N  * @brief  Set the SPI transfer sequence with MSB first.
N  * @param  spi is the base address of SPI module.
N  * @return None
N  */
Nstatic __INLINE void SPI_SET_MSB_FIRST(SPI_T *spi)
Xstatic __inline void SPI_SET_MSB_FIRST(SPI_T *spi)
N{
N   spi->CNTRL &= ~SPI_CNTRL_LSB_Msk;
X   spi->CNTRL &= ~(1ul << 10);
N}
N
N/**
N  * @brief  Set the data width of a SPI transaction.
N  * @param  spi is the base address of SPI module.
N  * @param  u32Width is the bit width of transfer data.  
N  * @return None
N  */
Nstatic __INLINE void SPI_SET_DATA_WIDTH(SPI_T *spi, uint32_t u32Width)
Xstatic __inline void SPI_SET_DATA_WIDTH(SPI_T *spi, uint32_t u32Width)
N{
N   if(u32Width == 32)
N        u32Width = 0;
N        
N   spi->CNTRL = (spi->CNTRL & ~SPI_CNTRL_TX_BIT_LEN_Msk) | (u32Width << SPI_CNTRL_TX_BIT_LEN_Pos);
X   spi->CNTRL = (spi->CNTRL & ~(0x1Ful << 3)) | (u32Width << 3);
N}
N
N/**
N  * @brief  Get the SPI busy state.
N  * @param  spi is the base address of SPI module.
N  * @return SPI busy status
N  * @retval 0 SPI module is not busy
N  * @retval 1 SPI module is busy
N  */
Nstatic __INLINE uint32_t SPI_IS_BUSY(SPI_T *spi)
Xstatic __inline uint32_t SPI_IS_BUSY(SPI_T *spi)
N{
N  return ( (spi->CNTRL & SPI_CNTRL_GO_BUSY_Msk) == SPI_CNTRL_GO_BUSY_Msk ? 1:0);
X  return ( (spi->CNTRL & (1ul << 0)) == (1ul << 0) ? 1:0);
N}
N
N/**
N  * @brief  Set the GO_BUSY bit to trigger SPI transfer.
N  * @param  spi is the base address of SPI module.
N  * @return None
N  */
Nstatic __INLINE void SPI_TRIGGER(SPI_T *spi)
Xstatic __inline void SPI_TRIGGER(SPI_T *spi)
N{
N  spi->CNTRL |= SPI_CNTRL_GO_BUSY_Msk;
X  spi->CNTRL |= (1ul << 0);
N}
N
Nuint32_t SPI_Open(SPI_T *spi, uint32_t u32MasterSlave, uint32_t u32SPIMode, uint32_t u32DataWidth, uint32_t u32BusClock);
Nvoid SPI_Close(SPI_T *spi);
Nvoid SPI_ClearRxFIFO(SPI_T *spi);
Nvoid SPI_ClearTxFIFO(SPI_T *spi);
Nvoid SPI_DisableAutoSS(SPI_T *spi);
Nvoid SPI_EnableAutoSS(SPI_T *spi, uint32_t u32SSPinMask, uint32_t u32ActiveLevel);
Nuint32_t SPI_SetBusClock(SPI_T *spi, uint32_t u32BusClock);
Nvoid SPI_EnableFIFO(SPI_T *spi, uint32_t u32TxThreshold, uint32_t u32RxThreshold);
Nvoid SPI_DisableFIFO(SPI_T *spi);
Nuint32_t SPI_GetBusClock(SPI_T *spi);
Nvoid SPI_EnableInt(SPI_T *spi, uint32_t u32Mask);
Nvoid SPI_DisableInt(SPI_T *spi, uint32_t u32Mask);
N
N/*@}*/ /* end of group MINI51_SPI_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group MINI51_SPI_Driver */
N
N/*@}*/ /* end of group MINI51_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__SPI_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 3467 ".\CMSIS\Mini51Series.h" 2
N#include "timer.h"
L 1 ".\StdDriver\inc\timer.h" 1
N/**************************************************************************//**
N * @file     timer.h
N * @version  V1.00
N * $Revision: 6 $
N * $Date: 13/10/07 3:50p $
N * @brief    Mini51 series TIMER driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __TIMER_H__
N#define __TIMER_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup MINI51_Device_Driver MINI51 Device Driver
N  @{
N*/
N
N/** @addtogroup MINI51_TIMER_Driver TIMER Driver
N  @{
N*/
N
N/** @addtogroup MINI51_TIMER_EXPORTED_CONSTANTS TIMER Exported Constants
N  @{
N*/
N
N#define TIMER_ONESHOT_MODE                  (0UL)                           /*!< Timer working in one shot mode */
N#define TIMER_PERIODIC_MODE                 (1UL << TIMER_TCSR_MODE_Pos)    /*!< Timer working in periodic mode */
N#define TIMER_TOGGLE_MODE                   (2UL << TIMER_TCSR_MODE_Pos)    /*!< Timer working in toggle mode */
N#define TIMER_CONTINUOUS_MODE               (3UL << TIMER_TCSR_MODE_Pos)    /*!< Timer working in continuous mode */
N#define TIMER_CAPTURE_FREE_COUNTING_MODE    (0UL)                           /*!< Free counting mode */
N#define TIMER_CAPTURE_TRIGGER_COUNTING_MODE (TIMER_TEXCON_CAP_MODE_Msk)     /*!< Trigger counting mode */
N#define TIMER_CAPTURE_COUNTER_RESET_MODE    (TIMER_TEXCON_RSTCAPSEL_Msk)    /*!< Counter reset mode */
N#define TIMER_CAPTURE_FALLING_EDGE              (0UL)                               /*!< Falling edge trigger timer capture */
N#define TIMER_CAPTURE_RISING_EDGE               (1UL << TIMER_TEXCON_TEX_EDGE_Pos)  /*!< Rising edge trigger timer capture */
N#define TIMER_CAPTURE_FALLING_THEN_RISING_EDGE  (2UL << TIMER_TEXCON_TEX_EDGE_Pos)  /*!< Falling edge then rising edge trigger timer capture */
N#define TIMER_CAPTURE_RISING_THEN_FALLING_EDGE  (3UL << TIMER_TEXCON_TEX_EDGE_Pos)  /*!< Rising edge then falling edge trigger timer capture */
N#define TIMER_COUNTER_RISING_EDGE           (TIMER_TEXCON_TX_PHASE_Msk)     /*!< Counter increase on rising edge */
N#define TIMER_COUNTER_FALLING_EDGE          (0UL)                           /*!< Counter increase on falling edge */
N
N
N/*@}*/ /* end of group MINI51_TIMER_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup MINI51_TIMER_EXPORTED_FUNCTIONS TIMER Exported Functions
N  @{
N*/
N
N/**
N  * @brief This macro is used to set new Timer compared value
N  * @param[in] timer The base address of Timer module
N  * @param[in] u32Value  Timer compare value. Valid values are between 2 to 0xFFFFFF
N  * @return None
N  */
N#define TIMER_SET_CMP_VALUE(timer, u32Value) ((timer)->TCMPR = (u32Value))
N
N/**
N  * @brief This macro is used to set new Timer prescale value
N  * @param[in] timer The base address of Timer module
N  * @param[in] u32Value  Timer prescale value. Valid values are between 0 to 0xFF
N  * @return None
N  * @note Clock input is divided by (prescale + 1) before it is fed into timer
N  */
N#define TIMER_SET_PRESCALE_VALUE(timer, u32Value) ((timer)->TCSR = ((timer)->TCSR & ~TIMER_TCSR_PRESCALE_Msk) | (u32Value))
N
N/**
N  * @brief This macro is used to check if specify Timer is inactive or active
N  * @return timer is activate or inactivate
N  * @retval 0 Timer 24-bit up counter is inactive
N  * @retval 1 Timer 24-bit up counter is active
N  */
N#define TIMER_IS_ACTIVE(timer) ((timer)->TCSR & TIMER_TCSR_CACT_Msk ? 1 : 0)
N
N
N/**
N  * @brief This function is used to start Timer counting
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_Start(TIMER_T *timer)
Xstatic __inline void TIMER_Start(TIMER_T *timer)
N{
N    timer->TCSR |= TIMER_TCSR_CEN_Msk;
X    timer->TCSR |= (1ul << 30);
N}
N
N/**
N  * @brief This function is used to start Timer counting
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_Stop(TIMER_T *timer)
Xstatic __inline void TIMER_Stop(TIMER_T *timer)
N{
N    timer->TCSR &= ~TIMER_TCSR_CEN_Msk;
X    timer->TCSR &= ~(1ul << 30);
N}
N
N/**
N  * @brief This function is used to enable the Timer wake-up function
N  * @param[in] timer The base address of Timer module
N  * @return None
N  * @note  To wake the system from power down mode, timer clock source must be ether LXT or LIRC
N  */
N__STATIC_INLINE void TIMER_EnableWakeup(TIMER_T *timer)
Xstatic __inline void TIMER_EnableWakeup(TIMER_T *timer)
N{
N    timer->TCSR |= TIMER_TCSR_WAKE_EN_Msk;
X    timer->TCSR |= (1ul << 23);
N}
N
N/**
N  * @brief This function is used to disable the Timer wake-up function
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_DisableWakeup(TIMER_T *timer)
Xstatic __inline void TIMER_DisableWakeup(TIMER_T *timer)
N{
N    timer->TCSR &= ~TIMER_TCSR_WAKE_EN_Msk;
X    timer->TCSR &= ~(1ul << 23);
N}
N
N
N/**
N  * @brief This function is used to enable the capture pin detection de-bounce function.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_EnableCaptureDebounce(TIMER_T *timer)
Xstatic __inline void TIMER_EnableCaptureDebounce(TIMER_T *timer)
N{
N    timer->TEXCON |= TIMER_TEXCON_TEXDB_Msk;
X    timer->TEXCON |= (1ul << 6);
N}
N
N/**
N  * @brief This function is used to disable the capture pin detection de-bounce function.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_DisableCaptureDebounce(TIMER_T *timer)
Xstatic __inline void TIMER_DisableCaptureDebounce(TIMER_T *timer)
N{
N    timer->TEXCON &= ~TIMER_TEXCON_TEXDB_Msk;
X    timer->TEXCON &= ~(1ul << 6);
N}
N
N
N/**
N  * @brief This function is used to enable the counter pin detection de-bounce function.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_EnableEventCounterDebounce(TIMER_T *timer)
Xstatic __inline void TIMER_EnableEventCounterDebounce(TIMER_T *timer)
N{
N    timer->TEXCON |= TIMER_TEXCON_TCDB_Msk;
X    timer->TEXCON |= (1ul << 7);
N}
N
N/**
N  * @brief This function is used to disable the counter pin detection de-bounce function.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_DisableEventCounterDebounce(TIMER_T *timer)
Xstatic __inline void TIMER_DisableEventCounterDebounce(TIMER_T *timer)
N{
N    timer->TEXCON &= ~TIMER_TEXCON_TCDB_Msk;
X    timer->TEXCON &= ~(1ul << 7);
N}
N
N/**
N  * @brief This function is used to enable the Timer time-out interrupt function.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_EnableInt(TIMER_T *timer)
Xstatic __inline void TIMER_EnableInt(TIMER_T *timer)
N{
N    timer->TCSR |= TIMER_TCSR_IE_Msk;
X    timer->TCSR |= (1ul << 29);
N}
N
N/**
N  * @brief This function is used to disable the Timer time-out interrupt function.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_DisableInt(TIMER_T *timer)
Xstatic __inline void TIMER_DisableInt(TIMER_T *timer)
N{
N    timer->TCSR &= ~TIMER_TCSR_IE_Msk;
X    timer->TCSR &= ~(1ul << 29);
N}
N
N/**
N  * @brief This function is used to enable the Timer capture trigger interrupt function.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_EnableCaptureInt(TIMER_T *timer)
Xstatic __inline void TIMER_EnableCaptureInt(TIMER_T *timer)
N{
N    timer->TEXCON |= TIMER_TEXCON_TEXIEN_Msk;
X    timer->TEXCON |= (1ul << 5);
N}
N
N/**
N  * @brief This function is used to disable the Timer capture trigger interrupt function.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_DisableCaptureInt(TIMER_T *timer)
Xstatic __inline void TIMER_DisableCaptureInt(TIMER_T *timer)
N{
N    timer->TEXCON &= ~TIMER_TEXCON_TEXIEN_Msk;
X    timer->TEXCON &= ~(1ul << 5);
N}
N
N/**
N  * @brief This function indicates Timer time-out interrupt occurred or not.
N  * @param[in] timer The base address of Timer module
N  * @return Timer time-out interrupt occurred or not
N  * @retval 0 Timer time-out interrupt did not occur
N  * @retval 1 Timer time-out interrupt occurred
N  */
N__STATIC_INLINE uint32_t TIMER_GetIntFlag(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetIntFlag(TIMER_T *timer)
N{
N    return(timer->TISR & TIMER_TISR_TIF_Msk ? 1 : 0);
X    return(timer->TISR & (1ul << 0) ? 1 : 0);
N}
N
N/**
N  * @brief This function clears the Timer time-out interrupt flag.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_ClearIntFlag(TIMER_T *timer)
Xstatic __inline void TIMER_ClearIntFlag(TIMER_T *timer)
N{
N    timer->TISR = TIMER_TISR_TIF_Msk;
X    timer->TISR = (1ul << 0);
N}
N
N/**
N  * @brief This function indicates Timer capture interrupt occurred or not.
N  * @param[in] timer The base address of Timer module
N  * @return Timer capture interrupt occurred or not
N  * @retval 0 Timer capture interrupt did not occur
N  * @retval 1 Timer capture interrupt occurred
N  */
N__STATIC_INLINE uint32_t TIMER_GetCaptureIntFlag(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetCaptureIntFlag(TIMER_T *timer)
N{
N    return timer->TEXISR;
N}
N
N/**
N  * @brief This function clears the Timer capture interrupt flag.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_ClearCaptureIntFlag(TIMER_T *timer)
Xstatic __inline void TIMER_ClearCaptureIntFlag(TIMER_T *timer)
N{
N    timer->TEXISR = TIMER_TEXISR_TEXIF_Msk;
X    timer->TEXISR = (1ul << 0);
N}
N
N/**
N  * @brief This function indicates Timer has waked up system or not.
N  * @param[in] timer The base address of Timer module
N  * @return Timer has waked up system or not
N  * @retval 0 Timer did not wake up system
N  * @retval 1 Timer wake up system
N  */
N__STATIC_INLINE uint32_t TIMER_GetWakeupFlag(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetWakeupFlag(TIMER_T *timer)
N{
N    return (timer->TISR & TIMER_TISR_TWF_Msk ? 1 : 0);
X    return (timer->TISR & (1ul << 1) ? 1 : 0);
N}
N
N/**
N  * @brief This function clears the Timer capture interrupt flag.
N  * @param[in] timer The base address of Timer module
N  * @return None
N  */
N__STATIC_INLINE void TIMER_ClearWakeupFlag(TIMER_T *timer)
Xstatic __inline void TIMER_ClearWakeupFlag(TIMER_T *timer)
N{
N    timer->TISR = TIMER_TISR_TWF_Msk;
X    timer->TISR = (1ul << 1);
N}
N
N/**
N  * @brief This function clears the Timer wake-up system flag.
N  * @param[in] timer The base address of Timer module
N  * @return Timer capture data value
N  */
N__STATIC_INLINE uint32_t TIMER_GetCaptureData(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetCaptureData(TIMER_T *timer)
N{
N    return timer->TCAP;
N}
N
N/**
N  * @brief This function reports the current timer counter value.
N  * @param[in] timer The base address of Timer module
N  * @return Timer counter value
N  */
N__STATIC_INLINE uint32_t TIMER_GetCounter(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetCounter(TIMER_T *timer)
N{
N    return timer->TDR;
N}
N
Nuint32_t TIMER_Open(TIMER_T *timer, uint32_t u32Mode, uint32_t u32Freq);
Nvoid TIMER_Close(TIMER_T *timer);
Nvoid TIMER_Delay(TIMER_T *timer, uint32_t u32Usec);
Nvoid TIMER_EnableCapture(TIMER_T *timer, uint32_t u32CapMode, uint32_t u32Edge);
Nvoid TIMER_DisableCapture(TIMER_T *timer);
Nvoid TIMER_EnableEventCounter(TIMER_T *timer, uint32_t u32Edge);
Nvoid TIMER_DisableEventCounter(TIMER_T *timer);
Nuint32_t TIMER_GetModuleClock(TIMER_T *timer);
N
N
N/*@}*/ /* end of group MINI51_TIMER_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group MINI51_TIMER_Driver */
N
N/*@}*/ /* end of group MINI51_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__TIMER_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 3468 ".\CMSIS\Mini51Series.h" 2
N#include "uart.h"
L 1 ".\StdDriver\inc\uart.h" 1
N/**************************************************************************//**
N * @file     UART.h
N * @version  V1.00
N * $Revision: 10 $
N * $Date: 13/09/30 6:48p $ 
N * @brief    Mini51 series UART driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/ 
N#ifndef __UART_H__
N#define __UART_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup MINI51_Device_Driver MINI51 Device Driver
N  @{
N*/
N
N/** @addtogroup MINI51_UART_Driver UART Driver
N  @{
N*/
N
N/** @addtogroup MINI51_UART_EXPORTED_CONSTANTS UART Exported Constants
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UA_FCR constants definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N
N#define UART_FCR_RFITL_1BYTE        (0x0 << UART_FCR_RFITL_Pos)   /*!< UA_FCR setting to set RX FIFO Trigger Level to 1 bit */
N#define UART_FCR_RFITL_4BYTES       (0x1 << UART_FCR_RFITL_Pos)   /*!< UA_FCR setting to set RX FIFO Trigger Level to 4 bits */
N#define UART_FCR_RFITL_8BYTES       (0x2 << UART_FCR_RFITL_Pos)   /*!< UA_FCR setting to set RX FIFO Trigger Level to 8 bits */
N#define UART_FCR_RFITL_14BYTES      (0x3 << UART_FCR_RFITL_Pos)   /*!< UA_FCR setting to set RX FIFO Trigger Level to 14 bits */
N
N#define UART_FCR_RTS_TRI_LEV_1BYTE        (0x0 << UART_FCR_RTS_TRI_LEV_Pos)  /*!< UA_FCR setting to set RTS Trigger Level to 1 bit */
N#define UART_FCR_RTS_TRI_LEV_4BYTES       (0x1 << UART_FCR_RTS_TRI_LEV_Pos)  /*!< UA_FCR setting to set RTS Trigger Level to 4 bits */
N#define UART_FCR_RTS_TRI_LEV_8BYTES       (0x2 << UART_FCR_RTS_TRI_LEV_Pos)  /*!< UA_FCR setting to set RTS Trigger Level to 8 bits */
N#define UART_FCR_RTS_TRI_LEV_14BYTES      (0x3 << UART_FCR_RTS_TRI_LEV_Pos)  /*!< UA_FCR setting to set RTS Trigger Level to 14 bits */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UA_LCR constants definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_WORD_LEN_5        (0) /*!< UA_LCR setting to set UART word length to 5 bits */
N#define UART_WORD_LEN_6        (1) /*!< UA_LCR setting to set UART word length to 6 bits */
N#define UART_WORD_LEN_7        (2) /*!< UA_LCR setting to set UART word length to 7 bits */
N#define UART_WORD_LEN_8        (3) /*!< UA_LCR setting to set UART word length to 8 bits */
N
N#define UART_PARITY_NONE    (0x0 << UART_LCR_PBE_Pos) /*!< UA_LCR setting to set UART as no parity   */
N#define UART_PARITY_ODD     (0x1 << UART_LCR_PBE_Pos) /*!< UA_LCR setting to set UART as odd parity  */
N#define UART_PARITY_EVEN    (0x3 << UART_LCR_PBE_Pos) /*!< UA_LCR setting to set UART as even parity */
N#define UART_PARITY_MARK    (0x5 << UART_LCR_PBE_Pos) /*!< UA_LCR setting to keep parity bit as '1'  */
N#define UART_PARITY_SPACE   (0x7 << UART_LCR_PBE_Pos) /*!< UA_LCR setting to keep parity bit as '0'  */
N
N#define UART_STOP_BIT_1     (0x0 << UART_LCR_NSB_Pos) /*!< UA_LCR setting for one stop bit  */
N#define UART_STOP_BIT_1_5   (0x1 << UART_LCR_NSB_Pos) /*!< UA_LCR setting for 1.5 stop bit when 5-bit word length  */
N#define UART_STOP_BIT_2     (0x1 << UART_LCR_NSB_Pos) /*!< UA_LCR setting for two stop bit when 6, 7, 8-bit word length */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART RTS LEVEL TRIGGER constants definitions                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_RTS_IS_HIGH_LEV_TRG    (0x1 << UART_MCR_LEV_RTS_Pos) /*!< Set RTS is High Level Tigger   */
N#define UART_RTS_IS_LOW_LEV_TRG     (0x0 << UART_MCR_LEV_RTS_Pos) /*!< Set RTS is Low Level Tigger    */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UA_FUNC_SEL constants definitions                                                                       */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_FUNC_SEL_UART    (0x0 << UART_FUN_SEL_FUN_SEL_Pos) /*!< UA_FUNC_SEL setting to set UART Function  (Default) */
N#define UART_FUNC_SEL_IrDA    (0x2 << UART_FUN_SEL_FUN_SEL_Pos) /*!< UA_FUNC_SEL setting to set IrDA Function            */
N#define UART_FUNC_SEL_RS485   (0x3 << UART_FUN_SEL_FUN_SEL_Pos) /*!< UA_FUNC_SEL setting to set RS485 Function           */
N
N
N/*@}*/ /* end of group MINI51_UART_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup MINI51_UART_EXPORTED_FUNCTIONS UART Exported Functions
N  @{
N*/
N
N/**
N *    @brief    Calculate UART baudrate mode0 divider
N *
N *    @param    None
N *    
N *    @return    UART baudrate mode0 register setting value
N *    
N */
N#define UART_BAUD_MODE0        (0)
N
N/**
N *    @brief    Calculate UART baudrate mode0 divider
N *
N *    @param    None
N *    
N *    @return    UART baudrate mode2 register setting value
N *    
N */
N#define UART_BAUD_MODE2        (UART_BAUD_DIV_X_EN_Msk | UART_BAUD_DIV_X_ONE_Msk)
N
N
N/**
N *    @brief    Calculate UART baudrate mode0 divider
N *
N *    @param    u32SrcFreq      UART clock frequency
N *    @param    u32BaudRate     Baudrate of UART module
N *    
N *    @return    UART baudrate mode0 divider
N *    
N */
N#define UART_BAUD_MODE0_DIVIDER(u32SrcFreq, u32BaudRate)    (((u32SrcFreq + (u32BaudRate*8)) / u32BaudRate >> 4)-2)
N
N/**
N *    @brief    Calculate UART baudrate mode2 divider
N *
N *    @param    u32SrcFreq    UART clock frequency
N *    @param    u32BaudRate    Baudrate of UART module
N *    
N *    @return    UART baudrate mode2 divider  
N */
N#define UART_BAUD_MODE2_DIVIDER(u32SrcFreq, u32BaudRate)    (((u32SrcFreq + (u32BaudRate/2)) / u32BaudRate)-2)     
N
N
N/**
N *    @brief    Write Data to Tx data register
N *
N *    @param    uart        The base address of UART module.
N *    @param    u8Data  Data byte to transmit 
N *                          
N *    @return    None
N */
N#define UART_WRITE(uart, u8Data)    (uart->THR = (u8Data))
N
N/**
N *    @brief    Read Rx data register
N *
N *    @param    uart        The base address of UART module. 
N *
N *    @return    The oldest data byte in RX FIFO 
N */
N#define UART_READ(uart)    (uart->RBR)
N
N
N/**
N *    @brief    Get Tx empty register value. 
N *
N *    @param    uart        The base address of UART module  
N *
N *    @return    Tx empty register value. 
N */
N#define UART_GET_TX_EMPTY(uart)    (uart->FSR & UART_FSR_TX_EMPTY_Msk) 
N
N
N/**
N *    @brief    Get Rx empty register value. 
N *
N *    @param    uart        The base address of UART module 
N * 
N *    @return    Rx empty register value.
N */
N#define UART_GET_RX_EMPTY(uart)    (uart->FSR & UART_FSR_RX_EMPTY_Msk) 
N
N/**
N *    @brief    Check specified uart port transmission is over. 
N *
N *    @param    uart        The base address of UART module 
N * 
N *    @return    TE_Flag.
N */
N#define UART_IS_TX_EMPTY(uart)    ((uart->FSR & UART_FSR_TE_FLAG_Msk) >> UART_FSR_TE_FLAG_Pos) 
N
N
N/**
N *    @brief    Wait specified uart port transmission is over 
N *
N *    @param    uart        The base address of UART module 
N *
N *    @return    None 
N */
N#define UART_WAIT_TX_EMPTY(uart)    while(!(((uart->FSR) & UART_FSR_TE_FLAG_Msk) >> UART_FSR_TE_FLAG_Pos))
N                                     
N/**
N *    @brief    Check RDA_IF is set or not
N *
N *    @param    uart        The base address of UART module 
N *
N *    @return     
N *            0 : The number of bytes in the RX FIFO is less than the RFITL  
N *            1 : The number of bytes in the RX FIFO equals or larger than RFITL
N */
N#define UART_IS_RX_READY(uart)    ((uart->ISR & UART_ISR_RDA_IF_Msk)>>UART_ISR_RDA_IF_Pos)
N
N
N/**
N *    @brief    Check TX FIFO is full or not 
N *
N *    @param    uart        The base address of UART module 
N *
N *    @return     
N *            1 = TX FIFO is full
N *            0 = TX FIFO is not full
N */
N#define UART_IS_TX_FULL(uart)    ((uart->FSR & UART_FSR_TX_FULL_Msk)>>UART_FSR_TX_FULL_Pos)
N
N/**
N *    @brief    Check RX FIFO is full or not 
N *
N *    @param    uart        The base address of UART module  
N *
N *    @return
N *            1 = RX FIFO is full
N *            0 = RX FIFO is not full
N *
N */
N#define UART_IS_RX_FULL(uart)    ((uart->FSR & UART_FSR_RX_FULL_Msk)>>UART_FSR_RX_FULL_Pos)
N
N
N/**
N *    @brief    Get Tx full register value 
N *
N *    @param    uart        The base address of UART module 
N *
N *    @return    Tx full register value 
N */
N#define UART_GET_TX_FULL(uart)    (uart->FSR & UART_FSR_TX_FULL_Msk)
N
N
N/**
N *    @brief    Get Rx full register value 
N *
N *    @param    uart        The base address of UART module 
N *
N *    @return    Rx full register value 
N */
N#define UART_GET_RX_FULL(uart)    (uart->FSR & UART_FSR_RX_FULL_Msk)
N
N
N/**
N *    @brief    Enable specified interrupt
N *
N *    @param    uart        The base address of UART module  
N *    @param    u32eIntSel    Interrupt type select 
N *                        - UART_IER_TIME_OUT_EN_Msk    : Rx Time Out interrupt
N *                        - UART_IER_WAKE_EN_Msk        : Wakeup interrupt
N *                        - UART_IER_BUF_ERR_IEN_Msk    : Buffur Error interrupt   
N *                        - UART_IER_RTO_IEN_Msk        : Rx time-out interrupt       
N *                        - UART_IER_MODEM_IEN_Msk    : Modem interrupt           
N *                        - UART_IER_RLS_IEN_Msk        : Rx Line status interrupt                              
N *                        - UART_IER_THRE_IEN_Msk        : Tx empty interrupt          
N *                        - UART_IER_RDA_IEN_Msk        : Rx ready interrupt           
N *
N *    @return    None                                                    
N */
N#define UART_ENABLE_INT(uart, u32eIntSel)    (uart->IER |= (u32eIntSel))
N
N
N/**
N *    @brief    Disable specified interrupt  
N *
N *    @param    uart        The base address of UART module 
N *    @param    u32eIntSel    Interrupt type select 
N *                        - UART_IER_TIME_OUT_EN_Msk    : Rx Time Out interrupt
N *                        - UART_IER_WAKE_EN_Msk           : Wakeup interrupt
N *                        - UART_IER_BUF_ERR_IEN_Msk    : Buffur Error interrupt   
N *                        - UART_IER_RTO_IEN_Msk         : Rx time-out interrupt       
N *                        - UART_IER_MODEM_IEN_Msk       : Modem interrupt           
N *                        - UART_IER_RLS_IEN_Msk         : Rx Line status interrupt                              
N *                        - UART_IER_THRE_IEN_Msk        : Tx empty interrupt          
N *                        - UART_IER_RDA_IEN_Msk         : Rx ready interrupt          
N *    @return    None                                                    
N */
N#define UART_DISABLE_INT(uart, u32eIntSel)    (uart->IER &= ~ (u32eIntSel))
N
N
N/**
N *    @brief    Get specified interrupt flag/status
N *
N *    @param    uart            The base address of UART module 
N *    @param    u32eIntTypeFlag    Interrupt Type Flag,should be   
N *                            - UART_IER_TIME_OUT_EN_Msk    : Rx Time Out interrupt
N *                            - UART_IER_WAKE_EN_Msk           : Wakeup interrupt
N *                            - UART_IER_BUF_ERR_IEN_Msk    : Buffur Error interrupt   
N *                            - UART_IER_RTO_IEN_Msk         : Rx time-out interrupt       
N *                            - UART_IER_MODEM_IEN_Msk       : Modem interrupt           
N *                            - UART_IER_RLS_IEN_Msk         : Rx Line status interrupt                              
N *                            - UART_IER_THRE_IEN_Msk        : Tx empty interrupt          
N *                            - UART_IER_RDA_IEN_Msk         : Rx ready interrupt      
N *
N *    @return
N *            0 = The specified interrupt is not happened. 
N *            1 = The specified interrupt is happened.                                                      
N */                                                                                      
N#define UART_GET_INT_FLAG(uart,u32eIntTypeFlag)    ((uart->ISR & (u32eIntTypeFlag))?1:0)
N
N
N/**
N *    @brief    Set RTS pin is low
N *
N *    @param    uart        The base address of UART module 
N *    @return    None
N */ 
N__INLINE void UART_CLEAR_RTS(UART_T* uart)  
X__inline void UART_CLEAR_RTS(UART_T* uart)  
N{
N    uart->MCR |= UART_MCR_LEV_RTS_Msk;
X    uart->MCR |= (1ul << 9);
N    uart->MCR &= UART_MCR_RTS_Msk;
X    uart->MCR &= (1ul << 1);
N}
N
N/**
N *    @brief    Set RTS pin is high
N *
N *    @param    uart        The base address of UART module 
N *    @return    None
N */ 
N__INLINE void UART_SET_RTS(UART_T* uart)
X__inline void UART_SET_RTS(UART_T* uart)
N{
N    uart->MCR |= UART_MCR_LEV_RTS_Msk | UART_MCR_RTS_Msk;
X    uart->MCR |= (1ul << 9) | (1ul << 1);
N}
N
N/**
N *	@brief	Clear RS-485 Address Byte Detection Flag
N *
N *	@param	uart	The base address of UART module 
N *	@return	None
N */                                                                                                                                 
N#define UART_RS485_CLEAR_ADDR_FLAG(uart)    (uart->FSR  |= UART_FSR_RS485_ADD_DETF_Msk)
N
N
N/**
N *    @brief    Get RS-485 Address Byte Detection Flag
N *
N *    @param    uart        The base address of UART module 
N *    @return    RS-485 Address Byte Detection Flag
N */    
N#define UART_RS485_GET_ADDR_FLAG(uart)    ((uart->FSR  & UART_FSR_RS485_ADD_DETF_Msk) >> UART_FSR_RS485_ADD_DETF_Pos)
N
N
Nvoid UART_ClearIntFlag(UART_T* uart , uint32_t u32InterruptFlag);
Nvoid UART_Close(UART_T* uart );
Nvoid UART_DisableFlowCtrl(UART_T* uart );
Nvoid UART_DisableInt(UART_T*  uart, uint32_t u32InterruptFlag );
Nvoid UART_EnableFlowCtrl(UART_T* uart );
Nvoid UART_EnableInt(UART_T*  uart, uint32_t u32InterruptFlag );
Nvoid UART_Open(UART_T* uart, uint32_t u32baudrate);
Nint32_t UART_ReadBytes(UART_T* uart, uint8_t *pu8RxBuf, uint32_t u32ReadBytes);
Nvoid UART_SetLine_Config(UART_T* uart, uint32_t u32baudrate, uint32_t u32data_width, uint32_t u32parity, uint32_t  u32stop_bits);
Nvoid UART_SetTimeoutCnt(UART_T* uart, uint32_t u32TOC);
Nvoid UART_SelectIrDAMode(UART_T* uart, uint32_t u32Buadrate, uint32_t u32Direction);
Nvoid UART_SelectRS485Mode(UART_T* uart, uint32_t u32Mode, uint32_t u32Addr);
Nuint32_t UART_WriteBytes(UART_T* uart,uint8_t *pu8TxBuf, uint32_t u32WriteBytes);
N
N
N/*@}*/ /* end of group MINI51_UART_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group MINI51_UART_Driver */
N
N/*@}*/ /* end of group MINI51_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__UART_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
N
N
N
N
N
N
N
N
L 3469 ".\CMSIS\Mini51Series.h" 2
N#include "wdt.h"
L 1 ".\StdDriver\inc\wdt.h" 1
N/**************************************************************************//**
N * @file     wdt.h
N * @version  V1.00
N * $Revision: 5 $
N * $Date: 13/10/05 1:30p $ 
N * @brief    Mini51 series WDT driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/ 
N#ifndef __WDT_H__
N#define __WDT_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup MINI51_Device_Driver MINI51 Device Driver
N  @{
N*/
N
N/** @addtogroup MINI51_WDT_Driver WDT Driver
N  @{
N*/
N
N/** @addtogroup MINI51_WDT_EXPORTED_CONSTANTS WDT Exported Constants
N  @{
N*/
N#define WDT_TIMEOUT_2POW4          (0UL << WDT_WTCR_WTIS_Pos) /*!< WDT setting for timeout interval = 2^4 * WDT clocks */
N#define WDT_TIMEOUT_2POW6          (1UL << WDT_WTCR_WTIS_Pos) /*!< WDT setting for timeout interval = 2^6 * WDT clocks */
N#define WDT_TIMEOUT_2POW8          (2UL << WDT_WTCR_WTIS_Pos) /*!< WDT setting for timeout interval = 2^8 * WDT clocks */
N#define WDT_TIMEOUT_2POW10         (3UL << WDT_WTCR_WTIS_Pos) /*!< WDT setting for timeout interval = 2^10 * WDT clocks */
N#define WDT_TIMEOUT_2POW12         (4UL << WDT_WTCR_WTIS_Pos) /*!< WDT setting for timeout interval = 2^12 * WDT clocks */
N#define WDT_TIMEOUT_2POW14         (5UL << WDT_WTCR_WTIS_Pos) /*!< WDT setting for timeout interval = 2^14 * WDT clocks */
N#define WDT_TIMEOUT_2POW16         (6UL << WDT_WTCR_WTIS_Pos) /*!< WDT setting for timeout interval = 2^16 * WDT clocks */
N#define WDT_TIMEOUT_2POW18         (7UL << WDT_WTCR_WTIS_Pos) /*!< WDT setting for timeout interval = 2^18 * WDT clocks */
N
N/*@}*/ /* end of group MINI51_WDT_EXPORTED_CONSTANTS */
N    
N    
N/** @addtogroup MINI51_WDT_EXPORTED_FUNCTIONS WDT Exported Functions
N  @{
N*/
N
N/** 
N  *  @brief This macro clear WDT time-out reset system flag. 
N  */
N#define WDT_CLEAR_RESET_FLAG()  (WDT->WTCR = (WDT->WTCR & ~(WDT_WTCR_WTIF_Msk | WDT_WTCR_WTWKF_Msk)) | WDT_WTCR_WTRF_Msk)
N
N/** 
N  * @brief This macro clear WDT time-out interupt flag. 
N  */
N#define WDT_CLEAR_TIMEOUT_INT_FLAG() (WDT->WTCR = (WDT->WTCR & ~(WDT_WTCR_WTRF_Msk | WDT_WTCR_WTWKF_Msk)) | WDT_WTCR_WTIF_Msk)
N
N/** @brief This macro clear WDT time-out wake-up system flag. */
N#define WDT_CLEAR_TIMEOUT_WAKEUP_FLAG() (WDT->WTCR = (WDT->WTCR & ~(WDT_WTCR_WTRF_Msk | WDT_WTCR_WTIF_Msk)) | WDT_WTCR_WTWKF_Msk)
N
N/** 
N  * @brief This macro indicate WDT time-out to reset system or not.
N  * @return WDT reset system or not
N  * @retval 0 WDT did not cause system reset
N  * @retval 1 WDT caused system reset 
N  */
N#define WDT_GET_RESET_FLAG() (WDT->WTCR & WDT_WTCR_WTRF_Msk ? 1 : 0)
N
N/** 
N  * @brief This macro indicate WDT time-out interrupt occurred or not.
N  * @return WDT time-out interrupt occurred or not
N  * @retval 0 WDT time-out interrupt did not occurr
N  * @retval 1 WDT time-out interrupt occurred 
N  */
N#define WDT_GET_TIMEOUT_INT_FLAG() (WDT->WTCR & WDT_WTCR_WTIF_Msk ? 1 : 0)
N
N/** 
N  * @brief This macro indicate WDT time-out waked system up or not
N  * @return WDT time-out waked system up or not
N  * @retval 0 WDT did not wake up system
N  * @retval 1 WDT waked up system
N  */
N#define WDT_GET_TIMEOUT_WAKEUP_FLAG() (WDT->WTCR & WDT_WTCR_WTWKF_Msk ? 1 : 0)
N
N/** 
N  * @brief This macro is used to reset 18-bit WDT counter.
N  * @details If WDT is activated and enabled to reset system, software must reset WDT counter 
N  *  before WDT time-out plus reset delay reached. Or WDT generate a reset signal.
N  */
N#define WDT_RESET_COUNTER() (WDT->WTCR  = (WDT->WTCR & ~(WDT_WTCR_WTIF_Msk | WDT_WTCR_WTWKF_Msk | WDT_WTCR_WTRF_Msk)) | WDT_WTCR_WTR_Msk)
N
N
Nvoid  WDT_Open(uint32_t u32TimeoutInterval,
N                  uint32_t u32ResetDelay,
N                  uint32_t u32EnableReset,
N                  uint32_t u32EnableWakeup);  
Nvoid WDT_Close(void);
N
Nvoid WDT_EnableInt(void);
Nvoid WDT_DisableInt(void);
N
N/*@}*/ /* end of group MINI51_WDT_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group MINI51_WDT_Driver */
N
N/*@}*/ /* end of group MINI51_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__WDT_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 3470 ".\CMSIS\Mini51Series.h" 2
N
N#endif  // __MINI51SERIES_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 5 "User\global.h" 2
N
N#define WHAT_EVER_DO_NOT_CARE		1
N
N#define DEBUG_ACMP_OUT_PORT			P3
N#define DEBUG_ACMP_OUT_PIN			BIT6
N#define DEBUG_GPIO_PORT					P5
N#define DEBUG_GPIO_PIN					BIT0
N#define DEBUG_TX_PORT						P0
N#define DEBUG_TX_PIN						BIT0
N#define DEBUG_RX_PORT						P1
N#define DEBUG_RX_PIN						BIT2
N
N#define TIMER_INVALID_CNT 		0xFFFFFFFF
N#define BIT_MASK							0x00000001
N
N//#define unSystemTick 				SysTick->VAL
N
N#define SET           			(1)     
N#define RESET          			(0)      
N
N#define INDEX_INCREASE(INDEX, MAX)	((INDEX) = (((INDEX) < ((MAX) - 1)) ? ((INDEX) + 1) : 0))
N
Nextern __IO uint32_t unSystemTick;
Xextern volatile uint32_t unSystemTick;
N
Ntypedef struct
N{
N	struct
N	{
N		__IO uint16_t bMotorNeedToRun:1;
X		volatile uint16_t bMotorNeedToRun:1;
N		__IO uint16_t bRotateDirection:1;
X		volatile uint16_t bRotateDirection:1;
N	}MCR;
N	struct
N	{
N		__IO uint16_t bMotorPowerOn:1;
X		volatile uint16_t bMotorPowerOn:1;
N		__IO uint16_t bZeroCrossDetecting:1;
X		volatile uint16_t bZeroCrossDetecting:1;
N		__IO uint16_t bLocked:1;
X		volatile uint16_t bLocked:1;
N		__IO uint16_t bThisPhaseDetectedZX:1;
X		volatile uint16_t bThisPhaseDetectedZX:1;
N		__IO uint16_t bNewComFrameReceived:1;
X		volatile uint16_t bNewComFrameReceived:1;
N	}MSR;
N	__IO uint16_t	unMissedZXD_CNT;
X	volatile uint16_t	unMissedZXD_CNT;
N	__IO uint16_t	unSuccessZXD_CNT;
X	volatile uint16_t	unSuccessZXD_CNT;
N	__IO uint16_t unLocatingDuty;		/*!<  PWM Locating Duty  */
X	volatile uint16_t unLocatingDuty;		 
N	__IO uint16_t unRampUpDuty;			/*!<  PWM Ramp Up Start Duty  */
X	volatile uint16_t unRampUpDuty;			 
N	__IO uint16_t unTargetDuty;			/*!<  PWM Target (Locked State) Duty  */
X	volatile uint16_t unTargetDuty;			 
N	__IO uint16_t unActualDuty;			/*!<  PWM Actual Duty  */
X	volatile uint16_t unActualDuty;			 
N	__IO uint16_t unLocatingPeriod;	/*!<  Locating State One Phase Period  */
X	volatile uint16_t unLocatingPeriod;	 
N	__IO uint16_t unRESERVE_1;				/*!<  for 4 bytes align */
X	volatile uint16_t unRESERVE_1;				 
N	__IO uint32_t unRampUpPeriod;		/*!<  Ramp Up Start One Phase Period  */
X	volatile uint32_t unRampUpPeriod;		 
N	__IO uint32_t unActualPeriod;		/*!<  Actual One Phase Period  */
X	volatile uint32_t unActualPeriod;		 
N	__IO uint32_t unPhaseChangeCNT;	/*!<  Phase changed counter  */
X	volatile uint32_t unPhaseChangeCNT;	 
N	__IO uint16_t unRPM;							/*!<  Actual RPM  */
X	volatile uint16_t unRPM;							 
N	__IO uint16_t unBattery;					/*!<  Battery Voltage  */
X	volatile uint16_t unBattery;					 
N	__IO uint16_t unCurrent;					/*!<  Current  */
X	volatile uint16_t unCurrent;					 
N	__IO uint16_t unRESERVE_2;				/*!<  for 4 bytes align */
X	volatile uint16_t unRESERVE_2;				 
N} MOTOR_T;
N
Ntypedef union
N{
N	uint16_t unValue[sizeof(MOTOR_T)/sizeof(uint16_t)];
N	MOTOR_T structMotor;
N} MOTOR_UNION_T;
N
N
N#include "BLDCSensorLess.h"
L 1 "User\BLDCSensorLess.h" 1
N#ifndef __BLDC_SENSOR_LESS_H__
N#define __BLDC_SENSOR_LESS_H__
N
N#include "global.h"
L 1 "User\global.h" 1
N#ifndef __GLOBAL_H__
S#define __GLOBAL_H__
S
S#include "Mini51Series.h"
S
S#define WHAT_EVER_DO_NOT_CARE		1
S
S#define DEBUG_ACMP_OUT_PORT			P3
S#define DEBUG_ACMP_OUT_PIN			BIT6
S#define DEBUG_GPIO_PORT					P5
S#define DEBUG_GPIO_PIN					BIT0
S#define DEBUG_TX_PORT						P0
S#define DEBUG_TX_PIN						BIT0
S#define DEBUG_RX_PORT						P1
S#define DEBUG_RX_PIN						BIT2
S
S#define TIMER_INVALID_CNT 		0xFFFFFFFF
S#define BIT_MASK							0x00000001
S
S//#define unSystemTick 				SysTick->VAL
S
S#define SET           			(1)     
S#define RESET          			(0)      
S
S#define INDEX_INCREASE(INDEX, MAX)	((INDEX) = (((INDEX) < ((MAX) - 1)) ? ((INDEX) + 1) : 0))
S
Sextern __IO uint32_t unSystemTick;
S
Stypedef struct
S{
S	struct
S	{
S		__IO uint16_t bMotorNeedToRun:1;
S		__IO uint16_t bRotateDirection:1;
S	}MCR;
S	struct
S	{
S		__IO uint16_t bMotorPowerOn:1;
S		__IO uint16_t bZeroCrossDetecting:1;
S		__IO uint16_t bLocked:1;
S		__IO uint16_t bThisPhaseDetectedZX:1;
S		__IO uint16_t bNewComFrameReceived:1;
S	}MSR;
S	__IO uint16_t	unMissedZXD_CNT;
S	__IO uint16_t	unSuccessZXD_CNT;
S	__IO uint16_t unLocatingDuty;		/*!<  PWM Locating Duty  */
S	__IO uint16_t unRampUpDuty;			/*!<  PWM Ramp Up Start Duty  */
S	__IO uint16_t unTargetDuty;			/*!<  PWM Target (Locked State) Duty  */
S	__IO uint16_t unActualDuty;			/*!<  PWM Actual Duty  */
S	__IO uint16_t unLocatingPeriod;	/*!<  Locating State One Phase Period  */
S	__IO uint16_t unRESERVE_1;				/*!<  for 4 bytes align */
S	__IO uint32_t unRampUpPeriod;		/*!<  Ramp Up Start One Phase Period  */
S	__IO uint32_t unActualPeriod;		/*!<  Actual One Phase Period  */
S	__IO uint32_t unPhaseChangeCNT;	/*!<  Phase changed counter  */
S	__IO uint16_t unRPM;							/*!<  Actual RPM  */
S	__IO uint16_t unBattery;					/*!<  Battery Voltage  */
S	__IO uint16_t unCurrent;					/*!<  Current  */
S	__IO uint16_t unRESERVE_2;				/*!<  for 4 bytes align */
S} MOTOR_T;
S
Stypedef union
S{
S	uint16_t unValue[sizeof(MOTOR_T)/sizeof(uint16_t)];
S	MOTOR_T structMotor;
S} MOTOR_UNION_T;
S
S
S#include "BLDCSensorLess.h"
S#include "Communication.h"
S#include "Error.h"
S#include "Protection.h"
N#endif 
L 5 "User\BLDCSensorLess.h" 2
N
Ntypedef enum {
N	ENUM_TIM1_AVOID_ZXD = 0,
N	ENUM_TIM1_ZXD_FILTER//,
N//		ENUM_TIM1_START_ZXD
N}ENUM_TIM1_USAGE;
N
N// GPIOs
N#define BRG_FAULT_PORT				P3
N#define BRG_FAULT_PIN_NUM			2
N#define BRG_FAULT_PIN				BIT2
N#define BRG_EN_PORT					P3
N#define BRG_EN_PIN					BIT0
N#define BRG_ENABLE					(P30 = 1)
N#define BRG_DISABLE					(P30 = 0)
N
N//	#define ACMP0_FALLING_ENABLE		(ACMP->CMPCR[0] = ACMP_CMPCR_FALLING_Msk | ACMP_CMPCR_HYSEN_Msk | ACMP_CMPCR_ACMPIE_Msk | ACMP_CMPCR_ACMPEN_Msk)
N//	#define ACMP0_RISING_ENABLE			(ACMP->CMPCR[0] = ACMP_CMPCR_RISING_Msk | ACMP_CMPCR_HYSEN_Msk | ACMP_CMPCR_ACMPIE_Msk | ACMP_CMPCR_ACMPEN_Msk)
N//	#define ACMP0_EDGE_SELECT			((PWM->PHCHG & DETEC_UP) ? (ACMP_CMPCR_RISING_Msk) : (ACMP_CMPCR_FALLING_Msk))
N#define DETEC_UP_POS				7
N#define DETEC_UP					(1ul << DETEC_UP_POS)
N#define ACMP0_EDGE_MATCH			(((PWM->PHCHG & DETEC_UP) >> DETEC_UP_POS) == (( ACMP->CMPSR & ACMP_CMPSR_ACMPCO0_Msk) >> ACMP_CMPSR_ACMPCO0_Pos))
N#define ACMP0_ENABLE				(ACMP->CMPCR[0] |= ACMP_CMPCR_HYSEN_Msk | ACMP_CMPCR_ACMPEN_Msk)
N#define ACMP0_INT_ENABLE			(ACMP->CMPCR[0] |= ACMP_CMPCR_ACMPIE_Msk)
N#define ACMP0_INT_DISABLE			(ACMP->CMPCR[0] &= (~ACMP_CMPCR_ACMPIE_Msk))
N#define AVOID_ZXD_AFTER_PHCHG		160	// 160/2M = 80us
N#define ZXD_FILTER_TIME				200	// 200/2M = 100us
N#define CALC_TIME_BT_ZXD_SET_TIM	60	// calculation time between after confirmed ZX and set TIMER0
N#define TIME_DEBT					(ZXD_FILTER_TIME + CALC_TIME_BT_ZXD_SET_TIM)	// Included ZXD filter time and calculation time between after confirmed ZX and set TIMER0
N#define ZXD_BEFORE_PHCHG			50	// 50/2M = 25us	// If it already need change phase when ZX was confirmed ZX, give some time to TIM0 to response
N#define ACMP_HYS_AVG_TIME			20	// Average Hysteresis time 20/2M = 10us
N#define MIN_PHASE_TIME				500	//(AVOID_ZXD_AFTER_PHCHG + ZXD_FILTER_TIME + 100)	// 1200/2M=0.6ms, 8333RPM if 42PC=1MC==7EC
N#define MAX_PHASE_TIME				(10000)	// Unit 2MH, 5ms, 286rpm if 42PC=1MC==7EC
N
N#define MINI51_TIM_CNT_MAX						0xFFFFFF
N#define GET_TIM1_CMP_VALUE(x)					(((x) >= MINI51_TIM_CNT_MAX) ? ((x) - MINI51_TIM_CNT_MAX) : (x))
N#define GET_TIMER_DIFF(iLast, iThis)	(((iThis) > (iLast)) ? ((iThis) - (iLast)) : ((iThis) + (MINI51_TIM_CNT_MAX - (iLast))))
N#define MAX_MISS_ZXD_THRESHOLD				12
N#define MIN_SUCC_ZXD_THRESHOLD				4
N
N#define MOSFET_DRV_0_4_PORT		P2
N#define MOSFET_DRV_5_PORT			P0
N#define MOSFET_DRV_0_PIN			BIT2
N#define MOSFET_DRV_1_PIN			BIT3
N#define MOSFET_DRV_2_PIN			BIT4
N#define MOSFET_DRV_3_PIN			BIT5
N#define MOSFET_DRV_4_PIN			BIT6
N#define MOSFET_DRV_5_PIN			BIT4
N
N#define MOSFET_AS_PIN_ADDR		GPIO_PIN_ADDR(2, 2)
N#define MOSFET_BS_PIN_ADDR		GPIO_PIN_ADDR(2, 4)
N#define MOSFET_CS_PIN_ADDR    GPIO_PIN_ADDR(2, 6)
N#define MOSFET_AD_PIN_ADDR		GPIO_PIN_ADDR(2, 3)
N#define MOSFET_BD_PIN_ADDR		GPIO_PIN_ADDR(2, 5)
N#define MOSFET_CD_PIN_ADDR		GPIO_PIN_ADDR(0, 4)
N
N#define GPIO_OFFD_OFF_SET			16
N#define ZERO_DETECT_PORT			P1
N#define ZERO_DETECT_A_PIN			BIT0
N#define ZERO_DETECT_B_PIN			BIT3
N#define ZERO_DETECT_C_PIN			BIT5
N#define ZERO_DETECT_M_PIN			BIT4
N
N#define PWM_PHCHG_PWM_MASK		(0x00003F00ul)
N#define PWM_PHCHG_D0_7_MASK		(0x000000FFul)
N#define PWM_PERIOD 						(884-1)	// PWM T=0.08ms, if target is 3K PRM, 42 E-Circle per M-Circle,
N											// each PC should less than 0.5 ms.
N											// So each E-Circle at least has 6 PWM circle
N
N#define ROTATE_CLOCKWISE			0
N#define ROTATE_ANTICLOCKWISE	1
N
N#define PWM_INT_ENABLE				(PWM_EnableDutyInt(PWM, 1, WHAT_EVER_DO_NOT_CARE))
N
N#define PWM_INT_DISABLE				(PWM->PIER = 0)
N
N#define IS_PWM_IRQ_ENABLED		(PWM->PIER)
N
N// To increase shut down speed we can just directly write a constant number into PHCHG register
N// But since we also have protection form driver IC, it is not so critical here
N// So better just shut down, not change other bit in the register
N// First write PHCHGNXT because between write PHCHG and PHCHGNXT time, PHCHG may be updated by PHCHGNXT
N//#define	MOSFET_ALL_OFF			(PWM->PHCHGNXT = (PWM->PHCHGNXT & (~PWM_PHCHG_PWM_MASK)) | PWM_PHCHG_D0_7_MASK); /
N//								(PWM->PHCHG = (PWM->PHCHG & (~PWM_PHCHG_PWM_MASK)) | PWM_PHCHG_D0_7_MASK);
N// After shut down all MOSFET you need to re-initialize all PHCHG register bits
N#define MOSFET_SHUT_DOWN_VAL		(0x000000FFul)
N#define	MOTOR_SHUT_DOWN				BRG_DISABLE; \
N									PWM_INT_DISABLE; \
N									(TIMER_Stop(TIMER0)); \
N									(TIMER_Stop(TIMER1)); \
N									(TIMER_DisableInt(TIMER0)); \
N									(TIMER_DisableInt(TIMER1)); \
N									(PWM->PHCHGNXT = MOSFET_SHUT_DOWN_VAL); \
N									(PWM->PHCHG = MOSFET_SHUT_DOWN_VAL)
X#define	MOTOR_SHUT_DOWN				BRG_DISABLE; 									PWM_INT_DISABLE; 									(TIMER_Stop(TIMER0)); 									(TIMER_Stop(TIMER1)); 									(TIMER_DisableInt(TIMER0)); 									(TIMER_DisableInt(TIMER1)); 									(PWM->PHCHGNXT = MOSFET_SHUT_DOWN_VAL); 									(PWM->PHCHG = MOSFET_SHUT_DOWN_VAL)
N
N//(ACMP->CMPCR[0] &= ~(ACMP_CMPCR_ACMPIE_Msk | ACMP_CMPCR_ACMPEN_Msk)); \
N
X
N#define MOTOR_SET_DUTY(x)			(PWM->CMR[1] = (x)); \
N									(PWM->CMR[3] = (x)); \
N									(PWM->CMR[5] = (x))
X#define MOTOR_SET_DUTY(x)			(PWM->CMR[1] = (x)); 									(PWM->CMR[3] = (x)); 									(PWM->CMR[5] = (x))
N//#define MOTOR_SET_DUTY(x)			(PWM->CMR[0] = (x)); \
N//									(PWM->CMR[2] = (x)); \
N//									(PWM->CMR[4] = (x))
X
N//#define MOTOR_SET_DUTY(x)			(PWM->CMR[0] = (x)); \
N//									(PWM->CMR[1] = (x)); \
N//									(PWM->CMR[2] = (x)); \
N//									(PWM->CMR[3] = (x)); \
N//									(PWM->CMR[4] = (x)); \
N//									(PWM->CMR[5] = (x))
X
N
N	#ifdef __USED_BY_BLDC_SENSOR_LESS_C__
S		#define EXTERNAL_BLDC  
S
S	// UP side PWM
S		#define PHASE_AB_PIN      		(0x0239ul)	// 0000 0010 0011 1001
S		#define PHASE_AC_PIN     		(0x022Dul)	// 0000 0010 0010 1101
S		#define PHASE_BC_PIN     		(0x0827ul)	// 0000 1000 0010 0111
S		#define PHASE_BA_PIN      		(0x0836ul)  // 0000 1000 0011 0110
S		#define PHASE_CA_PIN           	(0x201Eul)  // 0010 0000 0001 1110
S		#define PHASE_CB_PIN			(0x201Bul)	// 0010 0000 0001 1011
S
S	// Down side PWM
S//		#define PHASE_AB_PIN      		(0x0439ul)	// 0000 0100 0011 1001
S//		#define PHASE_AC_PIN     		(0x102Dul)	// 0001 0000 0010 1101
S//		#define PHASE_BC_PIN     		(0x1027ul)	// 0001 0000 0010 0111
S//		#define PHASE_BA_PIN      		(0x0136ul)  // 0000 0001 0011 0110
S//		#define PHASE_CA_PIN           	(0x011Eul)  // 0000 0001 0001 1110
S//		#define PHASE_CB_PIN			(0x041Bul)	// 0000 0100 0001 1011
S
S	// Both sides PWM
S//		#define PHASE_AB_PIN      		(0x0339ul)	// 0000 0110 0011 1001
S//		#define PHASE_AC_PIN     		(0x122Dul)	// 0001 0010 0010 1101
S//		#define PHASE_BC_PIN     		(0x1827ul)	// 0001 1000 0010 0111
S//		#define PHASE_BA_PIN      		(0x0936ul)  // 0000 1001 0011 0110
S//		#define PHASE_CA_PIN           	(0x211Eul)  // 0010 0001 0001 1110
S//		#define PHASE_CB_PIN			(0x241Bul)	// 0010 0100 0001 1011
S													//													//
S		#define CMP0_PIN_P13			0x30000000  // P13 is selected as CMPP0 pin. 
S		#define CMP0_PIN_P12			0x20000000  // P12 is selected as CMPP0 pin. 
S		#define CMP0_PIN_P10			0x10000000  // P10 is selected as CMPP0 pin. 
S		#define CMP0_PIN_P15			0x00000000  // P15 is selected as CMPP0 pin.
S
S		const uint32_t PHASE_TAB_CLOCKWISE[] = { 
S			PWM_PHCHG_T0_Msk | CMP0_PIN_P15 | PHASE_AB_PIN,
S			PWM_PHCHG_T0_Msk | CMP0_PIN_P13 | PHASE_AC_PIN | DETEC_UP,
S			PWM_PHCHG_T0_Msk | CMP0_PIN_P10 | PHASE_BC_PIN,
S			PWM_PHCHG_T0_Msk | CMP0_PIN_P15 | PHASE_BA_PIN | DETEC_UP,
S			PWM_PHCHG_T0_Msk | CMP0_PIN_P13 | PHASE_CA_PIN,
S			PWM_PHCHG_T0_Msk | CMP0_PIN_P10 | PHASE_CB_PIN | DETEC_UP
S//			PWM_PHCHG_T0_Msk | CMP0_PIN_P15 | PHASE_AB_PIN | DETEC_UP,
S//			PWM_PHCHG_T0_Msk | CMP0_PIN_P13 | PHASE_AC_PIN,
S//			PWM_PHCHG_T0_Msk | CMP0_PIN_P10 | PHASE_BC_PIN | DETEC_UP,
S//			PWM_PHCHG_T0_Msk | CMP0_PIN_P15 | PHASE_BA_PIN,
S//			PWM_PHCHG_T0_Msk | CMP0_PIN_P13 | PHASE_CA_PIN | DETEC_UP,
S//			PWM_PHCHG_T0_Msk | CMP0_PIN_P10 | PHASE_CB_PIN
S		};
S		const uint32_t PHASE_TAB_ANTICLOCKWISE[] = {                        
S			PWM_PHCHG_T0_Msk | CMP0_PIN_P15 | PHASE_AB_PIN | DETEC_UP,  
S			PWM_PHCHG_T0_Msk | CMP0_PIN_P10 | PHASE_CB_PIN ,      
S			PWM_PHCHG_T0_Msk | CMP0_PIN_P13 | PHASE_CA_PIN | DETEC_UP,             
S			PWM_PHCHG_T0_Msk | CMP0_PIN_P15 | PHASE_BA_PIN , 
S			PWM_PHCHG_T0_Msk | CMP0_PIN_P10 | PHASE_BC_PIN | DETEC_UP,            
S			PWM_PHCHG_T0_Msk | CMP0_PIN_P13 | PHASE_AC_PIN 
S		};
S
S		typedef enum {	
S			MOTOR_IDLE = 0,
S//			MOTOR_STOP, 
S			MOTOR_START,	// if not already rotating then just jumo to MOTOR_LOCATE
S			MOTOR_LOCATE,
S			MOTOR_WAIT_AFTER_LOCATE,
S			MOTOR_RAMPUP_WO_ZXD,
S			MOTOR_RAMPUP_W_ZXD,
S			MOTOR_LOCKED
S		} ENUM_MOTOR_STATE;
S
S		typedef enum {	
S			DETECT_START = 0,
S			DETECT_PHASE_1_P,
S			DETECT_PHASE_1_A,
S			DETECT_PHASE_2_P,
S			DETECT_PHASE_2_A,
S			DETECT_PHASE_3_P,
S			DETECT_PHASE_3_A
S		} ENUM_ROTATE_DETECT_STATE;
S
S//		typedef enum {
S//			ENUM_MOTOR_POWER_ON = 0,
S//			ENUM_MOTOR_ZX_DETECTING,
S//			ENUM_MOTOR_LOCKED
S//		}ENUM_MOTOR_SR_BIT;
S
S		typedef enum {	
S			STATUS_ERROR = 0,
S			STATUS_FINISHED,
S			STATUS_WORKING = 0xFFFF
S		} ENUM_STATUS;
S
S		const uint8_t unLocatePhaseSequencyTable[] = {0, 1, 2, 1};
S
S		#define IS_ROTATING_DETECTING											0xFFFF
S		#define MAX_ROTATING_DETECT_PHASE_TIME						30	// half phase max 30ms
S		#define MAX_ALREADY_ROTATING_DETECT_TIME					200	// 200ms used to detect is motor is already rotating
S		#define RAMP_UP_MIN_PERIOD_NUM_THRS								300	// After ramp up to minimum period, force continue rotate these phases
S		#define CHANGE_DT_PR_AFTER_PHASE_CHANGED_NUM			9		// Used in ramp up
S		#define CHANGE_DUTY_AFTER_PHASE_CHANGED_NUM				5		// Used after locked
S
S//		#define MOTOR_RUNNING_MSK					(0x01ul)
S//		#define MOTOR_R_DIRECTION_MSK				(0x02ul)
S//		#define IS_MOTOR_NEED_TO_RUN(x)				((x) & MOTOR_RUNNING_MSK)
S
S//		#define IS_MOTOR_R_CLOCKWISE				(((tMotor.structMotor.MCR & MOTOR_R_DIRECTION_MSK) == 0) ? TRUE : FALSE)
S		#define GET_PHASE_VALUE(x)					((tMotor.structMotor.MCR.bRotateDirection == ROTATE_CLOCKWISE) ? PHASE_TAB_CLOCKWISE[(x)] : PHASE_TAB_ANTICLOCKWISE[(x)])
S		#define PHASE_NUMBER								(sizeof(PHASE_TAB_CLOCKWISE)/sizeof(uint32_t))
S		#define PHASE_INCREASE(x) 					INDEX_INCREASE((x), PHASE_NUMBER) //((x) = (((x) == (PHASE_NUMBER - 1)) ? 0 : ((x) + 1)))
S
S//		#define RESET_MOTOR_SR_BIT(x)				(tMotor.structMotor.MSR &= (~(1ul << (x))))
S//		#define SET_MOTOR_SR_BIT(x)					(tMotor.structMotor.MSR |= (1ul << (x)))
S//		#define IS_MOTOR_STATUS_SET(x)				(tMotor.structMotor.MSR & (1ul << (x)))
S
S		#define WAIT_AFTER_LOCATE_TIME				0	// ms
S
S		#define MOTOR_RAMPUP_DT_MAX						(PWM_PERIOD - 200)
S		#define MOTOR_RAMPUP_DT_FACTOR				(1.02)
S//		#define MOTOR_RAMPUP_DT_INCR(x)			((x) = (((x) > MOTOR_RAMPUP_DT_MAX) ? (x) : (uint16_t)((x) * MOTOR_RAMPUP_DT_FACTOR)))
S		#define MOTOR_RAMPUP_DT_INCR(x)				((x) = (((x) > MOTOR_RAMPUP_DT_MAX) ? (x) : ((x) + 1)))
S
S		#define MOTOR_RAMPUP_PR_MIN						(1000 - 1)	// frequency 2M, 2857RPM if 1MC==7EC==42PC
S		#define MOTOR_RAMPUP_PR_FACTOR				(0.98)
S		#define MOTOR_RAMPUP_PR_DCR(x)				((x) = (((x) < MOTOR_RAMPUP_PR_MIN) ? (x) : (uint16_t)((x) * MOTOR_RAMPUP_PR_FACTOR)))
S//		#define MOTOR_RAMPUP_PR_DCR(x)			((x) = (((x) < MOTOR_RAMPUP_PR_MIN) ? (x) : ((x) - 100)))
S		#define MOTOR_START_ZXD_SPEED					(1600 - 1)	// frequency 2M,
S//		#define MOTOR_START_ZXD_MINROT_CNT			200	// After phase change xxx times at max speed of rampup, start to detect ZX
S
S		#define MAX_MOTOR_PWR_DUTY 						(PWM_PERIOD - 150)
S		#define MAX_SINGLE_PHASE_DURATION			80  // 80ms,
S//		typedef enum {
S//			PHASE_AB = 0,
S//			PHASE_AC,
S//			PHASE_BC,
S//			PHASE_BA,
S//			PHASE_CA,
S//			PHASE_CB
S//		} ENUM_MOTOR_PHASE;
S
S//		typedef enum {
S//			PHASE_AB = 0,
S//			PHASE_CB,
S//			PHASE_CA,
S//			PHASE_BA,
S//			PHASE_BC,
S//			PHASE_AC
S//		} ENUM_MOTOR_ANTICLOCKWISE_PHASE;
S
S
S		static ENUM_MOTOR_STATE tMotorState = MOTOR_IDLE;
S		static ENUM_ROTATE_DETECT_STATE tRotateDetectState = DETECT_START;
S		static uint8_t unLocateIndex;
S		static uint8_t unPhaseChangeCNT_AtCurrentPeriod;	/* This variable is only used at start up ramp up stage.
S															Only after phase has changed for a certain number at current period,
S															the actual period will increase or decrease to target period. */
S		static uint8_t unPhaseChangeCNT_AtCurrentDuty;	/* Only after phase has changed for a certain number at current duty,
S														the actual duty will increase or decrease to target duty */
S		static uint16_t unPeriodChangeCNT_AfterPR_ReachMini;	/* This variable is only used at start up ramp up stage.
S																Phase period changed counter after phase period has been lower to
S																ramp up min period*/
S		static uint32_t unLastPhaseChangeTime;
S		static uint32_t unRotateDetectStartTime;	// Used to record when enter motor start, 
S												// ALready rotating detect end time will be compared with this time
N	#else 
N		#define EXTERNAL_BLDC extern
N	#endif
NEXTERNAL_BLDC __IO MOTOR_UNION_T tMotor;	// Motor control register
Xextern volatile MOTOR_UNION_T tMotor;	
NEXTERNAL_BLDC __IO ENUM_TIM1_USAGE FLAG_TIM1_USEAGE;
Xextern volatile ENUM_TIM1_USAGE FLAG_TIM1_USEAGE;
NEXTERNAL_BLDC __IO uint32_t unLastZXDetectedTime;
Xextern volatile uint32_t unLastZXDetectedTime;
NEXTERNAL_BLDC __IO uint32_t unZXMatchCNT;
Xextern volatile uint32_t unZXMatchCNT;
N//EXTERNAL_BLDC uint32_t iPhaseChangeCNT4Period;	// Used to check if phase has been changed after every 60ms.
N											// If not, force MOSFET OFF. 
N											// 60ms=1.39rps=83.33rpm, we should make sure 1st startup ramp phase < 60ms
N
NEXTERNAL_BLDC uint8_t unCurrentPhase;
Xextern uint8_t unCurrentPhase;
NEXTERNAL_BLDC uint8_t FLAG_PHASE_CHANGED;
Xextern uint8_t FLAG_PHASE_CHANGED;
NEXTERNAL_BLDC __INLINE void BLDC_stopMotor(void);
Xextern __inline void BLDC_stopMotor(void);
NEXTERNAL_BLDC void BLDC_SensorLessManager(void);
Xextern void BLDC_SensorLessManager(void);
N#endif
L 69 "User\global.h" 2
N#include "Communication.h"
L 1 "User\Communication.h" 1
N#ifndef __COMMUNICATION_H__
N#define __COMMUNICATION_H__
N
N#include "global.h"
N
N	#ifdef __USED_BY_COMMUNICATION_C__
S		#define EXTERNAL_COMM  
S		#define COM_SPI_TRANS_ERR_THRESHOLD		6
S		#define REVS_BYTE_ORDER(unIndex)			((((unIndex) & BIT_MASK) == 0) ? ((unIndex) + 1) : ((unIndex) - 1))	 			
S		uint16_t CRC_TABLE16[] = {0x0000,0x8005,0x800F,0x000A,0x801B,0x001E,0x0014,0x8011,0x8033,0x0036,0x003C,0x8039,0x0028,0x802D,0x8027,0x0022,
S		0x8063,0x0066,0x006C,0x8069,0x0078,0x807D,0x8077,0x0072,0x0050,0x8055,0x805F,0x005A,0x804B,0x004E,0x0044,0x8041,
S		0x80C3,0x00C6,0x00CC,0x80C9,0x00D8,0x80DD,0x80D7,0x00D2,0x00F0,0x80F5,0x80FF,0x00FA,0x80EB,0x00EE,0x00E4,0x80E1,
S		0x00A0,0x80A5,0x80AF,0x00AA,0x80BB,0x00BE,0x00B4,0x80B1,0x8093,0x0096,0x009C,0x8099,0x0088,0x808D,0x8087,0x0082,
S		0x8183,0x0186,0x018C,0x8189,0x0198,0x819D,0x8197,0x0192,0x01B0,0x81B5,0x81BF,0x01BA,0x81AB,0x01AE,0x01A4,0x81A1,
S		0x01E0,0x81E5,0x81EF,0x01EA,0x81FB,0x01FE,0x01F4,0x81F1,0x81D3,0x01D6,0x01DC,0x81D9,0x01C8,0x81CD,0x81C7,0x01C2,
S		0x0140,0x8145,0x814F,0x014A,0x815B,0x015E,0x0154,0x8151,0x8173,0x0176,0x017C,0x8179,0x0168,0x816D,0x8167,0x0162,
S		0x8123,0x0126,0x012C,0x8129,0x0138,0x813D,0x8137,0x0132,0x0110,0x8115,0x811F,0x011A,0x810B,0x010E,0x0104,0x8101,
S		0x8303,0x0306,0x030C,0x8309,0x0318,0x831D,0x8317,0x0312,0x0330,0x8335,0x833F,0x033A,0x832B,0x032E,0x0324,0x8321,
S		0x0360,0x8365,0x836F,0x036A,0x837B,0x037E,0x0374,0x8371,0x8353,0x0356,0x035C,0x8359,0x0348,0x834D,0x8347,0x0342,
S		0x03C0,0x83C5,0x83CF,0x03CA,0x83DB,0x03DE,0x03D4,0x83D1,0x83F3,0x03F6,0x03FC,0x83F9,0x03E8,0x83ED,0x83E7,0x03E2,
S		0x83A3,0x03A6,0x03AC,0x83A9,0x03B8,0x83BD,0x83B7,0x03B2,0x0390,0x8395,0x839F,0x039A,0x838B,0x038E,0x0384,0x8381,
S		0x0280,0x8285,0x828F,0x028A,0x829B,0x029E,0x0294,0x8291,0x82B3,0x02B6,0x02BC,0x82B9,0x02A8,0x82AD,0x82A7,0x02A2,
S		0x82E3,0x02E6,0x02EC,0x82E9,0x02F8,0x82FD,0x82F7,0x02F2,0x02D0,0x82D5,0x82DF,0x02DA,0x82CB,0x02CE,0x02C4,0x82C1,
S		0x8243,0x0246,0x024C,0x8249,0x0258,0x825D,0x8257,0x0252,0x0270,0x8275,0x827F,0x027A,0x826B,0x026E,0x0264,0x8261,
S		0x0220,0x8225,0x822F,0x022A,0x823B,0x023E,0x0234,0x8231,0x8213,0x0216,0x021C,0x8219,0x0208,0x820D,0x8207,0x0202};
S		
S		typedef enum {
S			COMM_READ_MCR = 0,
S			COMM_READ_MSR,
S			COMM_READ_MISS_ZXD_CNT,
S			COMM_READ_SCS_ZXD_CNT,
S			COMM_READ_LOCATING_DUTY,
S			COMM_READ_RAMP_UP_DUTY,
S			COMM_READ_TARGET_DUTY,
S			COMM_READ_ACTUAL_DUTY,
S			COMM_READ_LOCATING_PERIOD,
S			COMM_READ_RESERVED_1,
S			COMM_READ_RAMP_UP_PERIOD_LOW,
S			COMM_READ_RAMP_UP_PERIOD_HIGH,
S			COMM_READ_ACTUAL_PERIOD_LOW,
S			COMM_READ_ACTUAL_PERIOD_HIGH,
S			COMM_READ_PHASE_CHANGE_CNT_LOW,
S			COMM_READ_PHASE_CHANGE_CNT_HIGH,
S			COMM_READ_RPM,
S			COMM_READ_BATTERY,
S			COMM_READ_CURRENT,
S			COMM_READ_RESERVE_2,
S			COMM_READ_MAX
S		} ENUM_COMM_READ_CMD;
S
S		typedef enum {
S			COMM_WRITE_DUMMY = 0,
S			COMM_WRITE_MOTOR_NEED_TO_RUN,
S			COMM_WRITE_ROTATE_DIRECTION,
S			COMM_WRITE_LOCATING_DUTY,
S			COMM_WRITE_RAMP_UP_DUTY,
S			COMM_WRITE_TARGET_DUTY,
S			COMM_WRITE_LOCATING_PERIOD,
S			COMM_WRITE_RAMP_UP_PERIOD,
S			COMM_WRITE_CMD_MAX
S		} ENUM_COMM_WRITE_CMD;
S		uint32_t unValidFrameCNT;
N	#else 
N		#define EXTERNAL_COMM extern
N	#endif
N
N#define COMM_PORT					P0
N#define COMM_CLK_PIN				BIT7
N#define COMM_CS_PIN					BIT1
N#define COMM_TX_PIN					BIT6
N#define COMM_RX_PIN					BIT5
N
N#define COMM_FIFO_LENGTH					3
N#define COMM_BIT_LENTH						16	// Because STM32F407 can only configure SPI to be 8bits/16bits width
N										// highest bit in first half word is used to indicate command or data
N#define COMM_RD_CMD_CNT						2	// R(0):Address | CRC
N#define COMM_WR_CMD_CNT						4	// W(1):Address | Data Low | Data High | CRC
N
N// If using FIFO, need to use 32 bit
N#define COMM_RD_CMD_CNT_IN_32BIT	1	
N#define COMM_WR_CMD_CNT_IN_32BIT	2	
N		
N#define COMM_RW_CMD_MASK					(0x8000)
N#define IS_COMM_RD_CMD(value)			(((value) & COMM_RW_CMD_MASK) == COMM_RW_CMD_MASK)
N#define IS_COMM_WR_CMD(value)			(((value) & COMM_RW_CMD_MASK) == 0)
N#define COMM_DATA_MASK						(0x7FFF)
N#define COMM_GET_DATA(value)			((value) & COMM_DATA_MASK)
N#define COMM_BAUT_RATE						0	// 5MHz
N#define MTR_INVALID_MOTOR_CMD			0xFFFF
N//typedef enum{
N//	MOTOR_MCR = 0,	/*!<  Motor Control  */
N//	MOTOR_MSR,		/*!<  Motor Status  */
N//	MOTOR_MISS_ZXD_CNT,
N//	MOTOR_SCS_ZXD_CNT,
N//	MOTOR_LCT_DUTY,		/*!<  PWM Locating Duty  */
N//	MOTOR_RU_DUTY,		/*!<  PWM Ramp Up Start Duty  */
N//	MOTOR_TGT_DUTY,		/*!<  PWM Target (Locked State) Duty  */
N//	MOTOR_ACT_DUTY,		/*!<  PWM Actual Duty  */
N//	MOTOR_LCT_PERIOD,	/*!<  Locating State One Phase Period  */
N//	MOTOR_RU_PERIOD_LOW,	/*!<  Ramp Up Start One Phase Period  */
N//	MOTOR_RU_PERIOD_HIGH,	/*!<  Ramp Up Start One Phase Period  */
N//	MOTOR_ACT_PERIOD_LOW,	/*!<  Actual One Phase Period  */
N//	MOTOR_ACT_PERIOD_HIGH,	/*!<  Actual One Phase Period  */
N//	MOTOR_RPM,			/*!<  Actual RPM  */
N//	MOTOR_RESERVE,		/*!<  Reserve for future use (round up 32bits) */
N//	MOTOR_BATTERY,		/*!<  Battery Voltage  */
N//	MOTOR_CURRENT		/*!<  Current  */
N//} ENUM_COMM_REG;
NEXTERNAL_COMM uint32_t unCOM_SPI_TransCNT;
Xextern uint32_t unCOM_SPI_TransCNT;
NEXTERNAL_COMM uint32_t unCOM_SPI_TransErrCNT;
Xextern uint32_t unCOM_SPI_TransErrCNT;
NEXTERNAL_COMM uint16_t unCOM_SPI_ReadData[4];	//COMM_FIFO_LENGTH];	// 0 or 0xFFFF means no data
Xextern uint16_t unCOM_SPI_ReadData[4];	
NEXTERNAL_COMM uint16_t unRegisterValue;	// 0 or 0xFFFF means no data
Xextern uint16_t unRegisterValue;	
N//EXTERNAL_COMM ENUM_COMM_REG tRegister;
NEXTERNAL_COMM uint8_t FlagRegisterNeedWrite;
Xextern uint8_t FlagRegisterNeedWrite;
NEXTERNAL_COMM uint16_t unReadValueCRC;
Xextern uint16_t unReadValueCRC;
NEXTERNAL_COMM void COMM_Manager(void);
Xextern void COMM_Manager(void);
N#endif
L 70 "User\global.h" 2
N#include "Error.h"
L 1 "User\Error.h" 1
N#ifndef __ERROR_H__
N#define __ERROR_H__
N
N#include "global.h"
N
N#define LED_PORT					P5
N#define LED_PIN						BIT4
N#define LED_OUTPUT				P54
N
N#define GET_SPECIFIED_EEROR(x)		((unErrorMaster & (1L << (x)) == 0) ? FALSE : TRUE)
N#define IS_ANY_EEROR				((unErrorMaster == 0) ? FALSE : TRUE)
N/*
N	ERR_NULL = 0,
N	ERR_CURRENT_WARNING,	// Current > 5A
N	ERR_LOCATE_FAIL,
N	ERR_RAMPUP_FAIL,
N	ERR_BATTERY_LOW,
N	ERR_INTERNAL,	// Loss lock, single phase duration too long
N	ERR_CURRENT_BURNING,	// Current > 15A
N	ERR_BRD_FAULT
N	*/
N#define MOTOR_ERROR_MSK				0xFFFFFFFEul
N#define NO_MOTOR_EEROR				(((unErrorMaster & MOTOR_ERROR_MSK) == 0) ? TRUE : FALSE)
N
N// Max 32 type of error because used uint32_t's bit to mark each error
Ntypedef enum {
N	ERR_NULL = 0,
N	ERR_CURRENT_WARNING,	// Current > 5A
N	ERR_COMMUNICATION_FAIL,
N	ERR_LOCATE_FAIL,
N	ERR_RAMPUP_FAIL,
N	ERR_BATTERY_LOW,
N	ERR_INTERNAL,	// Loss lock, single phase duration too long
N	ERR_CURRENT_BURNING,	// Current > 15A
N	ERR_BRD_FAULT
N} ENUM_ERROR_LEVEL;
N
N	#define LED_ON					(LED_OUTPUT = 0)
N	#define LED_OFF 				(LED_OUTPUT = 1)
N	#define LED_TOGGLE 			(GPIO_TOGGLE(LED_OUTPUT))
N
N#ifdef __USED_BY_ERROR_C__
S	#define EXTERNAL_ERROR  
S
S
S	#define LED_PATTERN_INTERVAL	2000  //2s
S	#define LED_BLINK_ON_TIME			200  //0.2s
S	#define LED_BLINK_OFF_TIME		200  //0.2s, so 3 times is (0.4x3 = 1.2s)
S	#define LED_BLINK_INTERVAL		(LED_BLINK_ON_TIME + LED_BLINK_OFF_TIME)
S	// Since LED can not blink to fast (for human watchable), 3 type of blink make sense
S	// So this table is introduced. Since ERR_BRD_FAULT is constantly ON, we can use it as array size
S	const uint32_t unLED_BLINK_PATTERN_TABLE[ERR_BRD_FAULT] = {1 * LED_BLINK_INTERVAL,
S			1 * LED_BLINK_INTERVAL,
S			2 * LED_BLINK_INTERVAL,
S			2 * LED_BLINK_INTERVAL,
S			2 * LED_BLINK_INTERVAL,
S			2 * LED_BLINK_INTERVAL,
S			3 * LED_BLINK_INTERVAL};
N#else 
N	#define EXTERNAL_ERROR extern
N#endif
N
NEXTERNAL_ERROR uint32_t unErrorMaster;
Xextern uint32_t unErrorMaster;
NEXTERNAL_ERROR void delay(uint32_t unDelayMs);
Xextern void delay(uint32_t unDelayMs);
NEXTERNAL_ERROR void resetError(ENUM_ERROR_LEVEL enumErrorType);
Xextern void resetError(ENUM_ERROR_LEVEL enumErrorType);
NEXTERNAL_ERROR void setError(ENUM_ERROR_LEVEL enumErrorType);
Xextern void setError(ENUM_ERROR_LEVEL enumErrorType);
NEXTERNAL_ERROR void clearError(void);
Xextern void clearError(void);
NEXTERNAL_ERROR void ERR_Manager(void);
Xextern void ERR_Manager(void);
N
N#endif
L 71 "User\global.h" 2
N#include "Protection.h"
L 1 "User\Protection.h" 1
N#ifndef __PROTECTION_H__
S#define __PROTECTION_H__
S
S#include "global.h"
S
S#define BATTERY_V_PORT				P3
S#define BATTERY_V_PIN				BIT1
S#define CURRENT_PORT				P5
S#define CURRENT_PIN					BIT3
S
S#define ADC_CURRENT_CHN_IDX			0
S#define ADC_BATTERY_CHN_IDX			7
S#define ADC_CURRENT_CHN_MSK			(0x01 << ADC_CURRENT_CHN_IDX)
S#define ADC_BATTERY_CHN_MSK			(0x01 << ADC_BATTERY_CHN_IDX)
S#define ADC_CURRENT_CMP_MSK			ADC_CMP0_INT
S#define ADC_BATTERY_CMP_MSK			ADC_CMP1_INT
S#define ADC_ADF_MSK					ADC_ADF_INT
S
S// 5x50 m ohm R = 10m ohm, 30A*0.01=0.3V, VCC=3V, (0.3/3)*1024=102
S// 5x50 m ohm R = 10m ohm, 30A*0.01=0.3V, VCC=5V, (0.3/5)*1024=61
S#define ADC_CURRENT_HIGH_THRS			68
S#define ADC_CURRENT_HIGH_CNT			12	// 300us*8*2(one current, one battery)=4.8ms
S									//16	// 15us*16*2(one current, one battery)=0.48ms interval of measurement
S// 5x50 m ohm R = 10m ohm, 1A*0.01=0.01V, VCC=5V, (0.01/5)*1024=2
S#define ADC_CURRENT_HIGH_THRS_MT		5	// For MOSFET check at start up, but 2 can be noise, so maybe 5 is OK
S											// If it is higher than 5 also maybe ADC is wrong
S
S// Set 6.8V as min, (6.8/13.3)*3.3=1.687V, (1.687/3.3)*1024=524	// Actually using 10K and 3.3K R
S// Set 10.2V as min, (10.2/13.3)*3.3=2.53V, (2.53/3)*1024=864	// Actually using 10K and 3.3K R
S// Set 10.2V as min, (10.2/13.3)*3.3=2.53V, (2.53/5)*1024=518	// Actually using 10K and 3.3K R
S// Set 10.2V as min, (10.2/12)*2=1.7V, (1.7/5)*1024=348	// Actually using 10K and 2K R
S#define ADC_BAT_LOW_THRS				348
S#define ADC_BAT_LOW_CNT					16	// Battery may need further filter, 300us*16*2(one current, one battery)=9.6ms
S// Set 11.5V as min, (11.5/12)*2=1.92V, (1.92/5)*1024=393	// Actually using 10K and 2K R
S#define ADC_BAT_LOW_THRS_MT				393
S
S#ifdef __USED_BY_PTC_C__
S	#define EXTERNAL_PTC
S
S	volatile uint32_t* unMosfetTestTable[] = {MOSFET_AS_PIN_ADDR, MOSFET_BS_PIN_ADDR, MOSFET_CS_PIN_ADDR,
S			MOSFET_AD_PIN_ADDR, MOSFET_BD_PIN_ADDR, MOSFET_CD_PIN_ADDR};
S	#define SET_MOSFET_ON_MANUAL(pinAddr)		(*(pinAddr) = 0)
S	#define SET_MOSFET_OFF_MANUAL(pinAddr)		(*(pinAddr) = 1)
S
S#else
S	#define EXTERNAL_PTC extern
S#endif
S
SEXTERNAL_PTC void PTC_checkMotor(void);
S
N#endif
L 72 "User\global.h" 2
N#endif 
L 5 "User\Protection.h" 2
N
N#define BATTERY_V_PORT				P3
N#define BATTERY_V_PIN				BIT1
N#define CURRENT_PORT				P5
N#define CURRENT_PIN					BIT3
N
N#define ADC_CURRENT_CHN_IDX			0
N#define ADC_BATTERY_CHN_IDX			7
N#define ADC_CURRENT_CHN_MSK			(0x01 << ADC_CURRENT_CHN_IDX)
N#define ADC_BATTERY_CHN_MSK			(0x01 << ADC_BATTERY_CHN_IDX)
N#define ADC_CURRENT_CMP_MSK			ADC_CMP0_INT
N#define ADC_BATTERY_CMP_MSK			ADC_CMP1_INT
N#define ADC_ADF_MSK					ADC_ADF_INT
N
N// 5x50 m ohm R = 10m ohm, 30A*0.01=0.3V, VCC=3V, (0.3/3)*1024=102
N// 5x50 m ohm R = 10m ohm, 30A*0.01=0.3V, VCC=5V, (0.3/5)*1024=61
N#define ADC_CURRENT_HIGH_THRS			68
N#define ADC_CURRENT_HIGH_CNT			12	// 300us*8*2(one current, one battery)=4.8ms
N									//16	// 15us*16*2(one current, one battery)=0.48ms interval of measurement
N// 5x50 m ohm R = 10m ohm, 1A*0.01=0.01V, VCC=5V, (0.01/5)*1024=2
N#define ADC_CURRENT_HIGH_THRS_MT		5	// For MOSFET check at start up, but 2 can be noise, so maybe 5 is OK
N											// If it is higher than 5 also maybe ADC is wrong
N
N// Set 6.8V as min, (6.8/13.3)*3.3=1.687V, (1.687/3.3)*1024=524	// Actually using 10K and 3.3K R
N// Set 10.2V as min, (10.2/13.3)*3.3=2.53V, (2.53/3)*1024=864	// Actually using 10K and 3.3K R
N// Set 10.2V as min, (10.2/13.3)*3.3=2.53V, (2.53/5)*1024=518	// Actually using 10K and 3.3K R
N// Set 10.2V as min, (10.2/12)*2=1.7V, (1.7/5)*1024=348	// Actually using 10K and 2K R
N#define ADC_BAT_LOW_THRS				348
N#define ADC_BAT_LOW_CNT					16	// Battery may need further filter, 300us*16*2(one current, one battery)=9.6ms
N// Set 11.5V as min, (11.5/12)*2=1.92V, (1.92/5)*1024=393	// Actually using 10K and 2K R
N#define ADC_BAT_LOW_THRS_MT				393
N
N#ifdef __USED_BY_PTC_C__
N	#define EXTERNAL_PTC
N
N	volatile uint32_t* unMosfetTestTable[] = {MOSFET_AS_PIN_ADDR, MOSFET_BS_PIN_ADDR, MOSFET_CS_PIN_ADDR,
X	volatile uint32_t* unMosfetTestTable[] = {((volatile uint32_t *)(((((uint32_t)0x50000000) + 0x04200)+(0x20*(2))) + ((2)<<2))), ((volatile uint32_t *)(((((uint32_t)0x50000000) + 0x04200)+(0x20*(2))) + ((4)<<2))), ((volatile uint32_t *)(((((uint32_t)0x50000000) + 0x04200)+(0x20*(2))) + ((6)<<2))),
N			MOSFET_AD_PIN_ADDR, MOSFET_BD_PIN_ADDR, MOSFET_CD_PIN_ADDR};
X			((volatile uint32_t *)(((((uint32_t)0x50000000) + 0x04200)+(0x20*(2))) + ((3)<<2))), ((volatile uint32_t *)(((((uint32_t)0x50000000) + 0x04200)+(0x20*(2))) + ((5)<<2))), ((volatile uint32_t *)(((((uint32_t)0x50000000) + 0x04200)+(0x20*(0))) + ((4)<<2)))};
N	#define SET_MOSFET_ON_MANUAL(pinAddr)		(*(pinAddr) = 0)
N	#define SET_MOSFET_OFF_MANUAL(pinAddr)		(*(pinAddr) = 1)
N
N#else
S	#define EXTERNAL_PTC extern
N#endif
N
NEXTERNAL_PTC void PTC_checkMotor(void);
X void PTC_checkMotor(void);
N
N#endif
L 14 "User\Protection.c" 2
N
N#define MOTOR_TEST_MOSFET_ON_DURATION	50	// 50ms
N
Nvoid PTC_checkMotor(void)
N{
N	uint8_t unCheckIndex;
N	clearError();
N	// Battery check
N	// Battery voltage check will be done in ADC interrupt on the fly, so no need to check here.
N
N	// LED check
N	// Check what?
N
N	// MOSFET check
N	// Open each MOSFET one by one to see if there is any current.
N	// If yes means some MOSFET is short
N	// Set ADC Current threshold to very low
N	// Set ADC Voltage threshold to very high
N    // Configure and enable Comperator 0 to monitor channel 0(current) input greater or euqal to 93
N    ADC_ENABLE_CMP0(ADC, ADC_CURRENT_CHN_IDX, ADC_CMP_GREATER_OR_EQUAL_TO, ADC_CURRENT_HIGH_THRS_MT, ADC_CURRENT_HIGH_CNT);
X    (((ADC_T *) (((uint32_t)0x40000000) + 0xE0000))->ADCMPR[0] = ((0) << 3) | (((1ul << 2))) | ((5) << 16) | (((12) - 1) << 8) | (1ul << 0));
N    // Configure and enable Comperator 1 to monitor channel 7(battery) input less than 0x200
N    ADC_ENABLE_CMP1(ADC, ADC_BATTERY_CHN_IDX, ADC_CMP_LESS_THAN, ADC_BAT_LOW_THRS_MT, ADC_BAT_LOW_CNT);
X    (((ADC_T *) (((uint32_t)0x40000000) + 0xE0000))->ADCMPR[1] = ((7) << 3) | ((0UL)) | ((393) << 16) | ((16 - 1) << 8) | (1ul << 0));
N	for (unCheckIndex = 0; unCheckIndex < (sizeof(unMosfetTestTable) / sizeof(uint32_t*)); unCheckIndex++)
N	{
N		SET_MOSFET_ON_MANUAL(unMosfetTestTable[unCheckIndex]);
X		(*(unMosfetTestTable[unCheckIndex]) = 0);
N		delay(MOTOR_TEST_MOSFET_ON_DURATION);
X		delay(50);
N		SET_MOSFET_OFF_MANUAL(unMosfetTestTable[unCheckIndex]);
X		(*(unMosfetTestTable[unCheckIndex]) = 1);
N		if (IS_ANY_EEROR == TRUE)
X		if (((unErrorMaster == 0) ? (0) : (1)) == (1))
N		{
N			BLDC_stopMotor();
N//			while (1)
N//			{
N//				ERR_Manager();
N//			}
N		}
N	}
N    // Configure and enable Comperator 0 to monitor channel 0(current) input greater or euqal to 93
N    ADC_ENABLE_CMP0(ADC, ADC_CURRENT_CHN_IDX, ADC_CMP_GREATER_OR_EQUAL_TO, ADC_CURRENT_HIGH_THRS, ADC_CURRENT_HIGH_CNT);
X    (((ADC_T *) (((uint32_t)0x40000000) + 0xE0000))->ADCMPR[0] = ((0) << 3) | (((1ul << 2))) | ((68) << 16) | (((12) - 1) << 8) | (1ul << 0));
N    // Configure and enable Comperator 1 to monitor channel 7(battery) input less than 0x200
N    ADC_ENABLE_CMP1(ADC, ADC_BATTERY_CHN_IDX, ADC_CMP_LESS_THAN, ADC_BAT_LOW_THRS, ADC_BAT_LOW_CNT);
X    (((ADC_T *) (((uint32_t)0x40000000) + 0xE0000))->ADCMPR[1] = ((7) << 3) | ((0UL)) | ((348) << 16) | ((16 - 1) << 8) | (1ul << 0));
N}
